subsite,site,title,excerpt,url,contentType,codeLanguage/0,codeLanguage/1,body,sections/0,sections/1,sections/2,sections/3,sections/4,sections/5,sections/6,sections/7,sections/8,sections/9,sections/10,sections/11,sections/12,sections/13,level,sections/14,sections/15,sections/16,sections/17,sections/18,sections/19,sections/20,sections/21,sections/22,sections/23,sections/24,sections/25,sections/26,sections/27,sections/28,sections/29,sections/30,sections/31,sections/32,sections/33,sections/34,sections/35,sections/36,sections/37,sections/38,sections/39,sections/40,sections/41,sections/42,sections/43,sections/44,sections/45,sections/46,sections/47,sections/48,sections/49,sections/50,sections/51,sections/52,sections/53,sections/54,sections/55,sections/56,sections/57,sections/58,sections/59,sections/60,sections/61,sections/62,sections/63,sections/64,sections/65,sections/66,sections/67,sections/68,sections/69,sections/70,sections/71,sections/72,sections/73,sections/74,sections/75,sections/76,sections/77,sections/78,sections/79,sections/80,sections/81,sections/82,sections/83,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Default callout usage,Use default appearance and interactivity of annotation callout views.,https://docs.mapbox.com/ios/maps/examples/default-callout/,example,Swift,Objective-C,"Default callout usage If you are interested in using non-default callout features, see the MGLCalloutView and MGLCalloutDelegate protocols for more information about creating customized callouts. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] view.addSubview(mapView) // Remember to set the delegate. mapView.delegate = self addAnnotation() } func addAnnotation() { let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 35.03946, longitude: 135.72956) annotation.title = ""Kinkaku-ji"" annotation.subtitle = ""\(annotation.coordinate.latitude), \(annotation.coordinate.longitude)"" mapView.addAnnotation(annotation) // Center the map on the annotation. mapView.setCenter(annotation.coordinate, zoomLevel: 17, animated: false) // Pop-up the callout view. mapView.selectAnnotation(annotation, animated: true, completionHandler: nil) } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { return true } func mapView(_ mapView: MGLMapView, leftCalloutAccessoryViewFor annotation: MGLAnnotation) -> UIView? { if (annotation.title! == ""Kinkaku-ji"") { // Callout height is fixed; width expands to fit its content. let label = UILabel(frame: CGRect(x: 0, y: 0, width: 60, height: 50)) label.textAlignment = .right label.textColor = UIColor(red: 0.81, green: 0.71, blue: 0.23, alpha: 1) label.text = ""金閣寺"" return label } return nil } func mapView(_ mapView: MGLMapView, rightCalloutAccessoryViewFor annotation: MGLAnnotation) -> UIView? { return UIButton(type: .detailDisclosure) } func mapView(_ mapView: MGLMapView, annotation: MGLAnnotation, calloutAccessoryControlTapped control: UIControl) { // Hide the callout view. mapView.deselectAnnotation(annotation, animated: false) // Show an alert containing the annotation's details let alert = UIAlertController(title: annotation.title!!, message: ""A lovely (if touristy) place."", preferredStyle: .alert) alert.addAction(UIAlertAction(title: ""OK"", style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) } } Copy Was this page helpful? Yes No",Default callout usage,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Create a draggable Marker,Drag the Marker to a new location on a map and populates its coordinates in a display.,https://docs.mapbox.com/mapbox-gl-js/example/drag-a-marker/,example,JavaScript,,Create a draggable Marker Drag the Marker to a new location on a map and populates its coordinates in a display. Was this example helpful? Yes No,Create a draggable Marker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Extrude polygons for 3D indoor mapping,Create a 3D indoor map with the fill-extrude-height paint property.,https://docs.mapbox.com/mapbox-gl-js/example/3d-extrusion-floorplan/,example,JavaScript,,Extrude polygons for 3D indoor mapping Create a 3D indoor map with the fill-extrude-height paint property. Was this example helpful? Yes No,Extrude polygons for 3D indoor mapping,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Build a store locator using Mapbox GL JS,Build a map application with Mapbox GL JS. This guide walks you through all the code that you need to build a store locator.,https://docs.mapbox.com/help/tutorials/building-a-store-locator/,tutorial,JavaScript,,"advanced JavaScript Build a store locator using Mapbox GL JS Prerequisite Familiarity with front-end development concepts. Some advanced JavaScript required. This guide will walk you through how to create a store locator map using Mapbox GL JS. You'll be able to browse all the locations from a sidebar and select a specific store to view more information. Selecting a marker on the map will highlight the selected store on the sidebar. You will use Sweetgreen, a local salad shop, as an example. They have a healthy number of locations, plus their salads are delicious! This guide shows you how to use Mapbox GL JS to build an interactive web map. If you're new to Mapbox GL JS, you might want to read our guide on Mapbox web applications first. Getting started For this project, we recommend that you create a local folder called ""store-locator"" to house your project files. You'll see this folder referred to as your project folder. There are a few resources you'll need before getting started: A style URL. A style URL points to a unique map you have created with Mapbox Studio. You can either create a custom style with the Mapbox Studio style editor or use a Mapbox style. An access token from your account. You will use an access token to associate a map with your account. Your access token is on the Account page. Mapbox GL JS. The Mapbox JavaScript library that uses WebGL to render interactive maps from Mapbox GL styles. A text editor. You'll be writing HTML, CSS, and JavaScript after all. Data. We collected some of Sweetgreen's locations and marked up the data in GeoJSON. Custom map marker. You'll be using an image for your map marker. Save the image to your project folder. Download custom marker Add structure In your project folder, create an index.html file. Set up the document by adding Mapbox GL JS and CSS to your head: <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> Next, markup the page to create a map container and sidebar listing: <div class='sidebar pad2'>Listing</div> <div id='map' class='map pad2'>Map</div> Then, apply some CSS to create the page layout: body { background: #404040; color: #f8f8f8; font: 500 20px/26px 'Helvetica Neue', Helvetica, Arial, Sans-serif; margin: 0; padding: 0; -webkit-font-smoothing: antialiased; } /* The page is split between map and sidebar - the sidebar gets 1/3, map gets 2/3 of the page. You can adjust this to your personal liking. */ .sidebar { width: 33.3333%; } .map { border-left: 1px solid #fff; position: absolute; left: 33.3333%; width: 66.6666%; top: 0; bottom: 0; } .pad2 { padding: 20px; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } Initialize the map Now that you have the structure of the page, initialize the map with Mapbox GL JS. First, add your access token using mapboxgl.accessToken. Then, create a new map object using new mapboxgl.Map() and store it in a variable called map: mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // This adds the map to your page var map = new mapboxgl.Map( { // container id specified in the HTML container: 'map', // style URL style: 'mapbox://styles/mapbox/light-v 10 ', // initial position in [lon, lat] format center: [-77.034084, 38.909671], // initial zoom zoom: 14 } ); As you can see above, the Mapbox GL JS map requires several options: container: the id of the <div> element on the page where the map should live. In this case, the id for the <div> is 'map'. style: the style URL for the map style. In this case, use the Mapbox Light map which has the style URL mapbox://styles/mapbox/light- 10. center: the initial centerpoint of the map in [longitude, latitude] format. zoom: the initial zoom level of the map. Load data With Mapbox GL JS, map rendering happens in the browser. For the browser to render your map, you need to add a layer with geospatial data and instructions for how that data should be rendered. To add a source to the map, your code needs to access the geospatial data. Store all the GeoJSON data in sweetgreen.geojson in a variable called stores: var stores = { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.034084142948, 38.909671288923 ] }, ""properties"": { ""phoneFormatted"": ""(202) 234-7336"", ""phone"": ""2022347336"", ""address"": ""1471 P St NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 15th St NW"", ""postalCode"": ""20005"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.049766, 38.900772 ] }, ""properties"": { ""phoneFormatted"": ""(202) 507-8357"", ""phone"": ""2025078357"", ""address"": ""2221 I St NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 22nd St NW"", ""postalCode"": ""20037"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.043929, 38.910525 ] }, ""properties"": { ""phoneFormatted"": ""(202) 387-9338"", ""phone"": ""2023879338"", ""address"": ""1512 Connecticut Ave NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at Dupont Circle"", ""postalCode"": ""20036"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.0672, 38.90516896 ] }, ""properties"": { ""phoneFormatted"": ""(202) 337-9338"", ""phone"": ""2023379338"", ""address"": ""3333 M St NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 34th St NW"", ""postalCode"": ""20007"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.002583742142, 38.887041080933 ] }, ""properties"": { ""phoneFormatted"": ""(202) 547-9338"", ""phone"": ""2025479338"", ""address"": ""221 Pennsylvania Ave SE"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""btwn 2nd & 3rd Sts. SE"", ""postalCode"": ""20003"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -76.933492720127, 38.99225245786 ] }, ""properties"": { ""address"": ""8204 Baltimore Ave"", ""city"": ""College Park"", ""country"": ""United States"", ""postalCode"": ""20740"", ""state"": ""MD"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.097083330154, 38.980979 ] }, ""properties"": { ""phoneFormatted"": ""(301) 654-7336"", ""phone"": ""3016547336"", ""address"": ""4831 Bethesda Ave"", ""cc"": ""US"", ""city"": ""Bethesda"", ""country"": ""United States"", ""postalCode"": ""20814"", ""state"": ""MD"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.359425054188, 38.958058116661 ] }, ""properties"": { ""phoneFormatted"": ""(571) 203-0082"", ""phone"": ""5712030082"", ""address"": ""11935 Democracy Dr"", ""city"": ""Reston"", ""country"": ""United States"", ""crossStreet"": ""btw Explorer & Library"", ""postalCode"": ""20190"", ""state"": ""VA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.10853099823, 38.880100922392 ] }, ""properties"": { ""phoneFormatted"": ""(703) 522-2016"", ""phone"": ""7035222016"", ""address"": ""4075 Wilson Blvd"", ""city"": ""Arlington"", ""country"": ""United States"", ""crossStreet"": ""at N Randolph St."", ""postalCode"": ""22203"", ""state"": ""VA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -75.28784, 40.008008 ] }, ""properties"": { ""phoneFormatted"": ""(610) 642-9400"", ""phone"": ""6106429400"", ""address"": ""68 Coulter Ave"", ""city"": ""Ardmore"", ""country"": ""United States"", ""postalCode"": ""19003"", ""state"": ""PA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -75.20121216774, 39.954030175164 ] }, ""properties"": { ""phoneFormatted"": ""(215) 386-1365"", ""phone"": ""2153861365"", ""address"": ""3925 Walnut St"", ""city"": ""Philadelphia"", ""country"": ""United States"", ""postalCode"": ""19104"", ""state"": ""PA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.043959498405, 38.903883387232 ] }, ""properties"": { ""phoneFormatted"": ""(202) 331-3355"", ""phone"": ""2023313355"", ""address"": ""1901 L St. NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 19th St"", ""postalCode"": ""20036"", ""state"": ""D.C."" } } ] } ; Now you can add a layer that contains this data and describes how it should be rendered. Add the data to your map once the map loads using addLayer(). Create a new layer, and specify stores as a GeoJSON data source. Then, add instructions for rendering the source. This example only adds minimal styling --- for full details on all the layer styling options, see the Mapbox Style Specification: map.on('load', function(e) { // Add the data to your map as a layer map.addLayer( { id: 'locations', type: 'symbol', // Add a GeoJSON source containing place coordinates and information. source: { type: 'geojson', data: stores } , layout: { 'icon-image': 'restaurant-15', 'icon-allow-overlap': true, } } ); } ); Note: restaurant-15 refers to an icon in the Mapbox Light style you added earlier in the code. Build store listing Now that the points are on your map, it's time to build the restaurant location listing by iterating through the GeoJSON and creating a list of restaurants dynamically. This means that if you need to add a location then you only need to update the GeoJSON. First, update the sidebar HTML to hold the listing information and update your CSS to accommodate the layout changes: <div class='sidebar'> <div class='heading'> <h1>Our locations</h1> </div> <div id='listings' class='listings'></div> </div> body { color: #404040; font: 400 15px/22px 'Source Sans Pro', 'Helvetica Neue', Sans-serif; margin: 0; padding: 0; -webkit-font-smoothing: antialiased; } * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } h1 { font-size: 22px; margin: 0; font-weight: 400; line-height: 20px; padding: 20px 2px; } a { color: #404040; text-decoration: none; } a:hover { color: #101010; } .sidebar { position: absolute; width: 33.3333%; height: 100%; top: 0; left: 0; overflow: hidden; border-right: 1px solid rgba(0, 0, 0, 0.25); } .pad2 { padding: 20px; } .map { position: absolute; left: 33.3333%; width: 66.6666%; top: 0; bottom: 0; } .heading { background: #fff; border-bottom: 1px solid #eee; height: 60px; line-height: 60px; padding: 0 10px; } .listings { height: 100%; overflow: auto; padding-bottom: 60px; } .listings .item { display: block; border-bottom: 1px solid #eee; padding: 10px; text-decoration: none; } .listings .item:last-child { border-bottom: none; } .listings .item .title { display: block; color: #00853e; font-weight: 700; } .listings .item .title small { font-weight: 400; } .listings .item.active .title, .listings .item .title:hover { color: #8cc63f; } .listings .item.active { background-color: #f8f8f8; } ::-webkit-scrollbar { width: 3px; height: 3px; border-left: 0; background: rgba(0, 0, 0, 0.1); } ::-webkit-scrollbar-track { background: none; } ::-webkit-scrollbar-thumb { background: #00853e; border-radius: 0; } .clearfix { display: block; } .clearfix::after { content: '.'; display: block; height: 0; clear: both; visibility: hidden; } Next, build a function to iterate through the Sweetgreen locations and add each one to the sidebar listing: function buildLocationList(data) { // Iterate through the list of stores for (i = 0; i < data.features.length; i++) { var currentFeature = data.features[i]; // Shorten data.feature.properties to `prop` so we're not // writing this long form over and over again. var prop = currentFeature.properties; // Select the listing container in the HTML and append a div // with the class 'item' for each store var listings = document.getElementById('listings'); var listing = listings.appendChild(document.createElement('div')); listing.className = 'item'; listing.id = 'listing-' + i; // Create a new link with the class 'title' for each store // and fill it with the store address var link = listing.appendChild(document.createElement('a')); link.href = '#'; link.className = 'title'; link.dataPosition = i; link.innerHTML = prop.address; // Create a new div with the class 'details' for each store // and fill it with the city and phone number var details = listing.appendChild(document.createElement('div')); details.innerHTML = prop.city; if (prop.phone) { details.innerHTML += ' · ' + prop.phoneFormatted; } } } Then, you will need to call this function when the map loads. You can do this by adding buildLocationList(stores); inside your map.on('load', ...) function after addLayer(). The result will look like this: Make the map interactive When a user clicks a link in the sidebar or on a point on the map, you want three things to happen: The map to fly to the associated store location. A popup to be displayed at that point. The listing to be highlighted in the sidebar. This will require a bit more code, but you can do it! Define interactivity functions First, define two functions: one that flies the map to the correct store, and one that displays a popup at that point. These functions will be fired both when a user clicks on a link in the sidebar listing and when a user clicks on a store location in the map. (Highlighting the listing on the sidebar will be handled separately for the two different click events.) function flyToStore(currentFeature) { map.flyTo( { center: currentFeature.geometry.coordinates, zoom: 15 } ); } function createPopUp(currentFeature) { var popUps = document.getElementsByClassName('mapboxgl-popup'); // Check if there is already a popup on the map and if so, remove it if (popUps[0]) popUps[0].remove(); var popup = new mapboxgl.Popup( { closeOnClick: false } ) .setLngLat(currentFeature.geometry.coordinates) .setHTML('<h3>Sweetgreen</h3>' + '<h4>' + currentFeature.properties.address + '</h4>') .addTo(map); } You can also style your popups using CSS: /* Marker tweaks */ .mapboxgl-popup-close-button { display: none; } .mapboxgl-popup-content { font: 400 15px/22px 'Source Sans Pro', 'Helvetica Neue', Sans-serif; padding: 0; width: 180px; } .mapboxgl-popup-content-wrapper { padding: 1%; } .mapboxgl-popup-content h3 { background: #91c949; color: #fff; margin: 0; display: block; padding: 10px; border-radius: 3px 3px 0 0; font-weight: 700; margin-top: -15px; } .mapboxgl-popup-content h4 { margin: 0; display: block; padding: 10px; font-weight: 400; } .mapboxgl-popup-content div { padding: 10px; } .mapboxgl-container .leaflet-marker-icon { cursor: pointer; } .mapboxgl-popup-anchor-top > .mapboxgl-popup-content { margin-top: 15px; } .mapboxgl-popup-anchor-top > .mapboxgl-popup-tip { border-bottom-color: #91c949; } For the .remove() method to work in older browsers, you will need to include the code below at the beginning of your script: // This will let you use the .remove() function later on if (!('remove' in Element.prototype)) { Element.prototype.remove = function() { if (this.parentNode) { this.parentNode.removeChild(this); } } ; } See the HTML documentation for more information. Add event listeners Now that you've defined these two functions, you want them to fire when a user clicks on a restaurant in the sidebar listing or when a user clicks on a restaurant on the map. To do this, you will add event listeners that listen for ""click"" events and execute some function when they happen. You will add two event listeners: one for when a link in the sidebar is clicked and one for when a location on the map is clicked. Use this code for when a link is clicked: // Add an event listener for the links in the sidebar listing link.addEventListener('click', function(e) { // Update the currentFeature to the store associated with the clicked link var clickedListing = data.features[this.dataPosition]; // 1. Fly to the point associated with the clicked link flyToStore(clickedListing); // 2. Close all other popups and display popup for clicked store createPopUp(clickedListing); // 3. Highlight listing in sidebar (and remove highlight for all other listings) var activeItem = document.getElementsByClassName('active'); if (activeItem[0]) { activeItem[0].classList.remove('active'); } this.parentNode.classList.add('active'); } ); Use this code for when a location on the map is clicked: // Add an event listener for when a user clicks on the map map.on('click', function(e) { // Query all the rendered points in the view var features = map.queryRenderedFeatures(e.point, { layers: ['locations'] } ); if (features.length) { var clickedPoint = features[0]; // 1. Fly to the point flyToStore(clickedPoint); // 2. Close all other popups and display popup for clicked store createPopUp(clickedPoint); // 3. Highlight listing in sidebar (and remove highlight for all other listings) var activeItem = document.getElementsByClassName('active'); if (activeItem[0]) { activeItem[0].classList.remove('active'); } // Find the index of the store.features that corresponds to the clickedPoint that fired the event listener var selectedFeature = clickedPoint.properties.address; for (var i = 0; i < stores.features.length; i++) { if (stores.features[i].properties.address === selectedFeature) { selectedFeatureIndex = i; } } // Select the correct list item using the found index and add the active class var listing = document.getElementById('listing-' + selectedFeatureIndex); listing.classList.add('active'); } } ); Add custom markers This section will walk you through how to replace the existing standard symbol layer with custom markers. First, you will need to remove the existing symbol layer and related functions. Remove the symbol layer by deleting the .addLayer() function from your code, and replace it with the .addSource() code below. Instead of styling the symbol layer with addLayer, you will use the Markers API to add an image to each point in the GeoJSON data: map.addSource('places', { type: 'geojson', data: stores } ); You'll also want to delete the function that listened for a click on a symbol to fly to the location, display a popup, and highlight the list item. Then, add the custom Sweetgreen icons to the map using mapboxgl.Marker() objects. Unlike the symbol layer, which has symbols embedded in the map, mapboxgl.Marker() objects are HTML DOM elements that can be styled with CSS. Add a new class to the CSS called .marker and set the Sweetgreen marker you downloaded earlier as the background-image: .marker { border: none; cursor: pointer; height: 56px; width: 56px; background-image: url(marker.png); background-color: rgba(0, 0, 0, 0); } To add the new markers to the map, iterate through all stores and add the new marker to the map at each location: stores.features.forEach(function(marker) { // Create a div element for the marker var el = document.createElement('div'); // Add a class called 'marker' to each div el.className = 'marker'; // By default the image for your custom marker will be anchored // by its center. Adjust the position accordingly // Create the custom markers, set their position, and add to map new mapboxgl.Marker(el, { offset: [0, -23] } ) .setLngLat(marker.geometry.coordinates) .addTo(map); } ); Add new event listeners Now that you have replaced your symbols with markers, you will need to re-add some code for flying to the position on the map, displaying a popup, and highlighting the list item in the sidebar when clicking on the marker. Within your forEach function from above, add an event listener: el.addEventListener('click', function(e) { var activeItem = document.getElementsByClassName('active'); // 1. Fly to the point flyToStore(marker); // 2. Close all other popups and display popup for clicked store createPopUp(marker); // 3. Highlight listing in sidebar (and remove highlight for all other listings) e.stopPropagation(); if (activeItem[0]) { activeItem[0].classList.remove('active'); } var listing = document.getElementById('listing-' + i); console.log(listing); listing.classList.add('active'); } ); Final tweaks You will need to adjust the position of the popup to account for the added height of the marker. You can do this using CSS: .mapboxgl-popup { padding-bottom: 50px; } At this point, you can also freshen up the type with Source Sans Pro: <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700' rel='stylesheet'> You'll need to update the font property in body style: font: 400 15px/22px 'Source Sans Pro', 'Helvetica Neue', Sans-serif; Finished product You have completed the store locator. Next steps After following this guide, you have the tools you need to create your own store locator. Explore more Mapbox GL JS resources on our help page. Was this page helpful? Yes No",Build a store locator using Mapbox GL JS,Getting started,Add structure,Initialize the map,Load data,Build store listing,Make the map interactive,Define interactivity functions,Add event listeners,Add custom markers,Add new event listeners,Final tweaks,Finished product,Next steps,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,Welcome to Mapbox Maps SDK for Unity documentation! | Mapbox SDK for Unity,,https://docs.mapbox.com/mapbox-unity-sdk/index.html,,,,"Toggle navigation Mapbox Maps SDK for Unity Version Notes|View in Github The Mapbox Maps SDK for Unity is a C#-based wrapper for Mapbox's location APIs. It allows Unity developers to easily access and interact with our Maps, Geocoding, and Directions services from within the Unity 3D platform. Getting started Get the SDK Quick start links: Getting started Changelog Known issues API Documentation Unity SDK page Back to top © 2017 Mapbox",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Create a simple map view,Learn how to quickly display a Mapbox Street map in your app.,https://docs.mapbox.com/android/maps/examples/create-a-simple-map-view/,example,Java,,"Create a simple map view Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.basics.SimpleMapViewActivity""> <!-- Set the starting camera position and map style using xml--> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.73581"" mapbox:mapbox_cameraTargetLng=""-73.99155"" mapbox:mapbox_cameraZoom=""11"" /> </FrameLayout> Copy Activity View on GitHub Java Kotlin package com.mapbox.mapboxandroiddemo.examples.basics; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; /** * The most basic example of adding a map to an activity. */ public class SimpleMapViewActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_basic_simple_mapview); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Map is set up and the style has loaded. Now you can add data or make other map adjustments. } }); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Create a simple map view,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,zoom level,A zoom level determines how much of a map is visible.,https://docs.mapbox.com/help/glossary/zoom-level/,glossary,,,"zoom level A zoom level determines how much of the map is visible: at zoom level 0 you see the whole world, at zoom level 16 you could see a small road. This data is stored in a quadtree data structure. The zoom level also affects the size of the vector tiles that are loaded. Was this page helpful? Yes No",zoom level,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Advanced navigation app,Add advanced navigation functionality to an iOS app.,https://docs.mapbox.com/ios/navigation/examples/advanced/,example,Swift,,"Advanced navigation app import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections import Mapbox class AdvancedViewController: UIViewController, MGLMapViewDelegate, CLLocationManagerDelegate, NavigationMapViewDelegate, NavigationViewControllerDelegate { var mapView: NavigationMapView? var currentRoute: Route? { get { return routes?.first } set { guard let selected = newValue else { routes?.remove(at: 0); return } guard let routes = routes else { self.routes = [selected]; return } self.routes = [selected] + routes.filter { $0 != selected } } } var routes: [Route]? { didSet { guard let routes = routes, let current = routes.first else { mapView?.removeRoutes(); return } mapView?.showRoutes(routes) mapView?.showWaypoints(current) } } var startButton: UIButton? var locationManager = CLLocationManager() private typealias RouteRequestSuccess = (([Route]) -> Void) private typealias RouteRequestFailure = ((NSError) -> Void) //MARK: - Lifecycle Methods override func viewDidLoad() { super.viewDidLoad() locationManager.delegate = self locationManager.requestWhenInUseAuthorization() mapView = NavigationMapView(frame: view.bounds) mapView?.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView?.userTrackingMode = .follow mapView?.delegate = self mapView?.navigationMapViewDelegate = self let gesture = UILongPressGestureRecognizer(target: self, action: #selector(handleLongPress(_:))) mapView?.addGestureRecognizer(gesture) view.addSubview(mapView!) startButton = UIButton() startButton?.setTitle(""Start Navigation"", for: .normal) startButton?.translatesAutoresizingMaskIntoConstraints = false startButton?.backgroundColor = .blue startButton?.contentEdgeInsets = UIEdgeInsets(top: 10, left: 20, bottom: 10, right: 20) startButton?.addTarget(self, action: #selector(tappedButton(sender:)), for: .touchUpInside) startButton?.isHidden = true view.addSubview(startButton!) startButton?.bottomAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.bottomAnchor, constant: -20).isActive = true startButton?.centerXAnchor.constraint(equalTo: self.view.centerXAnchor).isActive = true view.setNeedsLayout() } //overriding layout lifecycle callback so we can style the start button override func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() startButton?.layer.cornerRadius = startButton!.bounds.midY startButton?.clipsToBounds = true startButton?.setNeedsDisplay() } @objc func tappedButton(sender: UIButton) { guard let route = currentRoute else { return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) let navigationOptions = NavigationOptions(navigationService: navigationService) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) navigationViewController.delegate = self present(navigationViewController, animated: true, completion: nil) } @objc func handleLongPress(_ gesture: UILongPressGestureRecognizer) { guard gesture.state == .ended else { return } let spot = gesture.location(in: mapView) guard let location = mapView?.convert(spot, toCoordinateFrom: mapView) else { return } requestRoute(destination: location) } func requestRoute(destination: CLLocationCoordinate2D) { guard let userLocation = mapView?.userLocation!.location else { return } let userWaypoint = Waypoint(location: userLocation, heading: mapView?.userLocation?.heading, name: ""user"") let destinationWaypoint = Waypoint(coordinate: destination) let options = NavigationRouteOptions(waypoints: [userWaypoint, destinationWaypoint]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let routes = routes else { return } self.routes = routes self.startButton?.isHidden = false self.mapView?.showRoutes(routes) self.mapView?.showWaypoints(self.currentRoute!) } } // Delegate method called when the user selects a route func navigationMapView(_ mapView: NavigationMapView, didSelect route: Route) { self.currentRoute = route } } Copy Was this page helpful? Yes No",Advanced navigation app,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Set a point after Geocoder result,Style a Marker used to mark the location of the mapbox-gl-geocoder result.,https://docs.mapbox.com/mapbox-gl-js/example/point-from-geocoder-result/,example,JavaScript,,Set a point after Geocoder result Style a Marker used to mark the location of the mapbox-gl-geocoder result. Was this example helpful? Yes No,Set a point after Geocoder result,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,shapefile,"A shapefile, also known as an Esri shapefile, is a file format for storing geographic vector data.",https://docs.mapbox.com/help/glossary/shapefile/,glossary,,,"shapefile A shapefile, also known as an Esri shapefile, is a file format for storing geographic vector data. You can upload shapefiles to Mapbox Studio to add custom data to your maps. When you upload shapefiles, Mapbox converts your data to vector tiles so you can create styles from it. When uploading shapefiles, keep the following in mind: Read the Mapbox Uploads API documentation for the current size limit for shapefiles. Note that this limit applies to the shapefile's uncompressed size, not the size of the compressed zip. Shapefiles are composed of several individual files, which should be combined into a single zip file before uploading. Of these files, Mapbox can read shp, shx, dbf, prj, and index files. Any other files you upload with your zip file will be ignored. For more information on uploading shapefiles, read the Mapbox Studio Manual uploads page. Download a sample shapefile Was this page helpful? Yes No",shapefile,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Storyboards,Set up Mapbox Navigation in a storyboard in Xcode.,https://docs.mapbox.com/ios/navigation/overview/storyboards/,guide,,,"Storyboards To set up Mapbox Navigation in a storyboard: Open the object library and drag in a Storyboard Reference. Pick Navigation from the dropdown and set bundle to com.mapbox.MapboxNavigation (org.cocoapods.MapboxNavigation if you are using CocoaPods) Set up a segue to the storyboard reference like you would to any other UIViewController. You also need to pass a route and optionally a directions instance to the NavigationViewController. To do that, override your UIViewController's prepare(for:sender:): override func prepare(for segue: UIStoryboardSegue, sender: Any?) { switch segue.identifier ?? """" { case ""MyNavigationSegue"": if let controller = segue.destination as? NavigationViewController { controller.route = route controller.directions = directions } default: break } } Was this page helpful? Yes No",Storyboards,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,layout and paint properties,Layout and paint properties are two sub-properties of a layer that decides how data from the layer is rendered in maps that use Mapbox GL.,https://docs.mapbox.com/help/glossary/layout-paint-property/,glossary,,,"layout and paint properties Layout and paint properties are two sub-properties of a layer that define how spatial data is rendered in Mapbox GL maps. Layout properties define how the renderer draws and applies data for that layer. Examples of layout properties include visibility, line-cap, and symbol-placement. Paint properties define how data for that layer is styled, and are applied later in the rendering properties. Examples of paint properties include fill-color, background-pattern, and line-opacity. For more information about layout and paint properties, see the Mapbox Style Specification. Was this page helpful? Yes No",layout and paint properties,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Set pitch and bearing,"Map options extend CameraOptions, so you can set more than just center and zoom.",https://docs.mapbox.com/mapbox-gl-js/example/set-perspective/,example,JavaScript,,"Set pitch and bearing Map options extend CameraOptions, so you can set more than just center and zoom. Was this example helpful? Yes No",Set pitch and bearing,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Localization and internationalization,An overview of localization and internationalization with the Mapbox Navigation SDK for iOS.,https://docs.mapbox.com/ios/navigation/overview/localization-and-internationalization/,guide,,,"Localization and internationalization The Mapbox Navigation SDK supports over a dozen major languages as well as some other locale settings. For a seamless user experience, the SDK’s default behavior matches the standard iOS behavior as much as possible, but several customization options are also available for specialized use cases. User interface The Mapbox Navigation SDK’s user interface automatically matches your application’s language whenever possible. To improve user experience, you should localize your application fully rather than piecemeal. However, if you want to display a turn-by-turn navigation experience in a language without first localizing your application, you can add the language to your Xcode project’s languages and add a stub Localizable.strings file to your application target. For more information about preparing your application for additional languages, consult “Localizing Your App” in Apple developer documentation. Distances, travel times, and arrival times are displayed according to the system language and region settings by default, regardless of the application’s language. By default, the measurement system is that of the spoken instructions. To override the measurement system displayed in the user interface but not that of the spoken instructions, set the NavigationSettings.distanceUnit property. The turn banner names the upcoming road or ramp destination in the local or national language. In some regions, the name may appear in multiple languages or scripts. A label near the bottom bar displays the current road name in the local language as well. By default, the map inside NavigationViewController displays road labels in the local language, while points of interest and places are displayed in the system’s preferred language, if that language is one of the eight supported by the Mapbox Streets source. The user can set the system’s preferred language in Settings, General Settings, Language & Region. A standalone NavigationMapView labels roads, points of interest, and places in the language specified by the current style. (The default Mapbox Navigation Guidance Day v2 style specifies English.) To match the behavior of the map inside NavigationViewController, call the NavigationMapView.localizeLabels() method from within MGLMapViewDelegate.mapView(_:didFinishLoading:): func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { if let mapView = mapView as? NavigationMapView { mapView.localizeLabels() } } Spoken instructions Turn instructions are announced in the user interface language when turn instructions are available in that language. Otherwise, if turn instructions are unavailable in that language, they are announced in English instead. To have instructions announced in a language other than the user interface language, set theDirectionsOptions.locale property when calculating the route with which to start navigation. Turn instructions are primarily designed to be announced by either the Mapbox Voice API (powered by Amazon Polly) or the Speech Synthesis framework built into iOS (also known as AVSpeechSynthesizer or VoiceOver). This SDK uses the Mapbox Voice API by default. If the Voice API lacks support for the turn instruction language, AVSpeechSynthesizer announces the instructions instead. The Voice API requires an Internet connection at various points along the route. To have AVSpeechSynthesizer announce the instructions regardless of the language, initialize a RouteVoiceController, then set NavigationViewController.voiceController to the RouteVoiceController before presenting the NavigationViewController. Neither the Voice API nor AVSpeechSynthesizer supports Burmese, Esperanto, Ukrainian, or Vietnamese; for these languages, you must create a subclass of RouteVoiceController that uses a third-party speech synthesizer. By default, the SDK provides distances in the predominant measurement system of the system region, which may not necessarily be the same region in which the user is traveling. To override the measurement system used in spoken instructions, set the RouteOptions.distanceMeasurementSystem property when calculating the route with which to start navigation. The upcoming road or ramp destination is named according to the local or national language. In some regions, the name may appear in multiple languages or scripts. Supported languages Language User interface Spoken instructions Remarks Arabic ✅ ✅ Uses VoiceOver Burmese — ✅ Manual, requires third-party text-to-speech Catalan ✅ — Chinese ✅ Simplified ✅ Mandarin Uses VoiceOver Danish ✅ ✅ Dutch ✅ ✅ English ✅ ✅ Esperanto — ✅ Manual, requires third-party text-to-speech Finnish — ✅ Manual, uses VoiceOver French ✅ ✅ German ✅ ✅ Hebrew ✅ ✅ Uses VoiceOver Hungarian ✅ ✅ Uses VoiceOver Indonesian — ✅ Manual, uses VoiceOver Italian ✅ ✅ Japanese ✅ ✅ Korean ✅ ✅ Norwegian — ✅ Manual Portuguese ✅ ✅ Polish — ✅ Manual Romanian — ✅ Manual Russian ✅ ✅ Slovenian — ✅ Manual, requires third-party text-to-speech Spanish ✅ ✅ Swedish ✅ ✅ Turkish — ✅ Manual Ukrainian — ✅ Manual, requires third-party text-to-speech Vietnamese ✅ ✅ Requires third-party text-to-speech Yoruba ✅ — Requires third-party text-to-speech Contributing See the contributing guide for instructions on adding a new localization or improving an existing localization. Was this page helpful? Yes No",Localization and internationalization,User interface,Spoken instructions,Supported languages,Contributing,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Use third-party vector tiles,Load a third-party vector source using a custom style.,https://docs.mapbox.com/ios/maps/examples/source-custom-vector/,example,Swift,Objective-C,"Use third-party vector tiles Download third_party_vector_style.json and add it to your project. Swift Objective C import Mapbox class ViewController: UIViewController { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() // Third party vector tile sources can be added. // In this case we're using custom style JSON (https://www.mapbox.com/mapbox-gl-style-spec/) to add a third party tile source from Mapillary: <https://d25uarhxywzl1j.cloudfront.net/v0.1/{z}/{x}/{y}.mvt> let customStyleURL = Bundle.main.url(forResource: ""third_party_vector_style"", withExtension: ""json"")! mapView = MGLMapView(frame: view.bounds, styleURL: customStyleURL) mapView.setCenter(CLLocationCoordinate2DMake(60.16, 24.93), zoomLevel: 12, animated: false) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .white // Set the minimum zoom level to prevent the map from zooming out past zoom level 6. mapView.minimumZoomLevel = 6 view.addSubview(mapView) } } Copy Was this page helpful? Yes No",Use third-party vector tiles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Update a choropleth layer by zoom level,"Using 2014 census data, display state or county population depending on zoom level.",https://docs.mapbox.com/mapbox-gl-js/example/updating-choropleth/,example,JavaScript,,"Update a choropleth layer by zoom level Using 2014 census data, display state or county population depending on zoom level. Was this example helpful? Yes No",Update a choropleth layer by zoom level,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Style Specification,"This specification defines and describes the visual appearance of a map: what data to draw, the order to draw it in, and how to style the data when drawing it.",https://docs.mapbox.com/mapbox-gl-js/style-spec/,specification,,,,Style Specification,Root Properties,Light,Sources,vector,raster,raster-dem,geojson,image,video,Sprite,Glyphs,Transition,Layers,,background,fill,line,symbol,circle,fill-extrusion,heatmap,hillshade,Types,Color,Formatted,String,Boolean,Number,Array,Expressions,Data expressions,Camera expressions,Composition,Type system,Expression reference,Feature data,Lookup,Decision,"Ramps, scales, curves",Variable binding,Math,Zoom,Heatmap,Other,Function,stops,property,base,type,default,colorSpace,Other filter,Existential Filters,Comparison Filters,Set Membership Filters,Combining Filters,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Work with markers in Mapbox.js,"Add custom, interactive markers to your map with Mapbox.js.",https://docs.mapbox.com/help/tutorials/markers-js/,tutorial,JavaScript,,"intermediate JavaScript Work with markers in Mapbox.js Note Mapbox.js is no longer in active development. To learn more about our newer mapping tools see Add custom markers in Mapbox GL JS. In this guide, we’ll show how to add markers, customize them, and make them interactive with Mapbox.js. Think of this guide as a curated stroll through all that’s possible with markers in Mapbox.js. Getting started For this guide you'll need your API access token. You can find your access token on your Account page. To better understand each example, you can copy the full source code into your own local project and experiment. We adapted many of these demos from Mapbox.js examples. Add markers You can add markers to your map using Leaflet or with GeoJSON using Mapbox.js. Add markers in Leaflet You can add a DOM marker to your map with L.marker. In the example below, we added a marker to the map by knowing its coordinates. Use this technique when you have only a few markers to add. <div id='map-leaflet' class='map'> </div> <script> var mapLeaflet = L.mapbox.map('map-leaflet') .setView([37.8, -96], 4) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); L.marker([38.913184, -77.031952]).addTo(mapLeaflet); L.marker([37.775408, -122.413682]).addTo(mapLeaflet); mapLeaflet.scrollWheelZoom.disable(); </script> Add markers with GeoJSON in Mapbox.js You can also save your marker coordinates as GeoJSON and then load your GeoJSON on a map with Mapbox.js. In this example, we added the coordinates of the Mapbox D.C. and San Francisco offices to our inline GeoJSON. The GeoJSON format organizes features, especially when working with larger data files. <div id='map_geo' class='map'> </div> <script> var geojson = [ { type: 'Feature', geometry: { type: 'Point', coordinates: [-77.031952, 38.913184] } } , { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.413682, 37.775408] } } ]; var mapGeo = L.mapbox.map('map_geo') .setView([37.8, -96], 4) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); var myLayer = L.mapbox.featureLayer().setGeoJSON(geojson).addTo(mapGeo); mapGeo.scrollWheelZoom.disable(); </script> You can also load GeoJSON as an external file hosted locally or on GitHub. In the next section, you'll learn how to style GeoJSON markers with the simplestyle specification. If you're new to working with GeoJSON, here are some tools to help you generate, validate, or format GeoJSON: geojson.net — create and customize GeoJSON. geojsonhint — validate GeoJSON with this lint tool. toGeoJSON — convert a KML or GPX file to GeoJSON. csv2geojson — convert a CSV file to GeoJSON. Style markers To style a marker, you can add simplestyle to your GeoJSON, load a custom image, or create your own markers with HTML and CSS. Style markers with simplestyle The simplestyle spec is a styling convention for GeoJSON. This means that you can add specific keys and values to each marker to change a marker's color, symbol, and size. Here are all the styling options available as keys and values: Key Value Example ""marker-color"" Any hex value Example: ""#3bb2d0"" ""marker-symbol"" Any Maki icon name, an integer, or a lowercase letter Example: ""1"" ""marker-size"" small, medium, large Example: ""large"" In this example, we took the GeoJSON from the previous section and added simplestyle. View the source to see how the marker styles are added to each feature. <div id='map_simple' class='map'> </div> <script> var geojson = [ { type: 'Feature', geometry: { type: 'Point', coordinates: [-77.031952, 38.913184] } , properties: { 'marker-color': '#3bb2d0', 'marker-size': 'large', 'marker-symbol': 'rocket' } } , { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.413682, 37.775408] } , properties: { 'marker-color': '#3bb2d0', 'marker-size': 'large', 'marker-symbol': 'rocket' } } ]; var mapSimple = L.mapbox.map('map_simple') .setView([37.8, -96], 4) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); var myLayer = L.mapbox.featureLayer().setGeoJSON(geojson).addTo(mapSimple); mapSimple.scrollWheelZoom.disable(); </script> Style markers with an image You can define a custom marker image in your GeoJSON by adding an icon object to each feature's properties. In this example, L.icon is used to set the marker image to each feature's iconURL. <div id='map-one' class='map'> </div> <script> var mapOne = L.mapbox.map('map-one') .setView([37.8, -96], 4) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); var myLayer = L.mapbox.featureLayer().addTo(mapOne); var geojson = [ { type: 'Feature', geometry: { type: 'Point', coordinates: [-77.031952, 38.913184] } , properties: { icon: { iconUrl: 'https://www.mapbox.com/mapbox.js/assets/images/astronaut1.png', iconSize: [50, 50], // size of the icon iconAnchor: [25, 25], // point of the icon which will correspond to marker's location popupAnchor: [0, -25], // point from which the popup should open relative to the iconAnchor className: 'dot' } } } , { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.413682, 37.775408] } , properties: { icon: { iconUrl: 'https://www.mapbox.com/mapbox.js/assets/images/astronaut2.png', iconSize: [50, 50], // size of the icon iconAnchor: [25, 25], // point of the icon which will correspond to marker's location popupAnchor: [0, -25], // point from which the popup should open relative to the iconAnchor className: 'dot' } } } ]; myLayer.on('layeradd', function(e) { var marker = e.layer, feature = marker.feature; marker.setIcon(L.icon(feature.properties.icon)); } ); myLayer.setGeoJSON(geojson); mapOne.scrollWheelZoom.disable(); </script> Style markers with HTML and CSS If you'd like to customize your markers even more, you can replace the standard marker with a <div>, assign it a class, and then style it with CSS using L.divIcon. In this example, you'll follow a similar pattern as you did when adding a marker image, but instead you'll assign a class name to the features and then add CSS to style it. <style> .my-icon { border-radius: 100%; width: 20px; height: 20px; text-align: center; line-height: 20px; color: white; } .icon-dc { background: #3bb2d0; } .icon-sf { background: #3bb2d0; } </style> <div id='map-two' class='map'> </div> <script> var mapTwo = L.mapbox.map('map-two') .setView([37.8, -96], 4) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); var myLayer = L.mapbox.featureLayer().addTo(mapTwo); var geojson = [ { type: 'Feature', geometry: { type: 'Point', coordinates: [-77.031952, 38.913184] } , properties: { icon: { className: 'my-icon icon-dc', // class name to style html: '★', // add content inside the marker, in this case a star iconSize: null // size of icon, use null to set the size in CSS } } } , { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.413682, 37.775408] } , properties: { icon: { className: 'my-icon icon-sf', // class name to style html: '★', // add content inside the marker, in this case a star iconSize: null // size of icon, use null to set the size in CSS } } } ]; myLayer.on('layeradd', function(e) { var marker = e.layer, feature = marker.feature; marker.setIcon(L.divIcon(feature.properties.icon)); } ); myLayer.setGeoJSON(geojson); mapTwo.scrollWheelZoom.disable(); </script> ```html ## Add popups You can add popups with simplestyle in your GeoJSON or with JavaScript. ### Add popups with simplestyle Simplestyle allows you to add popups automatically if you add `title` and `description` keys to each feature's properties. In the example below, these fields are added to the GeoJSON. Click the markers to trigger the popup. ```html <div id='map-popups' class='map'> </div> <script> var mapPopups = L.mapbox.map('map-popups') .setView([37.8, -96], 4) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); var myLayer = L.mapbox.featureLayer().addTo(mapPopups); var geojson = [ { type: 'Feature', geometry: { type: 'Point', coordinates: [-77.031952, 38.913184] } , properties: { title: 'Mapbox DC', description: '1714 14th St NW, Washington DC', 'marker-color': '#3bb2d0', 'marker-size': 'large', 'marker-symbol': 'rocket' } } , { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.413682, 37.775408] } , properties: { title: 'Mapbox SF', description: '155 9th St, San Francisco', 'marker-color': '#3bb2d0', 'marker-size': 'large', 'marker-symbol': 'rocket' } } ]; myLayer.setGeoJSON(geojson); mapPopups.scrollWheelZoom.disable(); </script> You can add HTML to you popups by adding it to the title and description values in your GeoJSON. This allows you to add links, images, videos, lists, and other HTML elements to your popups. Add popups with JavaScript You can customize the content of each popup with the L.bindPopup method. In this example, an image key is added to each feature's property object, and a reference to this key when is included when bindPopup() is called to make the image appear inside the popup. <div id='map-popups-js' class='map'> </div> <script> var mapPopupsJS = L.mapbox.map('map-popups-js') .setView([37.8, -96], 4) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); var myLayer = L.mapbox.featureLayer().addTo(mapPopupsJS); var geojson = [ { type: 'Feature', geometry: { type: 'Point', coordinates: [-77.031952, 38.913184] } , properties: { title: 'Mapbox DC', description: '1714 14th St NW, Washington DC', image: 'https://farm9.staticflickr.com/8604/15769066303_3e4dcce464_n.jpg', icon: { iconUrl: 'https://www.mapbox.com/mapbox.js/assets/images/astronaut1.png', iconSize: [50, 50], // size of the icon iconAnchor: [25, 25], // point of the icon which will correspond to marker's location popupAnchor: [0, -25], // point from which the popup should open relative to the iconAnchor className: 'dot' } } } , { type: 'Feature', geometry: { type: 'Point', coordinates: [-122.413682, 37.775408] } , properties: { title: 'Mapbox SF', description: '155 9th St, San Francisco', image: 'https://farm9.staticflickr.com/8571/15844010757_63b093d527_n.jpg', icon: { iconUrl: 'https://www.mapbox.com/mapbox.js/assets/images/astronaut2.png', iconSize: [50, 50], // size of the icon iconAnchor: [25, 25], // point of the icon which will correspond to marker's location popupAnchor: [0, -25], // point from which the popup should open relative to the iconAnchor className: 'dot' } } } ]; // Set a custom icon on each marker based on feature properties. myLayer.on('layeradd', function(e) { var marker = e.layer, feature = marker.feature; marker.setIcon(L.icon(feature.properties.icon)); var content = '<p><strong>' + feature.properties.title + '</strong></p><img src=""' + feature.properties.image + '"" alt="""">'; marker.bindPopup(content); } ); myLayer.setGeoJSON(geojson); mapPopupsJS.scrollWheelZoom.disable(); </script> More examples You can further customize your popups with Mapbox.js. Here are more examples to get you started: Add an image gallery to a popup Show popup outside of the marker Embed a video in a popup Embed an audio clip in a popup Tabs in popups Style popups with CSS Cluster markers For dense point data, try the Leaflet plug-in Markercluster to visualize your data. In the example below, we load an external GeoJSON file, create a clustergroup from the data, and add it to the map. Since Markercluster is a plugin, you'll need to add additional CSS and JS to enable it. <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/ v3.2.0 /leaflet.markercluster.js'></script> <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/ v3.2.0 /MarkerCluster.css' rel='stylesheet' /> <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/ v3.2.0 /MarkerCluster.Default.css' rel='stylesheet' /> <div id='map-cluster' class='map'></div> <script> var mapCluster = L.mapbox.map('map-cluster') .setView([38.9, -77], 11) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); L.mapbox.featureLayer() .loadURL('/help/data/stations.geojson') .on('ready', function(e) { var clusterGroup = new L.MarkerClusterGroup(); e.target.eachLayer(function(layer) { clusterGroup.addLayer(layer); } ); mapCluster.addLayer(clusterGroup); } ); mapCluster.scrollWheelZoom.disable(); </script> More examples For more ideas of what you can do with clusters in Mapbox.js, explore these examples: Marker clusters with Mapbox data Multiple differently styled clusters Clusters with custom polygon appearance Clusters with custom cluster icons Toggle layers Finally, take a look at how to toggle layers in Mapbox.js. You can help users sift through your markers by adding filters to let them turn layers on and off. In this example, the script automatically creates a toggle option for each transit line and will only add a new layer to the toggle list if its line is declared in the GeoJSON. <style> .filter-ui { background: #fff; position: absolute; top: 10px; right: 10px; z-index: 100; padding: 10px; border-radius: 3px; } .filter-ui input { vertical-align: middle; } </style> <nav id='filters' class='filter-ui'></nav> <div id='map-toggle' class='map'></div> <script> var mapToggle = L.mapbox.map('map-toggle') .setView([38.9, -77], 11) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); var filters = document.getElementById('filters'); var markers = L.mapbox.featureLayer().loadURL('/help/data/examples/stations.geojson'); markers.on('ready', function(e) { var typesObj = { } , types = []; var features = e.target._geojson.features; for (var i = 0; i < features.length; i++) { typesObj[features[i].properties.line] = true; } for (var key in typesObj) { if ( { } .hasOwnProperty.call(typesObj, key)) { types.push(key); } } var checkboxes = []; for (var j = 0; j < types.length; j++) { var item = filters.appendChild(document.createElement('div')); var checkbox = item.appendChild(document.createElement('input')); var label = item.appendChild(document.createElement('label')); checkbox.type = 'checkbox'; checkbox.id = types[j]; checkbox.checked = true; label.innerHTML = types[j]; label.setAttribute('for', types[j]); checkbox.addEventListener('change', update); checkboxes.push(checkbox); } function update() { var enabled = { } ; for (var k = 0; k < checkboxes.length; k++) { if (checkboxes[k].checked) enabled[checkboxes[k].id] = true; } markers.setFilter(function(feature) { return feature.properties.line in enabled; } ); } } ).addTo(mapToggle); mapToggle.scrollWheelZoom.disable(); </script> More examples For more ideas on how to filter or toggle your markers, explore these examples: Filter by marker symbol Multiple filters on markers Toggling layers Next steps You now have the tools, code, and inspiration to add any markers you need to your map. For more ways to extend your Mapbox.js project, explore the Build a store locator tutorial. Was this page helpful? Yes No",Work with markers in Mapbox.js,Getting started,Add markers,Add markers in Leaflet,Add markers with GeoJSON in Mapbox.js,Style markers,Style markers with simplestyle,Style markers with an image,Style markers with HTML and CSS,Add popups with JavaScript,More examples,Cluster markers,Toggle layers,Next steps,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Rerouting,Learn how to use and customize off-route detection with the Mapbox Navigation SDK for iOS for app's navigation experience.,https://docs.mapbox.com/ios/navigation/overview/rerouting/,guide,,,"Rerouting Rerouting is when a new route is generated after the user's progress along a route has already begun. There are a few reasons rerouting happens including the user going off-route and the Navigation SDK determining there is a faster route to the next waypoint from the user's current location. Off-route detection The Navigation SDK provides information about whether a user's device is on the route that was generated. If a user is off-route, you can provide additional instruction to the user and generate a new route. The RouteController's userIsOnRoute property uses the device location to check if a user is on or off the current route and returns a boolean. By default, if a user is off-route, a new route is generated from their current location to the next waypoint. NavigationServiceDelegate.navigationService(_:willRerouteFrom:) is called and Notification.Name.routeControllerWillReroute is posted after the SDK detects the need for a reroute but before receiving the new route. Then NavigationServiceDelegate.navigationService(_:didRerouteAlong:at:proactive:) is called and Notification.Name.routeControllerDidReroute is posted once you receive the new route. You can use these methods to customize built-in behavior and synchronize your application behavior with what's happening with navigation logic. You can also preempt rerouting on a case-by-case basis using the NavigationServiceDelegate.navigationService(_:shouldRerouteFrom:) delegate method. Faster-route detection By default, the Navigation SDK checks for a faster route every two minutes by making a request to the Direction API and comparing the response to the current route. You can customize the interval at which to check for a faster route by setting the RouteControllerProactiveReroutingInterval global variable. You can opt-out of faster-route detection by setting navigationService.router.reroutesProactively to false. navigationService.router.reroutesProactively = false Was this page helpful? Yes No",Rerouting,Off-route detection,Faster-route detection,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Make a tilequery request,Use the Tilequery API to search for features in a tileset. This example queries for up to 10 buildings which are within 50 meters of the single map click location.,https://docs.mapbox.com/android/java/examples/tilequery/,example,Java,,"Make a tilequery request Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:id=""@+id/constraint_layout"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.javaservices.TilequeryActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""40.73581"" mapbox:mapbox_cameraTargetLng=""-73.99155"" mapbox:mapbox_cameraZoom=""11"" /> <androidx.cardview.widget.CardView android:layout_width=""0dp"" android:layout_height=""0dp"" android:layout_marginBottom=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginStart=""8dp"" android:layout_marginTop=""8dp"" mapbox:layout_constraintBottom_toBottomOf=""@+id/mapView"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""@+id/guideline8""> <TextView android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:textStyle=""bold"" android:textColor=""@color/black_semi_transparent"" android:padding=""8dp"" android:text=""@string/api_response"" /> <ScrollView android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_marginLeft=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginTop=""32dp""> <TextView android:id=""@+id/tilequery_response_info_textview"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" /> </ScrollView> </androidx.cardview.widget.CardView> <androidx.constraintlayout.widget.Guideline android:id=""@+id/guideline8"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:orientation=""horizontal"" mapbox:layout_constraintGuide_percent=""0.7"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.graphics.BitmapFactory; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.TextView; import android.widget.Toast; import com.mapbox.android.core.permissions.PermissionsListener; import com.mapbox.android.core.permissions.PermissionsManager; import com.mapbox.api.tilequery.MapboxTilequery; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.modes.CameraMode; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Use the Mapbox Tilequery API to retrieve information about Features on a Vector Tileset. More info about * the Tilequery API can be found at https://www.mapbox.com/api-documentation/#tilequery */ public class TilequeryActivity extends AppCompatActivity implements OnMapReadyCallback, PermissionsListener, MapboxMap.OnMapClickListener { private static final String RESULT_GEOJSON_SOURCE_ID = ""RESULT_GEOJSON_SOURCE_ID""; private static final String CLICK_CENTER_GEOJSON_SOURCE_ID = ""CLICK_CENTER_GEOJSON_SOURCE_ID""; private static final String LAYER_ID = ""LAYER_ID""; private PermissionsManager permissionsManager; private MapboxMap mapboxMap; private MapView mapView; private TextView tilequeryResponseTextView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_javaservices_tilequery); tilequeryResponseTextView = findViewById(R.id.tilequery_response_info_textview); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @SuppressWarnings( {""MissingPermission""}) @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { TilequeryActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { addClickLayer(style); addResultLayer(style); displayDeviceLocation(style); mapboxMap.addOnMapClickListener(TilequeryActivity.this); Toast.makeText(TilequeryActivity.this, R.string.click_on_map_instruction, Toast.LENGTH_SHORT).show(); } }); } /** * Add a map layer which will show a marker icon where the map was clicked */ private void addClickLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addImage(""CLICK-ICON-ID"", BitmapFactory.decodeResource( TilequeryActivity.this.getResources(), R.drawable.red_marker)); loadedMapStyle.addSource(new GeoJsonSource(CLICK_CENTER_GEOJSON_SOURCE_ID, FeatureCollection.fromFeatures(new Feature[] {}))); loadedMapStyle.addLayer(new SymbolLayer(""click-layer"", CLICK_CENTER_GEOJSON_SOURCE_ID).withProperties( iconImage(""CLICK-ICON-ID""), iconOffset(new Float[] {0f, -12f}), iconIgnorePlacement(true), iconAllowOverlap(true) )); } /** * Add a map layer which will show marker icons for all of the Tilequery API results */ private void addResultLayer(@NonNull Style loadedMapStyle) { // Add the marker image to map loadedMapStyle.addImage(""RESULT-ICON-ID"", BitmapFactory.decodeResource( TilequeryActivity.this.getResources(), R.drawable.blue_marker)); // Retrieve GeoJSON information from the Mapbox Tilequery API loadedMapStyle.addSource(new GeoJsonSource(RESULT_GEOJSON_SOURCE_ID, FeatureCollection.fromFeatures(new Feature[] {}))); loadedMapStyle.addLayer(new SymbolLayer(LAYER_ID, RESULT_GEOJSON_SOURCE_ID).withProperties( iconImage(""RESULT-ICON-ID""), iconOffset(new Float[] {0f, -12f}), iconIgnorePlacement(true), iconAllowOverlap(true) )); } @Override public boolean onMapClick(@NonNull LatLng point) { Style style = mapboxMap.getStyle(); if (style != null) { // Move and display the click center layer's red marker icon to wherever the map was clicked on GeoJsonSource clickLocationSource = style.getSourceAs(CLICK_CENTER_GEOJSON_SOURCE_ID); if (clickLocationSource != null) { clickLocationSource.setGeoJson(Point.fromLngLat(point.getLongitude(), point.getLatitude())); } // Use the map click location to make a Tilequery API call makeTilequeryApiCall(style, point); return true; } return false; } /** * Use the Java SDK's MapboxTilequery class to build a API request and use the API response * * @param point the center point that the the tilequery will originate from. */ private void makeTilequeryApiCall(@NonNull final Style style, @NonNull LatLng point) { MapboxTilequery tilequery = MapboxTilequery.builder() .accessToken(getString(R.string.access_token)) .mapIds(""mapbox.mapbox-streets-v7"") .query(Point.fromLngLat(point.getLongitude(), point.getLatitude())) .radius(50) .limit(10) .geometry(""polygon"") .dedupe(true) .layers(""building"") .build(); tilequery.enqueueCall(new Callback<FeatureCollection>() { @Override public void onResponse(Call<FeatureCollection> call, Response<FeatureCollection> response) { tilequeryResponseTextView.setText(response.body().toJson()); GeoJsonSource resultSource = style.getSourceAs(RESULT_GEOJSON_SOURCE_ID); if (resultSource != null && response.body().features() != null) { resultSource.setGeoJson(FeatureCollection.fromFeatures(response.body().features())); } } @Override public void onFailure(Call<FeatureCollection> call, Throwable throwable) { Timber.d(""Request failed: %s"", throwable.getMessage()); Toast.makeText(TilequeryActivity.this, R.string.api_error, Toast.LENGTH_SHORT).show(); } }); } /** * Use the Maps SDK's LocationComponent to display the device location on the map */ @SuppressWarnings( {""MissingPermission""}) private void displayDeviceLocation(@NonNull Style loadedMapStyle) { // Check if permissions are enabled and if not request if (PermissionsManager.areLocationPermissionsGranted(this)) { // Get an instance of the component LocationComponent locationComponent = mapboxMap.getLocationComponent(); // Activate with options locationComponent.activateLocationComponent(this, loadedMapStyle); // Enable to make component visible locationComponent.setLocationComponentEnabled(true); // Set the component's camera mode locationComponent.setCameraMode(CameraMode.TRACKING); locationComponent.setRenderMode(RenderMode.COMPASS); // Zoom the camera into the device's current location mapboxMap.animateCamera(CameraUpdateFactory .newCameraPosition(new CameraPosition.Builder() .zoom(17) .build()), 2000); } else { permissionsManager = new PermissionsManager(this); permissionsManager.requestLocationPermissions(this); } } // The following three methods are related to showing the device's location via the LocationComponent @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { permissionsManager.onRequestPermissionsResult(requestCode, permissions, grantResults); } @Override public void onExplanationNeeded(List<String> permissionsToExplain) { Toast.makeText(this, R.string.user_location_permission_explanation, Toast.LENGTH_LONG).show(); } @Override public void onPermissionResult(boolean granted) { Style style = mapboxMap.getStyle(); if (granted && style != null) { displayDeviceLocation(style); } else { Toast.makeText(this, R.string.user_location_permission_not_granted, Toast.LENGTH_LONG).show(); finish(); } } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Make a tilequery request,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,RecyclerView Directions,Quickly show the directions route associated with a RecyclerView item.,https://docs.mapbox.com/android/maps/examples/recycler-view-directions/,example,Java,,"RecyclerView Directions Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""13.730219"" mapbox:mapbox_cameraTargetLng=""100.501723"" mapbox:mapbox_cameraZoom=""10.58"" /> <androidx.recyclerview.widget.RecyclerView android:id=""@+id/rv_on_top_of_map"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom"" android:layout_marginBottom=""32dp"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.graphics.BitmapFactory; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.cardview.widget.CardView; import androidx.recyclerview.widget.DefaultItemAnimator; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.LinearSnapHelper; import androidx.recyclerview.widget.RecyclerView; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import android.widget.Toast; import com.mapbox.api.directions.v5.DirectionsCriteria; import com.mapbox.api.directions.v5.MapboxDirections; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; import java.util.Random; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import static com.mapbox.core.constants.Constants.PRECISION_6; import static com.mapbox.mapboxsdk.style.layers.Property.LINE_JOIN_ROUND; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineJoin; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * When a RecyclerView item is tapped on, display the Mapbox Directions API route * associated with the item. */ public class RecyclerViewDirectionsActivity extends AppCompatActivity implements OnMapReadyCallback { private static final String TAG = ""RVDirectionsActivity""; private static final String SYMBOL_ICON_ID = ""SYMBOL_ICON_ID""; private static final String PERSON_ICON_ID = ""PERSON_ICON_ID""; private static final String MARKER_SOURCE_ID = ""MARKER_SOURCE_ID""; private static final String PERSON_SOURCE_ID = ""PERSON_SOURCE_ID""; private static final String DASHED_DIRECTIONS_LINE_LAYER_SOURCE_ID = ""DASHED_DIRECTIONS_LINE_LAYER_SOURCE_ID""; private static final String LAYER_ID = ""LAYER_ID""; private static final String PERSON_LAYER_ID = ""PERSON_LAYER_ID""; private static final String DASHED_DIRECTIONS_LINE_LAYER_ID = ""DASHED_DIRECTIONS_LINE_LAYER_ID""; private static final Point directionsOriginPoint = Point.fromLngLat(100.48730850219725, 13.737217333153827); private static final LatLng[] possibleDestinations = new LatLng[]{ new LatLng(13.773399508046145, 100.51116943359375), new LatLng(13.743387039520751, 100.45074462890625), new LatLng(13.732715012486663, 100.5523681640625), new LatLng(13.665336643848484, 100.45486450195312), new LatLng(13.7153719325982, 100.49263000488281), new LatLng(13.742053062720384, 100.51288604736328), new LatLng(13.77773432408578, 100.4806137084961), new LatLng(13.784736549340208, 100.55580139160156), new LatLng(13.71670606117596, 100.45520782470703) }; private final List<DirectionsRoute> directionsRouteList = new ArrayList<>(); private MapboxMap mapboxMap; private MapView mapView; private FeatureCollection dashedLineDirectionsFeatureCollection; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_recycler_view_directions); // Initialize the map view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { RecyclerViewDirectionsActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(new Style.Builder().fromUri(Style.LIGHT) // Set up the image, source, and layer for the person icon, // which is where all of the routes will start from .withImage(PERSON_ICON_ID, BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.ic_person))) .withSource(new GeoJsonSource(PERSON_SOURCE_ID, Feature.fromGeometry(directionsOriginPoint))) .withLayer(new SymbolLayer(PERSON_LAYER_ID, PERSON_SOURCE_ID).withProperties( iconImage(PERSON_ICON_ID), iconSize(2f), iconAllowOverlap(true), iconIgnorePlacement(true) )) // Set up the image, source, and layer for the potential destination markers .withImage(SYMBOL_ICON_ID, BitmapFactory.decodeResource( this.getResources(), R.drawable.red_marker)) .withSource(new GeoJsonSource(MARKER_SOURCE_ID, initDestinationFeatureCollection())) .withLayer(new SymbolLayer(LAYER_ID, MARKER_SOURCE_ID).withProperties( iconImage(SYMBOL_ICON_ID), iconAllowOverlap(true), iconIgnorePlacement(true), iconOffset(new Float[]{0f, -4f}) )) // Set up the source and layer for the direction route LineLayer .withSource(new GeoJsonSource(DASHED_DIRECTIONS_LINE_LAYER_SOURCE_ID)) .withLayerBelow( new LineLayer(DASHED_DIRECTIONS_LINE_LAYER_ID, DASHED_DIRECTIONS_LINE_LAYER_SOURCE_ID) .withProperties( lineWidth(7f), lineJoin(LINE_JOIN_ROUND), lineColor(Color.parseColor(""#2096F3"")) ), PERSON_LAYER_ID), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { getRoutesToAllPoints(); initRecyclerView(); Toast.makeText(RecyclerViewDirectionsActivity.this, R.string.toast_instruction, Toast.LENGTH_SHORT).show(); } }); } /** * Loop through the possible destination list of LatLng locations and get * the route for each destination. */ private void getRoutesToAllPoints() { for (LatLng singleLatLng : possibleDestinations) { getRoute(Point.fromLngLat(singleLatLng.getLongitude(), singleLatLng.getLatitude())); } } /** * Make a call to the Mapbox Directions API to get the route from the person location icon * to the marker's location and then add the route to the route list. * * @param destination the marker associated with the recyclerview card that was tapped on. */ @SuppressWarnings({""MissingPermission""}) private void getRoute(Point destination) { MapboxDirections client = MapboxDirections.builder() .origin(directionsOriginPoint) .destination(destination) .overview(DirectionsCriteria.OVERVIEW_FULL) .profile(DirectionsCriteria.PROFILE_DRIVING) .accessToken(getString(R.string.access_token)) .build(); client.enqueueCall(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { if (response.body() == null) { Log.d(TAG, ""No routes found, make sure you set the right user and access token.""); return; } else if (response.body().routes().size() < 1) { Log.d(TAG, ""No routes found""); return; } // Add the route to the list. directionsRouteList.add(response.body().routes().get(0)); } @Override public void onFailure(Call<DirectionsResponse> call, Throwable throwable) { Log.d(TAG, ""Error: "" + throwable.getMessage()); if (!throwable.getMessage().equals(""Coordinate is invalid: 0,0"")) { Toast.makeText(RecyclerViewDirectionsActivity.this, ""Error: "" + throwable.getMessage(), Toast.LENGTH_SHORT).show(); } } }); } /** * Update the GeoJSON data for the direction route LineLayer. * * @param route The route to be drawn in the map's LineLayer that was set up above. */ private void drawNavigationPolylineRoute(final DirectionsRoute route) { if (mapboxMap != null) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { List<Feature> directionsRouteFeatureList = new ArrayList<>(); LineString lineString = LineString.fromPolyline(route.geometry(), PRECISION_6); List<Point> lineStringCoordinates = lineString.coordinates(); for (int i = 0; i < lineStringCoordinates.size(); i++) { directionsRouteFeatureList.add(Feature.fromGeometry( LineString.fromLngLats(lineStringCoordinates))); } dashedLineDirectionsFeatureCollection = FeatureCollection.fromFeatures(directionsRouteFeatureList); GeoJsonSource source = style.getSourceAs(DASHED_DIRECTIONS_LINE_LAYER_SOURCE_ID); if (source != null) { source.setGeoJson(dashedLineDirectionsFeatureCollection); } } }); } } /** * Create a FeatureCollection to display the possible destination markers. * * @return a {@link FeatureCollection}, which represents the possible destinations. */ private FeatureCollection initDestinationFeatureCollection() { List<Feature> featureList = new ArrayList<>(); for (LatLng latLng : possibleDestinations) { featureList.add(Feature.fromGeometry( Point.fromLngLat(latLng.getLongitude(), latLng.getLatitude()))); } return FeatureCollection.fromFeatures(featureList); } /** * Set up the RecyclerView. */ private void initRecyclerView() { RecyclerView recyclerView = findViewById(R.id.rv_on_top_of_map); recyclerView.setLayoutManager(new LinearLayoutManager(getApplicationContext(), LinearLayoutManager.HORIZONTAL, true)); recyclerView.setItemAnimator(new DefaultItemAnimator()); recyclerView.setAdapter(new LocationRecyclerViewAdapter(this, createRecyclerViewLocations(), mapboxMap)); new LinearSnapHelper().attachToRecyclerView(recyclerView); } /** * Create data fro the RecyclerView. * * @return a list of {@link SingleRecyclerViewLocation} objects for the RecyclerView. */ private List<SingleRecyclerViewLocation> createRecyclerViewLocations() { ArrayList<SingleRecyclerViewLocation> locationList = new ArrayList<>(); for (int x = 0; x < possibleDestinations.length; x++) { SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation(); singleLocation.setName(String.format(getString(R.string.rv_directions_route_card_name), x)); singleLocation.setAvailableTables(String.format(getString( R.string.rv_directions_route_available_table_info), new Random().nextInt(possibleDestinations.length))); locationList.add(singleLocation); } return locationList; } /** * POJO model class for a single location in the RecyclerView. */ class SingleRecyclerViewLocation { private String name; private String availableTables; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAvailableTables() { return availableTables; } public void setAvailableTables(String availableTables) { this.availableTables = availableTables; } } static class LocationRecyclerViewAdapter extends RecyclerView.Adapter<LocationRecyclerViewAdapter.MyViewHolder> { private List<SingleRecyclerViewLocation> locationList; private MapboxMap map; private WeakReference<RecyclerViewDirectionsActivity> weakReference; public LocationRecyclerViewAdapter(RecyclerViewDirectionsActivity activity, List<SingleRecyclerViewLocation> locationList, MapboxMap mapBoxMap) { this.locationList = locationList; this.map = mapBoxMap; this.weakReference = new WeakReference<>(activity); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View itemView = LayoutInflater.from(parent.getContext()) .inflate(R.layout.rv_directions_card, parent, false); return new MyViewHolder(itemView); } @Override public void onBindViewHolder(MyViewHolder holder, int position) { SingleRecyclerViewLocation singleRecyclerViewLocation = locationList.get(position); holder.name.setText(singleRecyclerViewLocation.getName()); holder.numOfAvailableTables.setText(singleRecyclerViewLocation.getAvailableTables()); holder.setClickListener(new ItemClickListener() { @Override public void onClick(View view, int position) { weakReference.get() .drawNavigationPolylineRoute(weakReference.get().directionsRouteList.get(position)); } }); } @Override public int getItemCount() { return locationList.size(); } static class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener { TextView name; TextView numOfAvailableTables; CardView singleCard; ItemClickListener clickListener; MyViewHolder(View view) { super(view); name = view.findViewById(R.id.location_title_tv); numOfAvailableTables = view.findViewById(R.id.location_num_of_beds_tv); singleCard = view.findViewById(R.id.single_location_cardview); singleCard.setOnClickListener(this); } public void setClickListener(ItemClickListener itemClickListener) { this.clickListener = itemClickListener; } @Override public void onClick(View view) { clickListener.onClick(view, getLayoutPosition()); } } } public interface ItemClickListener { void onClick(View view, int position); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",RecyclerView Directions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,POI placement,An overview of the POI placement sample scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/poi-placement/,example,No code,,"POI placement The POI placement example makes it possible to find, add, and style points of interest (POIs) on a map. This example shows how to place custom prefabs over specific POIs. POI placement The POI Placement scene uses the POINTS OF INTEREST section in Abstract Map to place a variety of different markers at various POIs, organized by category. Each layer includes a prefab and a set of rules for where to place the prefab. You can find POI locations by category (as in this example), by name (""Starbucks""), by address, or by latitude longitude coordinates. When finding POIs by category or name, it is also possible to adjust the density of results. For example, a high density of ""Food"" POIs will show all restaurants, cafes, and bars in an area, while a lower density will only show popular ones. Customize POI prefabs The Unity SDK comes with a few POI prefabs, which can be edited or replaced as needed. These prefabs all have PoiLabelTextSetter.cs attached to them to handle variable label sizes. This script first looks for the POI's name, house number, or type. It then uses that string as a label, and applies a color background to make it readable. This background adjusts to fit the size of the string, with extra padding along the sides. It is possible hard code a specific label, or edit the script to change label attributes such as the background style. Note that these prefabs are all 2D sprites and TextMeshes that face the camera, but any style of prefab will work and PoiLabelTextSetter.cs does not necessarily have to be used. Create a custom scene with POIs The video tutorial below demonstrates how to approach adding POIs to a 3D map in a fly over scene. Benefits and limitations POI Placement allows you to add a variety of POI prefabs to a map, by category, name, address, or latitude and longitude. These prefabs can be 2D or 3D, though the scene uses 2D prefabs. These POIs do not explicitly interact with the map and will not necessarily replace any vector features. Use this example to mark POIs on a map. Was this page helpful? Yes No",POI placement,Customize POI prefabs,Create a custom scene with POIs,Benefits and limitations,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Annotation views,Custom annotation views with animated selection.,https://docs.mapbox.com/ios/maps/examples/annotation-views/,example,Swift,Objective-C,"Annotation views This example uses two classes within a single file: CustomAnnotationView is a subclass of MGLAnnotationView, a descendant of UIView. ViewController uses these annotation views with MGLMapView. To learn about more ways to add points to a map, see the Markers and annotations guide. Swift Objective C import Mapbox // Example view controller class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.styleURL = MGLStyle.darkStyleURL mapView.tintColor = .lightGray mapView.centerCoordinate = CLLocationCoordinate2D(latitude: 0, longitude: 66) mapView.zoomLevel = 2 mapView.delegate = self view.addSubview(mapView) // Specify coordinates for our annotations. let coordinates = [ CLLocationCoordinate2D(latitude: 0, longitude: 33), CLLocationCoordinate2D(latitude: 0, longitude: 66), CLLocationCoordinate2D(latitude: 0, longitude: 99) ] // Fill an array with point annotations and add it to the map. var pointAnnotations = [MGLPointAnnotation]() for coordinate in coordinates { let point = MGLPointAnnotation() point.coordinate = coordinate point.title = ""\(coordinate.latitude), \(coordinate.longitude)"" pointAnnotations.append(point) } mapView.addAnnotations(pointAnnotations) } // MARK: - MGLMapViewDelegate methods // This delegate method is where you tell the map to load a view for a specific annotation. To load a static MGLAnnotationImage, you would use `-mapView:imageForAnnotation:`. func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? { // This example is only concerned with point annotations. guard annotation is MGLPointAnnotation else { return nil } // Use the point annotation’s longitude value (as a string) as the reuse identifier for its view. let reuseIdentifier = ""\(annotation.coordinate.longitude)"" // For better performance, always try to reuse existing annotations. var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: reuseIdentifier) // If there’s no reusable annotation view available, initialize a new one. if annotationView == nil { annotationView = CustomAnnotationView(reuseIdentifier: reuseIdentifier) annotationView!.bounds = CGRect(x: 0, y: 0, width: 40, height: 40) // Set the annotation view’s background color to a value determined by its longitude. let hue = CGFloat(annotation.coordinate.longitude) / 100 annotationView!.backgroundColor = UIColor(hue: hue, saturation: 0.5, brightness: 1, alpha: 1) } return annotationView } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { return true } } // // MGLAnnotationView subclass class CustomAnnotationView: MGLAnnotationView { override func layoutSubviews() { super.layoutSubviews() // Use CALayer’s corner radius to turn this view into a circle. layer.cornerRadius = bounds.width / 2 layer.borderWidth = 2 layer.borderColor = UIColor.white.cgColor } override func setSelected(_ selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) // Animate the border width in/out, creating an iris effect. let animation = CABasicAnimation(keyPath: ""borderWidth"") animation.duration = 0.1 layer.borderWidth = selected ? bounds.width / 4 : 2 layer.add(animation, forKey: ""borderWidth"") } } Copy Was this page helpful? Yes No",Annotation views,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,filter,"A filter, also known as a predicate within iOS and macOS, gives you fine-grained control over the content of a style layer.",https://docs.mapbox.com/help/glossary/filter/,glossary,,,"filter A filter, also known as a predicate within iOS and macOS, gives you fine-grained control over the content of a style layer. A style layer that gets its features from a GeoJSON or vector source only includes the features that meet the filter or predicate condition that you define. See the documentation for filters and predicates for more information. Was this page helpful? Yes No",filter,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Place the geocoder input outside the map,Use the mapbox-gl-geocoder control to search for places using Mapbox Geocoding API attached to an element outside the map.,https://docs.mapbox.com/mapbox-gl-js/example/mapbox-gl-geocoder-outside-the-map/,example,JavaScript,,Place the geocoder input outside the map Use the mapbox-gl-geocoder control to search for places using Mapbox Geocoding API attached to an element outside the map. Was this example helpful? Yes No,Place the geocoder input outside the map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Select a feature within a layer,Allow a user to select a feature within a style layer.,https://docs.mapbox.com/ios/maps/examples/select-layer/,example,Swift,Objective-C,"Select a feature within a layer Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! let layerIdentifier = ""state-layer"" override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.delegate = self mapView.setCenter(CLLocationCoordinate2D(latitude: 39.23225, longitude: -97.91015), animated: false) mapView.autoresizingMask = [.flexibleHeight, .flexibleWidth] view.addSubview(mapView) // Add a single tap gesture recognizer. This gesture requires the built-in MGLMapView tap gestures (such as those for zoom and annotation selection) to fail. let singleTap = UITapGestureRecognizer(target: self, action: #selector(handleMapTap(sender:))) for recognizer in mapView.gestureRecognizers! where recognizer is UITapGestureRecognizer { singleTap.require(toFail: recognizer) } mapView.addGestureRecognizer(singleTap) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { // Load a tileset containing U.S. states and their population density. For more information about working with tilesets, see: https://www.mapbox.com/help/studio-manual-tilesets/ let url = URL(string: ""mapbox://examples.69ytlgls"")! let source = MGLVectorTileSource(identifier: ""state-source"", configurationURL: url) style.addSource(source) let layer = MGLFillStyleLayer(identifier: layerIdentifier, source: source) // Access the tileset layer. layer.sourceLayerIdentifier = ""stateData_2-dx853g"" // Create a stops dictionary. This defines the relationship between population density and a UIColor. let stops = [0: UIColor.yellow, 600: UIColor.red, 1200: UIColor.blue] // Style the fill color using the stops dictionary, exponential interpolation mode, and the feature attribute name. layer.fillColor = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:(density, 'linear', nil, %@)"", stops) // Insert the new layer below the Mapbox Streets layer that contains state border lines. See the layer reference for more information about layer names: https://www.mapbox.com/vector-tiles/mapbox-streets-v8/ // admin-1-boundary is available starting in mapbox-streets-v8, while admin-3-4-boundaries is provided here as a fallback for styles using older data sources. if let symbolLayer = style.layer(withIdentifier: ""admin-1-boundary"") ?? style.layer(withIdentifier: ""admin-3-4-boundaries"") { style.insertLayer(layer, below: symbolLayer) } else { fatalError(""Layer with specified identifier not found in current style"") } } @objc @IBAction func handleMapTap(sender: UITapGestureRecognizer) { // Get the CGPoint where the user tapped. let spot = sender.location(in: mapView) // Access the features at that point within the state layer. let features = mapView.visibleFeatures(at: spot, styleLayerIdentifiers: Set([layerIdentifier])) // Get the name of the selected state. if let feature = features.first, let state = feature.attribute(forKey: ""name"") as? String { changeOpacity(name: state) } else { changeOpacity(name: """") } } func changeOpacity(name: String) { guard let layer = mapView.style?.layer(withIdentifier: layerIdentifier) as? MGLFillStyleLayer else { fatalError(""Could not cast to specified MGLFillStyleLayer"") } // Check if a state was selected, then change the opacity of the states that were not selected. if !name.isEmpty { layer.fillOpacity = NSExpression(format: ""TERNARY(name = %@, 1, 0)"", name) } else { // Reset the opacity for all states if the user did not tap on a state. layer.fillOpacity = NSExpression(forConstantValue: 1) } } } Copy Was this page helpful? Yes No",Select a feature within a layer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Geographic Analytics,Introduction,Get started with the Geographic Analytics Extension for Tableau.,https://docs.mapbox.com/geographic-analytics/overview/,guide,,,"Geographic Analytics Extension for Tableau Current version: v 1.0 Performant vector maps Advanced geospatial analytics Install The Geographic Analytic Extension provides Tableau users with the ability to create geospatial visualizations that are not possible with Tableau Desktop yet. The overarching purpose of this extension is to extend Tableau's geospatial capabilities, introduce users to new geospatial techniques, and inspire thought about the future of mapping in Tableau. Capabilities The extension provides users with the following visualization capabilities: Clustering Hex Grid Square Grid Voronoi Data Elevation (isobands) All visualizations are dynamically generated and zoomed to the bounding box of the selected data. System requirements You must use Tableau 2018.2 or higher to access the Geographic Analytic Extension. No Mapbox account is required. The Extension API connects to your underlying data by binding to an individual worksheet. Once the connected, the API will query the underlying data of that specific worksheet. If the volume of data for that worksheet exceeds 10,000 rows, then the extension will display an error. It is important to note that this 10,000 rows is the documented limit for the Extension API. To resolve this error, reduce the data passed to the extension. Options for this include: Select fewer marks on the bound worksheet. Aggregate the dataset of the bound worksheet. Filter the dataset of the bound worksheet. There is a known issue that affects some users on Tableau Desktop for Windows. Due to the settings on the embedded browser utilized by Desktop, there may be an issue in which WebGL is not enabled. This will cause the extension to fail initialization. If this occurs, you will see an error. Unfortunately, this is a Tableau issue and cannot be resolved by Mapbox. If you see this issue, please contact Tableau Support. Installation instructions Once you have downloaded the extension from the link above or from the Tableau Extension Gallery, add it to your dashboard as normal. You do not need to sign up for a Mapbox account for the extension to function. Was this page helpful? Yes No",Geographic Analytics Extension for Tableau,Capabilities,System requirements,Installation instructions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Snapshotter,"Take a static snapshot photo of the map to use on the device in your app, a notification, or even to share with others.",https://docs.mapbox.com/android/maps/overview/snapshotter/,guide,Java,Kotlin,"Snapshotter The snapshot functionality of the Mapbox Maps SDK for Android generates a static map image to use in your Android project. Take a snapshot of any Mapbox map and add the image into: another screen in your app a home screen a home screen widget a notification a ListView/RecyclerView wherever else a Bitmap can be placed A Mapbox map doesn't need to be displayed to use the snapshot functionality. MapSnapshotter can be invoked anywhere in the app. Unless you have the map tiles already cached, the device will need an internet connection to download the style and tiles necessary to render the map, and thus, the snapshot. Snapshot generation can happen on the device's background thread and won't compromise the user experience. This snapshot feature is different than the Mapbox Static Images API. The MapboxStaticMap class helps you build a URL to request a static map image which looks like an embedded map without interactivity or controls. Taking a map snapshot The MapSnapshotter constructor requires a MapSnapshotter.Options object. Java Kotlin MapSnapshotter.Options snapShotOptions = new MapSnapshotter.Options(500, 500); snapShotOptions.withRegion(mapboxMap.getProjection().getVisibleRegion().latLngBounds); snapShotOptions.withStyle(mapboxMap.getStyle().getUrl()); MapSnapshotter mapSnapshotter = new MapSnapshotter(this, snapShotOptions); Copy Here are the various settings that are available within the MapSnapshotter.Options class. You would use them in the same way that withRegion() and withStyle() are used in the code snippet above. Method Description withApiBaseUrl Specifies the URL used for the Maps API endpoint. It's very rare that you'll need to change the API base URL. withLocalIdeographFontFamily Set the font family for generating glyphs locally for ideographs in the the ""CJK Unified Ideographs"" and ""Hangul Syllables"" ranges. withCameraPosition The camera position to use for the snapshot image. This position is overriden if withRegion is also used. withLogo A boolean flag to determine whether the Mapbox logo is included in the snapshot image. withPixelRatio The pixel ratio to use. The default is 1. withRegion The region to show in the snapshot image. This is applied after the camera position. withStyle The map style to use in the snapshot image. withStyleJson The map style JSON to use instead of a map style URL. Start the snapshot process with start() once you've created your MapSnapshotter object. When MapSnapshot is ready, use snapshot.getBitmap() to retrieve the Bitmap image. Java Kotlin mapSnapshotter.start(new MapSnapshotter.SnapshotReadyCallback() { @Override public void onSnapshotReady(MapSnapshot snapshot) { // Display, share, or use bitmap image how you'd like Bitmap bitmapImage = snapshot.getBitmap(); } }); Copy Once you have the Bitmap image, you're free to use it how you'd like. The Mapbox Android demo app has two examples that show how the snapshot Bitmap images can be used: Sharing example Share the real-time map snapshot image UI example Use the map snapshot image in a notification Was this page helpful? Yes No",Snapshotter,Taking a map snapshot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add a line annotation from GeoJSON,Draw a polyline by parsing a GeoJSON file.,https://docs.mapbox.com/ios/maps/examples/line-geojson/,example,Swift,Objective-C,"Add a line annotation from GeoJSON Download example.geojson and add it to your project. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 45.5076, longitude: -122.6736), zoomLevel: 11, animated: false) view.addSubview(self.mapView) mapView.delegate = self drawPolyline() } func drawPolyline() { // Parsing GeoJSON can be CPU intensive, do it on a background thread DispatchQueue.global(qos: .background).async(execute: { // Get the path for example.geojson in the app's bundle let jsonPath = Bundle.main.path(forResource: ""example"", ofType: ""geojson"") let url = URL(fileURLWithPath: jsonPath!) do { // Convert the file contents to a shape collection feature object let data = try Data(contentsOf: url) guard let shapeCollectionFeature = try MGLShape(data: data, encoding: String.Encoding.utf8.rawValue) as? MGLShapeCollectionFeature else { fatalError(""Could not cast to specified MGLShapeCollectionFeature"") } if let polyline = shapeCollectionFeature.shapes.first as? MGLPolylineFeature { // Optionally set the title of the polyline, which can be used for: // - Callout view // - Object identification polyline.title = polyline.attributes[""name""] as? String // Add the annotation on the main thread DispatchQueue.main.async(execute: { // Unowned reference to self to prevent retain cycle [unowned self] in self.mapView.addAnnotation(polyline) }) } } catch { print(""GeoJSON parsing failed"") } }) } func mapView(_ mapView: MGLMapView, alphaForShapeAnnotation annotation: MGLShape) -> CGFloat { // Set the alpha for all shape annotations to 1 (full opacity) return 1 } func mapView(_ mapView: MGLMapView, lineWidthForPolylineAnnotation annotation: MGLPolyline) -> CGFloat { // Set the line width for polyline annotations return 2.0 } func mapView(_ mapView: MGLMapView, strokeColorForShapeAnnotation annotation: MGLShape) -> UIColor { // Give our polyline a unique color by checking for its `title` property if (annotation.title == ""Crema to Council Crest"" && annotation is MGLPolyline) { // Mapbox cyan return UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1) } else { return .red } } } Copy Was this page helpful? Yes No",Add a line annotation from GeoJSON,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,TileMill,TileMill is a desktop application for designing maps.,https://docs.mapbox.com/help/glossary/tilemill/,glossary,,,"TileMill Note TileMill is no longer in active development. To learn more about our newer mapping tools see Mapbox Studio. TileMill is a desktop application for designing maps. It is no longer in active development. If you're designing a new map today, you should use Mapbox Studio. Was this page helpful? Yes No",TileMill,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,coordinate,A coordinate is the combination of longitude and latitude.,https://docs.mapbox.com/help/glossary/coordinate/,glossary,,,coordinate A coordinate is the combination of latitude and longitude. Altitude can be included as a third value. Was this page helpful? Yes No,coordinate,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Query map features,Official documentation about querying map features within the Mapbox Maps SDK for Android. Discover how to retrieve information about a selected place of interest.,https://docs.mapbox.com/android/maps/overview/query/,guide,Java,Kotlin,"Query map features The Maps SDK allows you to query map layers and return a list of GeoJSON features that include information about the feature's geometry and properties. For example, a user can query map features by tapping the map and return any POIs that exist at that point as a GeoJSON Feature. Then, you can access the properties in the feature, including the POI's name as a String. Querying the map won't always return the information that you are looking for. It is possible to receive a List<Feature> with 0 features in it. How querying works You can query the map for features that exist at a Point or within a BoundingBox. Aside from layers, it is also possible to query the source for specific information matching your query regardless if the items are being displayed on the map. Because features come from vector tile (or GeoJSON data that is converted to tiles internally), the query may split feature geometries or duplicate them across tile boundaries. As a result, features may appear multiple times in query results. For example, when querying by bounding box in an area that includes a highway spanning multiple tiles, the query will return a separate feature for every tile the highway spans. The geometry of each feature will be limited to the part of the highway that exists on that tile. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering. Query rendered features Use queryRenderedFeatures to return all map features currently rendered on the device. Features must be visible in the device's viewport and fully rendered before you can access them. Query at a point Query at point example Query the rendered map to get the properties at a specific location. queryRenderedFeatures only accepts a screen pixel value instead of LatLng, so in many cases you'll need convert screen position to geographic position. In the example below, when the map is clicked it provides a LatLng that is used to get the features at that point on the map. Java Kotlin @Override public void onMapClick(@NonNull LatLng point) { // Convert LatLng coordinates to screen pixel and only query the rendered features. final PointF pixel = mapboxMap.getProjection().toScreenLocation(point); List<Feature> features = mapboxMap.queryRenderedFeatures(pixel); // Get the first feature within the list if one exist if (features.size() > 0) { Feature feature = features.get(0); // Ensure the feature has properties defined if (feature.properties() != null) { for (Map.Entry<String, JsonElement> entry : feature.properties().entrySet()) { // Log all the properties Log.d(TAG, String.format(""%s = %s"", entry.getKey(), entry.getValue())); } } } } Copy Querying rendered features all layers: Java Kotlin List<Feature> features = mapboxMap.queryRenderedFeatures(pixel); Copy Querying rendered features in a specific layer: Java Kotlin // You can pass in a single layer id or a list of layer ids List<Feature> features = mapboxMap.queryRenderedFeatures(pixel,""LAYER-ID""); Copy Query inside a bounding box Query region example Query the rendered map to get the features found inside an Android view. To query the map for Features in an area, pass in a bounding box using a RectF object. This can either come from a Android View displayed to the user on top of the map or four coordinates that are shown within the viewport. The example below shows how to use four coordinates to create a RectF. The RectF object is passed into queryRenderedFeatures(). Java Kotlin RectF rectF = new RectF( mapView.getLeft(), mapView.getTop(), mapView.getRight(), mapView.getBottom() ); mapboxMap.queryRenderedFeatures(rectF); Copy Query source features querySourceFeatures() returns all features that match the query parameters regardless of whether or not the feature is currently rendered on the map. The domain of the query includes all currently-loaded vector tiles and GeoJSON source tiles. This function does not check tiles outside of the visible viewport. To query a source, you must pass in the query parameters as a set of Filters and only the features that satisfy the statement will be added to the returning list of features. In the example below, the map style contains a GeoJSON source called population-source, which contains a population property for each feature. The query below limits the features returned to those that have a population greater than 100,000. Java Kotlin GeoJsonSource source = mapboxMap.getSourceAs(""population-source""); List<Feature> features = source.querySourceFeatures(Expression.get(""population"")); Copy Was this page helpful? Yes No",Query map features,How querying works,Query rendered features,Query at a point,Query inside a bounding box,Query source features,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Hollow circle,Use Turf to calculate coordinates to eventually draw a ring around a center coordinate.,https://docs.mapbox.com/android/java/examples/turf-ring/,example,Java,,"Hollow circle Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.labs.SpaceStationLocationActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" mapbox:mapbox_cameraTargetLat="" 36.16218"" mapbox:mapbox_cameraTargetLng=""-115.150738"" mapbox:mapbox_cameraZoom=""11"" android:layout_height=""match_parent""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.geojson.Polygon; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.turf.TurfMeta; import com.mapbox.turf.TurfTransformation; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.turf.TurfConstants.UNIT_MILES; /** * Use {@link TurfTransformation#circle(Point, double, int, String)} to draw a hollow circle * (i.e. ring) around a center coordinate. */ public class TurfRingActivity extends AppCompatActivity implements MapboxMap.OnMapClickListener { private static final String OUTER_CIRCLE_GEOJSON_SOURCE_ID = ""OUTER_CIRCLE_GEOJSON_SOURCE_ID""; private static final String INNER_CIRCLE_GEOJSON_SOURCE_ID = ""INNER_CIRCLE_GEOJSON_SOURCE_ID""; private static final String OUTER_CIRCLE_LAYER_ID = ""OUTER_CIRCLE_LAYER_ID""; private static final String INNER_CIRCLE_LAYER_ID = ""INNER_CIRCLE_LAYER_ID""; private static final int OUTER_CIRCLE_MILE_RADIUS = 1; private static final double MILE_DIFFERENCE_BETWEEN_CIRCLES = .2; private static final int CIRCLE_STEPS = 360; private static final Point POINT_IN_MIDDLE_OF_CIRCLE = Point.fromLngLat(-115.150738, 36.16218); private MapView mapView; private MapboxMap mapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_hollow_circle); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { TurfRingActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(new Style.Builder() .fromUri(Style.LIGHT) .withSource(new GeoJsonSource(OUTER_CIRCLE_GEOJSON_SOURCE_ID)) .withSource(new GeoJsonSource(INNER_CIRCLE_GEOJSON_SOURCE_ID)) .withLayer(new FillLayer(OUTER_CIRCLE_LAYER_ID, OUTER_CIRCLE_GEOJSON_SOURCE_ID).withProperties( fillColor(Color.RED) )) .withLayer(new FillLayer(INNER_CIRCLE_LAYER_ID, INNER_CIRCLE_GEOJSON_SOURCE_ID).withProperties( fillColor(Color.RED) )), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { moveRing(POINT_IN_MIDDLE_OF_CIRCLE); TurfRingActivity.this.mapboxMap.addOnMapClickListener(TurfRingActivity.this); Toast.makeText(TurfRingActivity.this, getString(R.string.tap_on_map), Toast.LENGTH_SHORT).show(); } } ); } }); } @Override public boolean onMapClick(@NonNull LatLng point) { moveRing(Point.fromLngLat(point.getLongitude(), point.getLatitude())); return true; } private void moveRing(Point centerPoint) { if (mapboxMap.getStyle() != null) { Style style = mapboxMap.getStyle(); // Use Turf to calculate the coordinates for the outer ring of the final Polygon Polygon outerCirclePolygon = getTurfPolygon(OUTER_CIRCLE_MILE_RADIUS, centerPoint); // Use Turf to calculate the coordinates for the inner ring of the final Polygon Polygon innerCirclePolygon = getTurfPolygon( OUTER_CIRCLE_MILE_RADIUS - MILE_DIFFERENCE_BETWEEN_CIRCLES, centerPoint); GeoJsonSource outerCircleSource = style.getSourceAs(OUTER_CIRCLE_GEOJSON_SOURCE_ID); if (outerCircleSource != null) { // Use the two Polygon objects above to create the final Polygon that visually represents the ring. outerCircleSource.setGeoJson(Polygon.fromOuterInner( // Create outer LineString LineString.fromLngLats(TurfMeta.coordAll(outerCirclePolygon, false)), // Create inter LineString LineString.fromLngLats(TurfMeta.coordAll(innerCirclePolygon, false)) )); } } } private Polygon getTurfPolygon(@NonNull double radius, Point centerPoint) { return TurfTransformation.circle(centerPoint, radius, CIRCLE_STEPS, UNIT_MILES); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Hollow circle,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Change the case of labels,Use the upcase and downcase expressions to change the case of labels.,https://docs.mapbox.com/mapbox-gl-js/example/change-case-of-labels/,example,JavaScript,,Change the case of labels Use the upcase and downcase expressions to change the case of labels. Was this example helpful? Yes No,Change the case of labels,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Custom routes,Use the Mapbox Map Matching API with the Mapbox Navigation SDK or Navigation UI SDK for Android.,https://docs.mapbox.com/android/navigation/overview/map-matching/,guide,Java,Kotlin,"Custom routes SDKs covered: Navigation SDK Navigation UI SDK In some cases, you may want to have the user stick to a specific route that doesn't fit into the scope covered by the Mapbox Directions API. For example, a parking finder app where you want to guide a user past specific blocks with parking, but also allow people to navigate on it with the Mapbox Navigation SDK for Android. The Mapbox Map Matching API is an appropriate fit for this situation. Use a map matching response to generate a route Map matching is the art of taking coordinates and aligning them along a road network. In the parking example above, you would provide coordinates to the device, the coordinates would be passed to the Mapbox Map Matching API, and then the API would return a route that can be used in the Navigation SDK for Android. Here is an example of converting a MapboxMapMatching response into a DirectionsRoute: Java Kotlin MapboxMapMatching.builder() .accessToken(Mapbox.getAccessToken()) .coordinates(points) .steps(true) .voiceInstructions(true) .bannerInstructions(true) .profile(DirectionsCriteria.PROFILE_DRIVING) .build() .enqueueCall(new Callback<MapMatchingResponse>() { @Override public void onResponse(Call<MapMatchingResponse> call, Response<MapMatchingResponse> response) { if (response.isSuccessful()) { DirectionsRoute route = response.body().matchings().get(0).toDirectionRoute(); navigation.startNavigation(route); } } @Override public void onFailure(Call<MapMatchingResponse> call, Throwable throwable) { } }); Copy Navigation UI SDK When using MapboxMapMatching with the Navigation UI SDK's NavigationView, you need to make a few changes to your setup to make sure re-routes are successful. A RouteListener must be added to your NavigationViewOptions and you must return false in the allowRerouteFrom callback. This will make sure that the NavigationView does not make a Directions API request. Instead, it will wait for the new DirectionsRoute provided by your map matching response. Java Kotlin @Override public boolean allowRerouteFrom(Point offRoutePoint) { // Fetch new route with MapboxMapMatching // Create new options with map matching response route NavigationViewOptions options = NavigationViewOptions.builder() .directionsRoute(mapMatchingDirectionsRoute) .build(); navigationView.startNavigation(options); // Ignore internal routing, allowing MapboxMapMatching call return false; } Copy Map matching with MapboxNavigation In the core Navigation SDK, MapboxMapMatching requests replace NavigationRoute requests. To start navigation initially or to restart navigation after an off-route event has been fired, you can make a map matching request and then convert the MapMatchingMatching response to a DirectionsRoute with MapMatchingMatching#toDirectionRoute. Java Kotlin navigation.addOffRouteListener(new OffRouteListener() { @Override public void userOffRoute(Location location) { // Make the Map Matching request here // Call MapboxNavigation#startNavigation with successful response } }); Copy Was this page helpful? Yes No",Custom routes,Use a map matching response to generate a route,Navigation UI SDK,Map matching with MapboxNavigation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Line behind moving icon,Draw a line behind a moving SymbolLayer icon which moves along a Mapbox Directions API route.,https://docs.mapbox.com/android/maps/examples/moving-icon-with-trailing-line/,example,Java,,"Line behind moving icon Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.labs.MovingIconWithTrailingLineActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""9.014140"" mapbox:mapbox_cameraTargetLng=""38.754359"" mapbox:mapbox_cameraZoom=""12.580466""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.animation.Animator; import android.animation.AnimatorListenerAdapter; import android.animation.TypeEvaluator; import android.animation.ValueAnimator; import android.graphics.BitmapFactory; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.animation.LinearInterpolator; import android.widget.Toast; import com.mapbox.api.directions.v5.DirectionsCriteria; import com.mapbox.api.directions.v5.MapboxDirections; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.turf.TurfMeasurement; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import java.util.ArrayList; import java.util.List; import static com.mapbox.core.constants.Constants.PRECISION_6; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineCap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineJoin; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Make a directions request with the Mapbox Directions API and then draw a line behind a moving * SymbolLayer icon which moves along the Directions response route. */ public class MovingIconWithTrailingLineActivity extends AppCompatActivity { private static final String DOT_SOURCE_ID = ""dot-source-id""; private static final String LINE_SOURCE_ID = ""line-source-id""; private MapView mapView; private MapboxMap mapboxMap; private GeoJsonSource pointSource; private GeoJsonSource lineSource; private List<Point> routeCoordinateList; private List<Point> markerLinePointList = new ArrayList<>(); private int routeIndex; private Animator currentAnimator; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_moving_icon_with_trailing_line); // Initialize the mapboxMap view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(MapboxMap mapboxMap) { MovingIconWithTrailingLineActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Use the Mapbox Directions API to get a directions route getRoute(style, Point.fromLngLat(38.7508, 9.0309), // coffee shop Point.fromLngLat(38.795902, 8.984467) // airport ); } }); } }); } /** * Add data to the map once the GeoJSON has been loaded * * @param featureCollection returned GeoJSON FeatureCollection from the Directions API route request */ private void initData(Style fullyLoadedStyle, @NonNull FeatureCollection featureCollection) { routeCoordinateList = ((LineString) featureCollection.features().get(0).geometry()).coordinates(); initSources(fullyLoadedStyle, featureCollection); initSymbolLayer(fullyLoadedStyle); initDotLinePath(fullyLoadedStyle); animate(); } /** * Set up the repeat logic for moving the icon along the route. */ private void animate() { // Check if we are at the end of the points list if ((routeCoordinateList.size() - 1 > routeIndex)) { Point indexPoint = routeCoordinateList.get(routeIndex); Point newPoint = Point.fromLngLat(indexPoint.longitude(), indexPoint.latitude()); currentAnimator = createLatLngAnimator(indexPoint, newPoint); currentAnimator.start(); routeIndex++; } } private static class PointEvaluator implements TypeEvaluator<Point> { @Override public Point evaluate(float fraction, Point startValue, Point endValue) { return Point.fromLngLat( startValue.longitude() + ((endValue.longitude() - startValue.longitude()) * fraction), startValue.latitude() + ((endValue.latitude() - startValue.latitude()) * fraction) ); } } private Animator createLatLngAnimator(Point currentPosition, Point targetPosition) { ValueAnimator latLngAnimator = ValueAnimator.ofObject(new PointEvaluator(), currentPosition, targetPosition); latLngAnimator.setDuration((long) TurfMeasurement.distance(currentPosition, targetPosition, ""meters"")); latLngAnimator.setInterpolator(new LinearInterpolator()); latLngAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); animate(); } }); latLngAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { Point point = (Point) animation.getAnimatedValue(); pointSource.setGeoJson(point); markerLinePointList.add(point); lineSource.setGeoJson(Feature.fromGeometry(LineString.fromLngLats(markerLinePointList))); } }); return latLngAnimator; } /** * Make a request to the Mapbox Directions API. Once successful, pass the route to the * route layer. * * @param origin the starting point of the route * @param destination the desired finish point of the route */ private void getRoute(@NonNull final Style style, final Point origin, final Point destination) { MapboxDirections client = MapboxDirections.builder() .origin(origin) .destination(destination) .overview(DirectionsCriteria.OVERVIEW_FULL) .profile(DirectionsCriteria.PROFILE_WALKING) .accessToken(getString(R.string.access_token)) .build(); client.enqueueCall(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { System.out.println(call.request().url().toString()); // You can get the generic HTTP info about the response Timber.d(""Response code: %s"", response.code()); if (response.body() == null) { Timber.e(""No routes found, make sure you set the right user and access token.""); return; } else if (response.body().routes().size() < 1) { Timber.e(""No routes found""); return; } // Get the directions route DirectionsRoute currentRoute = response.body().routes().get(0); if (style.isFullyLoaded()) { mapboxMap.easeCamera(CameraUpdateFactory.newLatLngBounds( new LatLngBounds.Builder() .include(new LatLng(origin.latitude(), origin.longitude())) .include(new LatLng(destination.latitude(), destination.longitude())) .build(), 50), 5000); initData(style,FeatureCollection.fromFeature( Feature.fromGeometry(LineString.fromPolyline(currentRoute.geometry(), PRECISION_6)))); } } @Override public void onFailure(Call<DirectionsResponse> call, Throwable throwable) { Timber.e(""Error: %s"", throwable.getMessage()); Toast.makeText(MovingIconWithTrailingLineActivity.this, ""Error: "" + throwable.getMessage(), Toast.LENGTH_SHORT).show(); } }); } /** * Add various sources to the map. */ private void initSources(@NonNull Style loadedMapStyle, @NonNull FeatureCollection featureCollection) { loadedMapStyle.addSource(pointSource = new GeoJsonSource(DOT_SOURCE_ID, featureCollection)); loadedMapStyle.addSource(lineSource = new GeoJsonSource(LINE_SOURCE_ID)); } /** * Add the marker icon SymbolLayer. */ private void initSymbolLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addImage(""moving-red-marker"", BitmapFactory.decodeResource( getResources(), R.drawable.pink_dot)); loadedMapStyle.addLayer(new SymbolLayer(""symbol-layer-id"", DOT_SOURCE_ID).withProperties( iconImage(""moving-red-marker""), iconSize(1f), iconOffset(new Float[] {5f, 0f}), iconIgnorePlacement(true), iconAllowOverlap(true) )); } /** * Add the LineLayer for the marker icon's travel route. Adding it under the ""road-label"" layer, so that the * this LineLayer doesn't block the street name. */ private void initDotLinePath(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayerBelow(new LineLayer(""line-layer-id"", LINE_SOURCE_ID).withProperties( lineColor(Color.parseColor(""#F13C6E"")), lineCap(Property.LINE_CAP_ROUND), lineJoin(Property.LINE_JOIN_ROUND), lineWidth(4f)), ""road-label""); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (currentAnimator != null) { currentAnimator.cancel(); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Line behind moving icon,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Background fog,Add a gradient on top of a MapView to show a background fog effect.,https://docs.mapbox.com/android/maps/examples/map-fog-background/,example,Java,,"Background fog Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""-23.5485"" mapbox:mapbox_cameraTargetLng=""-46.6217"" mapbox:mapbox_cameraTilt=""59"" mapbox:mapbox_cameraZoom=""17.17"" mapbox:mapbox_cameraZoomMax=""18.02"" /> <ImageView android:layout_width=""match_parent"" android:layout_height=""250dp"" android:src=""@drawable/fog_background_gradient""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.building.BuildingPlugin; /** * Add an ImageView gradient on top of the MapView to create the effect of the map coming out of a * background fog. */ public class MapFogBackgroundActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private BuildingPlugin buildingPlugin; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_map_fog_background); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Using the Mapbox Building Plugin to easily display 3D extrusions on the map buildingPlugin = new BuildingPlugin(mapView, mapboxMap, style); buildingPlugin.setVisibility(true); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Background fog,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Color dependent on zoom level,"Make a property depend on the map zoom level, in this case, the water layers fill color.",https://docs.mapbox.com/android/maps/examples/change-color-based-on-zoom-level/,example,Java,,"Color dependent on zoom level Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.ZoomDependentFillColorActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.73581"" mapbox:mapbox_cameraTargetLng=""-73.99155"" mapbox:mapbox_cameraZoom=""0""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.FillLayer; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; /** * Use runtime styling to change the water layer's fill color based on the map zoom level */ public class ZoomDependentFillColorActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_zoom_dependent_fill_color); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { FillLayer layer = style.getLayerAs(""water""); if (layer == null) { return; } //Set a zoom function to update the color of the water layer.setProperties( fillColor(Expression.interpolate(Expression.exponential(1f), zoom(), stop(1f, rgb(0,209,22)), stop(8.5f, rgb(10,88,255)), stop(10f, rgb(255,10,10)), stop(18f, rgb(251,255,0))))); mapboxMap.animateCamera(CameraUpdateFactory.newLatLngZoom( new LatLng(40.73581, -73.99155), 12), 12000); } }); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Color dependent on zoom level,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Update a choropleth layer by zoom level,"Style a choropleth map with data-driven styling, local JSON data, and vector tile geometries.",https://docs.mapbox.com/android/maps/examples/update-by-zoom-level/,example,Java,,"Update a choropleth layer by zoom level Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.basics.SimpleMapViewActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""38.88"" mapbox:mapbox_cameraTargetLng=""-98"" mapbox:mapbox_cameraZoom=""3"" mapbox:mapbox_cameraZoomMin=""3"" /> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.Layer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.step; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.Property.NONE; import static com.mapbox.mapboxsdk.style.layers.Property.VISIBLE; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.visibility; /** * Display 2014 census data by state or county, depending on the map's zoom level. */ public class ChoroplethZoomChangeActivity extends AppCompatActivity { private static final int ZOOM_THRESHOLD = 4; private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_choropleth_zoom_change); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { VectorSource vectorSource = new VectorSource( ""population"", ""http://api.mapbox.com/v4/mapbox.660ui7x6.json?access_token="" + Mapbox.getAccessToken() ); style.addSource(vectorSource); FillLayer statePopulationLayer = new FillLayer(""state-population"", ""population""); statePopulationLayer.withSourceLayer(""state_county_population_2014_cen""); statePopulationLayer.setFilter(Expression.eq(get(""isState""), literal(true))); statePopulationLayer.withProperties( fillColor(step((get(""population"")), rgb(0,0,0), stop(0, rgb(242,241,45)), stop(750000, rgb(238,211,34)), stop(1000000, rgb(218,156,32)), stop(2500000, rgb(202,131,35)), stop(5000000, rgb(184,107,37)), stop(7500000, rgb(162,86,38)), stop(10000000, rgb(139,66,37)), stop(25000000, rgb(114,49,34)))), fillOpacity(0.75f) ); style.addLayerBelow(statePopulationLayer, ""waterway-label""); FillLayer countyPopulationLayer = new FillLayer(""county-population"", ""population""); countyPopulationLayer.withSourceLayer(""state_county_population_2014_cen""); countyPopulationLayer.setFilter(Expression.eq(get(""isCounty""), literal(true))); countyPopulationLayer.withProperties( fillColor(step(get(""population""), rgb(0,0,0), stop(0, rgb(242,241,45)), stop(100, rgb(238,211,34)), stop(1000, rgb(230,183,30)), stop(5000, rgb(218,156,32)), stop(10000, rgb(202,131,35)), stop(50000, rgb(184,107,37)), stop(100000, rgb(162,86,38)), stop(500000, rgb(139,66,37)), stop(1000000, rgb(114,49,34)))), fillOpacity(0.75f), visibility(NONE) ); style.addLayerBelow(countyPopulationLayer, ""waterway-label""); mapboxMap.addOnCameraMoveListener(new MapboxMap.OnCameraMoveListener() { @Override public void onCameraMove() { Layer stateLayer = style.getLayer(""state-population""); Layer countyLayer = style.getLayer(""county-population""); if (mapboxMap.getCameraPosition().zoom > ZOOM_THRESHOLD) { if (stateLayer != null && countyLayer != null) { countyLayer.setProperties(visibility(VISIBLE)); } } else { if (stateLayer != null && countyLayer != null) { countyLayer.setProperties(visibility(NONE)); } } } }); } }); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Update a choropleth layer by zoom level,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Click to add photo,Select a photo on the device and add it on the map tap location.,https://docs.mapbox.com/android/maps/examples/click-to-add-image/,example,Java,,"Click to add photo Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""25.7836"" mapbox:mapbox_cameraTargetLng=""-80.11725"" mapbox:mapbox_cameraZoom=""5"" /> </LinearLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.app.Activity; import android.content.Intent; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Color; import android.net.Uri; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngQuad; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.layers.RasterLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.style.sources.ImageSource; import java.io.FileNotFoundException; import java.io.InputStream; import java.util.ArrayList; import java.util.List; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; /** * Tap the map in four locations to set the bounds for an image that is selected from the device's gallery * and then added to the map. */ public class ClickToAddImageActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private static final String ID_IMAGE_SOURCE = ""source-id""; private static final String CIRCLE_SOURCE_ID = ""circle-source-id""; private static final String ID_IMAGE_LAYER = ""layer-id""; private static int PHOTO_PICK_CODE = 4; private MapView mapView; private MapboxMap mapboxMap; private LatLngQuad quad; private List<Feature> boundsFeatureList; private List<Point> boundsCirclePointList; private int imageCountIndex; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_click_to_add_image); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { boundsFeatureList = new ArrayList<>(); boundsCirclePointList = new ArrayList<>(); ClickToAddImageActivity.this.mapboxMap = mapboxMap; mapboxMap.addOnMapClickListener(ClickToAddImageActivity.this); imageCountIndex = 0; initCircleSource(style); initCircleLayer(style); Toast.makeText(ClickToAddImageActivity.this, R.string.tap_instructions, Toast.LENGTH_LONG).show(); } }); } @Override public boolean onMapClick(@NonNull LatLng point) { // Reset the lists once enough LatLngQuad points have been tapped if (boundsFeatureList.size() == 4) { boundsFeatureList = new ArrayList<>(); boundsCirclePointList = new ArrayList<>(); } boundsFeatureList.add(Feature.fromGeometry(Point.fromLngLat(point.getLongitude(), point.getLatitude()))); // Add the click point to the CircleLayer and update the display of the CircleLayer data boundsCirclePointList.add(Point.fromLngLat(point.getLongitude(), point.getLatitude())); Style style = mapboxMap.getStyle(); if (style != null) { GeoJsonSource circleSource = style.getSourceAs(CIRCLE_SOURCE_ID); if (circleSource != null) { circleSource.setGeoJson(FeatureCollection.fromFeatures(boundsFeatureList)); } } // Once the 4 LatLngQuad points have been set for where the image will placed... if (boundsCirclePointList.size() == 4) { // Create the LatLng objects to use in the LatLngQuad LatLng latLng1 = new LatLng(boundsCirclePointList.get(0).latitude(), boundsCirclePointList.get(0).longitude()); LatLng latLng2 = new LatLng(boundsCirclePointList.get(1).latitude(), boundsCirclePointList.get(1).longitude()); LatLng latLng3 = new LatLng(boundsCirclePointList.get(2).latitude(), boundsCirclePointList.get(2).longitude()); LatLng latLng4 = new LatLng(boundsCirclePointList.get(3).latitude(), boundsCirclePointList.get(3).longitude()); quad = new LatLngQuad(latLng1, latLng2, latLng3, latLng4); // Launch the intent to open the device's image gallery picker Intent pickPhotoIntent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI); pickPhotoIntent.setType(""image/*""); startActivityForResult(pickPhotoIntent, PHOTO_PICK_CODE); } return true; } /** * Set up the CircleLayer source for showing LatLngQuad map click points */ private void initCircleSource(@NonNull Style loadedMapStyle) { loadedMapStyle.addSource( new GeoJsonSource(CIRCLE_SOURCE_ID, FeatureCollection.fromFeatures(new Feature[] {})) ); } /** * Set up the CircleLayer for showing LatLngQuad map click points */ private void initCircleLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayer(new CircleLayer(""circle-layer-bounds-corner-id"", CIRCLE_SOURCE_ID).withProperties( circleRadius(8f), circleColor(Color.parseColor(""#d004d3"")) )); } /** * Calling onActivityResult() to handle the return to the example from the device's image galleyr picker */ @Override public void onActivityResult(int requestCode, int resultCode, final Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == PHOTO_PICK_CODE && resultCode == Activity.RESULT_OK) { if (data == null) { //Display an error Timber.d(""data == null""); return; } if (mapboxMap != null) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { Uri selectedImage = data.getData(); InputStream imageStream; try { imageStream = getContentResolver().openInputStream(selectedImage); Bitmap bitmapOfSelectedImage = BitmapFactory.decodeStream(imageStream); // Add the imageSource to the map style.addSource( new ImageSource(ID_IMAGE_SOURCE + imageCountIndex, quad, bitmapOfSelectedImage)); // Create a raster layer and use the imageSource's ID as the layer's data// Add the layer to the map style.addLayer(new RasterLayer(ID_IMAGE_LAYER + imageCountIndex, ID_IMAGE_SOURCE + imageCountIndex)); // Reset lists in preparation for adding more images boundsFeatureList = new ArrayList<>(); boundsCirclePointList = new ArrayList<>(); imageCountIndex++; // Clear circles from CircleLayer GeoJsonSource circleSource = style.getSourceAs(CIRCLE_SOURCE_ID); if (circleSource != null) { circleSource.setGeoJson(FeatureCollection.fromFeatures(boundsFeatureList)); } } catch (FileNotFoundException exception) { exception.printStackTrace(); } } }); } } } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Click to add photo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,SymbolLayer icons,Add markers via SymbolLayer and manipulate the data in real time. A Mapillary integration is also showcased in this example.,https://docs.mapbox.com/android/maps/examples/symbollayer-mapillary/,example,Java,,"SymbolLayer icons Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:animateLayoutChanges=""true""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.753971"" mapbox:mapbox_cameraTargetLng=""-122.439004"" mapbox:mapbox_cameraTilt=""25"" mapbox:mapbox_cameraZoom=""11"" /> <androidx.recyclerview.widget.RecyclerView android:id=""@+id/rv_on_top_of_map"" android:layout_width=""match_parent"" android:layout_height=""178dp"" android:layout_gravity=""bottom"" android:layout_marginBottom=""8dp"" android:visibility=""gone"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.animation.Animator; import android.animation.AnimatorSet; import android.animation.TypeEvaluator; import android.animation.ValueAnimator; import android.annotation.SuppressLint; import android.content.Context; import android.graphics.Bitmap; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.PointF; import android.graphics.PorterDuff; import android.graphics.PorterDuffXfermode; import android.graphics.Rect; import android.os.AsyncTask; import android.os.Bundle; import android.os.Handler; import androidx.annotation.IntDef; import androidx.annotation.NonNull; import androidx.interpolator.view.animation.FastOutSlowInInterpolator; import androidx.appcompat.app.AppCompatActivity; import androidx.cardview.widget.CardView; import androidx.recyclerview.widget.DefaultItemAnimator; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.PagerSnapHelper; import androidx.recyclerview.widget.RecyclerView; import androidx.recyclerview.widget.SnapHelper; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.layers.Layer; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonOptions; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.style.sources.Source; import com.mapbox.mapboxsdk.style.sources.TileSet; import com.mapbox.mapboxsdk.style.sources.VectorSource; import com.squareup.picasso.Picasso; import java.io.InputStream; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; import timber.log.Timber; import static androidx.recyclerview.widget.RecyclerView.SCROLL_STATE_IDLE; import static com.mapbox.mapboxsdk.style.expressions.Expression.all; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.gte; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.lt; import static com.mapbox.mapboxsdk.style.expressions.Expression.match; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.toNumber; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAnchor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineCap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineJoin; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textField; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.visibility; public class SymbolLayerMapillaryActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private static final String SOURCE_ID = ""mapbox.poi""; private static final String MAKI_LAYER_ID = ""mapbox.poi.maki""; private static final String LOADING_LAYER_ID = ""mapbox.poi.loading""; private static final String CALLOUT_LAYER_ID = ""mapbox.poi.callout""; private static final String PROPERTY_SELECTED = ""selected""; private static final String PROPERTY_LOADING = ""loading""; private static final String PROPERTY_LOADING_PROGRESS = ""loading_progress""; private static final String PROPERTY_TITLE = ""title""; private static final String PROPERTY_FAVOURITE = ""favourite""; private static final String PROPERTY_DESCRIPTION = ""description""; private static final String PROPERTY_POI = ""poi""; private static final String PROPERTY_STYLE = ""style""; private static final long CAMERA_ANIMATION_TIME = 1950; private static final float LOADING_CIRCLE_RADIUS = 60; private static final int LOADING_PROGRESS_STEPS = 25; //number of steps in a progress animation private static final int LOADING_STEP_DURATION = 50; //duration between each step private MapView mapView; private MapboxMap mapboxMap; private Style style; private RecyclerView recyclerView; private GeoJsonSource source; private FeatureCollection featureCollection; private HashMap<String, View> viewMap; private AnimatorSet animatorSet; private LoadMapillaryDataTask loadMapillaryDataTask; @ActivityStep private int currentStep; @Retention(RetentionPolicy.SOURCE) @IntDef( {STEP_INITIAL, STEP_LOADING, STEP_READY}) public @interface ActivityStep { } private static final int STEP_INITIAL = 0; private static final int STEP_LOADING = 1; private static final int STEP_READY = 2; private static final Map<Integer, Double> stepZoomMap = new HashMap<>(); static { stepZoomMap.put(STEP_INITIAL, 11.0); stepZoomMap.put(STEP_LOADING, 13.5); stepZoomMap.put(STEP_READY, 18.0); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_symbol_layer_mapillary); recyclerView = findViewById(R.id.rv_on_top_of_map); // Initialize the map view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { SymbolLayerMapillaryActivity.this.style = style; mapboxMap.getUiSettings().setCompassEnabled(false); mapboxMap.getUiSettings().setLogoEnabled(false); mapboxMap.getUiSettings().setAttributionEnabled(false); new LoadPoiDataTask(SymbolLayerMapillaryActivity.this).execute(); mapboxMap.addOnMapClickListener(SymbolLayerMapillaryActivity.this); } }); } @Override public boolean onMapClick(@NonNull LatLng point) { PointF screenPoint = mapboxMap.getProjection().toScreenLocation(point); List<Feature> features = mapboxMap.queryRenderedFeatures(screenPoint, CALLOUT_LAYER_ID); if (!features.isEmpty()) { // we received a click event on the callout layer Feature feature = features.get(0); PointF symbolScreenPoint = mapboxMap.getProjection().toScreenLocation(convertToLatLng(feature)); handleClickCallout(feature, screenPoint, symbolScreenPoint); } else { // we didn't find a click event on callout layer, try clicking maki layer return handleClickIcon(screenPoint); } return true; } public void setupData(final FeatureCollection collection) { if (mapboxMap == null) { return; } featureCollection = collection; if (style.isFullyLoaded()) { setupSource(style); setupMakiLayer(style); setupLoadingLayer(style); setupCalloutLayer(style); setupRecyclerView(); hideLabelLayers(style); setupMapillaryTiles(style); } } private void setupSource(@NonNull Style loadedMapStyle) { source = new GeoJsonSource(SOURCE_ID, featureCollection); loadedMapStyle.addSource(source); } private void refreshSource() { if (source != null && featureCollection != null) { source.setGeoJson(featureCollection); } } /** * Setup a layer with maki icons, eg. restaurant. */ private void setupMakiLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayer(new SymbolLayer(MAKI_LAYER_ID, SOURCE_ID) .withProperties( /* show maki icon based on the value of poi feature property * https://www.mapbox.com/maki-icons/ */ iconImage(""{poi}-15""), /* allows show all icons */ iconAllowOverlap(true), /* when feature is in selected state, grow icon */ iconSize(match(Expression.toString(get(PROPERTY_SELECTED)), literal(1.0f), stop(""true"", 1.5f)))) ); } /** * Setup layer indicating that there is an ongoing progress. */ private void setupLoadingLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayerBelow(new CircleLayer(LOADING_LAYER_ID, SOURCE_ID) .withProperties( circleRadius(interpolate(exponential(1), get(PROPERTY_LOADING_PROGRESS), getLoadingAnimationStops())), circleColor(Color.GRAY), circleOpacity(0.6f) ) .withFilter(eq(get(PROPERTY_LOADING), literal(true))), MAKI_LAYER_ID); } private Expression.Stop[] getLoadingAnimationStops() { List<Expression.Stop> stops = new ArrayList<>(); for (int i = 0; i < LOADING_PROGRESS_STEPS; i++) { stops.add(stop(i, LOADING_CIRCLE_RADIUS * i / LOADING_PROGRESS_STEPS)); } return stops.toArray(new Expression.Stop[LOADING_PROGRESS_STEPS]); } /** * Setup a layer with Android SDK call-outs * <p> * title of the feature is used as key for the iconImage * </p> */ private void setupCalloutLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayer(new SymbolLayer(CALLOUT_LAYER_ID, SOURCE_ID) .withProperties( /* show image with id title based on the value of the title feature property */ iconImage(""{title}""), /* set anchor of icon to bottom-left */ iconAnchor(Property.ICON_ANCHOR_BOTTOM_LEFT), /* offset icon slightly to match bubble layout */ iconOffset(new Float[] {-20.0f, -10.0f}) ) /* add a filter to show only when selected feature property is true */ .withFilter(eq((get(PROPERTY_SELECTED)), literal(true)))); } private void setupRecyclerView() { RecyclerView.Adapter adapter = new LocationRecyclerViewAdapter(this, featureCollection); final LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false); recyclerView.setLayoutManager(layoutManager); recyclerView.setItemAnimator(new DefaultItemAnimator()); recyclerView.setAdapter(adapter); recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); if (newState == SCROLL_STATE_IDLE) { int index = layoutManager.findFirstVisibleItemPosition(); setSelected(index, false); } } }); SnapHelper snapHelper = new PagerSnapHelper(); snapHelper.attachToRecyclerView(recyclerView); } private void hideLabelLayers(@NonNull Style style) { String id; for (Layer layer : style.getLayers()) { id = layer.getId(); if (id.startsWith(""place"") || id.startsWith(""poi"") || id.startsWith(""marine"") || id.startsWith(""road-label"")) { layer.setProperties(visibility(Property.NONE)); } } } private void setupMapillaryTiles(@NonNull Style loadedMapStyle) { loadedMapStyle.addSource(MapillaryTiles.createSource()); loadedMapStyle.addLayerBelow(MapillaryTiles.createLineLayer(), LOADING_LAYER_ID); } /** * This method handles click events for callout symbols. * <p> * It creates a hit rectangle based on the the textView, offsets that rectangle to the location * of the symbol on screen and hit tests that with the screen point. * </p> * * @param feature the feature that was clicked * @param screenPoint the point on screen clicked * @param symbolScreenPoint the point of the symbol on screen */ private void handleClickCallout(Feature feature, PointF screenPoint, PointF symbolScreenPoint) { View view = viewMap.get(feature.getStringProperty(PROPERTY_TITLE)); View textContainer = view.findViewById(R.id.text_container); // create hitbox for textView Rect hitRectText = new Rect(); textContainer.getHitRect(hitRectText); // move hitbox to location of symbol hitRectText.offset((int) symbolScreenPoint.x, (int) symbolScreenPoint.y); // offset vertically to match anchor behaviour hitRectText.offset(0, -view.getMeasuredHeight()); // hit test if clicked point is in textview hitbox if (hitRectText.contains((int) screenPoint.x, (int) screenPoint.y)) { // user clicked on text String callout = feature.getStringProperty(""call-out""); Toast.makeText(this, callout, Toast.LENGTH_LONG).show(); } else { // user clicked on icon List<Feature> featureList = featureCollection.features(); for (int i = 0; i < featureList.size(); i++) { if (featureList.get(i).getStringProperty(PROPERTY_TITLE).equals(feature.getStringProperty(PROPERTY_TITLE))) { toggleFavourite(i); } } } } /** * This method handles click events for maki symbols. * <p> * When a maki symbol is clicked, we moved that feature to the selected state. * </p> * * @param screenPoint the point on screen clicked */ private boolean handleClickIcon(PointF screenPoint) { List<Feature> features = mapboxMap.queryRenderedFeatures(screenPoint, MAKI_LAYER_ID); if (!features.isEmpty()) { String title = features.get(0).getStringProperty(PROPERTY_TITLE); List<Feature> featureList = featureCollection.features(); for (int i = 0; i < featureList.size(); i++) { if (featureList.get(i).getStringProperty(PROPERTY_TITLE).equals(title)) { setSelected(i, true); } } return true; } return false; } /** * Set a feature selected state with the ability to scroll the RecycleViewer to the provided index. * * @param index the index of selected feature * @param withScroll indicates if the recyclerView position should be updated */ private void setSelected(int index, boolean withScroll) { if (recyclerView.getVisibility() == View.GONE) { recyclerView.setVisibility(View.VISIBLE); } deselectAll(false); Feature feature = featureCollection.features().get(index); selectFeature(feature); animateCameraToSelection(feature); refreshSource(); loadMapillaryData(feature); if (withScroll) { recyclerView.scrollToPosition(index); } } /** * Deselects the state of all the features */ private void deselectAll(boolean hideRecycler) { for (Feature feature : featureCollection.features()) { feature.properties().addProperty(PROPERTY_SELECTED, false); } if (hideRecycler) { recyclerView.setVisibility(View.GONE); } } /** * Selects the state of a feature * * @param feature the feature to be selected. */ private void selectFeature(Feature feature) { feature.properties().addProperty(PROPERTY_SELECTED, true); } private Feature getSelectedFeature() { if (featureCollection != null) { for (Feature feature : featureCollection.features()) { if (feature.getBooleanProperty(PROPERTY_SELECTED)) { return feature; } } } return null; } /** * Animate camera to a feature. * * @param feature the feature to animate to */ private void animateCameraToSelection(Feature feature, double newZoom) { CameraPosition cameraPosition = mapboxMap.getCameraPosition(); if (animatorSet != null) { animatorSet.cancel(); } animatorSet = new AnimatorSet(); animatorSet.playTogether( createLatLngAnimator(cameraPosition.target, convertToLatLng(feature)), createZoomAnimator(cameraPosition.zoom, newZoom), createBearingAnimator(cameraPosition.bearing, feature.getNumberProperty(""bearing"").doubleValue()), createTiltAnimator(cameraPosition.tilt, feature.getNumberProperty(""tilt"").doubleValue()) ); animatorSet.start(); } private void animateCameraToSelection(Feature feature) { double zoom = feature.getNumberProperty(""zoom"").doubleValue(); animateCameraToSelection(feature, zoom); } private void loadMapillaryData(Feature feature) { if (loadMapillaryDataTask != null) { loadMapillaryDataTask.cancel(true); } loadMapillaryDataTask = new LoadMapillaryDataTask(this, mapboxMap, Picasso.with(getApplicationContext()), new Handler(), feature); loadMapillaryDataTask.execute(50); } /** * Set the favourite state of a feature based on the index. * * @param index the index of the feature to favourite/de-favourite */ private void toggleFavourite(int index) { Feature feature = featureCollection.features().get(index); String title = feature.getStringProperty(PROPERTY_TITLE); boolean currentState = feature.getBooleanProperty(PROPERTY_FAVOURITE); feature.properties().addProperty(PROPERTY_FAVOURITE, !currentState); View view = viewMap.get(title); ImageView imageView = view.findViewById(R.id.logoView); imageView.setImageResource(currentState ? R.drawable.ic_favorite : R.drawable.ic_favorite_border); Bitmap bitmap = SymbolGenerator.generate(view); style.addImage(title, bitmap); refreshSource(); } /** * Invoked when the bitmaps have been generated from a view. */ public void setImageGenResults(HashMap<String, View> viewMap, HashMap<String, Bitmap> imageMap) { if (style.isFullyLoaded()) { // calling addImages is faster as separate addImage calls for each bitmap. style.addImages(imageMap); } // need to store reference to views to be able to use them as hitboxes for click events. this.viewMap = viewMap; } private void setActivityStep(@ActivityStep int activityStep) { Feature selectedFeature = getSelectedFeature(); double zoom = stepZoomMap.get(activityStep); animateCameraToSelection(selectedFeature, zoom); currentStep = activityStep; } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); if (loadMapillaryDataTask != null) { loadMapillaryDataTask.cancel(true); } mapView.onStop(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } @Override public void onBackPressed() { if (currentStep == STEP_LOADING || currentStep == STEP_READY) { if (loadMapillaryDataTask != null) { loadMapillaryDataTask.cancel(true); } setActivityStep(STEP_INITIAL); deselectAll(true); refreshSource(); } else { super.onBackPressed(); } } private LatLng convertToLatLng(Feature feature) { Point symbolPoint = (Point) feature.geometry(); return new LatLng(symbolPoint.latitude(), symbolPoint.longitude()); } private Animator createLatLngAnimator(LatLng currentPosition, LatLng targetPosition) { ValueAnimator latLngAnimator = ValueAnimator.ofObject(new LatLngEvaluator(), currentPosition, targetPosition); latLngAnimator.setDuration(CAMERA_ANIMATION_TIME); latLngAnimator.setInterpolator(new FastOutSlowInInterpolator()); latLngAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mapboxMap.moveCamera(CameraUpdateFactory.newLatLng((LatLng) animation.getAnimatedValue())); } }); return latLngAnimator; } private Animator createZoomAnimator(double currentZoom, double targetZoom) { ValueAnimator zoomAnimator = ValueAnimator.ofFloat((float) currentZoom, (float) targetZoom); zoomAnimator.setDuration(CAMERA_ANIMATION_TIME); zoomAnimator.setInterpolator(new FastOutSlowInInterpolator()); zoomAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mapboxMap.moveCamera(CameraUpdateFactory.zoomTo((Float) animation.getAnimatedValue())); } }); return zoomAnimator; } private Animator createBearingAnimator(double currentBearing, double targetBearing) { ValueAnimator bearingAnimator = ValueAnimator.ofFloat((float) currentBearing, (float) targetBearing); bearingAnimator.setDuration(CAMERA_ANIMATION_TIME); bearingAnimator.setInterpolator(new FastOutSlowInInterpolator()); bearingAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mapboxMap.moveCamera(CameraUpdateFactory.bearingTo((Float) animation.getAnimatedValue())); } }); return bearingAnimator; } private Animator createTiltAnimator(double currentTilt, double targetTilt) { ValueAnimator tiltAnimator = ValueAnimator.ofFloat((float) currentTilt, (float) targetTilt); tiltAnimator.setDuration(CAMERA_ANIMATION_TIME); tiltAnimator.setInterpolator(new FastOutSlowInInterpolator()); tiltAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { mapboxMap.moveCamera(CameraUpdateFactory.tiltTo((Float) animation.getAnimatedValue())); } }); return tiltAnimator; } /** * Helper class to evaluate LatLng objects with a ValueAnimator */ private static class LatLngEvaluator implements TypeEvaluator<LatLng> { private final LatLng latLng = new LatLng(); @Override public LatLng evaluate(float fraction, LatLng startValue, LatLng endValue) { latLng.setLatitude(startValue.getLatitude() + ((endValue.getLatitude() - startValue.getLatitude()) * fraction)); latLng.setLongitude(startValue.getLongitude() + ((endValue.getLongitude() - startValue.getLongitude()) * fraction)); return latLng; } } /** * AsyncTask to load data from the assets folder. */ private static class LoadPoiDataTask extends AsyncTask<Void, Void, FeatureCollection> { private final WeakReference<SymbolLayerMapillaryActivity> activityRef; LoadPoiDataTask(SymbolLayerMapillaryActivity activity) { this.activityRef = new WeakReference<>(activity); } @Override protected FeatureCollection doInBackground(Void... params) { SymbolLayerMapillaryActivity activity = activityRef.get(); if (activity == null) { return null; } String geoJson = loadGeoJsonFromAsset(activity, ""sf_poi.geojson""); return FeatureCollection.fromJson(geoJson); } @Override protected void onPostExecute(FeatureCollection featureCollection) { super.onPostExecute(featureCollection); SymbolLayerMapillaryActivity activity = activityRef.get(); if (featureCollection == null || activity == null) { return; } activity.setupData(featureCollection); new GenerateViewIconTask(activity).execute(featureCollection); } static String loadGeoJsonFromAsset(Context context, String filename) { try { // Load GeoJSON file from local asset folder InputStream is = context.getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (Exception exception) { throw new RuntimeException(exception); } } } /** * AsyncTask to generate Bitmap from Views to be used as iconImage in a SymbolLayer. * <p> * Call be optionally be called to update the underlying data source after execution. * </p> * <p> * Generating Views on background thread since we are not going to be adding them to the view hierarchy. * </p> */ private static class GenerateViewIconTask extends AsyncTask<FeatureCollection, Void, HashMap<String, Bitmap>> { private final HashMap<String, View> viewMap = new HashMap<>(); private final WeakReference<SymbolLayerMapillaryActivity> activityRef; private final boolean refreshSource; GenerateViewIconTask(SymbolLayerMapillaryActivity activity, boolean refreshSource) { this.activityRef = new WeakReference<>(activity); this.refreshSource = refreshSource; } GenerateViewIconTask(SymbolLayerMapillaryActivity activity) { this(activity, false); } @SuppressWarnings(""WrongThread"") @Override protected HashMap<String, Bitmap> doInBackground(FeatureCollection... params) { SymbolLayerMapillaryActivity activity = activityRef.get(); if (activity != null) { HashMap<String, Bitmap> imagesMap = new HashMap<>(); LayoutInflater inflater = LayoutInflater.from(activity); FeatureCollection featureCollection = params[0]; for (Feature feature : featureCollection.features()) { View view = inflater.inflate(R.layout.mapillary_layout_callout, null); String name = feature.getStringProperty(PROPERTY_TITLE); TextView titleTv = view.findViewById(R.id.title); titleTv.setText(name); String style = feature.getStringProperty(PROPERTY_STYLE); TextView styleTv = view.findViewById(R.id.style); styleTv.setText(style); boolean favourite = feature.getBooleanProperty(PROPERTY_FAVOURITE); ImageView imageView = view.findViewById(R.id.logoView); imageView.setImageResource(favourite ? R.drawable.ic_favorite : R.drawable.ic_favorite_border); Bitmap bitmap = SymbolGenerator.generate(view); imagesMap.put(name, bitmap); viewMap.put(name, view); } return imagesMap; } else { return null; } } @Override protected void onPostExecute(HashMap<String, Bitmap> bitmapHashMap) { super.onPostExecute(bitmapHashMap); SymbolLayerMapillaryActivity activity = activityRef.get(); if (activity != null && bitmapHashMap != null) { activity.setImageGenResults(viewMap, bitmapHashMap); if (refreshSource) { activity.refreshSource(); } } } } /** * Async task which fetches pictures from around the POI using Mapillary services. * https://www.mapillary.com/developer/api-documentation/ */ private static class LoadMapillaryDataTask extends AsyncTask<Integer, Void, MapillaryDataLoadResult> { static final String URL_IMAGE_PLACEHOLDER = ""https://d1cuyjsrcm0gby.cloudfront.net/%s/thumb-320.jpg""; static final String KEY_UNIQUE_FEATURE = ""key""; static final String TOKEN_UNIQUE_FEATURE = ""{"" + KEY_UNIQUE_FEATURE + ""}""; static final String ID_SOURCE = ""cluster_source""; static final String ID_LAYER_UNCLUSTERED = ""unclustered_layer""; static final int IMAGE_SIZE = 128; static final String API_URL = ""https://a.mapillary.com/v3/images/"" + ""?lookat=%f,%f&closeto=%f,%f&radius=%d"" + ""&client_id=bjgtc1FDTnFPaXpxeTZuUDNabmJ5dzozOGE1ODhkMmEyYTkyZTI4""; private WeakReference<SymbolLayerMapillaryActivity> activityRef; private MapboxMap map; private Picasso picasso; private final Handler progressHandler; private int loadingProgress; private boolean loadingIncrease = true; private Feature feature; public LoadMapillaryDataTask(SymbolLayerMapillaryActivity activity, MapboxMap map, Picasso picasso, Handler progressHandler, Feature feature) { this.activityRef = new WeakReference<>(activity); this.map = map; this.picasso = picasso; this.progressHandler = progressHandler; this.feature = feature; } @Override protected void onPreExecute() { super.onPreExecute(); loadingProgress = 0; setLoadingState(true, false); } @Override protected MapillaryDataLoadResult doInBackground(Integer... radius) { progressHandler.post(progressRunnable); try { Thread.sleep(2500); //ensure loading visualisation } catch (InterruptedException exception) { exception.printStackTrace(); } OkHttpClient okHttpClient = new OkHttpClient(); try { Point poiPosition = (Point) feature.geometry(); @SuppressLint(""DefaultLocale"") Request request = new Request.Builder() .url(String.format(API_URL, poiPosition.longitude(), poiPosition.latitude(), poiPosition.longitude(), poiPosition.latitude(), radius[0] )) .build(); Response response = okHttpClient.newCall(request).execute(); FeatureCollection featureCollection = FeatureCollection.fromJson(response.body().string()); MapillaryDataLoadResult mapillaryDataLoadResult = new MapillaryDataLoadResult(featureCollection); for (Feature feature : featureCollection.features()) { String imageId = feature.getStringProperty(KEY_UNIQUE_FEATURE); String imageUrl = String.format(URL_IMAGE_PLACEHOLDER, imageId); Bitmap bitmap = picasso.load(imageUrl).resize(IMAGE_SIZE, IMAGE_SIZE).get(); //cropping bitmap to be circular bitmap = getCroppedBitmap(bitmap); mapillaryDataLoadResult.add(feature, bitmap); } return mapillaryDataLoadResult; } catch (Exception exception) { Timber.e(exception); } return null; } @Override protected void onPostExecute(MapillaryDataLoadResult mapillaryDataLoadResult) { super.onPostExecute(mapillaryDataLoadResult); setLoadingState(false, true); if (mapillaryDataLoadResult == null) { SymbolLayerMapillaryActivity activity = activityRef.get(); if (activity != null) { Toast.makeText(activity, ""Error. Unable to load Mapillary data."", Toast.LENGTH_LONG).show(); } return; } FeatureCollection featureCollection = mapillaryDataLoadResult.mapillaryFeatureCollection; Map<Feature, Bitmap> bitmapMap = mapillaryDataLoadResult.bitmapHashMap; for (Map.Entry<Feature, Bitmap> featureBitmapEntry : bitmapMap.entrySet()) { Feature feature = featureBitmapEntry.getKey(); String key = feature.getStringProperty(KEY_UNIQUE_FEATURE); map.getStyle().addImage(key, featureBitmapEntry.getValue()); } GeoJsonSource mapillarySource = (GeoJsonSource) map.getStyle().getSource(ID_SOURCE); if (mapillarySource == null) { map.getStyle().addSource(new GeoJsonSource(ID_SOURCE, featureCollection, new GeoJsonOptions() .withCluster(true) .withClusterMaxZoom(17) .withClusterRadius(IMAGE_SIZE / 3) )); // unclustered map.getStyle().addLayerBelow(new SymbolLayer(ID_LAYER_UNCLUSTERED, ID_SOURCE).withProperties( iconImage(TOKEN_UNIQUE_FEATURE), iconAllowOverlap(true), iconSize(interpolate(exponential(1f), zoom(), stop(12, 0.0f), stop(15, 0.8f), stop(16, 1.1f), stop(17, 1.4f), stop(18, 1.7f) ))), MAKI_LAYER_ID); // clustered int[][] layers = new int[][] { new int[] {20, Color.RED}, new int[] {10, Color.BLUE}, new int[] {0, Color.GREEN} }; for (int i = 0; i < layers.length; i++) { Expression pointCount = toNumber(Expression.get(""point_count"")); //Add cluster circles CircleLayer clusterLayer = new CircleLayer(""cluster-"" + i, ID_SOURCE); clusterLayer.setProperties( circleColor(layers[i][1]), circleRadius( interpolate( exponential(1f), zoom(), stop(12, 10f), stop(14, 16f), stop(15, 18f), stop(16, 20f) ) ), circleOpacity(0.6f) ); clusterLayer.setMaxZoom(17f); // Add a filter to the cluster layer that hides the circles based on ""point_count"" clusterLayer.setFilter( i == 0 ? gte(pointCount, literal(layers[i][0])) : all( gte(pointCount, literal(layers[i][0])), lt(pointCount, literal(layers[i - 1][0])) ) ); map.getStyle().addLayerBelow(clusterLayer, MAKI_LAYER_ID); } //Add the count labels SymbolLayer count = new SymbolLayer(""count"", ID_SOURCE); count.setProperties( textField(""{point_count}""), textSize(8f), textOffset(new Float[] {0.0f, 0.0f}), textColor(Color.WHITE), textIgnorePlacement(true) ); map.getStyle().addLayerBelow(count, MAKI_LAYER_ID); } else { mapillarySource.setGeoJson(featureCollection); } } static Bitmap getCroppedBitmap(Bitmap bitmap) { Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitma",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,SymbolLayer icons,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Switch from Google Maps to Mapbox,Are you using the Google Maps API? This guide walks you through how to convert a Google web map to a Mapbox web map using Mapbox GL JS.,https://docs.mapbox.com/help/tutorials/google-to-mapbox/,tutorial,JavaScript,,"intermediate JavaScript Switch from Google Maps to Mapbox Prerequisite Familiarity with front-end development concepts. Are you using Google Maps and want to switch to Mapbox? You’ve come to the right place! This tutorial will walk you through how to use Mapbox GL JS, a web mapping JavaScript library, to create a web map, add a marker, and attach a popup using similar methods that the Google Maps JavaScript API uses. Getting started This guide assumes that you are already familiar with the Google Maps JavaScript API V3 and with front-end web development concepts including HTML, CSS, and JavaScript. There are a few resources you'll need to get started: An access token. The token is used to associate a map with your account. mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; Mapbox GL JS. You’ll need the latest versions of the Mapbox GL JS JavaScript and CSS files. You can link directly to the Mapbox hosted versions by copying this snippet within the head tags of your HTML document. <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> A text editor. You'll be writing HTML, CSS, and JavaScript. Initializing a web map First, set up an HTML file and add the above JavaScript and CSS files to the head. Once you've got your HTML file set up, head to the next step. Google With the Google Maps JavaScript API, you can initialize a new map with JavaScript as shown below: var map = new google.maps.Map(document.getElementById('map'), { mapTypeId: 'roadmap', center: { lat: 64.1436456, lng: -21.9270884 } , zoom: 13 } ); Mapbox GL JS With Mapbox GL JS, you can initialize a map in a similar way. The result of the sample code below is a map that uses the Mapbox Streets template style, initialized at a set zoom level and coordinates. The style option below is set to the style URL for Mapbox Streets, one of our template styles: var map = new mapboxgl.Map( { container: 'map', // HTML container id style: 'mapbox://styles/mapbox/streets-v 11 ', // style URL center: [-21.9270884, 64.1436456], // starting position as [lng, lat] zoom: 13 } ); You can also use custom styles created with Mapbox Studio, or you can change your map's style dynamically in the browser at runtime, depending on your needs. Adding a marker Now you're ready to add a single marker to your map. Google With the Google Maps JavaScript API, you can add a marker to a map as shown below: var map = new google.maps.Map(document.getElementById('map'), { mapTypeId: 'roadmap', center: { lat: 64.1436456, lng: -21.9270884 } , zoom: 13 } ); var marker = new google.maps.Marker( { position: { lat: 64.1436456, lng: -21.9270884 } , title: 'Reykjavik Roasters - Coffee Shop', map: map } ); Mapbox GL JS There are many ways you can add markers to a map in Mapbox GL JS. The example below uses our default marker: var map = new mapboxgl.Map( { container: 'map', // HTML container id style: 'mapbox://styles/mapbox/streets-v 11 ', // style URL center: [-21.9270884, 64.1436456], // starting position as [lng, lat] zoom: 13 } ); var marker = new mapboxgl.Marker() .setLngLat([-21.9270884, 64.1436456]) .addTo(map); You can also attach markers to a set of points by loading a GeoJSON source or a vector tileset source. Adding interactivity No marker is complete without a popup. In the next steps, add a popup that appears and displays information when the marker is clicked. Google In the Google Maps JavaScript API, interactive popups are go by the name InfoWindow and are added like this: var map = new google.maps.Map(document.getElementById('map'), { mapTypeId: 'roadmap', center: { lat: 64.14356426, lng: -21.92661562 } , zoom: 13 } ); var marker = new google.maps.Marker( { position: { lat: 64.14356426, lng: -21.92661562 } , map: map } ); var infowindow = new google.maps.InfoWindow( { content: '<h3>Reykjavik Roasters</h3><p>A good coffee shop</p>' } ); marker.addListener('click', function() { infowindow.open(map, marker); } ); Mapbox GL JS In Mapbox GL JS, you can attach the popup directly to the marker and it will be displayed when the marker is clicked by default. No need to add an event listener. Here's how you add a popup and populate it with some HTML content: var map = new mapboxgl.Map( { container: 'map', // HTML container id style: 'mapbox://styles/mapbox/streets-v 11 ', // style URL center: [-21.92661562, 64.14356426], // starting position as [lng, lat] zoom: 13 } ); var popup = new mapboxgl.Popup() .setHTML('<h3>Reykjavik Roasters</h3><p>A good coffee shop</p>'); var marker = new mapboxgl.Marker() .setLngLat([-21.92661562, 64.14356426]) .setPopup(popup) .addTo(map); Next steps You've made a web map with a marker and popup with Mapbox GL JS. Be sure to explore our other Mapbox GL JS tutorials for more ways to build on your map: Add points to a web map Create a custom style Display map controls Mapbox Geocoding API Static maps Dive in further by checking out Mapbox GL JS documentation and examples! Was this page helpful? Yes No",Switch from Google Maps to Mapbox,Getting started,Initializing a web map,Google,Mapbox GL JS,Adding a marker,Adding interactivity,Next steps,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Show and hide a layer,Add a source and a toggleable layer.,https://docs.mapbox.com/ios/maps/examples/runtime-toggle-layer/,example,Swift,Objective-C,"Show and hide a layer Related example: custom raster source. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! var contoursLayer: MGLStyleLayer? override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 37.745395, longitude: -119.594421), zoomLevel: 11, animated: false) view.addSubview(mapView) addToggleButton() mapView.delegate = self } // Wait until the style is loaded before modifying the map style func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { addLayer(to: style) } func addLayer(to style: MGLStyle) { let source = MGLVectorTileSource(identifier: ""contours"", configurationURL: NSURL(string: ""mapbox://mapbox.mapbox-terrain-v2"")! as URL) let layer = MGLLineStyleLayer(identifier: ""contours"", source: source) layer.sourceLayerIdentifier = ""contour"" layer.lineJoin = NSExpression(forConstantValue: ""round"") layer.lineCap = NSExpression(forConstantValue: ""round"") layer.lineColor = NSExpression(forConstantValue: UIColor.brown) layer.lineWidth = NSExpression(forConstantValue: 1.0) style.addSource(source) if let water = style.layer(withIdentifier: ""water"") { // You can insert a layer below an existing style layer style.insertLayer(layer, below: water) } else { // or you can simply add it above all layers style.addLayer(layer) } self.contoursLayer = layer showContours() } @objc func toggleLayer(sender: UIButton) { sender.isSelected = !sender.isSelected if sender.isSelected { showContours() } else { hideContours() } } func showContours() { self.contoursLayer?.isVisible = true } func hideContours() { self.contoursLayer?.isVisible = false } func addToggleButton() { let button = UIButton(type: .system) button.setTitle(""Toggle Contours"", for: .normal) button.isSelected = true button.sizeToFit() button.center.x = self.view.center.x button.frame = CGRect(origin: CGPoint(x: button.frame.origin.x, y: self.view.frame.size.height - button.frame.size.height - 5), size: button.frame.size) button.addTarget(self, action: #selector(toggleLayer(sender:)), for: .touchUpInside) self.view.addSubview(button) if #available(iOS 11.0, *) { let safeArea = view.safeAreaLayoutGuide button.translatesAutoresizingMaskIntoConstraints = false let constraints = [ button.bottomAnchor.constraint(equalTo: safeArea.bottomAnchor, constant: -5), button.centerXAnchor.constraint(equalTo: safeArea.centerXAnchor) ] NSLayoutConstraint.activate(constraints) } else { button.autoresizingMask = [.flexibleTopMargin, .flexibleLeftMargin, .flexibleRightMargin] } } } Copy Was this page helpful? Yes No",Show and hide a layer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Animate 3D buildings based on ambient sounds,"Connects the runtime styling API with the Web Audio API, creating a map where the 3D buildings dance to the rhythm of your ambient environment.",https://docs.mapbox.com/mapbox-gl-js/example/dancing-buildings/,example,JavaScript,,"Animate 3D buildings based on ambient sounds Connects the runtime styling API with the Web Audio API, creating a map where the 3D buildings dance to the rhythm of your ambient environment. Was this example helpful? Yes No",Animate 3D buildings based on ambient sounds,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Add a hillshade layer,Add a raster-dem source as a hillshade layer for detailed slope and shading.,https://docs.mapbox.com/studio-manual/examples/hillshade/,example,No code,,"Add a hillshade layer About this style Hillshade layer data: The data for the hillshade layer comes from the mapbox-terrain-rgb tileset. Mapbox Terrain-RGB is a raster-dem source that contains global elevation data encoded in raster PNG tiles as color values. Because it uses a raster-dem source to calculate the slope and shadow pixel-by-pixel on the user’s computer, the resulting hillshading is much more detailed than the shading that’s possible with a vector-terrain tileset. It’s the difference between styling individual pixels vs. broader, less detailed polygons. Read more about the Mapbox Terrain-RGB tileset. Raster tile styling: With hillshade layers, you can customize the color, illumination direction, and intensity of the hillshading effect. Open this style in the style editor to experiment with hillshade style properties. Read more about the hillshade layer type in the Mapbox Style Specification. Related resources Looking for more guidance? Read our tutorials. Was this page helpful? Yes No",Add a hillshade layer,About this style,Related resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add custom icons with Markers,Use Marker to add custom icons to your map.,https://docs.mapbox.com/mapbox-gl-js/example/custom-marker-icons/,example,JavaScript,,Add custom icons with Markers Use Marker to add custom icons to your map. Was this example helpful? Yes No,Add custom icons with Markers,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Style circles with a data-driven property,Creating a visualization with a data expression for circle-color.,https://docs.mapbox.com/mapbox-gl-js/example/data-driven-circle-colors/,example,JavaScript,,Style circles with a data-driven property Creating a visualization with a data expression for circle-color. Was this example helpful? Yes No,Style circles with a data-driven property,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Animate a marker,Animate the position of a Marker by updating its location on each frame.,https://docs.mapbox.com/mapbox-gl-js/example/animate-marker/,example,JavaScript,,Animate a marker Animate the position of a Marker by updating its location on each frame. Was this example helpful? Yes No,Animate a marker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,geocoding,Geocoding is the process of taking an address or name of a place and converting it into latitude and longitude values.,https://docs.mapbox.com/help/glossary/geocoding/,glossary,,,"geocoding Geocoding is the process of taking an address or name of a place and converting it into latitude and longitude values. The Mapbox Geocoding API allows you to performs two types of geocoding: forward geocoding and reverse geocoding. Forward geocoding converts text into geographic coordinates. For example, turning the address of 2 Lincoln Memorial Circle NW into coordinate values of -77.050,38.889. Reverse geocoding converts geographic coordinates into a text description, for example, turning -77.050,38.889 into the address of 2 Lincoln Memorial Circle NW. For more information, see the Mapbox Geocoding API documentation. Was this page helpful? Yes No",geocoding,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Icon update based on API response,See the International Space Station location in real time.,https://docs.mapbox.com/android/maps/examples/api-response-icon-update/,example,Java,,"Icon update based on API response Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.labs.SpaceStationLocationActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.graphics.BitmapFactory; import android.os.Bundle; import android.os.Handler; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxandroiddemo.model.IssModel; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import retrofit2.Retrofit; import retrofit2.converter.gson.GsonConverterFactory; import retrofit2.http.GET; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; /** * Display the space station's real-time location */ public class SpaceStationLocationActivity extends AppCompatActivity { private static final String TAG = ""SpaceStationActivity""; private Handler handler; private Runnable runnable; private Call<IssModel> call; // apiCallTime is the time interval when we call the API in milliseconds, by default this is set // to 2000 and you should only increase the value, reducing the interval will only cause server // traffic, the latitude and longitude values aren't updated that frequently. private int apiCallTime = 2000; // Map variables private MapView mapView; private MapboxMap map; private GeoJsonSource spaceStationSource; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_space_station_location); // Initialize the MapView mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { map = mapboxMap; mapboxMap.setStyle(Style.SATELLITE_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initSpaceStationSymbolLayer(style); callApi(); Toast.makeText(SpaceStationLocationActivity.this, R.string.space_station_toast, Toast.LENGTH_SHORT).show(); } }); } }); } private void callApi() { // Build our client, The API we are using is very basic only returning a handful of // information, mainly, the current latitude and longitude of the International Space Station. Retrofit client = new Retrofit.Builder() .baseUrl(""http://api.open-notify.org/"") .addConverterFactory(GsonConverterFactory.create()) .build(); final IssApiService service = client.create(IssApiService.class); // A handler is needed to called the API every x amount of seconds. handler = new Handler(); runnable = new Runnable() { @Override public void run() { // Call the API so we can get the updated coordinates. call = service.loadLocation(); call.enqueue(new Callback<IssModel>() { @Override public void onResponse(Call<IssModel> call, Response<IssModel> response) { // We only need the latitude and longitude from the API. double latitude = response.body().getIssPosition().getLatitude(); double longitude = response.body().getIssPosition().getLongitude(); updateMarkerPosition(new LatLng(latitude, longitude)); } @Override public void onFailure(Call<IssModel> call, Throwable throwable) { // If retrofit fails or the API was unreachable, an error will be called. //to check if throwable is null, then give a custom message. if (throwable.getMessage() == null) { Timber.e(""Http connection failed""); } else { Timber.e(throwable.getMessage()); } } }); // Schedule the next execution time for this runnable. handler.postDelayed(this, apiCallTime); } }; // The first time this runs we don't need a delay so we immediately post. handler.post(runnable); } private void initSpaceStationSymbolLayer(@NonNull Style style) { style.addImage(""space-station-icon-id"", BitmapFactory.decodeResource( this.getResources(), R.drawable.iss)); style.addSource(new GeoJsonSource(""source-id"")); style.addLayer(new SymbolLayer(""layer-id"", ""source-id"").withProperties( iconImage(""space-station-icon-id""), iconIgnorePlacement(true), iconAllowOverlap(true), iconSize(.7f) )); } private void updateMarkerPosition(LatLng position) { // This method is were we update the marker position once we have new coordinates. First we // check if this is the first time we are executing this handler, the best way to do this is // check if marker is null; if (map.getStyle() != null) { spaceStationSource = map.getStyle().getSourceAs(""source-id""); if (spaceStationSource != null) { spaceStationSource.setGeoJson(FeatureCollection.fromFeature( Feature.fromGeometry(Point.fromLngLat(position.getLongitude(), position.getLatitude())) )); } } // Lastly, animate the camera to the new position so the user // wont have to search for the marker and then return. map.animateCamera(CameraUpdateFactory.newLatLng(position)); } // Interface used for Retrofit. public interface IssApiService { @GET(""iss-now"") Call<IssModel> loadLocation(); } @Override public void onResume() { super.onResume(); mapView.onResume(); // When the user returns to the activity we want to resume the API calling. if (handler != null && runnable != null) { handler.post(runnable); } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); // When the user leaves the activity, there is no need in calling the API since the map // isn't in view. if (handler != null && runnable != null) { handler.removeCallbacks(runnable); } } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Icon update based on API response,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Examples,Code examples for the Mapbox Navigation SDK for iOS.,https://docs.mapbox.com/ios/navigation/examples/,,,,Getting started Advanced navigation app Add advanced navigation functionality to an iOS app. Basic navigation app Add basic navigation functionality to an iOS application. Customize audio Custom voice controller Use a custom voice controller. Customize routing Custom server Generate a route using third-party data. Customize visual Embedded navigation Embed navigation into your application. Styled UI elements Customize the style of UI elements. Waypoint arrival screen Display a message when a user arrives at a waypoint. Custom destination marker Add a custom marker to the destination. AR Basic blue-line AR navigation Project a blue route line on the view of the road through your device.,Getting started,Customize audio,Customize routing,Customize visual,AR,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,dataset,A dataset is an editable collection of GeoJSON features.,https://docs.mapbox.com/help/glossary/dataset/,glossary,,,"dataset A dataset is an editable collection of GeoJSON features. Datasets can be uploaded to Mapbox via Mapbox Studio or the Mapbox Datasets API, and can be edited in the Mapbox Studio dataset editor. For more information, explore the Mapbox Studio manual. Was this page helpful? Yes No",dataset,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Editor,Mapbox Editor was an online interface for designing maps.,https://docs.mapbox.com/help/glossary/mapbox-editor/,glossary,,,"Mapbox Editor Note: Mapbox Editor has been deprecated. Your existing projects can be found here. For more information, see our announcement and guide to migrating a Mapbox Editor project. Mapbox Editor was an online interface for designing maps. Mapbox Editor is no longer in active development. For our most up-to-date map design tools, explore Mapbox Studio. Was this page helpful? Yes No",Mapbox Editor,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display a map with a custom style,Using a custom Mapbox-hosted style.,https://docs.mapbox.com/mapbox-gl-js/example/custom-style-id/,example,JavaScript,,Display a map with a custom style Using a custom Mapbox-hosted style. Was this example helpful? Yes No,Display a map with a custom style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Create new data,Learn how datasets work and how to create geospatial data from scratch using Mapbox.,https://docs.mapbox.com/help/how-mapbox-works/creating-data/,guide,,,"Create new data A dataset is an editable collection of GeoJSON features. Unlike tilesets, datasets can be edited on a feature-by-feature basis. Datasets cannot be used directly in a Mapbox Studio style but can be exported as a tileset or rendered with Mapbox GL JS. Any dataset exported to a tileset can be added as a layer in the Mapbox Studio style editor. Mapbox Studio dataset editor Use the dataset editor to create and manage your data Dataset Sample GeoJSON FeatureCollection { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1qi3x10"", ""title"": ""Burnham Park"", ""description"": ""A lakefront park on Chicago's south side."", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-blue"" }, ""geometry"": { ""coordinates"": [ -87.603735, 41.829985 ], ""type"": ""Point"" }, ""id"": ""0de616c939ce2f31676ff0294c78321b"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1r2v427"", ""title"": ""Jackson Park"", ""description"": ""A lakeside park that was the site of the 1893 World's Fair"", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-orange"" }, ""geometry"": { ""coordinates"": [ -87.580389, 41.783185 ], ""type"": ""Point"" }, ""id"": ""207437833677b4c5af354906d54fda84"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1qkj6v1"", ""title"": ""Calumet Park"", ""description"": ""A park on the Illinois-Indiana border featuring a historic fieldhouse."", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-green"" }, ""geometry"": { ""coordinates"": [ -87.530221, 41.715515 ], ""type"": ""Point"" }, ""id"": ""268b9f0edfdc3a8a2a021f019164eaef"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1qs0u84"", ""title"": ""Garfield Park"", ""description"": ""Home of the Garfield Park Conservatory."", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-blue"" }, ""geometry"": { ""coordinates"": [ -87.716002, 41.882102 ], ""type"": ""Point"" }, ""id"": ""451e1a14ee747776c48d459c52905cac"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1qq1kl3"", ""title"": ""Douglas Park"", ""description"": ""A large park near in Chicago's North Lawndale neighborhood"", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-orange"" }, ""geometry"": { ""coordinates"": [ -87.699329, 41.860092 ], ""type"": ""Point"" }, ""id"": ""4aaa9df412c62b53eeab4b16ec0ea825"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1r4bs18"", ""title"": ""Lincoln Park"", ""description"": ""A northside park that is home to the Lincoln Park Zoo"", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-blue"" }, ""geometry"": { ""coordinates"": [ -87.637596, 41.940403 ], ""type"": ""Point"" }, ""id"": ""7459e13bb6d8ecd1c797e2c168a6ad91"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1qnmnw2"", ""title"": ""Columbus Park"", ""description"": ""A large park in Chicago's Austin neighborhood"", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-orange"" }, ""geometry"": { ""coordinates"": [ -87.769775, 41.873683 ], ""type"": ""Point"" }, ""id"": ""a0a6bbc358a34ccea8687f8fee527964"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1qtkep5"", ""title"": ""Grant Park"", ""description"": ""A downtown park that is the site of many of Chicago's favorite festivals and events"", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-orange"" }, ""geometry"": { ""coordinates"": [ -87.619185, 41.876367 ], ""type"": ""Point"" }, ""id"": ""acba288f3abd79014145bc16e83fbc78"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1r12m56"", ""title"": ""Humboldt Park"", ""description"": ""A large park on Chicago's northwest side"", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-green"" }, ""geometry"": { ""coordinates"": [ -87.70199, 41.905423 ], ""type"": ""Point"" }, ""id"": ""be73854ebca0a6397ce0b63e06852b50"" }, { ""type"": ""Feature"", ""properties"": { ""id"": ""marker-iv1r541d9"", ""title"": ""Millennium Park"", ""description"": ""A downtown park known for it's art installations and unique architecture"", ""marker-size"": ""medium"", ""marker-color"": ""#1087bf"", ""marker-symbol"": ""marker-green"" }, ""geometry"": { ""coordinates"": [ -87.622554, 41.882534 ], ""type"": ""Point"" }, ""id"": ""f919f7ec1e3bf88e776772311af3b151"" } ] } In this example, you can see a visual representation of a dataset inside the Mapbox Studio dataset editor on the left and the actual contents of the dataset, a GeoJSON FeatureCollection, on the right. The contents of the dataset include geometry and properties for each point that you can see on the left, but does not contain any style information. For more details on how to style the points (for example, specify the symbols, colors, and the font for labels), see the Upload data guide, which covers converting datasets to tilesets. How datasets work Datasets are a hosted version of your raw data as GeoJSON. You can access and edit your datasets with the dataset editor or the Mapbox Datasets API. Format { ""id"": "" { feature_id } "", ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [0, 0] } , ""properties"": { ""name"": ""null island"" } } Datasets are stored as GeoJSON, a format for encoding a variety of geographic data often used by Mapbox web services and APIs. Based on JSON (JavaScript object notation), GeoJSON is native to the JavaScript language and can be parsed in modern software. Mapbox stores dataset features as collections of GeoJSON features. Features are individual (or in some cases groups of) points, lines, or polygons. The Mapbox Datasets API does not support GeometryCollections or null geometries. Each feature is defined by its geometry and properties: Geometry: This describes the shape and the location of each feature. You can specify Points, LineStrings, Polygons. The location and the exact shape of each feature is determined by the coordinates that are specified. Properties: This can contain any JSON object. Some examples of common properties that are applied to Mapbox datasets include title and description to include in popups in a web application. Dataset to tileset process You cannot add datasets directly to styles in the Mapbox Studio style editor. But you can export your dataset as a tileset and add it to your style in the Mapbox Studio style editor or Mapbox GL JS. When you export your dataset to a tileset, it is processed in the same way an upload would be processed. You can read more about how raw data becomes a tileset in the Upload data guide. Downloading datasets Once you’ve created a dataset, you can export it to a tileset for use in a Mapbox map (see the How map design works guide for more information), download it as a GeoJSON FeatureCollection, or access it with the Mapbox Datasets API. Datasets can still be edited after export, but you will need to make sure to sync your downloaded version with your new edits if you would like your local copy to reflect any changes you've made. To learn how to download and export datasets, see the datasets section of the Mapbox Studio Manual. Creating datasets You can create a dataset from scratch in the Mapbox Studio dataset editor or through the Mapbox Datasets API. Note that the process involves two steps in each case: creating an empty dataset, and adding features to that dataset. Mapbox Studio In Mapbox Studio, you can use the dataset editor to create a new dataset using a visual interface rather than writing the GeoJSON directly. To create a dataset with the Mapbox Studio dataset editor, you can either create a new empty dataset and add features to it by drawing them in the dataset editor, or you can upload a GeoJSON or CSV file as a dataset and edit, add, and delete features using the dataset editor interface. You can learn more about how to create datasets using the Mapbox Studio dataset editor in the Mapbox Studio Manual. Mapbox Datasets API Using the Mapbox Datasets API, you can add features by making requests to insert a feature. You cannot upload a file directly through the Datasets API. The Datasets API accepts one Feature at a time. If you would like to add many Features from a FeatureCollection, you can do so programmatically. You can read more about how to programmatically update datasets in the Mapbox Datasets API documentation. Was this page helpful? Yes No",Create new data,How datasets work,Format,Dataset to tileset process,Downloading datasets,Creating datasets,Mapbox Studio,Mapbox Datasets API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Draw multiple geometries,Filter and draw multiple geometries from a single GeoJSON file.,https://docs.mapbox.com/android/maps/examples/draw-multiple-geometries/,example,Java,,"Draw multiple geometries Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""65.509486"" mapbox:mapbox_cameraTargetLng=""16.951005"" mapbox:mapbox_cameraZoom=""3.296733"" /> </LinearLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.io.IOException; import java.io.InputStream; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; public class MultipleGeometriesActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private static final String GEOJSON_SOURCE_ID = ""GEOJSONFILE""; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_multiple_geometries); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { createGeoJsonSource(style); addPolygonLayer(style); addPointsLayer(style); } }); } private void createGeoJsonSource(@NonNull Style loadedMapStyle) { // Load data from GeoJSON file in the assets folder loadedMapStyle.addSource(new GeoJsonSource(GEOJSON_SOURCE_ID, loadJsonFromAsset(""fake_norway_campsites.geojson""))); } private void addPolygonLayer(@NonNull Style loadedMapStyle) { // Create and style a FillLayer that uses the Polygon Feature's coordinates in the GeoJSON data FillLayer countryPolygonFillLayer = new FillLayer(""polygon"", GEOJSON_SOURCE_ID); countryPolygonFillLayer.setProperties( PropertyFactory.fillColor(Color.RED), PropertyFactory.fillOpacity(.4f)); countryPolygonFillLayer.setFilter(eq(literal(""$type""), literal(""Polygon""))); loadedMapStyle.addLayer(countryPolygonFillLayer); } private void addPointsLayer(@NonNull Style loadedMapStyle) { // Create and style a CircleLayer that uses the Point Features' coordinates in the GeoJSON data CircleLayer individualCirclesLayer = new CircleLayer(""points"", GEOJSON_SOURCE_ID); individualCirclesLayer.setProperties( PropertyFactory.circleColor(Color.YELLOW), PropertyFactory.circleRadius(3f)); individualCirclesLayer.setFilter(eq(literal(""$type""), literal(""Point""))); loadedMapStyle.addLayer(individualCirclesLayer); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private String loadJsonFromAsset(String filename) { try { InputStream is = getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (IOException ex) { ex.printStackTrace(); return null; } } } Copy Was this page helpful? Yes No",Draw multiple geometries,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for iOS,iOS,Set up an external camera source,Use an external camera source instead of a device's built-in camera.,https://docs.mapbox.com/ios/vision/examples/set-up-an-external-camera-source/,example,Swift,,"Set up an external camera source Swift Objective C import UIKit import MapboxVision import AVFoundation /** * ""External camera"" example demonstrates how to create a custom source of video stream and pass it to `VisionManager`. */ // Example of custom video source is a simple video file reader class FileVideoSource: ObservableVideoSource { private let reader: AVAssetReader private let queue = DispatchQueue(label: ""FileVideoSourceQueue"") private lazy var timer: CADisplayLink = { let displayLink = CADisplayLink(target: self, selector: #selector(update)) displayLink.preferredFramesPerSecond = 30 return displayLink }() init(url: URL) { let asset = AVAsset(url: url) reader = try! AVAssetReader(asset: asset) super.init() let videoTrack = asset.tracks(withMediaType: .video).first! let output = AVAssetReaderTrackOutput( track: videoTrack, outputSettings: [ String(kCVPixelBufferPixelFormatTypeKey): NSNumber(value: kCVPixelFormatType_32BGRA) ] ) reader.add(output) } func start() { queue.async { [unowned self] in self.reader.startReading() self.timer.add(to: .main, forMode: .default) } } func stop() { queue.async { [unowned self] in self.stopReading() } } @objc func update() { queue.async { [unowned self] in if let buffer = self.reader.outputs.first?.copyNextSampleBuffer() { // notify all abservers about new sample buffer availability self.notify { observer in // construct `VideoSample` specifying the format of image contained in a sample buffer let videoSample = VideoSample(buffer: buffer, format: .BGRA) observer.videoSource(self, didOutput: videoSample) } } else { self.stopReading() } } } private func stopReading() { timer.invalidate() reader.cancelReading() } } class ExternalCameraViewController: UIViewController, VisionManagerDelegate { private var fileVideoSource: FileVideoSource! private var visionManager: VisionManager! private let visionViewController = VisionPresentationViewController() override func viewDidLoad() { super.viewDidLoad() addVisionView() // create a custom video source and subscribe to receiving new video samples fileVideoSource = FileVideoSource(url: Bundle.main.url(forResource: ""video"", withExtension: ""mp4"")!) fileVideoSource.add(observer: self) // create VisionManager with a custom video source visionManager = VisionManager.create(videoSource: fileVideoSource) } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) visionManager.start(delegate: self) fileVideoSource.start() } override func viewDidDisappear(_ animated: Bool) { super.viewDidDisappear(animated) fileVideoSource.stop() visionManager.stop() } private func addVisionView() { addChild(visionViewController) view.addSubview(visionViewController.view) visionViewController.didMove(toParent: self) } } extension ExternalCameraViewController: VideoSourceObserver { func videoSource(_ videoSource: VideoSource, didOutput videoSample: VideoSample) { DispatchQueue.main.async { [weak self] in // display received sample buffer by passing it to presentation controller self?.visionViewController.present(sampleBuffer: videoSample.buffer) } } } Copy Was this page helpful? Yes No",Set up an external camera source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Static Images API,"The Mapbox Static Images API allows you to request a standalone, static image of a map generated from a Mapbox GL-based style.",https://docs.mapbox.com/help/glossary/static-images-api/,glossary,,,"Static Images API The Mapbox Static Images API allows you to generate a standalone, static image of a map generated from a Mapbox GL-based style. This means you can add a map to your website or blog without JavaScript or plugins. Static Images API usage is measured in API requests (one request for each image). For styles that contain vector layers, the returned static map will be a PNG. For styles that contain raster layers, the returned static map will be a JPEG. A sample Static Images API request looks like: https://api.mapbox.com/styles/v1/mapbox/streets-v11/static/-122.4241,37.78,14.25,0,60/600x600?access_token= YOUR_MAPBOX_ACCESS_TOKEN The Static Images API has optional parameters that can be used to refine the results of a request. Related resources: Static Images API documentation Static Images API playground How static maps work Legacy Static Images API If you're working with classic styles, you are using the Legacy Static Images API. For details, see the documentation for the Legacy Static Images API . Was this page helpful? Yes No",Static Images API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,sprite,A sprite is a single image containing all icons included in a style.,https://docs.mapbox.com/help/glossary/sprite/,glossary,,,"sprite A sprite is a single image containing all icons included in a style. Sprites are often used in web development and even video games to improve performance. By combining lots of small images into a single image (sprite), you can reduce the number of requests needed to fetch all the images, improving performance and making your map load more quickly. If you're using Mapbox Studio, you don't have to worry about the technical underpinnings of sprites: uploading SVG icons automatically creates a sprite that your map will use. Similarly, all Mapbox template styles come with their own sprite filled with icons that you can use with that style. If you would like to do it yourself or are interested in what's under the hood, you can also create your own sprite. Here's a rundown of all the terminology and how sprites work. A sprite combines many icons into a single image: Sprite for Mapbox Streets An icon is a single image found within the sprite: Mapbox Streets icon named airport-15. Sprites are limited to 500 icons. Each icon can be a maximum of 512x512 pixels and have a max file size of 400KB. Every sprite has a complimentary JSON file that defines each icon, including the icon's size and position within the sprite - kind of like directions to each icon: ""airport-15"": { ""width"": 42, ""height"": 42, ""x"": 76, ""y"": 300, ""pixelRatio"": 2, ""visible"": true } This means that you can reference an icon by name, such as airport-15, and our map renderer will reference the JSON file to get data about the icon and then only show the sprite at that specific icon. To learn more about creating and editing sprites, read the Mapbox Style Reference: Sprites. Was this page helpful? Yes No",sprite,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Tileset sources and the Tilesets API,This feature is in beta. Learn about how to use line-delimited GeoJSON to create tileset sources and how to handle IDs in tileset sources.,https://docs.mapbox.com/help/troubleshooting/tileset-sources/,troubleshooting,,,"Tileset sources and the Tilesets API Public beta Tileset sources and the Mapbox Tilesets API functionalities documented in this guide are in public beta. All features and workflows are subject to potential changes. Tileset sources Beta This feature is in public beta and is subject to potential changes. A tileset source is a Mapbox service that allows you to save raw line-delimited GeoJSON on Mapbox.com and reference these sources in a recipe using an ID. The same tileset source can be used across multiple tilesets. If your data is not changing, then you do not need to upload it every time you want to publish a job. You can specify the source data for a layer directly in a recipe. This example recipe shows the source field: ""trees"": { ""source"": ""mapbox://tileset-source/ { username } /trees-data"", ""minzoom"": 4, ""maxzoom"": 8 } A tileset source can be composed of up to 10 files, which all must be line-delimited GeoJSON. Tileset sources are created and managed using the Tilesets API. Line-delimited GeoJSON The Tilesets API requires that tileset sources be formatted as line-delimited GeoJSON (uncompressed line-delimited sequences of GeoJSON features). Unlike features being collected under a FeatureCollection array, as is done in GeoJSON, features are separated by newline characters in the file. Putting each feature on its own line makes it faster and easier to process individual features. For example: { ""type"":""Feature"",""id"":1,""geometry"": { ""type"":""Point"",""coordinates"":[115.7,12.2] } ,""properties"": { ""name"":""cool feature"" } } { ""type"":""Feature"",""id"":2,""geometry"": { ""type"":""Point"",""coordinates"":[125.7,12.2] } ,""properties"": { ""name"":""neat feature"" } } { ""type"":""Feature"",""id"":3,""geometry"": { ""type"":""Point"",""coordinates"":[135.7,12.2] } ,""properties"": { ""name"":""bad place"" } } { ""type"":""Feature"",""id"":4,""geometry"": { ""type"":""Point"",""coordinates"":[105.7,12.2] } ,""properties"": { ""name"":""good place"" } } Validate line-delimited GeoJSON You can use the Tilesets CLI to validate a tileset source file by using the command: $ tilesets validate-source path/to/your/data.json To learn more about this command and other Tilesets CLI functions, see the Tilesets CLI documentation. Convert GeoJSON to line-delimited GeoJSON To convert a GeoJSON file to line-delimited GeoJSON, you can use the Tippecanoe tippecanoe-json-tool command: $ tippecanoe-json-tool in.geojson > out.geojson.ld Convert other data formats to line-delimited GeoJSON If your source data is in a vector format other than GeoJSON, such as a Shapefile or KML, you need to convert it to line-delimited GeoJSON before using it to create a tileset source. The Fiona CLI tool fio outputs line-delimited GeoJSON by default and is a good option for converting files. Here is an example converting a Shapefile into a line-delimited sequence of GeoJSON features: $ fio cat ~/data/countries.shp > countries.geojson.ld The ogr2ogr utility from GDAL (version 2.4) can also convert many data formats to line-delimited GeoJSON: $ ogr2ogr -f GeoJSONSeq countries.geojson.ld ~/data/countries.shp Feature IDs in the Tilesets API Beta This feature is in public beta and is subject to potential changes. The Tilesets API allows you to define which field in the tileset source is the identifier for your source features. By default, the system will use the top-level id field in each GeoJSON feature. You can override this with the rules defined in the Recipe reference section on IDs. Feature ID format The Mapbox Vector Tile v2 Specification requires that a vector tile feature ID be an Integer. Because of this, the Tilesets API will convert any non-integer IDs into integer hash representations that are consistent across your entire tileset: Integer IDs: If an integer ID field is present in the tileset source, the resulting vector tile feature ID will have the same value. String IDs: If an ID field is present and is a string value, the resulting vector tile feature ID will be an integer hash representation unique to that string, between 0 and 2^53. Floating point value or empty string IDs: If an ID field is present and is a floating point value or an empty string, or if there is no ID field, the resulting vector tile feature ID will be a randomly generated integer between 0 and 2^53. While ID collision for unidentified features is unlikely, unique IDs aren't guaranteed since feature parsing occurs in a distributed environment. To guarantee unique identifiers, bring your own IDs. Duplicate IDs: Duplicate feature IDs can cause unexpected behavior in tilesets and should be avoided. If you need your source data IDs to match your tileset IDs, you can either use integer IDs in the source data, or you can save the original ID of the feature as an attribute in the vector tiles using the add_to_attributes option in your recipe. Was this page helpful? Yes No",Tileset sources and the Tilesets API,Tileset sources,Line-delimited GeoJSON,Validate line-delimited GeoJSON,Convert GeoJSON to line-delimited GeoJSON,Convert other data formats to line-delimited GeoJSON,Feature IDs in the Tilesets API,Feature ID format,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Create a choropleth map,Add a fill layer and use expressions to style a choropleth map.,https://docs.mapbox.com/studio-manual/examples/choropleth-map/,example,No code,,"Create a choropleth map About this style Tileset from custom data: The data that is used as the source for the state-data layer comes from a custom tileset that was created by uploading a GeoJSON file to Mapbox Studio. This data is borrowed from the Leaflet choropleth tutorial and contains data on population density across US states. The tileset itself contains the geometry for each state and two properties: name (a string) and density (a number). Read more about uploading data to Mapbox Studio in the Overview section. Styling with expressions: The state-data layer is styled using property expressions. In this case, property expressions are being used on the Color property to style features across a data range. The color of each feature will be determined based on its density. Related resources Looking for more guidance? Read our Make a choropleth map, part 1: create a style tutorial. Was this page helpful? Yes No",Create a choropleth map,About this style,Related resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Picture in picture,Use the Android O release of picture-in-picture to maintain a map in a separate window.,https://docs.mapbox.com/android/maps/examples/picture-in-picture/,example,Java,,"Picture in picture Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/add_window_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginBottom=""16dp"" android:layout_marginRight=""16dp"" android:src=""@drawable/ic_crop_square_white_24dp"" mapbox:fabSize=""normal"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintRight_toRightOf=""parent""/> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""13.7563309"" mapbox:mapbox_cameraTargetLng=""100.501765"" mapbox:mapbox_cameraTilt=""0"" mapbox:mapbox_cameraZoom=""3"" tools:layout_editor_absoluteX=""8dp"" tools:layout_editor_absoluteY=""8dp""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.os.Bundle; import androidx.annotation.NonNull; import com.google.android.material.floatingactionbutton.FloatingActionButton; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; /** * Enter picture-in-picture mode with a map being persisted. Only works on devices running Android O and above. */ public class PictureInPictureActivity extends AppCompatActivity { private MapView mapView; private FloatingActionButton addPictureFab; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_picture_in_picture); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.SATELLITE_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { addPictureFab = findViewById(R.id.add_window_fab); addPictureFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { try { enterPictureInPictureMode(); } catch (Exception exception) { Toast.makeText(PictureInPictureActivity.this, R.string.no_picture_in_picture_support, Toast.LENGTH_SHORT).show(); } } }); } }); } }); } @Override public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode) { super.onPictureInPictureModeChanged(isInPictureInPictureMode); addPictureFab.setVisibility(isInPictureInPictureMode ? View.GONE : View.VISIBLE); if (isInPictureInPictureMode) { // Hide the controls in picture-in-picture mode. getSupportActionBar().hide(); } else { // Restore the playback UI based on the playback status. getSupportActionBar().show(); } } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Picture in picture,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Scale bar,Read docs on the Mapbox Scale Bar Plugin for Android. Provide a display of how far various map features are from one another at a certain zoom level.,https://docs.mapbox.com/android/plugins/overview/scalebar/,guide,Java,Kotlin,"Scale bar Scale bar example View a demo of using the plugin to add and style the scale bar. The Scale Bar Plugin for Android displays numbers and a line to help visualize how far various map features are from one another at a certain zoom level. The scale bar can be customized with options such as the text color and size, refresh interval, margins, and border width. Install the Scale Bar Plugin To start developing an application using the Scale Bar Plugin, you'll need to add the appropriate dependencies inside your build.gradle file. You can find the dependency given below on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-scalebar- v8. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-scalebar- v8 : 0.3.0 ' } Add the scale bar Initialize the plugin inside of onStyleLoaded because the Scale Bar Plugin requires the mapboxMap object and the scale bar is put on top of the map. Java Kotlin @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { ScaleBarPlugin scaleBarPlugin = new ScaleBarPlugin(mapView, mapboxMap); // Create a ScaleBarOptions object to use the Plugin's default styling scaleBarPlugin.create(new ScaleBarOptions(this)); } }); } Copy Customizing the scale bar The plugin's ScaleBarOptions provides many options for customizing the look of the scale bar and how the scale bar responds to map interaction. Once you create a ScaleBarOptions object, you can run various styling methods to set your preferences. Once you're done styling the scale bar the way that you'd like, give the ScaleBarOptions object to the ScaleBarPlugin object via the create() method. Java Kotlin @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { ScaleBarPlugin scaleBarPlugin = new ScaleBarPlugin(mapView, mapboxMap); // Set the custom styling via a ScaleBarOptions object ScaleBarOptions scaleBarOptions = new ScaleBarOptions(this) .setTextColor(R.color.mapboxRed) .setTextSize(40f) .setBarHeight(15f) .setBorderWidth(5f) .setMetricUnit(true) .setRefreshInterval(15) .setMarginTop(30f) .setMarginLeft(16f) .setTextBarMargin(15f) // Give the plugin the ScaleBarOptions object to style the scale bar scaleBarPlugin.create(scaleBarOptions); } }); } Copy Scale bar visibility The ScaleBarPlugin class has a setEnabled() method to adjust the scale bar's visibilty. Pass true as a parameter to make the scale bar visible and false to hide the scale bar. The scale bar is visible by default on scaleBarPlugin.create(), which means that you don't have to use setEnabled() to initially show the scale bar. Java Kotlin // To hide the scale bar scaleBarPlugin.setEnabled(false); Copy Was this page helpful? Yes No",Scale bar,Install the Scale Bar Plugin,Add the dependency,Add the scale bar,Customizing the scale bar,Scale bar visibility,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,tileset recipe,This feature is in beta. Tileset recipes describe how tileset source data should look and behave when a tileset is published by the Tilesets API.,https://docs.mapbox.com/help/glossary/tileset-recipe/,glossary,,,"tileset recipe Public beta Tileset recipes are in public beta. They are subject to potential changes. A tileset recipe is a set of rules that tells the Tilesets API how a tileset source's data should be transformed when it is published as a tileset. Recipes provide options for generating vector tiles such as degree of simplification, zoom level extent, geometry coalescing, attribute manipulation, and more. Learn more about the available configuration options for tileset recipes in the Recipe reference. Was this page helpful? Yes No",tileset recipe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for Android,Android,Set up an external camera source,Use an external camera source instead of a device's built-in camera.,https://docs.mapbox.com/android/vision/examples/set-up-an-external-camera-source/,example,Java,Kotlin,"Set up an external camera source Java Kotlin package com.mapbox.vision.examples; import android.graphics.Bitmap; import android.media.MediaMetadataRetriever; import android.os.Bundle; import android.os.Handler; import android.os.HandlerThread; import android.support.v7.app.AppCompatActivity; import com.mapbox.vision.VisionManager; import com.mapbox.vision.mobile.core.interfaces.VisionEventsListener; import com.mapbox.vision.mobile.core.models.AuthorizationStatus; import com.mapbox.vision.mobile.core.models.Camera; import com.mapbox.vision.mobile.core.models.Country; import com.mapbox.vision.mobile.core.models.FrameSegmentation; import com.mapbox.vision.mobile.core.models.classification.FrameSignClassifications; import com.mapbox.vision.mobile.core.models.detection.FrameDetections; import com.mapbox.vision.mobile.core.models.frame.ImageFormat; import com.mapbox.vision.mobile.core.models.frame.ImageSize; import com.mapbox.vision.mobile.core.models.position.VehicleState; import com.mapbox.vision.mobile.core.models.road.RoadDescription; import com.mapbox.vision.mobile.core.models.world.WorldDescription; import com.mapbox.vision.video.videosource.VideoSource; import com.mapbox.vision.video.videosource.VideoSourceListener; import com.mapbox.vision.view.VisionView; import org.jetbrains.annotations.NotNull; import java.io.File; import java.nio.ByteBuffer; import java.util.concurrent.TimeUnit; /** * Example shows how Vision SDK can work with external video source. This can be some custom camera implementation or any * other source of frames - video, set of pictures, etc. */ public class ExternalCameraSource extends AppCompatActivity { // Video file that will be processed. private static final String VIDEO_FILE = ""video.mp4""; private VideoSourceListener videoSourceListener; private VisionView visionView; private HandlerThread handlerThread = new HandlerThread(""VideoDecode""); // VideoSource that will play the file. private VideoSource customVideoSource = new VideoSource() { @Override public void attach(@NotNull VideoSourceListener videoSourceListener) { // video source is attached, we can start decoding frames from video and feeding them to Vision SDK ExternalCameraSource.this.videoSourceListener = videoSourceListener; handlerThread.start(); new Handler(handlerThread.getLooper()).post(new Runnable() { @Override public void run() { startFileVideoSource(); } }); } @Override public void detach() { videoSourceListener = null; handlerThread.quitSafely(); } }; // VideoSourceListener handles events from Vision SDK. private VisionEventsListener visionEventsListener = new VisionEventsListener() { @Override public void onAuthorizationStatusUpdated(@NotNull AuthorizationStatus authorizationStatus) {} @Override public void onFrameSegmentationUpdated(@NotNull FrameSegmentation frameSegmentation) {} @Override public void onFrameDetectionsUpdated(@NotNull FrameDetections frameDetections) { visionView.setDetections(frameDetections); } @Override public void onFrameSignClassificationsUpdated(@NotNull FrameSignClassifications frameSignClassifications) {} @Override public void onRoadDescriptionUpdated(@NotNull RoadDescription roadDescription) {} @Override public void onWorldDescriptionUpdated(@NotNull WorldDescription worldDescription) {} @Override public void onVehicleStateUpdated(@NotNull VehicleState vehicleState) {} @Override public void onCameraUpdated(@NotNull Camera camera) {} @Override public void onCountryUpdated(@NotNull Country country) {} @Override public void onUpdateCompleted() {} }; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); visionView = findViewById(R.id.vision_view); } @Override protected void onStart() { super.onStart(); VisionManager.create(); VisionManager.start(visionEventsListener); VisionManager.setVideoSourceListener(visionView); } @Override protected void onStop() { super.onStop(); VisionManager.stop(); VisionManager.destroy(); } /** * Decodes video source frame by frame and feeds frames to Vision SDK. */ private void startFileVideoSource() { // Use MediaMetadataRetriever to decode video. // It isn't the fastest approach to decode videos and you probably want some other method // if FPS is important (eg. MediaCodec). MediaMetadataRetriever retriever = new MediaMetadataRetriever(); retriever.setDataSource(new File(getExternalFilesDir(""""), VIDEO_FILE).getAbsolutePath()); // Get video frame size. int frameWidth = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH)); int frameHeight = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT)); ImageSize imageSize = new ImageSize(frameWidth, frameHeight); // ByteBuffer to hold RGBA bytes. ByteBuffer rgbaByteBuffer = ByteBuffer.wrap(new byte[frameWidth * frameHeight * 4]); // Get duration. long duration = Long.parseLong(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)); try { // Get frames one by one with 1 second intervals. for (int seconds = 0; seconds < duration; seconds++) { Bitmap bitmap = retriever .getFrameAtTime( TimeUnit.SECONDS.toMicros(seconds), MediaMetadataRetriever.OPTION_CLOSEST ) .copy(Bitmap.Config.ARGB_8888, false); bitmap.copyPixelsToBuffer(rgbaByteBuffer); videoSourceListener.onNewFrame( rgbaByteBuffer.array(), ImageFormat.RGBA, imageSize ); rgbaByteBuffer.clear(); } } catch (RuntimeException e) { e.printStackTrace(); } finally { try { retriever.release(); } catch (RuntimeException e) { e.printStackTrace(); } } } } Copy Was this page helpful? Yes No",Set up an external camera source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Map Matching API,"The Mapbox Map Matching API allows you to take recorded traces, such as the data from a GPS tracker, and snap them to the OpenStreetMap road and path network.",https://docs.mapbox.com/help/glossary/map-matching-api/,glossary,,,"Map Matching API The Mapbox Map Matching API allows you to take recorded traces, such as the data from a GPS unit or phone, and snap them to the OpenStreetMap road and path network. This produces clean paths that can be displayed on a map or used for other analysis. A sample Map Matching API request looks like: https://api.mapbox.com/matching/v5/mapbox/driving/-117.17282,32.71204;-117.17288,32.71225;-117.17293,32.71244?access_token= YOUR_MAPBOX_ACCESS_TOKEN The Map Matching API has optional parameters that can be used to refine the results of a request. Related resources: Map Matching API documentation Get started with the Map Matching API tutorial Was this page helpful? Yes No",Map Matching API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add raster imagery,Dynamically add a raster source.,https://docs.mapbox.com/ios/maps/examples/source-custom-raster/,example,Swift,Objective-C,"Add raster imagery Related example: custom raster style. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! var rasterLayer: MGLRasterStyleLayer? override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 45.5188, longitude: -122.6748), zoomLevel: 13, animated: false) mapView.delegate = self view.addSubview(mapView) // Add a UISlider that will control the raster layer’s opacity. addSlider() } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { // Add a new raster source and layer. let source = MGLRasterTileSource(identifier: ""stamen-watercolor"", tileURLTemplates: [""https://stamen-tiles.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.jpg""], options: [ .tileSize: 256 ]) let rasterLayer = MGLRasterStyleLayer(identifier: ""stamen-watercolor"", source: source) style.addSource(source) style.addLayer(rasterLayer) self.rasterLayer = rasterLayer } @objc func updateLayerOpacity(_ sender: UISlider) { rasterLayer?.rasterOpacity = NSExpression(forConstantValue: sender.value as NSNumber) } func addSlider() { let padding: CGFloat = 10 let slider = UISlider(frame: CGRect(x: padding, y: self.view.frame.size.height - 44 - 30, width: self.view.frame.size.width - padding * 2, height: 44)) slider.minimumValue = 0 slider.maximumValue = 1 slider.value = 1 slider.addTarget(self, action: #selector(updateLayerOpacity), for: .valueChanged) view.insertSubview(slider, aboveSubview: mapView) if #available(iOS 11.0, *) { let safeArea = view.safeAreaLayoutGuide slider.translatesAutoresizingMaskIntoConstraints = false let constraints = [ slider.bottomAnchor.constraint(equalTo: safeArea.bottomAnchor, constant: -mapView.logoView.bounds.height - 10), slider.widthAnchor.constraint(equalToConstant: self.view.frame.size.width - padding * 2), slider.centerXAnchor.constraint(equalTo: safeArea.centerXAnchor) ] NSLayoutConstraint.activate(constraints) } else { slider.autoresizingMask = [.flexibleTopMargin, .flexibleLeftMargin, .flexibleRightMargin] } } } Copy Was this page helpful? Yes No",Add raster imagery,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Data clustering,Learn how to use the Mapbox Maps SDK for Android to show clustered data on the map.,https://docs.mapbox.com/android/maps/overview/clustering/,guide,Java,Kotlin,"Data clustering Often, a map can show too much data at a single time. Markers overlap with each other. The map looks and feels cluttered. Users can't get a quick understanding of what the data is supposed to say. Showing clustered data is entirely possible by using the data-driven styling capabilities of the Mapbox Maps SDK for Android. Adjusting the amount of data shown on the map to the map's camera zoom level, is a way to provide users with a cleaner UI experience and less overwhelming location data experience. CircleLayer CircleLayer clustering example Use GeoJSON data and layers to show data with circle clusters Using CircleLayers is one way of two recommended ways to show data clustering. Different circle colors can represent the various data ranges. For example, blue circles might be clusters with 100+ data points, red circles with 50+, and green circles with 10+. Once the map is zoomed in enough, only individual data points would be visible. SymbolLayer The SymbolLayer is a bit more complicated but essentially the same as the CircleLayer implementation above. Depending on the shape/size of the SymbolLayer icons that you use, you might have to use thePropertyFactory's iconTranslate method to make sure that the data count SymbolLayer number text is lined up directly on top of the SymbolLayer cluster icons. Different icons could represent the various data ranges. For example, one image could be clusters with 100+ data points, a second image with 50+, and third image with 10+. Once the map is zoomed in enough, only individual data points would be visible SymbolLayer clustering example Use GeoJSON data and layers to show data with various images as the cluster icons To do this: Use a GeoJSON data source and add it to the Mapbox map as a GeoJsonSource. Java Kotlin try { mapboxMap.getStyle().addSource( new GeoJsonSource(""GEOJSON_SOURCE_ID"", new URL(""URL_POINTING_TO_GEOJSON_FILE""), new GeoJsonOptions() .withCluster(true) .withClusterMaxZoom(MAX_ZOOM) .withClusterRadius(DESIRED_CLUSTER_RADIUS) ) ); } catch (MalformedURLException malformedUrlException) { Log.e(TAG, ""Check the URL "" + malformedUrlException.getMessage()); } Copy Create a SymbolLayer with icons that represent the individual data points for when points are not clustered. These icons will only be visible when the map's camera is close enough to the map. Remember, the higher the map zoom value, the more zoomed in the camera is. A zoom level of 12 is closer to the map than a zoom value of 4. Create as many additional SymbolLayers or CircleLayers as you want for the various data ranges. You might have red circles represent data clusters that have 10-30 data points and then blue circles that have 50 or more data points. Data-driven styling and Expression filtering will determine which cluster layers are shown at which zoom level. Create a SymbolLayer for the hidden data amount text. That is, the number that appears and tells a user how many more data points are ""hidden"" behind the cluster icon/circle and can be viewed if the map is zoomed in on. Don't forget to use runtime styling to adjust the text size, text color, and other text properties: Java Kotlin SymbolLayer count = new SymbolLayer(""SYMBOL_LAYER_COUNT_LAYER_ID"", ""GEOJSON_SOURCE_ID""); count.setProperties( textField(Expression.toString(get(""point_count""))), textSize(TEXT_SIZE), textColor(TEXT_COLOR), textIgnorePlacement(true), textAllowOverlap(true) ); mapboxMap.getStyle().addLayer(count); Copy Was this page helpful? Yes No",Data clustering,CircleLayer,SymbolLayer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Filter symbols by text input,Filter symbols by icon name by typing in a text input.,https://docs.mapbox.com/mapbox-gl-js/example/filter-markers-by-input/,example,JavaScript,,Filter symbols by text input Filter symbols by icon name by typing in a text input. Was this example helpful? Yes No,Filter symbols by text input,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Swipe between maps,Use mapbox-gl-compare to swipe between and synchronize two maps.,https://docs.mapbox.com/mapbox-gl-js/example/mapbox-gl-compare/,example,JavaScript,,Swipe between maps Use mapbox-gl-compare to swipe between and synchronize two maps. Was this example helpful? Yes No,Swipe between maps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,latitude and longitude,Latitude and longitude are a pair of numbers (coordinates) used to describe a position on the plane of a geographic coordinate system.,https://docs.mapbox.com/help/glossary/lat-lon/,glossary,,,"latitude and longitude Latitude and longitude are a pair of numbers (coordinates) used to describe a position on the plane of a geographic coordinate system. The numbers are in decimal degrees format and range from -90 to 90 for latitude and -180 to 180 for longitude. For example, Washington DC has a latitude 38.8951 and longitude -77.0364. In API calls you will often see the numbers placed together and separated by a comma: -77.0364,38.8951. One common problem is mixing up the order of the coordinates. Some tools and APIs format longitude,latitude while others use latitude,longitude. Always check the documentation to see how you should format the coordinates. And if a point doesn't show where you expect it to — troubleshoot by switching the order! Was this page helpful? Yes No",latitude and longitude,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Create a line layer,"Create a GeoJSON line source, style it using properties, and add the layer to the map.",https://docs.mapbox.com/android/maps/examples/create-a-line-layer/,example,Java,,"Create a line layer Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.LineLayerActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""33.39243835"" mapbox:mapbox_cameraTargetLng=""-118.38265415000001"" mapbox:mapbox_cameraZoom=""13.448986053466797""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.List; /** * Add a GeoJSON line to a map. */ public class LineLayerActivity extends AppCompatActivity { private MapView mapView; private List<Point> routeCoordinates; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_line_layer); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.OUTDOORS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initRouteCoordinates(); // Create the LineString from the list of coordinates and then make a GeoJSON // FeatureCollection so we can add the line to our map as a layer. style.addSource(new GeoJsonSource(""line-source"", FeatureCollection.fromFeatures(new Feature[] {Feature.fromGeometry( LineString.fromLngLats(routeCoordinates) )}))); // The layer properties for our line. This is where we make the line dotted, set the // color, etc. style.addLayer(new LineLayer(""linelayer"", ""line-source"").withProperties( PropertyFactory.lineDasharray(new Float[] {0.01f, 2f}), PropertyFactory.lineCap(Property.LINE_CAP_ROUND), PropertyFactory.lineJoin(Property.LINE_JOIN_ROUND), PropertyFactory.lineWidth(5f), PropertyFactory.lineColor(Color.parseColor(""#e55e5e"")) )); } }); } }); } private void initRouteCoordinates() { // Create a list to store our line coordinates. routeCoordinates = new ArrayList<>(); routeCoordinates.add(Point.fromLngLat(-118.39439114221236, 33.397676454651766)); routeCoordinates.add(Point.fromLngLat(-118.39421054012902, 33.39769799454838)); routeCoordinates.add(Point.fromLngLat(-118.39408583869053, 33.39761901490136)); routeCoordinates.add(Point.fromLngLat(-118.39388373635917, 33.397328225582285)); routeCoordinates.add(Point.fromLngLat(-118.39372033447427, 33.39728514560042)); routeCoordinates.add(Point.fromLngLat(-118.3930882271826, 33.39756875508861)); routeCoordinates.add(Point.fromLngLat(-118.3928216241072, 33.39759029501192)); routeCoordinates.add(Point.fromLngLat(-118.39227981785722, 33.397234885594564)); routeCoordinates.add(Point.fromLngLat(-118.392021814881, 33.397005125197666)); routeCoordinates.add(Point.fromLngLat(-118.39090810203379, 33.396814854409186)); routeCoordinates.add(Point.fromLngLat(-118.39040499623022, 33.39696563506828)); routeCoordinates.add(Point.fromLngLat(-118.39005669221234, 33.39703025527067)); routeCoordinates.add(Point.fromLngLat(-118.38953208616074, 33.39691896489222)); routeCoordinates.add(Point.fromLngLat(-118.38906338075398, 33.39695127501678)); routeCoordinates.add(Point.fromLngLat(-118.38891287901787, 33.39686511465794)); routeCoordinates.add(Point.fromLngLat(-118.38898167981154, 33.39671074380141)); routeCoordinates.add(Point.fromLngLat(-118.38984598978178, 33.396064537239404)); routeCoordinates.add(Point.fromLngLat(-118.38983738968255, 33.39582400356976)); routeCoordinates.add(Point.fromLngLat(-118.38955358640874, 33.3955978295119)); routeCoordinates.add(Point.fromLngLat(-118.389041880506, 33.39578092284221)); routeCoordinates.add(Point.fromLngLat(-118.38872797688494, 33.3957916930261)); routeCoordinates.add(Point.fromLngLat(-118.38817327048618, 33.39561218978703)); routeCoordinates.add(Point.fromLngLat(-118.3872530598711, 33.3956265500598)); routeCoordinates.add(Point.fromLngLat(-118.38653065153775, 33.39592811523983)); routeCoordinates.add(Point.fromLngLat(-118.38638444985126, 33.39590657490452)); routeCoordinates.add(Point.fromLngLat(-118.38638874990086, 33.395737842093304)); routeCoordinates.add(Point.fromLngLat(-118.38723155962309, 33.395027006653244)); routeCoordinates.add(Point.fromLngLat(-118.38734766096238, 33.394441819579285)); routeCoordinates.add(Point.fromLngLat(-118.38785936686516, 33.39403972556368)); routeCoordinates.add(Point.fromLngLat(-118.3880743693453, 33.393616088784825)); routeCoordinates.add(Point.fromLngLat(-118.38791956755958, 33.39331092541894)); routeCoordinates.add(Point.fromLngLat(-118.3874852625497, 33.39333964672257)); routeCoordinates.add(Point.fromLngLat(-118.38686605540683, 33.39387816940854)); routeCoordinates.add(Point.fromLngLat(-118.38607484627983, 33.39396792286514)); routeCoordinates.add(Point.fromLngLat(-118.38519763616081, 33.39346171215717)); routeCoordinates.add(Point.fromLngLat(-118.38523203655761, 33.393196040109466)); routeCoordinates.add(Point.fromLngLat(-118.3849955338295, 33.393023711860515)); routeCoordinates.add(Point.fromLngLat(-118.38355931726203, 33.39339708930139)); routeCoordinates.add(Point.fromLngLat(-118.38323251349217, 33.39305243325907)); routeCoordinates.add(Point.fromLngLat(-118.3832583137898, 33.39244928189641)); routeCoordinates.add(Point.fromLngLat(-118.3848751324406, 33.39108499551671)); routeCoordinates.add(Point.fromLngLat(-118.38522773650804, 33.38926830725471)); routeCoordinates.add(Point.fromLngLat(-118.38508153482152, 33.38916777794189)); routeCoordinates.add(Point.fromLngLat(-118.38390332123025, 33.39012280171983)); routeCoordinates.add(Point.fromLngLat(-118.38318091289693, 33.38941192035707)); routeCoordinates.add(Point.fromLngLat(-118.38271650753981, 33.3896129783018)); routeCoordinates.add(Point.fromLngLat(-118.38275090793661, 33.38902416443619)); routeCoordinates.add(Point.fromLngLat(-118.38226930238106, 33.3889451769069)); routeCoordinates.add(Point.fromLngLat(-118.38258750605169, 33.388420985121336)); routeCoordinates.add(Point.fromLngLat(-118.38177049662707, 33.388083490107284)); routeCoordinates.add(Point.fromLngLat(-118.38080728551597, 33.38836353925403)); routeCoordinates.add(Point.fromLngLat(-118.37928506795642, 33.38717870977523)); routeCoordinates.add(Point.fromLngLat(-118.37898406448423, 33.3873079646849)); routeCoordinates.add(Point.fromLngLat(-118.37935386875012, 33.38816247841951)); routeCoordinates.add(Point.fromLngLat(-118.37794345248027, 33.387810620840135)); routeCoordinates.add(Point.fromLngLat(-118.37546662390886, 33.38847843095069)); routeCoordinates.add(Point.fromLngLat(-118.37091717142867, 33.39114243958559)); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Create a line layer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Tutorials,Find a step-by-step guide to help you get started or take your project to the next level.,https://docs.mapbox.com/help/tutorials/,,,,"Tutorials Find a step-by-step guide to help you get started or take your project to the next level. Access tokens intermediate cURL Creating access tokens with the Tokens API Walk through creating permanent and temporary access tokens using the Tokens API. Analysis intermediate JavaScript Analyze data with Turf.js and Mapbox.js Using Turf.js, you can add some spatial analysis to your map to solve problems. This guide walks through an example of Turf.js and Mapbox.js in a real-world context. intermediate JavaScript Analyze data with Turf.js and Mapbox GL JS Using Turf.js, add spatial analysis to our map to solve problems. This guide walks through an example of Turf.js and Mapbox GL JS in a real-world context. advanced JavaScript Processing satellite imagery Learn how to find satellite raster data, process it using the Rasterio command-line tool, and publish it on a webpage. Data intermediate JavaScript Create a timezone finder with Mapbox Tilequery API Create a timezone finder app with Mapbox Tilequery API. beginner No code Customize label text for a single label Use expressions in Mapbox Studio to alter a single label. advanced JavaScript Data-joins with Mapbox Boundaries Join data with v2 of the Mapbox Boundaries tileset. advanced No code Extend Mapbox Boundaries Extend the Mapbox Boundaries tileset. intermediate JavaScript Find elevations with the Tilequery API Use the Mapbox Tilequery API and the Mapbox Terrain tileset to create an app that returns the elevation at a specified coordinate. intermediate No code Get started with Mapbox Boundaries v1 Get started with v1 of the Mapbox Boundaries tileset. intermediate No code Get started with Mapbox Boundaries Get started with v2 of the Mapbox Boundaries tileset. intermediate JavaScript Make a heatmap with Mapbox GL JS Add custom HTML markers, style them, and add tooltips with Mapbox GL JS. intermediate No code Add OpenStreetMap data to your Mapbox project Learn how to export OpenStreetMap data to be used in your Mapbox project. intermediate JavaScript Point-in-polygon query with Mapbox Boundaries Query data in v2 of the Mapbox Boundaries tileset. intermediate JavaScript Make a healthy food finder with the Tilequery API Create a web app that uses the Mapbox Tilequery API in concert with the Mapbox Geocoding API to show all stores that sell food that are located within one mile of a query point. Datasets beginner No code Add points to a web map, Part 1: create a dataset Create a new dataset containing points. Directions advanced Java Build a navigation app for Android Integrate navigation into any Android application. intermediate JavaScript Get started with the Map Matching API Create a web app that uses the Mapbox Map Matching API to allow users to specify their own driving route. beginner JavaScript Getting started with the Mapbox Directions API Add routing capabilities to your application with the Mapbox Directions API. advanced Swift, Objective-C Build a navigation app for iOS Integrate navigation into any iOS application. advanced JavaScript Generate an optimized route Use the Mapbox Optimization API to generate a duration-optimized route between several points. Geocoding beginner No code Add points to a web map, Part 1: create a dataset Create a new dataset containing points. advanced JavaScript Sort stores by distance This guide walks you through all the code that you need to build a store locator which lets you search for the nearest location. intermediate JavaScript Local search with the Geocoding API This tutorial guides you through the process of creating a local search app using optional parameters from the Mapbox Geocoding API. intermediate JavaScript Make a healthy food finder with the Tilequery API Create a web app that uses the Mapbox Tilequery API in concert with the Mapbox Geocoding API to show all stores that sell food that are located within one mile of a query point. Map design beginner No code Add 3D buildings to a Mapbox Studio style Add a 3D building layer to a map style in Mapbox Studio. beginner No code Add points to a web map, part 2: create a style Add a tileset to a template style and upload custom icons in Mapbox Studio. beginner No code Make a choropleth map, part 1: create a style Upload custom data to Mapbox Studio, add it to a template style, and use filters to style your data. intermediate JavaScript Make a choropleth map, part 2: add interactivity Publish your style with Mapbox GL JS, create a legend, and add interactive elements. beginner No code Create a custom style Alter a template style to create a custom map style. beginner No code Customize label text for a single label Use expressions in Mapbox Studio to alter a single label. advanced Varies Build indoor floorplans with Mapbox Upload a floorplan to create an indoor map. intermediate JavaScript Make a heatmap with Mapbox GL JS Add custom HTML markers, style them, and add tooltips with Mapbox GL JS. intermediate JavaScript Get started with Mapbox GL JS expressions Learn how to write expressions in Mapbox GL JS. beginner No code Make a heatmap with Mapbox Studio Learn how to add and configure a heatmap layer using Mapbox Studio. beginner No code Style a single country Find and upload open source data to style in Mapbox Studio. Mobile apps intermediate Java Data-driven styling for Android Create a map for Android that styles a circle based on a data attribute. intermediate Java Tracking device location for Android Display a Mapbox map on an Android device and receive updates on the device's current location. advanced Java Build a navigation app for Android Integrate navigation into any Android application. intermediate Java Runtime styling for Android Change various properties of a map based on user interaction and other ""runtime"" situations. advanced Java Build a store locator for Android Build a store locator to integrate into an Android application. beginner Java First steps with the Mapbox Maps SDK for Android Walk through installing the Mapbox Maps SDK for Android, getting a map on the screen, and changing the map style. beginner Swift, Objective-C First steps with the Mapbox Maps SDK for iOS Walk through installing the Mapbox Maps SDK for iOS, getting a map on the screen, and placing a pin on it. intermediate Swift, Objective-C Get started with expressions using the Mapbox Maps SDK for iOS Create a map for iOS that styles a circle based on a data attribute. advanced Swift, Objective-C Build a navigation app for iOS Integrate navigation into any iOS application. advanced Swift, Objective-C Build a store locator for iOS Build a store locator that can be integrated into any iOS application. Navigation intermediate JavaScript Get started with the Isochrone API Create a web app using the Mapbox Isochrone API that allows users to visualize how far they could walk, bike, or drive within a given amount of time. intermediate JavaScript Get started with the Map Matching API Create a web app that uses the Mapbox Map Matching API to allow users to specify their own driving route. Satellite advanced No code Georeference imagery Take your non-georeferenced aerial image or historical map and get it onto a Mapbox map with the help of QGIS. advanced JavaScript Processing satellite imagery Learn how to find satellite raster data, process it using the Rasterio command-line tool, and publish it on a webpage. Third party integration intermediate No code Add a Mapbox Studio style as a basemap in ArcGIS Online Add your map as a basemap to ArcGIS Online. beginner No code Add a Mapbox style to a CARTO map Add your map as a basemap to CARTO. advanced No code Georeference imagery Take your non-georeferenced aerial image or historical map and get it onto a Mapbox map with the help of QGIS. advanced Varies Build indoor floorplans with Mapbox Upload a floorplan to create an indoor map. intermediate No code Add Mapbox maps as layers in ArcGIS and QGIS with WMTS Learn how to add Mapbox maps as layers in ArcGIS and QGIS with WMTS. beginner No code Prototype apps with Mapbox in Framer X Learn how to use the Mapbox component to add a map to a prototype in Framer X. intermediate JavaScript Use Mapbox with OpenLayers Learn how to use Mapbox with OpenLayers. intermediate No code Make a choropleth map with the Mapbox Visual for Power BI Create a choropleth data map with the Mapbox Visual for Microsoft Power BI. intermediate No code Create data visualizations with the Mapbox Visual for Power BI Use Microsoft Power BI to create a custom data visualization. Unity beginner No code Create a map in Unity Use the Mapbox Maps SDK for Unity to create a visualization of 3D buildings on top of a 3D terrain map for use in a Unity application. intermediate No code Custom map styles in Unity Use a custom map style from Mapbox Studio in a Unity application. Uploads beginner No code Add points to a web map, Part 1: create a dataset Create a new dataset containing points. beginner No code Add points to a web map, part 2: create a style Add a tileset to a template style and upload custom icons in Mapbox Studio. beginner No code Make a choropleth map, part 1: create a style Upload custom data to Mapbox Studio, add it to a template style, and use filters to style your data. intermediate JavaScript Make a choropleth map, part 2: add interactivity Publish your style with Mapbox GL JS, create a legend, and add interactive elements. advanced No code Georeference imagery Take your non-georeferenced aerial image or historical map and get it onto a Mapbox map with the help of QGIS. advanced Command line Get started using the Tilesets API and the Tilesets CLI This feature is in beta. Learn how to use the Tilesets CLI, a tool for accessing the Mapbox Tilesets API, to create new Mapbox tilesets. advanced Varies Build indoor floorplans with Mapbox Upload a floorplan to create an indoor map. intermediate No code Add OpenStreetMap data to your Mapbox project Learn how to export OpenStreetMap data to be used in your Mapbox project. beginner No code Style a single country Find and upload open source data to style in Mapbox Studio. advanced cURL Upload to Mapbox using cURL Learn how to use the Mapbox Uploads API. Web apps beginner JavaScript Add points to a web map, part 3: add interactivity Add popups when markers are clicked using Mapbox GL JS. intermediate JavaScript Analyze data with Turf.js and Mapbox.js Using Turf.js, you can add some spatial analysis to your map to solve problems. This guide walks through an example of Turf.js and Mapbox.js in a real-world context. intermediate JavaScript Analyze data with Turf.js and Mapbox GL JS Using Turf.js, add spatial analysis to our map to solve problems. This guide walks through an example of Turf.js and Mapbox GL JS in a real-world context. advanced JavaScript Build a store locator using Mapbox.js Build a map application with Mapbox.js. This guide walks you through all the code that you need to build a store locator. advanced JavaScript Build a store locator using Mapbox GL JS Build a map application with Mapbox GL JS. This guide walks you through all the code that you need to build a store locator. beginner No code Make a choropleth map, part 1: create a style Upload custom data to Mapbox Studio, add it to a template style, and use filters to style your data. intermediate JavaScript Make a choropleth map, part 2: add interactivity Publish your style with Mapbox GL JS, create a legend, and add interactive elements. intermediate JavaScript Create a timezone finder with Mapbox Tilequery API Create a timezone finder app with Mapbox Tilequery API. intermediate JavaScript Create interactive hover effects with Mapbox GL JS Use feature state and expressions with Mapbox GL JS to dynamically style individual features in a map that shows earthquakes from the past week. intermediate JavaScript Add custom markers in Mapbox GL JS Add custom HTML markers, style them, and add tooltips with Mapbox GL JS. intermediate JavaScript Extend with Mapbox.js Meet Mapbox.js - the toolset for creating interactions and greater customization of your map and data. intermediate JavaScript Find elevations with the Tilequery API Use the Mapbox Tilequery API and the Mapbox Terrain tileset to create an app that returns the elevation at a specified coordinate. advanced JavaScript Sort stores by distance This guide walks you through all the code that you need to build a store locator which lets you search for the nearest location. intermediate JavaScript Get started with the Isochrone API Create a web app using the Mapbox Isochrone API that allows users to visualize how far they could walk, bike, or drive within a given amount of time. intermediate JavaScript Get started with the Map Matching API Create a web app that uses the Mapbox Map Matching API to allow users to specify their own driving route. intermediate JavaScript Switch from Google Maps to Mapbox Are you using the Google Maps API? This guide walks you through how to convert a Google web map to a Mapbox web map using Mapbox GL JS. intermediate JavaScript Local search with the Geocoding API This tutorial guides you through the process of creating a local search app using optional parameters from the Mapbox Geocoding API. intermediate JavaScript Make a heatmap with Mapbox GL JS Add custom HTML markers, style them, and add tooltips with Mapbox GL JS. intermediate JavaScript Get started with Mapbox GL JS expressions Learn how to write expressions in Mapbox GL JS. beginner Varies Add custom icons or markers You can add markers, style them, and add tooltips dynamically with Mapbox GL JS. This overview samples all the ways to add custom, interactive markers. intermediate JavaScript Work with markers in Mapbox.js Add custom, interactive markers to your map with Mapbox.js. advanced JavaScript Generate an optimized route Use the Mapbox Optimization API to generate a duration-optimized route between several points. advanced JavaScript Show changes over time with Mapbox GL JS Build a map application with Mapbox GL JS to visualize changes in data over time. beginner No code Make a heatmap with Mapbox Studio Learn how to add and configure a heatmap layer using Mapbox Studio. intermediate JavaScript Make a healthy food finder with the Tilequery API Create a web app that uses the Mapbox Tilequery API in concert with the Mapbox Geocoding API to show all stores that sell food that are located within one mile of a query point.",Access tokens,Analysis,Data,Datasets,Directions,Geocoding,Map design,Mobile apps,Navigation,Satellite,Third party integration,Unity,Uploads,Web apps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Create hotspots from points,Use the Mapbox Maps SDK to visualize point data as hotspots.,https://docs.mapbox.com/android/maps/examples/create-hotspots-from-points/,example,Java,,"Create hotspots from points Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.dds.CreateHotspotsActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.66995747013945"" mapbox:mapbox_cameraTargetLng=""-103.59179687498357"" mapbox:mapbox_cameraZoom=""3""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.Bundle; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonOptions; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.net.URI; import java.net.URISyntaxException; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.toNumber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleBlur; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; /** * Use Mapbox GL clustering to visualize point data as hotspots. */ public class CreateHotspotsActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_create_hotspots_points); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { addClusteredGeoJsonSource(style); } }); } }); } private void addClusteredGeoJsonSource(@NonNull Style loadedMapStyle) { // Add a new source from our GeoJSON data and set the 'cluster' option to true. try { loadedMapStyle.addSource( // Point to GeoJSON data. This example visualizes all M1.0+ earthquakes from // 12/22/15 to 1/21/16 as logged by USGS' Earthquake hazards program. new GeoJsonSource(""earthquakes"", new URI(""https://www.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson""), new GeoJsonOptions() .withCluster(true) .withClusterMaxZoom(15) // Max zoom to cluster points on .withClusterRadius(20) // Use small cluster radius for the hotspots look ) ); } catch (URISyntaxException uriSyntaxException) { Timber.e(""Check the URL %s"", uriSyntaxException.getMessage()); } // Use the earthquakes source to create four layers: // three for each cluster category, and one for unclustered points // Each point range gets a different fill color. final int[][] layers = new int[][] { new int[] {150, Color.parseColor(""#E55E5E"")}, new int[] {20, Color.parseColor(""#F9886C"")}, new int[] {0, Color.parseColor(""#FBB03B"")} }; CircleLayer unclustered = new CircleLayer(""unclustered-points"", ""earthquakes""); unclustered.setProperties( circleColor(Color.parseColor(""#FBB03B"")), circleRadius(20f), circleBlur(1f)); unclustered.setFilter(Expression.neq(get(""cluster""), literal(true))); loadedMapStyle.addLayerBelow(unclustered, ""building""); for (int i = 0; i < layers.length; i++) { CircleLayer circles = new CircleLayer(""cluster-"" + i, ""earthquakes""); circles.setProperties( circleColor(layers[i][1]), circleRadius(70f), circleBlur(1f) ); Expression pointCount = toNumber(get(""point_count"")); circles.setFilter( i == 0 ? Expression.gte(pointCount, literal(layers[i][0])) : Expression.all( Expression.gte(pointCount, literal(layers[i][0])), Expression.lt(pointCount, literal(layers[i - 1][0])) ) ); loadedMapStyle.addLayerBelow(circles, ""building""); } } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Create hotspots from points,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Generate and add a missing icon to the map,Dynamically generate a missing icon at runtime and add it to the map.,https://docs.mapbox.com/mapbox-gl-js/example/add-image-missing-generated/,example,JavaScript,,Generate and add a missing icon to the map Dynamically generate a missing icon at runtime and add it to the map. Was this example helpful? Yes No,Generate and add a missing icon to the map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Matrix,Official documentation on the Mapbox Java SDK Matrix API.,https://docs.mapbox.com/android/java/overview/directions-matrix/,guide,Java,Kotlin,"Matrix The Mapbox Matrix API returns all travel times and distances between multiple locations. The Matrix API will always return the duration and distance of the fastest route between the locations. Durations between locations may not be symmetric (for example A to B may have a different duration than B to A), as the routes may differ by direction due to one-way streets or turn restrictions. The Matrix API returns durations in seconds and distances in meters. It does not return route geometries. Make sure to have a look at the Matrix API documentation if you want more information. This API allows you to build tools that efficiently check the reachability of coordinates from each other, filter locations by travel time, or run your own algorithms for solving optimization problems. The standard limit for request are a maximum 60 requests per minute and maximum 25 input coordinates. For example you can request a symmetric 25x25 matrix, an asymmetric 1x24 matrix with distinct coordinates or a 12x24 where sources and destinations share some coordinates. For higher volumes contact us. Before using this wrapper: Read the Mapbox Matrix API documentation. The API documentation contains all available parameters including some that are not listed in this guide. Make sure you have included the correct permissions inside of your AndroidManifest.xml file if you plan to use this API inside of an Android application. API request Before requesting and receiving the Matrix response, you'll need to use the MapboxMatrix builder to set the request parameters. The request passes in a List of Point objects, sets the directions profile, and provides an access token. Java Kotlin MapboxMatrix matrixApiClient = MapboxMatrix.builder() .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .profile(DirectionsCriteria.PROFILE_DRIVING) .coordinates(listOfCoordinates) .build(); Copy API response Like all API calls inside of the Mapbox Java SDK, the response will come inside a Retrofit callback. Inside onResponse(), you can access the API's returned response if successful. Java Kotlin client.enqueueCall(new Callback<MatrixResponse>() { @Override public void onResponse(Call<MatrixResponse> call, Response<MatrixResponse> response) { } } @Override public void onFailure(Call<MatrixResponse> call, Throwable throwable) { } }); Copy Was this page helpful? Yes No",Matrix,API request,API response,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Tokens API,"The Mapbox Tokens API allows you to create, edit, and delete access tokens.",https://docs.mapbox.com/help/glossary/tokens-api/,glossary,,,"Tokens API The Mapbox Tokens API allows you to create, edit, and delete access tokens. A sample Tokens API request to list your access tokens looks like: https://api.mapbox.com/tokens/v2/ { username } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN Related resources: Tokens API documentation How Mapbox works: Access tokens Creating access tokens with the Tokens API tutorial Was this page helpful? Yes No",Tokens API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Styling heatmaps,Gain minute control over heatmap coloring.,https://docs.mapbox.com/android/maps/examples/add-multiple-heatmap-styles/,example,Java,,"Styling heatmaps Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/switch_heatmap_style_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom|right"" android:layout_marginBottom=""16dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" app:layout_constraintBottom_toBottomOf=""parent"" app:layout_constraintEnd_toEndOf=""parent"" app:srcCompat=""@drawable/ic_swap_horiz_white_24dp"" mapbox:fabSize=""normal"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.HeatmapLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.io.InputStream; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.heatmapDensity; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.linear; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgba; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.heatmapColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.heatmapIntensity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.heatmapOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.heatmapRadius; public class MultipleHeatmapStylingActivity extends AppCompatActivity implements OnMapReadyCallback { private static final String HEATMAP_SOURCE_ID = ""HEATMAP_SOURCE_ID""; private static final String HEATMAP_LAYER_ID = ""HEATMAP_LAYER_ID""; private MapView mapView; private MapboxMap mapboxMap; private Expression[] listOfHeatmapColors; private Expression[] listOfHeatmapRadiusStops; private Float[] listOfHeatmapIntensityStops; private int index; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); index = 0; // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_multiple_heatmap_styling); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { MultipleHeatmapStylingActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { CameraPosition cameraPositionForFragmentMap = new CameraPosition.Builder() .target(new LatLng(34.056684, -118.254002)) .zoom(11.047) .build(); mapboxMap.animateCamera( CameraUpdateFactory.newCameraPosition(cameraPositionForFragmentMap), 2600); style.addSource(new GeoJsonSource(HEATMAP_SOURCE_ID, loadGeoJsonFromAsset(""la_heatmap_styling_points.geojson""))); initHeatmapColors(); initHeatmapRadiusStops(); initHeatmapIntensityStops(); addHeatmapLayer(style); findViewById(R.id.switch_heatmap_style_fab).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { index++; if (index == listOfHeatmapColors.length - 1) { index = 0; } if (style.getLayer(HEATMAP_LAYER_ID) != null) { style.getLayer(HEATMAP_LAYER_ID).setProperties( heatmapColor(listOfHeatmapColors[index]), heatmapRadius(listOfHeatmapRadiusStops[index]), heatmapIntensity(listOfHeatmapIntensityStops[index]) ); } } }); } }); } private void addHeatmapLayer(@NonNull Style loadedMapStyle) { // Create the heatmap layer HeatmapLayer layer = new HeatmapLayer(HEATMAP_LAYER_ID, HEATMAP_SOURCE_ID); // Heatmap layer disappears at whatever zoom level is set as the maximum layer.setMaxZoom(18); layer.setProperties( // Color ramp for heatmap. Domain is 0 (low) to 1 (high). // Begin color ramp at 0-stop with a 0-transparency color to create a blur-like effect. heatmapColor(listOfHeatmapColors[index]), // Increase the heatmap color weight weight by zoom level // heatmap-intensity is a multiplier on top of heatmap-weight heatmapIntensity(listOfHeatmapIntensityStops[index]), // Adjust the heatmap radius by zoom level heatmapRadius(listOfHeatmapRadiusStops[index] ), heatmapOpacity(1f) ); // Add the heatmap layer to the map and above the ""water-label"" layer loadedMapStyle.addLayerAbove(layer, ""waterway-label""); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } private void initHeatmapColors() { listOfHeatmapColors = new Expression[] { // 0 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.01), literal(0.25), rgba(224, 176, 63, 0.5), literal(0.5), rgb(247, 252, 84), literal(0.75), rgb(186, 59, 30), literal(0.9), rgb(255, 0, 0) ), // 1 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(255, 255, 255, 0.4), literal(0.25), rgba(4, 179, 183, 1.0), literal(0.5), rgba(204, 211, 61, 1.0), literal(0.75), rgba(252, 167, 55, 1.0), literal(1), rgba(255, 78, 70, 1.0) ), // 2 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(12, 182, 253, 0.0), literal(0.25), rgba(87, 17, 229, 0.5), literal(0.5), rgba(255, 0, 0, 1.0), literal(0.75), rgba(229, 134, 15, 0.5), literal(1), rgba(230, 255, 55, 0.6) ), // 3 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(135, 255, 135, 0.2), literal(0.5), rgba(255, 99, 0, 0.5), literal(1), rgba(47, 21, 197, 0.2) ), // 4 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(4, 0, 0, 0.2), literal(0.25), rgba(229, 12, 1, 1.0), literal(0.30), rgba(244, 114, 1, 1.0), literal(0.40), rgba(255, 205, 12, 1.0), literal(0.50), rgba(255, 229, 121, 1.0), literal(1), rgba(255, 253, 244, 1.0) ), // 5 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.01), literal(0.05), rgba(0, 0, 0, 0.05), literal(0.4), rgba(254, 142, 2, 0.7), literal(0.5), rgba(255, 165, 5, 0.8), literal(0.8), rgba(255, 187, 4, 0.9), literal(0.95), rgba(255, 228, 173, 0.8), literal(1), rgba(255, 253, 244, .8) ), //6 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.01), literal(0.3), rgba(82, 72, 151, 0.4), literal(0.4), rgba(138, 202, 160, 1.0), literal(0.5), rgba(246, 139, 76, 0.9), literal(0.9), rgba(252, 246, 182, 0.8), literal(1), rgba(255, 255, 255, 0.8) ), //7 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.01), literal(0.1), rgba(0, 2, 114, .1), literal(0.2), rgba(0, 6, 219, .15), literal(0.3), rgba(0, 74, 255, .2), literal(0.4), rgba(0, 202, 255, .25), literal(0.5), rgba(73, 255, 154, .3), literal(0.6), rgba(171, 255, 59, .35), literal(0.7), rgba(255, 197, 3, .4), literal(0.8), rgba(255, 82, 1, 0.7), literal(0.9), rgba(196, 0, 1, 0.8), literal(0.95), rgba(121, 0, 0, 0.8) ), // 8 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.01), literal(0.1), rgba(0, 2, 114, .1), literal(0.2), rgba(0, 6, 219, .15), literal(0.3), rgba(0, 74, 255, .2), literal(0.4), rgba(0, 202, 255, .25), literal(0.5), rgba(73, 255, 154, .3), literal(0.6), rgba(171, 255, 59, .35), literal(0.7), rgba(255, 197, 3, .4), literal(0.8), rgba(255, 82, 1, 0.7), literal(0.9), rgba(196, 0, 1, 0.8), literal(0.95), rgba(121, 0, 0, 0.8) ), // 9 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.01), literal(0.1), rgba(0, 2, 114, .1), literal(0.2), rgba(0, 6, 219, .15), literal(0.3), rgba(0, 74, 255, .2), literal(0.4), rgba(0, 202, 255, .25), literal(0.5), rgba(73, 255, 154, .3), literal(0.6), rgba(171, 255, 59, .35), literal(0.7), rgba(255, 197, 3, .4), literal(0.8), rgba(255, 82, 1, 0.7), literal(0.9), rgba(196, 0, 1, 0.8), literal(0.95), rgba(121, 0, 0, 0.8) ), // 10 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.01), literal(0.1), rgba(0, 2, 114, .1), literal(0.2), rgba(0, 6, 219, .15), literal(0.3), rgba(0, 74, 255, .2), literal(0.4), rgba(0, 202, 255, .25), literal(0.5), rgba(73, 255, 154, .3), literal(0.6), rgba(171, 255, 59, .35), literal(0.7), rgba(255, 197, 3, .4), literal(0.8), rgba(255, 82, 1, 0.7), literal(0.9), rgba(196, 0, 1, 0.8), literal(0.95), rgba(121, 0, 0, 0.8) ), // 11 interpolate( linear(), heatmapDensity(), literal(0.01), rgba(0, 0, 0, 0.25), literal(0.25), rgba(229, 12, 1, .7), literal(0.30), rgba(244, 114, 1, .7), literal(0.40), rgba(255, 205, 12, .7), literal(0.50), rgba(255, 229, 121, .8), literal(1), rgba(255, 253, 244, .8) ) }; } private void initHeatmapRadiusStops() { listOfHeatmapRadiusStops = new Expression[] { // 0 interpolate( linear(), zoom(), literal(6), literal(50), literal(20), literal(100) ), // 1 interpolate( linear(), zoom(), literal(12), literal(70), literal(20), literal(100) ), // 2 interpolate( linear(), zoom(), literal(1), literal(7), literal(5), literal(50) ), // 3 interpolate( linear(), zoom(), literal(1), literal(7), literal(5), literal(50) ), // 4 interpolate( linear(), zoom(), literal(1), literal(7), literal(5), literal(50) ), // 5 interpolate( linear(), zoom(), literal(1), literal(7), literal(15), literal(200) ), // 6 interpolate( linear(), zoom(), literal(1), literal(10), literal(8), literal(70) ), // 7 interpolate( linear(), zoom(), literal(1), literal(10), literal(8), literal(200) ), // 8 interpolate( linear(), zoom(), literal(1), literal(10), literal(8), literal(200) ), // 9 interpolate( linear(), zoom(), literal(1), literal(10), literal(8), literal(200) ), // 10 interpolate( linear(), zoom(), literal(1), literal(10), literal(8), literal(200) ), // 11 interpolate( linear(), zoom(), literal(1), literal(10), literal(8), literal(200) ), }; } private void initHeatmapIntensityStops() { listOfHeatmapIntensityStops = new Float[] { // 0 0.6f, // 1 0.3f, // 2 1f, // 3 1f, // 4 1f, // 5 1f, // 6 1.5f, // 7 0.8f, // 8 0.25f, // 9 0.8f, // 10 0.25f, // 11 0.5f }; } private String loadGeoJsonFromAsset(String filename) { try { // Load GeoJSON file InputStream is = getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (Exception exception) { Timber.e(""Exception loading GeoJSON: %s"", exception.toString()); exception.printStackTrace(); return null; } } } Copy Was this page helpful? Yes No",Styling heatmaps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for iOS,iOS,AR navigation,Introduction to Mapbox Vision AR for iOS.,https://docs.mapbox.com/ios/vision/overview/ar/,guide,,,"AR navigation Mapbox Vision AR for iOS is a high-level framework that sits on top of the Mapbox Vision SDK for iOS. Vision AR manages the navigation route, translates it to the core library, and renders an AR navigation route on top of the live video stream from the device’s built-in camera. Integration with other Mapbox tools Vision AR is intended to be used with the Mapbox Navigation SDK. Vision AR sits on top of the Vision SDK for iOS and next to the Mapbox Directions API and Mapbox Core Navigation. Route line To project a route line on the road, start by generating the route. Use MapboxDirections.swift to create a new Route object, which you can use to display a route on a map or start a navigation sequence.. In most cases, you'll also use the NavigationRouteOptions class (a subclass of MapboxDirections.swift's RouteOptions class) to set a few options. Read more about route generation in the Navigation SDK documentation. Then, create a VisionARManager and set the route to the route you generated. visionARManager = VisionARManager.create(visionManager: visionManager, delegate: self) let origin = CLLocationCoordinate2D() let destination = CLLocationCoordinate2D() let options = NavigationRouteOptions(coordinates: [origin, destination], profileIdentifier: .automobile) // query a navigation route between location coordinates and pass it to VisionARManager Directions.shared.calculate(options) { [weak self] (waypoints, routes, error) in guard let route = routes?.first else { return } self?.visionARManager.set(route: Route(route: route)) } See the full example code in the Basic blue-line AR navigation example. Related resources Basic blue-line AR navigation code example Vision AR for iOS reference documentation Was this page helpful? Yes No",AR navigation,Route line,Related resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Update a feature in realtime,Change an existing feature on your map in realtime by updating its data.,https://docs.mapbox.com/mapbox-gl-js/example/live-update-feature/,example,JavaScript,,Update a feature in realtime Change an existing feature on your map in realtime by updating its data. Was this example helpful? Yes No,Update a feature in realtime,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add multiple geometries from one GeoJSON source,Add a polygon and circle layer from the same GeoJSON source.,https://docs.mapbox.com/mapbox-gl-js/example/multiple-geometries/,example,JavaScript,,Add multiple geometries from one GeoJSON source Add a polygon and circle layer from the same GeoJSON source. Was this example helpful? Yes No,Add multiple geometries from one GeoJSON source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Support map fragment,Include a map fragment within your app using Android support library.,https://docs.mapbox.com/android/maps/examples/support-map-fragment/,example,Java,,"Support map fragment Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:background=""@color/md_divider_white"" tools:context="".examples.basics.SupportMapFragmentActivity""> <TextView android:id=""@+id/fragment_below_textview"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_marginTop=""8dp"" android:gravity=""center_horizontal"" android:text=""@string/fragment_in_card_below""/> <androidx.cardview.widget.CardView android:id=""@+id/cardview"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_below=""@id/fragment_below_textview"" android:layout_marginBottom=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginStart=""8dp"" android:layout_marginTop=""8dp"" app:cardCornerRadius=""2dp"" app:cardElevation=""@dimen/cardview_default_elevation""> <FrameLayout android:id=""@+id/container"" android:layout_width=""match_parent"" android:layout_height=""match_parent""/> </androidx.cardview.widget.CardView> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.basics; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.fragment.app.FragmentTransaction; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.MapboxMapOptions; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.maps.SupportMapFragment; /** * Include a map fragment within your app using Android support library. */ public class SupportMapFragmentActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_basic_support_map_frag); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // Create supportMapFragment SupportMapFragment mapFragment; if (savedInstanceState == null) { // Create fragment final FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Build mapboxMap MapboxMapOptions options = MapboxMapOptions.createFromAttributes(this, null); options.camera(new CameraPosition.Builder() .target(new LatLng(-52.6885, -70.1395)) .zoom(9) .build()); // Create map fragment mapFragment = SupportMapFragment.newInstance(options); // Add map fragment to parent container transaction.add(R.id.container, mapFragment, ""com.mapbox.map""); transaction.commit(); } else { mapFragment = (SupportMapFragment) getSupportFragmentManager().findFragmentByTag(""com.mapbox.map""); } mapFragment.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.SATELLITE, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Map is set up and the style has loaded. Now you can add data or make other map adjustments } }); } }); } } Copy Was this page helpful? Yes No",Support map fragment,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Styling the map,Learn how to use the Mapbox Maps SDK for Android to change your map style to a custom style or a pre-made style made by the talented Mapbox cartography team.,https://docs.mapbox.com/android/maps/overview/styling-map/,guide,Java,Kotlin,"Styling the map The Maps SDK for Android allows full customization of the look of the map. You can choose one of Mapbox's core styles designed by our cartographers or create a custom map style by adjusting the map's colors, icons, and fonts to match your application's UI or company's brand. There are two approaches to customizing the look of the map: creating a custom map style with Mapbox Studio and loading it into your application or updating map features at runtime using the Maps SDK for Android. Using runtime styling, you're able to dynamically change the look and feel of your map in real time. Lighten or darken the map based on the time of day, personalize icons and map colors based on your users’ activity, switch languages dynamically, or increase the size of labels based on user preferences to improve legibility. Style object A Style object refers to the Mapbox map style being used in your application. Sources, layers, and images appear on the map via a map style, so they are added and retrieved via the Style object rather than adding them to the actual MapboxMap object. A Style object must be created and given to the map for the map to appear properly. Create a Style by using a: default Mapbox style found in the Style class constants custom map style URL from a Mapbox account raw style JSON string or referenced style JSON via asset:// or path:// If the style fails to load or you set an invalid style URL, the map view will become blank. An error message will be logged in the Android logcat and the MapView.OnDidFailLoadingMapListener callback will be triggered. Changing the map style You'll have to change the map style URL programmatically if you'd like to load a completely new map style. Call mapboxMap.setStyle() with the style URL as the parameter. Java Kotlin mapboxMap.setStyle(new Style.Builder().fromUri(uniqueStyleUrl), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Custom map style has been loaded and map is now ready } }); Copy Default Mapbox styles As powerful as styling the map can be, Mapbox offers six professionally designed map styles: Mapbox Streets: Mapbox Streets is a comprehensive, general-purpose map that emphasizes legible styling of road and transit networks. Outdoor: Mapbox Outdoors is a general-purpose map with curated datasets and specialized styling tailored to hiking, biking, and the most adventurous use cases. Light and Dark: Mapbox Light and Mapbox Dark are subtle, full-featured maps designed to provide geographic context while highlighting the data on your analytics dashboard, data visualization, or data overlay. Satellite: is our full global basemap that works as a blank canvas or an overlay for your own data. Satellite Streets: combines our Mapbox Satellite with vector data from Mapbox Streets. The comprehensive set of road, label, and POI information brings clarity and context to the crisp detail in our high-resolution satellite imagery. Traffic: Visually show realtime traffic using either the provided day or night traffic styles. The Maps SDK's Style class has private static final Strings of the default Mapbox styles' URLs, so that you can conveniently reference the styles when you have to pass the style URL through the setStyle() method or other methods in your project. For example: Java Kotlin mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Custom map style has been loaded and map is now ready } }); Copy Retrieving a map layer Retrieving a map layer is the first step to adjusting the visual look of the map in real time. Every map style has a stack of map layers and each layer has an id. In the professionally-designed Mapbox Streets style, layers in that style have ids such as landuse, settlement-label, natural-point-label, and building. Java Kotlin Layer singleLayer = mapboxMap.getStyle().getLayer(UNIQUE_LAYER_ID); Copy You can view the map style's layer Z-index order and layer ids in Mapbox Studio. Another way to view this information is by printing out each layer ID to your Android logcat once the map has been loaded on the device. Java Kotlin mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { for (Layer singleLayer : mapboxMap.getStyle().getLayers()) { Log.d(TAG, ""onMapReady: layer id = "" + singleLayer.getId()); } } }); } }); Copy Once you have an individual map layer, you can then use data-driven styling and expressions to adjust the layer's properties. For example, here's how you'd use runtime styling to change the water layer's blue color to a deeper blue color: Java Kotlin button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { mapboxMap.getStyle().getLayer(""water"").setProperties(PropertyFactory.fillColor(Color.parseColor(""#004f6b""))); } }); Copy Style-related events Changing the map's style triggers a ""map event"". Read the map change event documentation for more information about the events and how to display or re-display data on your map after a map style has finished loading. Was this page helpful? Yes No",Styling the map,Style object,Changing the map style,Default Mapbox styles,Retrieving a map layer,Style-related events,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,SymbolLayer clustering,Use GeoJSON and SymbolLayer icons to view clustered images.,https://docs.mapbox.com/android/maps/examples/symbol-layer-clustering/,example,Java,,"SymbolLayer clustering Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.dds.ImageClusteringActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""2.69719"" mapbox:mapbox_cameraTargetLng=""126.355705"" mapbox:mapbox_cameraZoom=""4.119118""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.Bundle; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonOptions; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import java.net.URI; import java.net.URISyntaxException; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.all; import static com.mapbox.mapboxsdk.style.expressions.Expression.division; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.gt; import static com.mapbox.mapboxsdk.style.expressions.Expression.gte; import static com.mapbox.mapboxsdk.style.expressions.Expression.has; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.lt; import static com.mapbox.mapboxsdk.style.expressions.Expression.toNumber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textField; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textSize; /** * Use GeoJson data with SymbolLayers to create a data clustering effect. */ public class ImageClusteringActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_image_clustering); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initLayerIcons(style); addClusteredGeoJsonSource(style); Toast.makeText(ImageClusteringActivity.this, R.string.zoom_map_in_and_out_instruction, Toast.LENGTH_SHORT).show(); } }); } private void initLayerIcons(@NonNull Style loadedMapStyle) { loadedMapStyle.addImage(""single-quake-icon-id"", BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.single_quake_icon))); loadedMapStyle.addImage(""quake-triangle-icon-id"", BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.earthquake_triangle))); } private void addClusteredGeoJsonSource(@NonNull Style loadedMapStyle) { // Add a new source from the GeoJSON data and set the 'cluster' option to true. try { loadedMapStyle.addSource( // Point to GeoJSON data. This example visualizes all M1.0+ earthquakes from // 12/22/15 to 1/21/16 as logged by USGS' Earthquake hazards program. new GeoJsonSource(""earthquakes"", new URI(""https://www.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson""), new GeoJsonOptions() .withCluster(true) .withClusterMaxZoom(14) .withClusterRadius(50) ) ); } catch (URISyntaxException uriSyntaxException) { Timber.e(""Check the URL %s"" , uriSyntaxException.getMessage()); } //Creating a SymbolLayer icon layer for single data/icon points loadedMapStyle.addLayer(new SymbolLayer(""unclustered-points"", ""earthquakes"").withProperties( iconImage(""single-quake-icon-id""), iconSize( division( get(""mag""), literal(4.0f) ) ) )); // Use the earthquakes GeoJSON source to create three point ranges. int[] layers = new int[] {150, 20, 0}; for (int i = 0; i < layers.length; i++) { //Add clusters' SymbolLayers images SymbolLayer symbolLayer = new SymbolLayer(""cluster-"" + i, ""earthquakes""); symbolLayer.setProperties( iconImage(""quake-triangle-icon-id"") ); Expression pointCount = toNumber(get(""point_count"")); // Add a filter to the cluster layer that hides the icons based on ""point_count"" symbolLayer.setFilter( i == 0 ? all(has(""point_count""), gte(pointCount, literal(layers[i])) ) : all(has(""point_count""), gt(pointCount, literal(layers[i])), lt(pointCount, literal(layers[i - 1])) ) ); loadedMapStyle.addLayer(symbolLayer); } //Add a SymbolLayer for the cluster data number point count loadedMapStyle.addLayer(new SymbolLayer(""count"", ""earthquakes"").withProperties( textField(Expression.toString(get(""point_count""))), textSize(12f), textColor(Color.BLACK), textIgnorePlacement(true), // The .5f offset moves the data numbers down a little bit so that they're // in the middle of the triangle cluster image textOffset(new Float[] {0f, .5f}), textAllowOverlap(true) )); } @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",SymbolLayer clustering,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Place picker,Use the place picker function of the Places Plugin to choose a specific location in the world.,https://docs.mapbox.com/android/plugins/examples/place-picker/,example,Java,,"Place picker Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <Button android:id=""@+id/go_to_picker_button"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""center"" android:visibility=""invisible"" android:text=""@string/go_to_picker_activity"" /> <TextView android:id=""@+id/selected_location_info_textview"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.content.Intent; import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; import com.mapbox.api.geocoding.v5.models.CarmenFeature; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.plugins.places.picker.PlacePicker; import com.mapbox.mapboxsdk.plugins.places.picker.model.PlacePickerOptions; /** * Use the place picker functionality inside of the Places Plugin, to show UI for * choosing a map location. Once selected, return to the previous location with a * CarmenFeature to extract information from for whatever use that you want. */ public class PlaceSelectionPluginActivity extends AppCompatActivity { private static final int REQUEST_CODE = 5678; private TextView selectedLocationTextView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_place_selection); selectedLocationTextView = findViewById(R.id.selected_location_info_textview); goToPickerActivity(); } /** * Set up the PlacePickerOptions and startActivityForResult */ private void goToPickerActivity() { startActivityForResult( new PlacePicker.IntentBuilder() .accessToken(getString(R.string.access_token)) .placeOptions(PlacePickerOptions.builder() .statingCameraPosition(new CameraPosition.Builder() .target(new LatLng(40.7544, -73.9862)).zoom(16).build()) .build()) .build(this), REQUEST_CODE); } /** * This fires after a location is selected in the Places Plugin's PlacePickerActivity. * @param requestCode code that is a part of the return to this activity * @param resultCode code that is a part of the return to this activity * @param data the data that is a part of the return to this activity */ @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_CANCELED) { // Show the button and set the OnClickListener() Button goToPickerActivityButton = findViewById(R.id.go_to_picker_button); goToPickerActivityButton.setVisibility(View.VISIBLE); goToPickerActivityButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { goToPickerActivity(); } }); } else if (requestCode == REQUEST_CODE && resultCode == RESULT_OK) { // Retrieve the information from the selected location's CarmenFeature CarmenFeature carmenFeature = PlacePicker.getPlace(data); // Set the TextView text to the entire CarmenFeature. The CarmenFeature // also be parsed through to grab and display certain information such as // its placeName, text, or coordinates. selectedLocationTextView.setText(String.format( getString(R.string.selected_place_info), carmenFeature.toJson())); } } } Copy Was this page helpful? Yes No",Place picker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Creating access tokens with the Tokens API,Walk through creating permanent and temporary access tokens using the Tokens API.,https://docs.mapbox.com/help/tutorials/get-started-tokens-api/,tutorial,cURL,,"intermediate cURL Creating access tokens with the Tokens API Prerequisite Familiarity with APIs and using the command line. This guide will walk through how to create permanent/public and temporary access tokens with the Tokens API using cURL. After reading this tutorial, you will be able to create appropriately scoped access tokens with the Tokens API using cURL. If you're unsure what an access token is or how to use one, read our access tokens guide and Tokens API documentation for more details. Getting started You will need a couple resources to get started: Mapbox account. Sign up for free at mapbox.com/signup. Experience using APIs and the command line with cURL. Decide on your token scopes Access tokens are keys that allow you to access Mapbox APIs. Every token has one or more token scopes that set the permissions for the token, allowing that access token to do a specific job and interact with specific APIs. For example, if you need to upload data with your new token, you’ll need to select uploads:write. Or, if you need your new token to be able to create more access tokens, select tokens:write. If you aren’t sure what scopes you need your new token to have, refer to our API documentation. Each section lists which scopes are necessary to interact with the specific Mapbox API. Note When you create a new token, some of the scope options are secret scopes. If you add one or more secret scopes to your new token, it will be a secret token. You can only view secret tokens once, at the time when you create them, so it's important to copy the new secret token and save it in a secure place. Create a token that can create tokens To create access tokens using the Tokens API, you’ll need to use a token with the tokens:write scope. You can create a new token with the tokens:write scope on your access tokens page. As an example, a token with the scopes uploads:read, uploads:list, uploads:write, and tokens:write would allow you to create tokens that can interact with the Mapbox Uploads API. Note Every requested scope must be present in the access token used to allow the request. It is not possible to create a token with access to more scopes than the token that created it. Now that you have a token with the tokens:write scope, you can use it to create new tokens using the Tokens API. Make the token using the command line Permanent/public tokens A permanent or public tokens are access tokens that only have public scopes. In your command line, you can create a permanent/public token by using this command: curl -H ""Content-Type: application/json"" -X POST -d ' { ""note"": "" { token_name } "",""scopes"": [""styles:read"", ""fonts:read""] } ' 'https://api.mapbox.com/tokens/v2/ YOUR_MAPBOX_USERNAME ?access_token= YOUR_MAPBOX_ACCESS_TOKEN ' For example, to create a token for interacting with the Uploads API, your command may look like this: curl -H ""Content-Type: application/json"" -X POST -d ' { ""note"": ""Uploads token"",""scopes"": [""styles:tiles"", ""styles:read"", ""fonts:read"", ""datasets:read"", ""uploads:read"", ""uploads:write"", ""uploads:list""] } ' 'https://api.mapbox.com/tokens/v2/ YOUR_MAPBOX_USERNAME ?access_token= YOUR_MAPBOX_ACCESS_TOKEN ' Your response will look something like this: { ""client"":""api"",""note"":""Uploads token"",""usage"":""sk"",""id"":""cjo6jcmxn0l3x3vqmdr4epqk8"",""default"":false,""scopes"":[""styles:tiles"",""styles:read"",""fonts:read"",""datasets:read"",""uploads:read"",""uploads:write"",""uploads:list""],""created"":""2018-11-07T02:19:53.538Z"",""modified"":""2018-11-07T02:19:53.538Z"",""token"":"" { new_access_token } "" } Navigate to your access tokens page to see the new token in your account! Temporary tokens Our Tokens API offers the ability to create temporary tokens which expire at a set time. Temporary tokens can be created using public, secret, or even other temporary tokens as long as the authenticating token is scoped correctly. Temporary tokens do not show in your access tokens page. To make temporary tokens, you will need to include expires and scopes parameters in your API call: expires: The expires parameter should be in Coordinated Universal Time (UTC) and specifies when the temporary token will expire. It cannot be a time in the past or more than one hour in the future. If the authorizing token is temporary, the expires time for the new temporary token cannot be later than that of the authorizing temporary token. scopes: The scopes parameter specifies which scopes that the new temporary token will have. The authorizing token needs to have the same scopes as, or more scopes than, the new temporary token you are creating. Creating temporary tokens In your command line, you can create a temporary token by using this command: curl -X POST -d ' { ""expires"": ""2018-11-18T06:30:00Z"",""scopes"": [""styles:read"", ""fonts:read"", ""uploads:read"", ""uploads:write"", ""uploads:list""] } ' 'https://api.mapbox.com/tokens/v2/ YOUR_MAPBOX_USERNAME ?access_token= YOUR_MAPBOX_ACCESS_TOKEN ' For example, to create a temporary token for interacting with the Uploads API, your command may look like this: curl -H ""Content-Type: application/json"" -X POST -d ' { ""note"": ""Uploads temp token"", ""expires"": ""2018-11-18T06:30:00Z"", ""scopes"": [""styles:tiles"", ""styles:read"", ""fonts:read"", ""datasets:read"", ""uploads:read"", ""uploads:write"", ""uploads:list""] } ' 'https://api.mapbox.com/tokens/v2/ YOUR_MAPBOX_USERNAME ?access_token= YOUR_MAPBOX_ACCESS_TOKEN ' Your response should look something like this: { ""token"": "" { new_temporary_token } "" } Finished product You have created an access token with the correct scopes using the Tokens API. Go to your access tokens page to find the new token. Next steps Now that you have a token, you can use it according to its scopes. Was this page helpful? Yes No",Creating access tokens with the Tokens API,Getting started,Decide on your token scopes,Create a token that can create tokens,Make the token using the command line,Permanent/public tokens,Temporary tokens,Creating temporary tokens,Finished product,Next steps,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Offline maps,Learn about how offline maps work.,https://docs.mapbox.com/help/troubleshooting/mobile-offline/,troubleshooting,,,"Offline maps Applications built with the Mapbox Maps SDK for Android or iOS can download maps of selected regions for use when the device lacks network connectivity. Offline maps are useful for apps whose users expect to travel through areas with limited data connectivity or who want to save on cellular roaming charges while traveling abroad. Requirements Before your application can download maps for use offline, the Mapbox Maps SDKs for iOS and Android need: A geographic bounding box or a geographic region. A zoom level range. A style URL (for example mapbox://styles/mapbox/light-v9). If the application provides each of the above requirements, the Mapbox Maps SDK for iOS or Android can request all the required resources from Mapbox's servers and will store them in a database on the device. Downloaded resources include: Style JSON. All fonts and icons associated with the style. TileJSON for all sources. Map tiles covering the geographic area of the offline regions. Ambient caching The Maps SDKs for iOS and Android also automatically cache tiles and other resources that are requested during normal use of the app. These resources are stored in the same database as offline resources, but unlike offline resources, they are limited to 50 MB of space. When this limit is reached, the least-recently used resources that aren't shared by an offline region will be evicted to make room for newer resources. Working with offline maps With the Maps SDKs for iOS and Android, you can create offline maps, access a list of offline maps stored on the device, and remove offline maps that are no longer needed. When managing your offline regions, remember: An offline region cannot be modified after creation, but it is possible to create a new region with a modified definition and remove the existing region. When you remove an offline region, resources that are shared with other offline regions will not be removed. For more information on working with offline maps, explore the documentation for the Mapbox Maps SDKs for Android and iOS. Note When adding symbol layers to an existing map with the Mapbox Maps SDKs for iOS and Android, you will need to take additional precautions for them to be visible offline: Font stacks for symbol layers added to a map that will be used offline must be explicitly defined to match a font stack already being used for a layer within the map. The font stacks listed must be in the same order of the existing layer's font stack and must not contain any additional fonts. Icon images for symbol layers added to a map that will be used offline must be explicitly defined to match an existing style image that is already being used within the style. If a symbol layer for a given source can't load, all related layers that reference the same source will also fail to load. By explicitly stating the font stacks and icon image names used within a dynamically added symbol layer, you will make sure that the symbol layer will be visible when the map is offline. Updating offline resources If the device has network connectivity, the Maps SDK for Android or iOS will make periodic network requests to revalidate cached tiles and other resources if the Cache-Control or Expires HTTP response headers have expired. If an updated resource is available, it will replace the older version in the offline database. When the SDK automatically updates offline map tiles, the offline region is not re-download from scratch. The offline tile update process is the same process as with regular map tiles: The map tile's only downloaded if there's a new version of that tile. Tile ceiling & limits An app can download multiple regions for offline use, but the total offline download is capped at a maximum tile count (or ""ceiling"") across all downloaded regions. The tile ceiling is 6,000 tiles. The total tile count in an offline region is the sum of the tiles downloaded from each source in your style. For example, if you would like to download a region covering 10 tiles and your style includes one vector tile source and one raster tile source (see sample JSON below), the resulting tile count would be 20. ""sources"": { ""mapbox-streets"": { ""url"": ""mapbox://mapbox.mapbox-streets-v7"", ""type"": ""vector"" } , ""mapbox-satellite"": { ""url"": ""mapbox://mapbox.satellite"", ""type"": ""raster"", ""tileSize"": 256 } } Six thousand tiles covers a region roughly the size of Greater London within the M25 at zoom levels 0–15 or the contiguous United States at zoom levels 0–9. The size of these tiles on disk will vary according to the selected style. To estimate the number of tiles needed to download a region offline, use our offline tile count estimator. Note that this only generates an estimate of the number of tiles needed to load a defined region offline. The size of the download will vary according to the location being downloaded and the style being used in your application. Offline tile count estimator You can create an unlimited number of offline regions. Your Mapbox-powered application will reuse tiles and resources that are required by multiple regions, conserving network traffic and disk space. The Maps SDKs for Android and iOS do not limit the download speed of offline regions, nor do they limit the amount of disk space that may be used by offline resources. The effective limits will depend on the storage capacity of the mobile device and the speed of the network to which it is connected. Please note that our terms of service do not allow you or an end user to redistribute offline maps downloaded from Mapbox servers. Network data and disk space The total size of offline resources will vary from region to region depending on: The geographic extent of the region. The zoom level range of the region. Feature count and density. The sources, fonts, and icons used by the style. The size of individual tiles required by the region. Whether the region overlaps existing downloaded regions. For the default Mapbox Streets style, some typical total sizes are: City of Barcelona: 83 MB. Greater London within the M25 at zoom levels 0–15: 120 MB. Contiguous United States at zoom levels 0–9: 290 MB. For Mapbox Satellite: City of Barcelona: 45 MB. Greater London within the M25 at zoom levels 0–15: 400 MB. Contiguous United States at zoom levels 0–9: 315 MB. Note that these sizes are rough estimates; they do not account for size savings from automatic resource sharing between multiple regions. We suggest benchmarking typical regions for your application to get an estimate. The Maps SDK downloads tiles when any connection is available, including over regular mobile data (2G, 3G, 4G, etc.). Because only individual highly-optimized tiles download, there's no risk of the user incurring an unexpected 100 MB download by opening the map in a region that's already downloaded (unless the user is browsing 100 MB worth of tiles). The Mapbox iOS and Android SDKs do not include any built-in controls to prevent your users from downloading large offline resources over a cellular network. If you would like to provide your users with this option, we recommend tracking your app's network connectivity type using the your platform of choice's APIs, then activating or deactivating the download as desired. Managing offline download size When storage space is at a premium, there are a few tactics you can use to decrease the total size of your offline resources: Reduce the number of font stacks in your style. A font stack is a combination of primary and fallback fonts that defines the order in which the Maps SDK should try to find the characters rendered on your map. If the rendered cannot find a particular character in the primary font, then the Maps SDK will look for it in the fallback font. Mapbox default styles often use the Arial Unicode font as a fallback font. Because the Maps SDK needs to download the entirety of each font stack to function offline, reducing the total number of font stacks in your style can drastically reduce the total size of your downloaded resources. For example, if your style uses three different font stacks that use Arial Unicode (Comic Sans + Arial Unicode, Comic Sans Bold + Arial Unicode, and Comic Sans italic + Arial Unicode), you have to download the entire Arial Unicode font three times because it's part of three font stacks. You can manage font stacks used within a custom style using the Mapbox Studio style editor. Reduce the number of sources in your style. Does the offline experience you've incorporated in your app require the same level of detail as the online experience you provide? Would reducing the file size by removing some sources would be more beneficial to your users than a higher level of detail? For example, the road network may be more important to your offline users than terrain details. If this is the case, consider removing the Mapbox Terrain tileset from your style. Request style-optimized vector tiles in your style. Style-optimized vector tiles exclude any features that do not appear in your style. For example, if the parks in your style only appear above zoom level 14, all park features would be removed from vector tiles below zoom level 14, reducing the file size of those tiles. Was this page helpful? Yes No",Offline maps,Requirements,Ambient caching,Working with offline maps,Updating offline resources,Tile ceiling & limits,Network data and disk space,Managing offline download size,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Add custom icons or markers,"You can add markers, style them, and add tooltips dynamically with Mapbox GL JS. This overview samples all the ways to add custom, interactive markers.",https://docs.mapbox.com/help/tutorials/markers/,tutorial,Varies,,"beginner Varies Add custom icons or markers There are many different ways to style point data in Mapbox Studio, Mapbox GL JS, and the Mapbox iOS and Android SDKs. In these tutorials, we’ll walk you through several ways to visualize your point data across platforms with custom icons and markers. There's no one right way to build your map, and this guide is designed to provide you with a better understanding of which methods make the most sense for your project. Use the marker playground Use the marker playground to add an image marker to the map and view the platform-specific code necessary to recreate this map in your own iOS, Android, or web application. Add markers in Mapbox GL JS If you already have GeoJSON data that you would like to visualize, you can use Mapbox GL JS to add custom markers to your map. When using the Mapbox GL JS Marker method, you can use any file type that can be used as an image in CSS as a marker on your map. To build a custom marker map entirely in Mapbox GL JS, follow the Add custom markers in Mapbox GL JS tutorial. This tutorial is code-based. Add custom icons in Mapbox Studio If you are starting from scratch and need to draw data to be added to a map, start with the Add points to a map tutorial series. In this tutorial series, you'll learn how to draw data from scratch in the Mapbox Studio dataset editor, add custom icons to a map in the Mapbox Studio style editor, and make your map interactive using Mapbox GL JS. Making your map interactive will require writing code. Part 1: create a dataset Learn how to create a new dataset in the Mapbox Studio dataset editor, draw new points, save your dataset, and export it as a tileset. Add points to a web map, Part 1: create a dataset Part 2: create a style Learn to create a new style with one of the Mapbox default styles, add a tileset as a layer, and style the points with custom icons in the Mapbox Studio style editor. Add points to a web map, Part 2: create a style Part 3: add interactivity Learn how to use Mapbox GL JS to add popups when each point is clicked. This part requires writing code. Add points to a web map, Part 3: add interactivity Note In this tutorial series you will add custom icons inside Mapbox Studio. Mapbox Studio only supports SVG images. Other image formats are supported when using markers in Mapbox GL JS. Add markers in iOS The Mapbox Maps SDK for iOS offers a few different methods for visualizing point data on your map. Each method has its merits and drawbacks, so be sure to take a quick look, particularly if you expect to add a lot of markers or display highly customized markers. See the Adding Points to a Map guide for the Mapbox Maps SDK for iOS for more information on how to use the available methods for visualizing point data on your map and to learn about each method's trade-offs. Add markers in Android The Annotation plugin is the recommended way to add markers to a map when using the Maps SDK for Android. The Annotation plugin simplifies the way to set and adjust the visual properties of annotations on a Mapbox map. Directly using the Maps SDK for Android's sources and layers instead of the Annotation plugin, is the advanced way to add annotations. Add markers in Mapbox.js Note Mapbox.js is no longer in active development. To learn more about our newer mapping tools see Add custom markers in Mapbox GL JS. If you want to know how to add markers with Mapbox.js, read our Work with markers with Mapbox.js guide. In this guide, you will learn how to add markers, customize them, and make them interactive with Mapbox.js. Was this page helpful? Yes No",Add custom icons or markers,Use the marker playground,Add markers in Mapbox GL JS,Add custom icons in Mapbox Studio,Part 1: create a dataset,Part 2: create a style,Part 3: add interactivity,Add markers in iOS,Add markers in Android,Add markers in Mapbox.js,,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Landsat-live,"Landsat Live is a satellite imagery source with the latest imagery, everywhere in the world.",https://docs.mapbox.com/help/glossary/landsat-live/,glossary,,,"Landsat-live Landsat-live has the latest satellite imagery, everywhere in the world. Each pixel is captured within the past 32 days and rendered directly into our layers. To use the imagery in your projects, you can add it to your web map or mobile application with the mapbox.landsat-live tileset ID. You can also add vector footprints and metadata streams with mapbox.landsat-live-vt tileset ID for vector streams. Was this page helpful? Yes No",Landsat-live,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Add a Mapbox style to a CARTO map,Add your map as a basemap to CARTO.,https://docs.mapbox.com/help/tutorials/carto/,tutorial,No code,,"beginner No code Add a Mapbox style to a CARTO map Maps styles created with the Mapbox Studio style editor or Studio Classic can be added as basemaps to CARTO. Any of the preset basemaps or a custom style from Mapbox can be added as the primary basemap for your CARTO map. Getting started For this guide, you'll need a Mapbox account and a CARTO account. Log in to each, then head on to the next steps. Open the CARTO project where you would like to add your Mapbox style. Click on the pencil icon and click on the current BASEMAP that is listed. Under Style, click the + . Add style created with Studio In Mapbox Studio, click the Share & use button next to the style you would like to add to your CARTO project. When the Share & use modal opens, switch to the Use tab. Click the Third party option, and toggle to CARTO. Copy the URL by clicking the clipboard icon. Back in CARTO, paste the Share URL you copied in the previous step into the text box, then click on ADD BASEMAP. The Studio style you added will appear as the CARTO basemap. Add style created with Studio Classic In Mapbox Studio, visit the Classic page at mapbox.com/studio/classic . Find the style you would like to use, then click on the clipboard icon to copy the style's tileset ID to your clipboard. Head back to your CARTO project, where the ""Change basemap"" dialog should still be open. Click on the Mapbox tab, and paste the tileset ID you copied to your clipboard in the previous step into the ""Enter Your Map ID/URL"" text box. You will also need to paste a valid access token into the ""Enter Your Access Token"" text box. To finish adding your Mapbox basemap, click on ADD BASEMAP. The Mapbox Studio Classic style you added will appear as the CARTO basemap. Finished product You added styles created in both Mapbox Studio and Mapbox Studio Classic to a map in CARTO! Was this page helpful? Yes No",Add a Mapbox style to a CARTO map,Getting started,Add style created with Studio,Add style created with Studio Classic,Finished product,,,,,,,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Introduction,A brief introduction to the Mapbox Navigation SDK for iOS.,https://docs.mapbox.com/ios/navigation/overview/,guide,,,"Navigation SDK for iOS Current version: v 0.36.0 View changelog A navigation UI ready to drop into your application Professionally designed map styles Worldwide driving, cycling, and walking directions Traffic avoidance and proactive rerouting Contribute on GitHub The Mapbox Navigation SDK gives you all the tools you need to add turn-by-turn navigation to your application. It takes only a few minutes to drop a full-fledged turn-by-turn navigation view controller into your application. Or use the Core Navigation framework directly to build something truly custom. Structure of the SDK The Navigation SDK is divided into two frameworks: the Mapbox Core Navigation framework (MapboxCoreNavigation) and the Mapbox Navigation framework (MapboxNavigation). Mapbox Core Navigation The Mapbox Core Navigation framework (MapboxCoreNavigation) contains the logic that allows you to receive user location updates, determine their relation to the route line, and get notifications that indicate the current state of the application in the form of a RouteProgress object. You can use MapboxCoreNavigation directly in your project to build a completely custom navigation UI or use it via the Mapbox Navigation framework (MapboxNavigation), which is powered by MapboxCoreNavigation. Mapbox Navigation The Mapbox Navigation framework (MapboxNavigation) is the ready-made turn-by-turn navigation user interface (UI). Use MapboxNavigation to get up and running quickly with an in-app navigation experience. With a few lines of code, add a drop-in UI, automatic day-to-night map switching, and automatic rerouting in traffic. Adjust the style of various elements of the ready-made UI, react to location-related events as they occur, and adjust various aspects of the map view’s appearance. Requirements The Mapbox Navigation SDK and Core Navigation are compatible with applications written in Swift 4.2 or Objective-C in Xcode 10.0. The Mapbox Navigation and Mapbox Core Navigation frameworks run on iOS 9.0 and above. Product capabilities This documentation contains information for both the Mapbox Core Navigation and Mapbox Navigation libraries across a variety of topics: Build route requests Route generation Fundamentals Offline routing Track progress along a route Route progress Fundamentals Maneuver instructions Rerouting Customize the visual experience Localization and internationalization Map and app styling Other topics CarPlay Storyboards Installation You can install the Mapbox Navigation SDK for iOS using either CocoaPods or Carthage. Completing either of these two installation options will provide access to the Mapbox Navigation SDK, map services, and directions services. Installing MapboxNavigation versus MapboxCoreNavigation MapboxCoreNavigation is a dependency of MapboxNavigation. If you install MapboxNavigation you will also have access to all MapboxCoreNavigation's classes and methods. If you do not plan to use the drop-in UI, you can replace MapboxNavigation with MapboxCoreNavigation in the Podfile code snippet below. CocoaPods To install Mapbox Navigation using CocoaPods: Create a Podfile with the following specification: pod 'MapboxNavigation', '~> 0.36.0 ' Run pod repo update && pod install and open the resulting Xcode workspace. Carthage Alternatively, to install Mapbox Navigation using Carthage: Create a Cartfile with the following dependency: github ""mapbox/mapbox-navigation-ios"" ~> 0.36.0 Run carthage update --platform iOS to build only the iOS dependencies. Follow the rest of Carthage’s iOS integration instructions. Your application target’s Embedded Frameworks should include MapboxNavigation.framework, MapboxCoreNavigation.framework, and MapboxNavigationNative.framework. Configuration Mapbox APIs and map tiles require a Mapbox account and API access token. In the project editor, select the application target, then go to the Info tab. Under the “Custom iOS Target Properties” section, set MGLMapboxAccessToken to your access token. You can get an access token from the Mapbox account page. In order for the SDK to track the user’s location as they move along the route, set NSLocationWhenInUseUsageDescription to: Shows your location on the map and helps improve OpenStreetMap. Users expect the SDK to continue to track the user’s location and deliver audible instructions even while a different application is visible or the device is locked. To do this, go to the Capabilities tab. Under the Background Modes section, enable “Audio, AirPlay, and Picture in Picture” and “Location updates”. (Alternatively, add the audio and location values to the UIBackgroundModes array in the Info tab.) Now import the relevant modules and present a new NavigationViewController. You can also push to a navigation view controller from within a storyboard if you set up your application’s UI in Interface Builder. import MapboxDirections import MapboxCoreNavigation import MapboxNavigation // Define two waypoints to travel between let origin = Waypoint(coordinate: CLLocationCoordinate2D(latitude: 38.9131752, longitude: -77.0324047), name: ""Mapbox"") let destination = Waypoint(coordinate: CLLocationCoordinate2D(latitude: 38.8977, longitude: -77.0365), name: ""White House"") // Set options let options = NavigationRouteOptions(waypoints: [origin, destination]) // Request a route using MapboxDirections.swift Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first else { return } // Pass the generated route to the the NavigationViewController let viewController = NavigationViewController(for: route) present(viewController, animated: true, completion: nil) } Testing and development Simulate a route Use MapboxNavigationService(simulating:.always) to simulate progress along a route. This simulation mode is different from the simulation features built into both the Simulator and Xcode. The simulation mode built into the Navigation SDK never deviates from the current route, but it does behave more realistically by accounting for the expected travel speed and course at any given time. While navigating, you can double-tap the left or right side of the “Simulating” banner to adjust the playback speed. let navigationService = MapboxNavigationService(route: route, simulating: .always) let navigationOptions = NavigationOptions(navigationService: navigationService) let viewController = NavigationViewController(for: route, options: navigationOptions) Pricing See our pricing page for more details. Available resources For further details, consult the guides and examples included with this API reference. Documentation for the Mapbox Navigation SDK for iOS comes in the form of: API documentation Examples Tutorials and troubleshooting guides We welcome your bug reports, feature requests, and contributions. If you can't find what you're looking for, reach out to our support team. Was this page helpful? Yes No",Navigation SDK for iOS,Structure of the SDK,Mapbox Core Navigation,Mapbox Navigation,Requirements,Product capabilities,Installation,CocoaPods,Carthage,Configuration,Testing and development,Simulate a route,Pricing,Available resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Uploads API,The Mapbox Uploads API transforms geographic data into tilesets that can be used with maps and geographic applications.,https://docs.mapbox.com/help/glossary/uploads-api/,glossary,,,"Uploads API With the Mapbox Uploads API, you can integrate Mapbox’s powerful data upload pipeline into your application to transform geographic data into tilesets. Mapbox provides temporary credentials to stage a spatial file on S3, and then process it into raster tiles or vector tiles that can be read by Mapbox GL and Mapbox.js. The Uploads API supports a wide range of spatial file types: GeoJSON KML GPX Shapefiles CSV GeoTIFF MBTiles A sample Uploads API request to retrieve temporary S3 credentials looks like: https://api.mapbox.com/uploads/v1/ { username } /credentials?access_token= YOUR_MAPBOX_ACCESS_TOKEN Related resources: Uploads API documentation Upload to Mapbox using cURL tutorial Upload errors troubleshooting guide Was this page helpful? Yes No",Uploads API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Variable label placement,"To increase the chance of high-priority labels staying visible, provide the map renderer a list of preferred text anchor positions.",https://docs.mapbox.com/android/maps/examples/variable-label-placement/,example,Java,,"Variable label placement Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""38.907"" mapbox:mapbox_cameraTargetLng=""-77.04"" mapbox:mapbox_cameraZoom=""11.15""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_BOTTOM; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_LEFT; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_RIGHT; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_TOP; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_JUSTIFY_AUTO; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textField; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textJustify; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textRadialOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textVariableAnchor; /** * To increase the chance of high-priority labels staying visible, provide the map * renderer a list of preferred text anchor positions via * {@link com.mapbox.mapboxsdk.style.layers.PropertyFactory#textVariableAnchor(String[])}. */ public class VariableLabelPlacementActivity extends AppCompatActivity { private static final String GEOJSON_SRC_ID = ""poi_source_id""; private static final String POI_LABELS_LAYER_ID = ""poi_labels_layer_id""; private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_variable_text_placement); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { GeoJsonSource source = new GeoJsonSource(GEOJSON_SRC_ID); source.setUrl(""asset://poi_places.geojson""); mapboxMap.setStyle(new Style.Builder().fromUri(Style.LIGHT) .withSource(source) // Adds a SymbolLayer to display POI labels .withLayer(new SymbolLayer(POI_LABELS_LAYER_ID, GEOJSON_SRC_ID) .withProperties( textField(get(""description"")), textSize(17f), textColor(Color.RED), textVariableAnchor( new String[]{TEXT_ANCHOR_TOP, TEXT_ANCHOR_BOTTOM, TEXT_ANCHOR_LEFT, TEXT_ANCHOR_RIGHT}), textJustify(TEXT_JUSTIFY_AUTO), textRadialOffset(0.5f))), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { Toast.makeText(VariableLabelPlacementActivity.this, getString(R.string.zoom_map_in_and_out_variable_label_instruction), Toast.LENGTH_SHORT).show(); } }); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Variable label placement,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,KML,KML is a geospatial file format that’s commonly in Google products.,https://docs.mapbox.com/help/glossary/kml/,glossary,,,"KML KML is a file format that is like GeoJSON, but used more commonly in Google products. Like GeoJSON, it can store points, lines, polygons, and other vector data. Unlike GeoJSON, it's based on XML, rather than JSON. You can upload KML files to Mapbox Studio to add custom data to your maps. When you upload KML files, Mapbox converts your data to vector tiles so you can create styles from it. When uploading KML, note that Mapbox does not support any KML extensions. For more information on uploading shapefiles, read the Mapbox Studio Manual uploads page. Download a sample KML file Was this page helpful? Yes No",KML,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for Android,Android,AR navigation,Introduction to Mapbox Vision AR for Android.,https://docs.mapbox.com/android/vision/overview/ar/,guide,,,"AR navigation Mapbox Vision AR for Android is a high-level framework that sits on top of the Mapbox Vision SDK for Android. Vision AR manages the navigation route, translates it to the core library, and renders an AR navigation route on top of the live video stream from the device’s built-in camera. Integration with other Mapbox tools Vision AR is intended to be used with the Mapbox Navigation SDK. Vision AR sits on top of the Vision SDK for Android and next to the Mapbox Directions API and the Mapbox Navigation SDK. Route line To project a route line on the road, start by generating the route. You can use the Mapbox Navigation SDK to create a new request to the Mapbox Directions API or use a custom navigation engine. If you want to use the Mapbox Navigation SDK for Android, you will need to add it as a dependency following the instructions in the Navigation SDK documentation. The example below uses the Mapbox Navigation SDK for Android's NavigationRoute.Builder class to create a new request to the Mapbox Directions API. The response will be a NavigationRoute object, which you can use to display a route on a map or start a navigation sequence. Read more about generating routes with the Navigation SDK in the Route generation guide. Use the VisionArManager's setRoute method to use the generated route in a Vision AR view. Java Kotlin VisionArManager.setRoute(new Route( getRoutePoints(route), (float) routeProgress.durationRemaining(), ""Source street name"", ""Target street name"" )); Copy By default a solid blue line is used to display the route. Some customization is possible. Use VisionArView.setLaneVisualParams to change color, width, light coordinate, light color and ambient color. Related resources Basic blue-line AR navigation code example Vision AR for Android reference documentation Was this page helpful? Yes No",AR navigation,Route line,Related resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Static and print maps,Learn how the Mapbox Static Images API works and how to create static maps.,https://docs.mapbox.com/help/how-mapbox-works/static-maps/,guide,,,"Static and print maps Static maps are standalone images in PNG format that can be displayed on web and mobile devices without the aid of a mapping library or API. They look like an embedded map without interactivity or controls. You can request a static map from the Mapbox Static Images API by providing a few parameters, including center coordinates, zoom level, rotation, and tilt. Static maps may also include overlays like lines, markers, or polygons. Learn how to build a Static Images API request using the Static Images API playground. The image below was generated using the Mapbox Static Images API and can be added to a webpage using the following code: <img alt='static Mapbox map of the San Francisco bay area' src='https://api.mapbox.com/styles/v1/mapbox/streets-v 11 /static/-122.337798,37.810550,9.67,0.00,0.00/1000x600@2x?access_token= YOUR_MAPBOX_ACCESS_TOKEN ' > How static maps work The Mapbox Static Images API allows you to request a static image representation of any map style in your Mapbox account. You can retrieve a static map in a few different image and file formats depending on the Mapbox tool you are using. See How to create a static map below for more information on supported file types. Retina When you request a Retina map with @2x, you will receive an image that's twice the width and height that you've specified in your API call. For example, using a width attribute of 700 px with the @2x parameter will return an image with an actual width of 1,400 px. High resolution images Mapbox Studio offers 100 high resolution image exports per account using the print panel. If you are interested in having a higher number of allowed image exports, contact Mapbox sales. With the Mapbox Static Images API, image exports can be up to 1,280 px x 1,280 px in size. While enabling retina may improve the quality of the image, you cannot export at a higher resolution using the Static Images API, and we do not support vector image formats. Static images for print To print images generated from the Mapbox Studio print export option for any use, contact us. Print maps require appropriate Mapbox attribution. Creating static maps Below is a list of image formats that are supported and which tools you can use to generate them: Format Tool(s) PNG Mapbox Static Images API PNG, JPG high-resolution Mapbox Studio (limited number of exports per account) The following formats are not supported as a map export option and are not on our road map for integration: SVG EPS PDF Mapbox Static Images API You can get a static image of your map by formatting a URL with your specific values to make the request. See the Mapbox Static Images API documentation for more information about available parameters and values. Mapbox Static Images API playground To learn how to build a Static Images API request, explore the Mapbox Static Images API playground. Overlays You can add overlays to any maps made with the Static Images API. An overlay is data that can be added on top of the map at request time. Overlays are comma separated and can be a mix of valid GeoJSON, custom markers, paths, or polygons. Read more about how to add an overlay to a static map in our Static Images API documentation. Mapbox Studio The Mapbox Studio print panel allows you to export high resolution images of custom map styles. Click the printer icon to toggle the print panel on and off. Position your map and specify Print export settings in the print panel. Settings include image dimensions (in inches or centimeters), resolution (in pixels per inch), and file format (PNG or JPG). The maximum image export is 8,000 px by 8,000 px. Read more about the print panel in the Mapbox Studio manual. Was this page helpful? Yes No",Static and print maps,How static maps work,Retina,High resolution images,Static images for print,Creating static maps,Mapbox Static Images API,Mapbox Static Images API playground,Overlays,Mapbox Studio,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for Android,Android,Introduction,The official overview documentation for the Mapbox Vision SDK for Android.,https://docs.mapbox.com/android/vision/overview/,guide,,,"Vision SDK for Android Beta This feature is in public beta and is subject to potential changes. Current version: v 0.7.1 View changelog AI and AR features for drivers that run on today’s mobile and embedded applications Build augmented reality navigation with turn-by-turn directions and custom objects Create custom alerts for speeding, lane departures, tailgating, and more Neural networks run on-device: real time performance without taxing your data plan Install The Mapbox Vision SDK for Android is a library for interpreting road scenes in real-time directly on Android devices using the device’s built-in camera. Features include: Classification and display of regulatory and warning signs Object detection for vehicles, pedestrians, road signs, and traffic lights Semantic segmentation of the roadway into 14 different classes Augmented reality navigation with global coverage Support for external cameras: WiFi or wired connection SDK structure There are three Vision-related SDKs you can interact with directly. All three depend on the Vision Core module. Available SDKs Vision SDK (vision) is the primary SDK, needed for any application of Mapbox Vision. Its components enable camera configuration, display of classification, detection, and segmentation layers, lane feature extraction, and other interfaces. Vision accesses real-time inference running in VisionCore. Vision AR SDK (vision-ar) is an add-on module for Vision used to create customizable augmented reality experiences. It allows configuration of the user’s route visualization: lane material (shaders, textures), lane geometry, occlusion, custom objects, and more. Read more in the AR navigation guide. Vision Safety SDK (vision-safety) is an add-on module for Vision used to create customizable alerts for speeding, nearby vehicles, cyclists, pedestrians, lane departures, and more. Read more in the Safety alerts guide. Core logic Vision Core is the core logic of the system, including all machine learning models. Importing any of the Vision-related SDKs listed above into your project automatically brings VisionCore along. Requirements VisionSDK requires Android 6 (API 23) and higher, with QC Snapdragon 650, 710, 8xx (but less than 855) with Open CL support. Some of devices that will work with the Vision SDK: Samsung Galaxy S8, S8+, S9, S9+, Note 8 QC Snapdragon 650, 710, 8xx (but less than 855) with Open CL support Xiaomi Mi 6, 8 HTC U11, U11+, U12, U12+ OnePlus 5, 6 You can also check more details at Vision SDK FAQ. Besides software and hardware requirements, use of the Vision SDK requires that the device is pointed with a view of the road. Use a dashboard or windshield mount to keep your phone oriented correctly while you drive, such as Car Phone Mount Windshield and Car Mount Holder. Getting started To set up the Vision SDK you will need to download the SDK, install the dependencies relevant to your project, and complete a few configuration steps. Download and install the SDK Download from vision.mapbox.com/install You must download the relevant dependencies from vision.mapbox.com/install before continuing. You can download the dependency directly or import it into your project using Maven. This will require that you are logged into your Mapbox account. SDK configuration After downloading or importing the SDK into your project, configure the following in your Android Studio project. Set your Mapbox access token Mapbox APIs require a Mapbox account and access token: Get an access token from the Mapbox account page. Open the strings.xml file, create a new string with name=""mapbox_access_token"", and paste the access token. <string name=""mapbox_access_token"" translatable=""false"">YOUR_ACCESS_TOKEN_HERE</string> Create a new class, initialize VisionManager, and pass it your Mapbox access token: Java Kotlin public class VisionApp extends Application { @Override public void onCreate() { super.onCreate(); VisionManager.init(this, getResources().getString(R.string.mapbox_access_token)); } } Copy Configure permissions The Mapbox Vision SDK will require the following permissions: <uses-permission android:name=""android.permission.INTERNET"" /> <uses-permission android:name=""android.permission.ACCESS_NETWORK_STATE"" /> <uses-permission android:name=""android.permission.CAMERA"" /> <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" /> <uses-permission android:name=""android.permission.ACCESS_FINE_LOCATION"" /> <uses-permission android:name=""android.permission.ACCESS_COARSE_LOCATION"" /> These should all be granted before calling the SDK. Add VisionView to the activity layout (optional) VisionView will render the image that was produced by Vision SDK. You can add it with the following snippet: <com.mapbox.vision.view.VisionView android:id=""@+id/vision_view"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:visualization_mode=""detection"" /> app:visualization_mode specifies what will be rendered on VisionView: clear video source, segmentation, or detections. Lifecycle methods You will need to call lifecycle methods of VisionManager. To listen for events, that Vision SDK produces, you pass an instance of VisionEventsListener to the VisionManager.start() method. Java Kotlin @Override protected void onResume() { super.onResume(); ... VisionManager.create(); VisionManager.start(myVisionEventsListenerInstance); } @Override protected void onPause() { super.onPause(); ... VisionManager.stop(); VisionManager.destroy(); } Copy Device setup Besides installing the framework, you will need to set up the device in the vehicle. Some things to consider when choosing and setting up a mount: Generally, shorter length mounts will vibrate less. Mounting to your windshield or to the dashboard itself are both options. Place the phone near or behind your rearview mirror. Note that your local jurisdiction may have limits on where mounts may be placed. Make sure the phone’s camera view is unobstructed (you will be able to tell with any of the video screens open). Testing and development Read more about setting up your development environment for testing the capabilities of the Vision SDK in the Testing and development guide. Conditions Pricing: For details on pricing, read the Vision FAQ. Attribution: While the Vision SDK is using the camera you must display the Mapbox watermark on screen. Read more about attribution requirements in our terms of service. Was this page helpful? Yes No",Vision SDK for AndroidBetaThis feature is in public beta and is subject to potential changes.,SDK structure,Available SDKs,Core logic,Requirements,Getting started,Download and install the SDK,SDK configuration,Set your Mapbox access token,Configure permissions,Add VisionView to the activity layout (optional),Lifecycle methods,Device setup,Testing and development,,Conditions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Adjust the zoom extent of your tileset,Learn how to manually adjust the zoom extent of your tilesets.,https://docs.mapbox.com/help/troubleshooting/adjust-tileset-zoom-extent/,troubleshooting,,,"Adjust the zoom extent of your tileset When you upload data to your Mapbox account as a tileset, you may notice that your data has been simplified or that it is not rendered at all zoom levels. The Mapbox Streets source data is also limited to specific zoom levels. This guide provides an explanation for why this happens. It also describes some techniques for manually adjusting the zoom extent of your tilesets and for adding your own sources with custom zoom levels. Why this happens Data simplification and zoom level limiting make your map load faster and limit the file size of the resulting tileset. Vector data simplification Simplification at lower zoom levels reduces complexity on the map in places where the details would not even be noticed. This simplification makes the map load more efficiently. The amount of data that can exist in a single vector tile has an upper size limit. By simplifying complex vector features during the upload process, we make sure each tile in your vector tileset falls below this upper limit and will display correctly on your maps. Minimum and maximum zoom levels Sometimes, it is not possible to display data legibly at a given zoom level. For example, a dense series of topographic lines would turn into a jumble of features when viewing the map at a low zoom level. Conversely, lower-resolution data would appear too coarse at high zoom levels. To prevent both of these potential issues, the Mapbox Uploads API analyzes your data and automatically determines the maximum and minimum zoom levels at which tiles should be rendered. For raster tilesets, the uploaded image resolution sets the minzoom and maxzoom levels. Higher resolution images will result in the tileset rendering at more zoom levels. Note: regardless of maximum zoom level, data can be overzoomed and visualized to zoom 22. Adjust the zoom extent of your tileset There are two techniques for adjusting the zoom extent of your tilesets. Transform data with Tippecanoe Much of the data behind Mapbox Streets comes from OpenStreetMap. You can download this data using Overpass Turbo and adjust its zoom level options with Tippecanoe, a command-line utility for converting complex data into vector tiles. To download, prepare, and upload data from OpenStreetMap to your Mapbox account: Download the data you want to work with using Overpass Turbo. Install Tippecanoe using the command line. First, install Homebrew, then run brew install tippecanoe. Create your tileset using Tippecanoe's zoom level options. For example, to set the minimum zoom to 2 and maximum zoom to 7, the command would look something like this: tippecanoe -o geography_regions.mbtiles -Z 2 -z 7 Documents/geography_regions.geojson Upload the MBTiles file you created in step 3 to your Mapbox account as a tileset. For more details on installing and using Tippecanoe to transform your data, read the Manage large data files for Mapbox Studio with Tippecanoe guide. Upload with Mapbox Studio Classic You can manually set minzoom and maxzoom levels with Mapbox Studio Classic, our legacy desktop design tool: Download the latest version of Mapbox Studio Classic. In Mapbox Studio Classic, click Styles & Sources > New style or source > Create custom vector tiles to create a new source. Click New layer, browse to find the file you want to upload, then click the Save as button to save the source. Click Settings and set the minzoom and maxzoom of your data. Use caution, because this step will create vector tiles for each zoom level and can be costly with large and complex data files. See troubleshooting uploads for more information. Save your changes, then click Upload to Mapbox. Your source will appear on the Tileset list page of Mapbox Studio. You cannot set maxzoom beyond 16 in Mapbox Studio Classic. If you want your maxzoom to be more than 16: Exit out of Mapbox Studio Classic. In a text editor, open the data.yml file found in your source’s .tm2source folder. Save and close the file. Re-open Mapbox Studio Classic and upload your tileset. For more details on how to optimize massive data files and convert them to performant vector tiles, read the Uploads guide. Was this page helpful? Yes No",Adjust the zoom extent of your tileset,Why this happens,Vector data simplification,Minimum and maximum zoom levels,Transform data with Tippecanoe,Upload with Mapbox Studio Classic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Find elevations with the Tilequery API,Use the Mapbox Tilequery API and the Mapbox Terrain tileset to create an app that returns the elevation at a specified coordinate.,https://docs.mapbox.com/help/tutorials/find-elevations-with-tilequery-api/,tutorial,JavaScript,,"intermediate JavaScript Find elevations with the Tilequery API Prerequisite Familiarity with front-end development concepts. In this tutorial, you will use the Mapbox Tilequery API and the Mapbox Terrain vector tileset to create an app that, when a user clicks a point on the map, returns the elevation at that point. Getting started To complete this tutorial, you will need: A Mapbox access token. Your Mapbox access tokens are on your Account page. Mapbox GL JS. Mapbox GL JS is a JavaScript API for building web maps. Mapbox Tilequery API. The Tilequery API allows you to retrieve data about specific features from a vector tileset, based on a given latitude and longitude. Mapbox Terrain vector tileset. The Mapbox Terrain vector tileset provides terrain data, including elevation contours. jQuery. jQuery is a JavaScript library you will use to add your API request to the application. A text editor. Use the text editor of your choice for writing HTML, CSS, and JavaScript. Create a map To get started, you will create a map using Mapbox GL JS. Open your text editor and create a new file named index.html. Set up this new HTML file by pasting the following code into your text editor. This code creates the structure of the page. This code also imports Mapbox GL JS and jQuery in the <head> of the page. The Mapbox GL JS JavaScript and CSS files allow you to use Mapbox GL JS functionality and style, while jQuery will allow you to use Ajax to parse your Tilequery API call. There is also a <div> element with the ID map in the <body> of the page. This <div> is the container in which the map will be displayed on the page. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Find elevations with the Tilequery API</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <script src='https://code.jquery.com/jquery-3.4.1.min.js'></script> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Specify the container ID style: 'mapbox://styles/mapbox/outdoors-v 11 ', // Specify which map style to use center: [-122.43877, 37.75152], // Specify the starting position [lng, lat] zoom: 11.5 // Specify the starting zoom } ); </script> </body> </html> This Mapbox GL JS code sets the style for the map to Mapbox Outdoors, gives it coordinates on which to center, and sets a zoom level. Save your changes. Open the HTML file in your browser to see the rendered map, which is centered on San Francisco. Get coordinates when a user clicks In this app, the coordinates used in the Tilequery API request will be generated when a user clicks on the map. To get these coordinates, you will create a map.on('click') function that gets the longitude and the latitude at the clicked location. Add the following JavaScript above the closing </script> tag in your HTML file: // Create variables for the latitude and longitude var lng; var lat; map.on('click', function(e) { // When the map is clicked, set the lng and lat variables equal to the lng and lat properties in the returned lngLat object lng = e.lngLat.lng; lat = e.lngLat.lat; console.log(lng + ', ' + lat); } ); When the map is clicked, the returned event includes a Mapbox GL JS lngLat object, which includes the longitude and latitude of the clicked point. The map.on('click') function sets the lng and lat variables equal to these properties. Save your work, then refresh your browser page and open the browser's developer tools. When you click on the map, your app will print the clicked point's longitude and latitude to the JavaScript console. Add the sidebar In the <body> of your HTML, add a new <div>. This <div> will be used to show the clicked point's longitude, latitude, and elevation: <div class=""eleInfo""> <div>Longitude: <span id='lng'></span></div> <div>Latitude: <span id='lat'></span></div> <div>Elevation: <span id='ele'></span></div> </div> To style the new <div>, add the following CSS to the <style> section of your HTML: .eleInfo { position: absolute; font-family: sans-serif; margin-top: 5px; margin-left: 5px; padding: 5px; width: 200px; border: 2px solid black; font-size: 20px; color: #222; background-color: #fff; } Finally, create three new variables that you will use to target the new <span> IDs. Add the following code in your JavaScript, below the lng and lat variables: var lngDisplay = document.getElementById('lng'); var latDisplay = document.getElementById('lat'); var eleDisplay = document.getElementById('ele'); Save your work and refresh the page. The new sidebar will be on the left side of the page. In an upcoming step, you will use the <span> IDs that you created to display the longitude, latitude, and elevation in the sidebar. Tilequery API request format The Mapbox Tilequery API allows you to retrieve data about specific features from a vector tileset, based on a given latitude and longitude. A Tilequery request has two required two parameters: tileset_id: The identifier of the tileset being queried. { lon, lat }: The coordinates of the query point. The Tilequery API also accepts several optional parameters. In this tutorial, you will use two optional parameters: limit: This parameter allows you to specify the maximum number of results that a query can return. The default number of results is five, and the maximum number is 50. layers: This parameter allows you to only return results from specific layers in the queried tileset. An example call to the Tilequery API that has a limit of 50 results and only returns results from the contour layer looks like: https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/-105.01109,39.75953.json?layers=contour&limit=50&access_token= YOUR_MAPBOX_ACCESS_TOKEN A Tilequery API request returns a GeoJSON FeatureCollection of features at or near the geographic point described by { lon } , { lat }. To learn more about the Tilequery API, its other optional parameters, and its response object, explore the Tilequery API documentation. Mapbox Terrain tileset In this tutorial, you will use the Tilequery API to query the Mapbox Terrain vector tileset, which includes features like topography, hillshades, and landcover. Specifically, you will use the layers parameter to return features in the contour source layer, which contain a property called ele. This property is the elevation value in meters, and is mapped to 10 meter height increments. In the Mapbox Terrain tileset, contours are comprised of stacked polygons. This means that most Tilequery API requests that query the Mapbox Terrain tileset will return multiple features from the contour layer. Because the elevation data you want is included in the contour layer, you will need to parse the returned GeoJSON to isolate the features from the contour layer and find the highest elevation value. Elevation data limitations in the Mapbox Terrain tileset The Tilequery API's limit parameter allows 50 or fewer features in a response. Since this tutorial uses the Mapbox Terrain vector tileset, which includes elevation data at 10 meter increments, 50 returned features may not be enough to return the largest value for some locations at high elevations. Also, since the elevations are returned in 10 meter increments, the results may lose some nuance. For example, a hill that is 264 meters high would return a highest elevation of 260 meters. Mapbox does not have any other vector data sources with more precise elevation data than is available in the Terrain tileset. If you are using the Tilequery API for areas with steep elevation changes, or if you require precise elevations, we recommend that you use the Tilequery API to query a custom tileset that contains this information. Add the Tilequery API call You have already created variables that capture the longitude and latitude when a user clicks on the map. In this step, you will use these lng and lat variables in a call to the Tilequery API. Write a function getElevation() that uses the lng and lat values to construct a Tilequery API request, then uses Ajax to send the request and retrieve the results. Add the following code to your JavaScript, before the closing </script> tag: function getElevation() { // Construct the API request var query = 'https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/' + lng + ',' + lat + '.json?layers=contour&limit=50&access_token=' + mapboxgl.accessToken; $.ajax( { method: 'GET', url: query, } ).done(function(data) { // Get all the returned features var allFeatures = data.features; console.log(allFeatures); // Create an empty array to add elevation data to var elevations = []; // For each returned feature, add elevation data to the elevations array for (i = 0; i < allFeatures.length; i++) { elevations.push(allFeatures[i].properties.ele); } console.log(elevations); // In the elevations array, find the largest value var highestElevation = Math.max(...elevations); console.log(highestElevation); } ); } The Tilequery API returns feature objects. Since the feature objects in this query come from the contour layer, each of them contains a properties.ele value. For each item in allFeatures, this code snippet takes the properties.ele value and pushes it to the elevations array. Then, using Math.max and spread syntax (...elevations), it sets the highestElevation variable to the largest value in the elevations array. Now, you need to call getElevation() when a user clicks on the map. Update the map.on('click') function: map.on('click', function(e) { lng = e.lngLat.lng; lat = e.lngLat.lat; getElevation(); } ); Save your changes and open your developer tools. Refresh the page in your browser and click on the map. On click, three items will be printed out to the console: allFeatures: Contains all the feature objects returned by the call to the Tilequery API. You can explore each feature object to see properties.ele for that feature. elevations: Contains every properties.ele value. highestElevation: The largest value in elevations, and therefore the highest point returned by the Tilequery API for the requested coordinates. Display the returned values Now that you have seen the results of the Tilequery API request printed to the console, your next step is to display them in the sidebar that you created earlier. Update the getElevation() function: function getElevation() { // make API request var query = 'https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/' + lng + ',' + lat + '.json?layers=contour&limit=50&access_token=' + mapboxgl.accessToken; $.ajax( { method: 'GET', url: query, } ).done(function(data) { // Display the longitude and latitude values lngDisplay.textContent = lng.toFixed(2); latDisplay.textContent = lat.toFixed(2); // Get all the returned features var allFeatures = data.features; // Create an empty array to add elevation data to var elevations = []; // For each returned feature, add elevation data to the elevations array for (i = 0; i < allFeatures.length; i++) { elevations.push(allFeatures[i].properties.ele); } // In the elevations array, find the largest value var highestElevation = Math.max(...elevations); // Display the largest elevation value eleDisplay.textContent = highestElevation + ' meters'; } ); } This updated function sets the value of lngDisplay and latDisplay to the clicked longitude and latitude respectively, and uses toFixed(2) to limit the displayed value to two decimal points. It also sets the value of eleDisplay to highestElevation. Save your changes and refresh the page in your browser. Now, when you click a location on the map, its longitude, latitude, and elevation will display in the sidebar. Add a marker to the clicked location The final step is to add a marker to the map at the coordinates where the user clicks. This will help the user better visualize the location that they are getting coordinates and elevation data for. Add the following code to your JavaScript, before the map.on('click') function: var marker = new mapboxgl.Marker( { 'color': '#314ccd' } ); You can use the Mapbox GL JS lngLat object that is returned when the map is clicked to set the marker's location. To draw the marker on the map at the clicked coordinates, add the following code inside of your map.on('click') function: marker.setLngLat(e.lngLat).addTo(map); Save your work and refresh the page. Now when you click on the map, you will see a blue marker at the clicked coordinates. Final product You have created an app that returns a clicked point's elevation and displays it on the map. The final HTML file will look like the following: <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Find elevations with the Tilequery API</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <script src='https://code.jquery.com/jquery-3.4.1.min.js'></script> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } .eleInfo { position: absolute; font-family: sans-serif; margin-top: 5px; margin-left: 5px; padding: 5px; width: 200px; border: 2px solid black; font-size: 20px; color: #222; background-color: #fff; } </style> </head> <body> <div id='map'></div> <div class=""eleInfo""> <div>Longitude: <span id='lng'></span></div> <div>Latitude: <span id='lat'></span></div> <div>Elevation: <span id='ele'></span></div> </div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Specify the container ID style: 'mapbox://styles/mapbox/outdoors-v 11 ', // Specify which map style to use center: [-122.43877, 37.75152], // Specify the starting position [lng, lat] zoom: 11.5 // Specify the starting zoom } ); var lng; var lat; var lngDisplay = document.getElementById('lng'); var latDisplay = document.getElementById('lat'); var eleDisplay = document.getElementById('ele'); var marker = new mapboxgl.Marker( { 'color': '#314ccd' } ); map.on('click', function(e) { // Use the returned LngLat object to set the marker location // https://docs.mapbox.com/mapbox-gl-js/api/#lnglat marker.setLngLat(e.lngLat).addTo(map); // Create variables set to the LngLat object's lng and lat properties lng = e.lngLat.lng; lat = e.lngLat.lat; getElevation(); } ); function getElevation() { // Make the API request var query = 'https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/' + lng + ',' + lat + '.json?layers=contour&limit=50&access_token=' + mapboxgl.accessToken; $.ajax( { method: 'GET', url: query, } ).done(function(data) { // Display the longitude and latitude values lngDisplay.textContent = lng.toFixed(2); latDisplay.textContent = lat.toFixed(2); // Get all the returned features var allFeatures = data.features; // Create an empty array to add elevation data to var elevations = []; // For each returned feature, add elevation data to the elevations array for (i = 0; i < allFeatures.length; i++) { elevations.push(allFeatures[i].properties.ele); } // In the elevations array, find the largest value var highestElevation = Math.max(...elevations); // Display the largest elevation value eleDisplay.textContent = highestElevation + ' meters'; } ); } </script> </body> </html> Next steps To build on top of the tools and techniques you used in this tutorial, explore the following resources: Explore the Tilequery API documentation for more information on how to use the optional parameters. Learn how to use the Tilequery API outside of a map with the Create a timezone finder with the Tilequery API tutorial. Learn how to use the Tilequery API in conjunction with the Mapbox Geocoding API to query results from a custom tileset with the Make a healthy food finder with the Tilequery API tutorial. If using the Tilequery API to query the Mapbox Terrain vector tileset does not provide the level of elevation detail that you need, you can explore an alternative method of retrieving elevation data using Mapbox Terrain-RGB, a raster tileset, instead. Was this page helpful? Yes No",Find elevations with the Tilequery API,Getting started,Create a map,Get coordinates when a user clicks,Add the sidebar,Tilequery API request format,Mapbox Terrain tileset,Add the Tilequery API call,Display the returned values,Add a marker to the clicked location,Final product,Next steps,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Calendar integration,Show calendar event locations on the map.,https://docs.mapbox.com/android/maps/examples/calendar-integration/,example,Java,,"Calendar integration Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> <androidx.recyclerview.widget.RecyclerView android:id=""@+id/calendar_rv_on_top_of_map"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom"" android:layout_marginBottom=""8dp""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.Manifest; import android.content.Context; import android.content.pm.PackageManager; import android.database.Cursor; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.PointF; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.net.Uri; import android.os.Build; import android.os.Bundle; import android.provider.CalendarContract; import androidx.annotation.NonNull; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.android.core.permissions.PermissionsListener; import com.mapbox.api.geocoding.v5.GeocodingCriteria; import com.mapbox.api.geocoding.v5.MapboxGeocoding; import com.mapbox.api.geocoding.v5.models.CarmenFeature; import com.mapbox.api.geocoding.v5.models.GeocodingResponse; import com.mapbox.core.exceptions.ServicesException; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.Calendar; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; /** * Use the Android system's calendar content provider and the Mapbox Geocoding API to show * past calendar events on the map. */ public class CalendarIntegrationActivity extends AppCompatActivity implements OnMapReadyCallback, PermissionsListener, MapboxMap.OnMapClickListener { private static final int MY_CAL_REQ = 0; private static final int TITLE_INDEX = 1; private static final int EVENT_LOCATION_INDEX = 2; private static final String MARKER_IMAGE_ID = ""MARKER_IMAGE_ID""; private static final String MARKER_LAYER_ID = ""MARKER_LAYER_ID""; private static final String PROPERTY_TITLE = ""title""; private static final String PROPERTY_LOCATION = ""location""; private String geojsonSourceId = ""geojsonSourceId""; private MapView mapView; private MapboxMap mapboxMap; private List<Feature> featureList; private FeatureCollection featureCollection; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_calendar_content_provider); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { CalendarIntegrationActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { featureCollection = FeatureCollection.fromFeatures(new Feature[] {}); getCalendarData(style); mapboxMap.addOnMapClickListener(CalendarIntegrationActivity.this); } }); } @Override public boolean onMapClick(@NonNull LatLng point) { return handleClickIcon(mapboxMap.getProjection().toScreenLocation(point)); } /** * This method handles click events for SymbolLayer symbols. * * @param screenPoint the point on screen clicked */ private boolean handleClickIcon(PointF screenPoint) { List<Feature> features = mapboxMap.queryRenderedFeatures(screenPoint, MARKER_LAYER_ID); if (!features.isEmpty()) { String calendarEventTitle = features.get(0).getStringProperty(PROPERTY_TITLE); String calendarEventLocation = features.get(0).getStringProperty(PROPERTY_LOCATION); Toast.makeText(this, calendarEventTitle + "" – "" + calendarEventLocation, Toast.LENGTH_SHORT).show(); return true; } return false; } /** * Using a Calendar content provider (https://developer.android.com/guide/topics/providers/calendar-provider), * retrieve the title and location of calendar events that are from the main account signed in on the device. */ public void getCalendarData(@NonNull Style style) { if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CALENDAR) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.READ_CALENDAR}, MY_CAL_REQ); } else { Uri calendarUri; if (Integer.parseInt(Build.VERSION.SDK) >= 8 && Integer.parseInt(Build.VERSION.SDK) <= 13) { calendarUri = Uri.parse(""content://com.android.calendar/events""); } else if (Integer.parseInt(Build.VERSION.SDK) >= 14) { calendarUri = CalendarContract.Events.CONTENT_URI; } else { calendarUri = Uri.parse(""content://calendar/events""); } Calendar startTime = Calendar.getInstance(); startTime.set(2018, 2, 1, 0, 0); Calendar endTime = Calendar.getInstance(); endTime.set(2018, 6, 1, 0, 0); String selection = ""(( "" + CalendarContract.Events.DTSTART + "" >= "" + startTime.getTimeInMillis() + "" )"" + "" AND ( "" + CalendarContract.Events.DTSTART + "" <= "" + endTime.getTimeInMillis() + "" ))""; String[] projection = new String[] {CalendarContract.Events.CALENDAR_ID, CalendarContract.Events.TITLE, CalendarContract.Events.EVENT_LOCATION, CalendarContract.Events.DTSTART}; Cursor cur = this.getContentResolver().query(calendarUri, projection, selection, null, null); featureList = new ArrayList<>(); int index = 0; if (cur != null) { if (!deviceHasInternetConnection()) { Toast.makeText(this, R.string.no_connectivity, Toast.LENGTH_LONG).show(); Timber.d(""No internet connectivity""); } else { while (cur.moveToNext()) { if (index <= 80) { if (cur.getString(EVENT_LOCATION_INDEX) != null && !cur.getString(EVENT_LOCATION_INDEX).isEmpty()) { makeMapboxGeocodingRequest(style, cur.getString(TITLE_INDEX), cur.getString(EVENT_LOCATION_INDEX)); } else { Timber.d(""getCalendarData: location is null or empty""); } index++; } } setUpData(style); } } } } /** * Use the Mapbox Java SDK's wrapper for making a Mapbox Geocoding API request. The text in the calendar event's * location field is used to make a geocoding request. * * @param eventTitle title of the calendar event so that it can be added as a Feature property. The title is * eventually displayed in a Toast when a calendar event icon is tapped on. * @param eventLocation the event's location. This text is used in the Mapbox geocoding search */ private void makeMapboxGeocodingRequest(@NonNull final Style style, final String eventTitle, final String eventLocation) { try { // Build a Mapbox geocoding request MapboxGeocoding client = MapboxGeocoding.builder() .accessToken(getString(R.string.access_token)) .query(eventLocation) .geocodingTypes(GeocodingCriteria.TYPE_ADDRESS) .mode(GeocodingCriteria.MODE_PLACES) .build(); client.enqueueCall(new Callback<GeocodingResponse>() { @Override public void onResponse(Call<GeocodingResponse> call, Response<GeocodingResponse> response) { List<CarmenFeature> results = response.body().features(); if (results.size() > 0) { // Get the first Feature from the successful geocoding response CarmenFeature feature = results.get(0); if (feature != null && style.isFullyLoaded()) { LatLng featureLatLng = new LatLng(feature.center().latitude(), feature.center().longitude()); Feature singleFeature = Feature.fromGeometry(Point.fromLngLat(featureLatLng.getLongitude(), featureLatLng.getLatitude())); singleFeature.addStringProperty(PROPERTY_TITLE, eventTitle); singleFeature.addStringProperty(PROPERTY_LOCATION, eventLocation); featureList.add(singleFeature); featureCollection = FeatureCollection.fromFeatures(featureList); GeoJsonSource source = style.getSourceAs(geojsonSourceId); if (source != null) { source.setGeoJson(featureCollection); } else { Timber.d(""onResponse: listOfCalendarEvents == null""); } } } else { Toast.makeText(CalendarIntegrationActivity.this, R.string.no_results, Toast.LENGTH_SHORT).show(); } } @Override public void onFailure(Call<GeocodingResponse> call, Throwable throwable) { Timber.d(""Geocoding Failure: %s"", throwable.getMessage()); } }); } catch (ServicesException servicesException) { Timber.d(""Error geocoding: %s"", servicesException.toString()); servicesException.printStackTrace(); } } /** * Sets up all of the sources and layers needed for this example * * @param style style */ public void setUpData(@NonNull Style style) { setupSource(style); setUpImage(style); setUpCalendarIconLayer(style); Toast.makeText(CalendarIntegrationActivity.this, R.string.click_on_calendar_icon_instruction, Toast.LENGTH_SHORT).show(); } /** * Adds the GeoJSON source to the map */ private void setupSource(@NonNull Style style) { style.addSource(new GeoJsonSource(geojsonSourceId, featureCollection)); } /** * Adds the marker image to the map for use as a SymbolLayer icon */ private void setUpImage(@NonNull Style style) { Bitmap icon = BitmapFactory.decodeResource( this.getResources(), R.drawable.calendar_event_icon); style.addImage(MARKER_IMAGE_ID, icon); } /** * Setup a layer with a calendar icon representing the location of each calendar event. */ private void setUpCalendarIconLayer(@NonNull Style style) { SymbolLayer eventSymbolLayer = new SymbolLayer(MARKER_LAYER_ID, geojsonSourceId); eventSymbolLayer.withProperties( iconImage(MARKER_IMAGE_ID), iconSize(1.8f), iconAllowOverlap(true), iconIgnorePlacement(true) ); style.addLayer(eventSymbolLayer); } @Override public void onExplanationNeeded(List<String> permissionsToExplain) { Toast.makeText(this, R.string.user_calendar_permission_explanation, Toast.LENGTH_LONG).show(); } @Override public void onPermissionResult(boolean granted) { // Left empty on purpose } @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { switch (requestCode) { case MY_CAL_REQ: { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { if (mapboxMap != null) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { getCalendarData(style); } }); } } else { Toast.makeText(this, R.string.user_calendar_permission_explanation, Toast.LENGTH_LONG).show(); } return; } default: return; } } public boolean deviceHasInternetConnection() { ConnectivityManager connectivityManager = (ConnectivityManager) getApplicationContext().getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetwork = connectivityManager.getActiveNetworkInfo(); return activeNetwork != null && activeNetwork.isConnected(); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Calendar integration,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Query a map feature,Click the map to add a marker at the location and display the maps property information for that feature.,https://docs.mapbox.com/android/maps/examples/query-a-map-feature/,example,Java,,"Query a map feature Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.query.QueryFeatureActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""29.7565"" mapbox:mapbox_cameraTargetLng=""-95.3625"" mapbox:mapbox_cameraZoom=""16""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.query; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.PointF; import android.os.AsyncTask; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.widget.TextView; import android.widget.Toast; import com.google.gson.JsonElement; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.annotations.BubbleLayout; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.lang.ref.WeakReference; import java.util.HashMap; import java.util.List; import java.util.Map; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import static com.mapbox.mapboxsdk.style.layers.Property.ICON_ANCHOR_BOTTOM; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAnchor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Display map property information for a clicked map feature. */ public class QueryFeatureActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private static final String GEOJSON_SOURCE_ID = ""GEOJSON_SOURCE_ID""; private static final String MARKER_IMAGE_ID = ""MARKER_IMAGE_ID""; private static final String CALLOUT_IMAGE_ID = ""CALLOUT_IMAGE_ID""; private static final String MARKER_LAYER_ID = ""MARKER_LAYER_ID""; private static final String CALLOUT_LAYER_ID = ""CALLOUT_LAYER_ID""; private GeoJsonSource source; private MapView mapView; private MapboxMap mapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_query_feature); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { QueryFeatureActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { setUpData(); mapboxMap.addOnMapClickListener(QueryFeatureActivity.this); Toast.makeText(QueryFeatureActivity.this, getString(R.string.click_on_map_instruction), Toast.LENGTH_SHORT).show(); } }); } /** * Sets up all of the sources and layers needed for this example */ public void setUpData() { if (mapboxMap != null) { mapboxMap.getStyle(style -> { setupSource(style); setUpClickLocationIconImage(style); setUpClickLocationMarkerLayer(style); setUpInfoWindowLayer(style); }); } } /** * Adds the GeoJSON source to the map */ private void setupSource(@NonNull Style loadedStyle) { source = new GeoJsonSource(GEOJSON_SOURCE_ID); loadedStyle.addSource(source); } /** * Adds the marker image to the map for use as a SymbolLayer icon */ private void setUpClickLocationIconImage(@NonNull Style loadedStyle) { loadedStyle.addImage(MARKER_IMAGE_ID, BitmapFactory.decodeResource( this.getResources(), R.drawable.red_marker)); } /** * Needed to show the Feature properties info window. */ private void refreshSource(Feature featureAtClickPoint) { if (source != null) { source.setGeoJson(featureAtClickPoint); } } /** * Adds a SymbolLayer to the map to show the click location marker icon. */ private void setUpClickLocationMarkerLayer(@NonNull Style loadedStyle) { loadedStyle.addLayer(new SymbolLayer(MARKER_LAYER_ID, GEOJSON_SOURCE_ID) .withProperties( iconImage(MARKER_IMAGE_ID), iconAllowOverlap(true), iconIgnorePlacement(true), iconOffset(new Float[] {0f, -8f}) )); } /** * Adds a SymbolLayer to the map to show the Feature properties info window. */ private void setUpInfoWindowLayer(@NonNull Style loadedStyle) { loadedStyle.addLayer(new SymbolLayer(CALLOUT_LAYER_ID, GEOJSON_SOURCE_ID) .withProperties( // show image with id title based on the value of the name feature property iconImage(CALLOUT_IMAGE_ID), // set anchor of icon to bottom-left iconAnchor(ICON_ANCHOR_BOTTOM), // prevent the feature property window icon from being visible even // if it collides with other previously drawn symbols iconAllowOverlap(false), // prevent other symbols from being visible even if they collide with the feature property window icon iconIgnorePlacement(false), // offset the info window to be above the marker iconOffset(new Float[] {-2f, -28f}) )); } /** * This method handles click events for SymbolLayer symbols. * * @param screenPoint the point on screen clicked */ private boolean handleClickIcon(PointF screenPoint) { List<Feature> features = mapboxMap.queryRenderedFeatures(screenPoint); if (!features.isEmpty()) { Feature feature = features.get(0); StringBuilder stringBuilder = new StringBuilder(); for (Map.Entry<String, JsonElement> entry : feature.properties().entrySet()) { stringBuilder.append(String.format(""%s - %s"", entry.getKey(), entry.getValue())); stringBuilder.append(System.getProperty(""line.separator"")); } new GenerateViewIconTask(QueryFeatureActivity.this).execute(FeatureCollection.fromFeature(feature)); } else { Toast.makeText(this, getString(R.string.query_feature_no_properties_found), Toast.LENGTH_SHORT).show(); } return true; } @Override public boolean onMapClick(@NonNull LatLng point) { return handleClickIcon(mapboxMap.getProjection().toScreenLocation(point)); } /** * Invoked when the bitmap has been generated from a view. */ public void setImageGenResults(HashMap<String, Bitmap> imageMap) { if (mapboxMap != null) { mapboxMap.getStyle(style -> { style.addImages(imageMap); }); } } /** * AsyncTask to generate Bitmap from Views to be used as iconImage in a SymbolLayer. * <p> * Call be optionally be called to update the underlying data source after execution. * </p> * <p> * Generating Views on background thread since we are not going to be adding them to the view hierarchy. * </p> */ private static class GenerateViewIconTask extends AsyncTask<FeatureCollection, Void, HashMap<String, Bitmap>> { private final WeakReference<QueryFeatureActivity> activityRef; private Feature featureAtMapClickPoint; GenerateViewIconTask(QueryFeatureActivity activity) { this.activityRef = new WeakReference<>(activity); } @SuppressWarnings(""WrongThread"") @Override protected HashMap<String, Bitmap> doInBackground(FeatureCollection... params) { QueryFeatureActivity activity = activityRef.get(); HashMap<String, Bitmap> imagesMap = new HashMap<>(); if (activity != null) { LayoutInflater inflater = LayoutInflater.from(activity); featureAtMapClickPoint = params[0].features().get(0); StringBuilder stringBuilder = new StringBuilder(); BubbleLayout bubbleLayout = (BubbleLayout) inflater.inflate( R.layout.activity_query_feature_window_symbol_layer, null); TextView titleTextView = bubbleLayout.findViewById(R.id.info_window_title); titleTextView.setText(activity.getString(R.string.query_feature_marker_title)); for (Map.Entry<String, JsonElement> entry : featureAtMapClickPoint.properties().entrySet()) { stringBuilder.append(String.format(""%s - %s"", entry.getKey(), entry.getValue())); stringBuilder.append(System.getProperty(""line.separator"")); } TextView propertiesListTextView = bubbleLayout.findViewById(R.id.info_window_feature_properties_list); propertiesListTextView.setText(stringBuilder.toString()); int measureSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); bubbleLayout.measure(measureSpec, measureSpec); int measuredWidth = bubbleLayout.getMeasuredWidth(); bubbleLayout.setArrowPosition(measuredWidth / 2 - 5); Bitmap bitmap = QueryFeatureActivity.SymbolGenerator.generate(bubbleLayout); imagesMap.put(CALLOUT_IMAGE_ID, bitmap); } return imagesMap; } @Override protected void onPostExecute(HashMap<String, Bitmap> bitmapHashMap) { super.onPostExecute(bitmapHashMap); QueryFeatureActivity activity = activityRef.get(); if (activity != null && bitmapHashMap != null) { activity.setImageGenResults(bitmapHashMap); activity.refreshSource(featureAtMapClickPoint); } } } /** * Utility class to generate Bitmaps for Symbol. */ private static class SymbolGenerator { /** * Generate a Bitmap from an Android SDK View. * * @param view the View to be drawn to a Bitmap * @return the generated bitmap */ static Bitmap generate(@NonNull View view) { int measureSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); view.measure(measureSpec, measureSpec); int measuredWidth = view.getMeasuredWidth(); int measuredHeight = view.getMeasuredHeight(); view.layout(0, 0, measuredWidth, measuredHeight); Bitmap bitmap = Bitmap.createBitmap(measuredWidth, measuredHeight, Bitmap.Config.ARGB_8888); bitmap.eraseColor(Color.TRANSPARENT); Canvas canvas = new Canvas(bitmap); view.draw(canvas); return bitmap; } } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Query a map feature,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Publish your style,Learn how to publish map styles made in Mapbox Studio.,https://docs.mapbox.com/studio-manual/overview/publish-your-style/,guide,,,"Publish your style Once you've finished adding data and styling your map, the next step is to add it to a web or mobile application. This section covers everything you can do with your published style. Mapbox Studio topics covered in this section: Upload Dataset Tileset Template style Custom style Add data to style Style data Publish Draft vs. production styles For each style you create in Mapbox Studio, there is both a draft and production style URL available: Use the draft style URL to quickly iterate and get feedback on your style without impacting map styles being used in applications already in production. Use the production style URL when your style is ready for end users in a production application. When making edits to your style in the style editor, the updated style is saved as a draft in your account. The draft style URL will include all edits to your style up to that point. The production style URL will only include edits you have made before hitting the Publish button. Do not use draft styles in production applications Draft style URLs are meant for prototyping and iteration — they are not cached and are heavily rate limited. Using a draft style URL in a production application could result in degraded performance and blank maps for your end users due to rate limiting. As a result, draft style URLs should not be used in production. Publish Before using your style in a production application, you need to publish it inside the style editor. When making edits to your style in the style editor, the updated style is saved as a draft in your account. Changes made in the style editor will not be reflected in the production version of your style until you explicitly publish it using the Publish button. Share button Inside the style editor, there is a Share button in the top toolbar. This button will open a modal with all the available options for sharing or using your style as either a draft or production-ready style in an application. For both draft and production versions of your style, there are three options for using the style: Share: A URL that can be shared with anyone. Develop: Convenient access to the resources needed to use your style on various platforms. Download: Download a zipped folder with the style JSON and all necessary assets. Read more about each option below. Share URL The Share URL provides a staging address for your map style. It gives you a quick way to share your map with others to get feedback, collaborate on designs, or to show off your creative work. Click the clipboard button to copy the share URL to your clipboard. Paste it into a browser window to see your style. Develop Your style URL and access token are provided in the share modal so you can use your custom style in a web, mobile, or third party application. A style URL is how you refer to your map style . Combined with your access token, it allows you to access and use your map with any of the Mapbox products. Style URL A complete style URL, for example mapbox://styles/mapbox/streets-v 10, is comprised of three components: mapbox://styles: points to Mapbox's Styles API /mapbox: your Mapbox username /streets-v 10: your style's unique ID If you are using the draft version of your style, /draft will also be appended to the end of the style URL. Note The mapbox://styles notation for Mapbox styles is an alias to the full Styles API URL: https://api.mapbox.com/styles/v1/streets-v { constants.VERSION_STREETS_STYLE }. Access token Mapbox uses access tokens to associate your apps and tool usage with your account. Every account has a default public access token, but you can create new access tokens as well. You can find your access tokens on your Account page. Platforms Toggle to the platform that is relevant to your project for related resources. Web The Web option provides the resources necessary to initialize your map style on a webpage using Mapbox GL JS. Mapbox GL JS is a JavaScript library for creating interactive maps with Mapbox styles. This API harnesses the power of GL-driven maps, including smooth zooming, map bearing and pitch, and vector data available for interaction and styling in the browser. You can use custom styles created in the Mapbox Studio style editor, or the default styles we provide, and programmatically add additional data including GeoJSON, images, or even video! For information on using a Mapbox Studio style with Mapbox.js or Leaflet, see the Mapbox.js and Leaflet section below. Right-to-left support in Mapbox GL JS Mapbox Studio loads the mapbox-gl-rtl-text plugin, which adds support for text in the Arabic and Hebrew languages, by default. This plugin is not bundled with Mapbox GL JS. It must be set using the setRTLTextPlugin method in Mapbox GL JS. iOS, Android, and Unity The iOS, Android, and Unity options provide the resources necessary to use your map style with one of our mobile Maps SDKs. Third party The Third party options provide the resources necessary to use your custom map style with various third-party applications including ArcGIS Online, Tableau, CARTO, and Fulcrum. Both Mapbox template styles and your custom styles designed in Mapbox Studio come with a WMTS endpoint that can be used to add your styles to desktop GIS applications. You can use the following endpoint with any of your custom styles: https://api.mapbox.com/styles/v1/YOUR_USERNAME/YOUR_STYLE_ID/wmts?access_token=YOUR_ACCESS_TOKEN This WMTS endpoint allows you to use this map in: ArcMap: Available in ArcGIS Desktop 10+. See our documentation on adding Mapbox layers as WMTS in ArcMap to get started. QGIS: This feature is available in QGIS 2.0+. See our documentation on adding Mapbox layers as WMTS in QGIS to get started. Download Download a zip file that contains all pieces of your style, including a JSON document adhering to the Mapbox Style Specification, the sprite containing all icons and images used in the style, and all fonts used in the style. This can be stored locally, altered in a text editor, uploaded to your account, or shared with other Mapbox Studio users. Mapbox.js and Leaflet You can use Mapbox Studio styles with other web mapping libraries like Mapbox.js and Leaflet using the Mapbox Static Tiles API to generate raster tiles from your Mapbox Studio style. Mapbox.js Mapbox.js is our older JavaScript web mapping library that extends the popular Leaflet.js library. Mapbox.js can be used to create interactive maps using your Mapbox Studio styles as a basemap. Note that using Mapbox.js does not provide all the features available with a Mapbox Studio style. Mapbox.js v3.0.1 and beyond support adding styles from Mapbox Studio, using the styleLayer method: L.mapbox.styleLayer('mapbox://styles/YOUR_USERNAME/YOUR_STYLE_ID').addTo(map); See the full example in the Mapbox.js documentation. Leaflet Leaflet is an open-source JavaScript library for mobile-friendly interactive maps. You can add a Mapbox Studio style to a Leaflet map using this endpoint with the L.TileLayer class: https://api.mapbox.com/styles/v1/YOUR_USERNAME/YOUR_STYLE_ID/tiles/256/ { z } / { x } / { y } ?access_token=YOUR_ACCESS_TOKEN Attribution and Terms of Service Whether you're creating a custom style with Mapbox Studio or building a mobile app with the Android SDK, all Mapbox tools are governed by our attribution requirements and our terms of service. For more information about either of these requirements, contact Mapbox Support. Was this page helpful? Yes No",,Publish your style,Publish,Share button,Share URL,Develop,Style URL,Access token,Platforms,Web,"iOS, Android, and Unity",Third party,Download,Mapbox.js and Leaflet,Mapbox.js,Leaflet,Attribution and Terms of Service,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Markers and annotations,Mapbox offers several ways to add markers to a map. Read about the benefits of each approach.,https://docs.mapbox.com/ios/maps/overview/markers-and-annotations/,guide,,,"Markers and annotations Mapbox offers a few different ways to add markers to a map, each with different trade-offs. Below is an overview of the variety of approaches that can be used. Annotations Our annotations API includes the MGLAnnotationImage, and MGLAnnotationView classes. These are most like MapKit’s annotation class and provide a familiar interface for working with markers and callouts. MGLAnnotationImage MGLAnnotationView MGLAnnotationImage is an annotation class that is customizable with any UIImage. It is highly performant, as the images are rendered directly using OpenGL. If you need to animate your annotations or control z-layer ordering, consider working with MGLAnnotationView instead which supports any animation that can be applied to a UIView. View hierarchy can be manipulated by using instance methods available on UIView such as -[UIView bringSubviewToFront:]. MGLAnnotationView is an annotation class that is a customizable UIView. Use this class if you need your markers to be dynamic or animated. MGLAnnotationView has a significant advantage over MGLAnnotationImage when you need every annotation to be unique. For example, annotation views are ideal for showing user locations on a map using high-resolution profile pictures. The map can slow down when many annotation views are visible at the same time, so if you need to add a large number of markers, consider using our runtime styling APIs instead. Both MGLAnnotationImage and MGLAnnotationView can become interactive by adding a few lines of code. When the user taps an annotation, the annotation’s name appears in a callout. An annotation view can additionally respond to drag-and-drop gestures. Runtime styling For full control of how markers are displayed on a map, consider using our runtime styling APIs. Like MGLAnnotationImage, it is a performant approach to adding markers because they rendered directly using OpenGL. The runtime styling APIs also provide support for rendering labels together with icons, finer control of z-ordering, and clustering, so consider using this set of APIs if you need to display a large amount of highly customizable markers. Our runtime styling API is the most powerful option if you need to create rich data visualizations within in your map, but it is the most complex and has a steeper learning curve than our annotations API. The runtime styling API includes our MGLSymbolStyleLayer and MGLCircleStyleLayer classes that can be used to dynamically display on markers on map when used in conjunction with either an MGLVectorSource or an MGLShapeSource. If you need to implement callouts with the MGLSymbolStyleLayer or MGLCircleStyleLayer, you will need to implement your own tap gesture recognizer that calls -[MGLMapView visibleFeaturesAtPoint:inStyleLayersWithIdentifiers:] to get the tapped point feature, then show a UIView you provide. Additionally, if you need to animate markers when using the runtime styling APIs, consider using a timer to update the source data coordinates as needed. MGLCircleStyleLayer MGLSymbolStyleLayer The MGLCircleStyleLayer class is the style layer class responsible for displaying the source’s point features as circle-shaped markers. You can specify circle fill and outline colors, as well as size. You can also dynamically change the circle’s styling properties based on any attributes your source data contains. The MGLSymbolStyleLayer class is the style layer class responsible for displaying the source’s point features as icons and labels. You can use custom images as icons and also combine text labels, placing them exactly where you specify. You can also dynamically change the symbol’s styling properties based on any attributes your source data contains. Still undecided on which approach will work for your use case? Reach out to our support team. See the table below for a summary of APIs that can be used to add markers to a map: ✅ Recommended ⚠️ Supported with caveats ➖ Unavailable or not supported Feature MGLAnnotationView MGLAnnotationImage MGLSymbolStyleLayer MGLCircleStyleLayer Customizability ✅ Text labels, interactive subviews ⚠️ Static images only ✅ Full support for text labels and label placement ✅ Customize circle color and outline Borrows familiar concepts from MapKit, Google Maps SDK ➖ Mapbox GL JS, Mapbox Studio Mapbox GL JS, Mapbox Studio Can use images ✅ ✅ ✅ ➖ Can use text ✅ ➖ ✅ ➖ Control Z-index ✅ ➖ ⚠️ Add multiple layers at, above, or below a specified layer index to control ordering ⚠️ Add multiple layers at, above, or below a specified layer index to control ordering Drag and drop ✅ ➖ ➖ ➖ Core Animation support ✅ ➖ ➖ ➖ Add/move/replace ✅ ✅ ⚠️ Partial data updates are less performant than using annotations ⚠️ Partial data updates are less performant than using annotations SceneKit support ✅ ➖ ➖ ➖ Can be dynamically styled based on data attributes ✅ Subclass MGLPointAnnotation to add custom attributes ✅ Subclass MGLPointAnnotation to add custom attributes ✅ ✅ Supports callouts ✅ Built-in callouts included ✅ Built-in callouts included ⚠️ Implement your own gesture recognizer that uses feature querying, then create custom UIViews to mimic native callouts ⚠️ Implement your own gesture recognizer that uses feature querying, then create custom UIViews to mimic native callouts Supports clustering ⚠️ Use a third-party plugin ➖ ✅ ✅ Was this page helpful? Yes No",,Markers and annotations,Runtime styling,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Display buildings in 3D,Use the building plugin to easily display 3D building height.,https://docs.mapbox.com/android/plugins/examples/display-3d-buildings-on-any-map-style/,example,Java,,"Display buildings in 3D Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.plugins.BuildingPluginActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraBearing=""300"" mapbox:mapbox_cameraTargetLat=""41.87827"" mapbox:mapbox_cameraTargetLng=""-87.62877"" mapbox:mapbox_cameraTilt=""60"" mapbox:mapbox_cameraZoom=""16"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.building.BuildingPlugin; /** * Use the buildings plugin to display buildings' heights (extrusions) in 3D. */ public class BuildingPluginActivity extends AppCompatActivity { private MapView mapView; private BuildingPlugin buildingPlugin; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_building_plugin); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap map) { map.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { buildingPlugin = new BuildingPlugin(mapView, map, style); buildingPlugin.setMinZoomLevel(15f); buildingPlugin.setVisibility(true); } }); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,Display buildings in 3D,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Zoom-based icon switch,Change SymbolLayer icons based on the camera's zoom level.,https://docs.mapbox.com/android/maps/examples/symbol-switch-on-zoom/,example,Java,,"Zoom-based icon switch Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.dds.SymbolSwitchOnZoomActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""45.459145"" mapbox:mapbox_cameraTargetLng=""9.186176"" mapbox:mapbox_cameraZoom=""10.662822""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.step; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; /** * Use the SymbolLayer's setMinZoom and setMaxZoom methods to create the effect of SymbolLayer icons switching * based on the map camera's zoom level. */ public class SymbolSwitchOnZoomActivity extends AppCompatActivity implements OnMapReadyCallback { private static final float ZOOM_LEVEL_FOR_SWITCH = 12; private static final String BLUE_PERSON_ICON_ID = ""blue-car-icon-marker-icon-id""; private static final String BLUE_PIN_ICON_ID = ""blue-marker-icon-marker-icon-id""; private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_zoom_based_icon_switch); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(final MapboxMap mapboxMap) { mapboxMap.setStyle(new Style.Builder().fromUri(Style.OUTDOORS) // Add images to the map so that the SymbolLayers can reference the images. .withImage(BLUE_PERSON_ICON_ID, BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.ic_person))) .withImage(BLUE_PIN_ICON_ID, BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.blue_marker))) // Add random data to the GeoJsonSource and then add the GeoJsonSource to the map .withSource(new GeoJsonSource(""source-id"", FeatureCollection.fromFeatures(new Feature[]{ Feature.fromGeometry(Point.fromLngLat( 9.205394983291626, 45.47661043757903)), Feature.fromGeometry(Point.fromLngLat( 9.223880767822266, 45.47623240235297)), Feature.fromGeometry(Point.fromLngLat( 9.15530204772949, 45.4706650227671)), Feature.fromGeometry(Point.fromLngLat( 9.153714179992676, 45.48625229963004)), Feature.fromGeometry(Point.fromLngLat( 9.158306121826172, 45.482731998239636)), Feature.fromGeometry(Point.fromLngLat( 9.188523888587952, 45.4923746929562)), Feature.fromGeometry(Point.fromLngLat( 9.20929491519928, 45.45314676076135)), Feature.fromGeometry(Point.fromLngLat( 9.177778959274292, 45.45569808340158)) }) )), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Create a SymbolLayer and use the {@link com.mapbox.mapboxsdk.style.expressions.Expression.step()} // to adjust the SymbolLayer icon based on the zoom level. The blue person icon is set as the default // icon and then a step is used to switch to the blue person icon at a certain map camera zoom level. SymbolLayer singleLayer = new SymbolLayer(""symbol-layer-id"", ""source-id""); singleLayer.setProperties( iconImage(step(zoom(), literal(BLUE_PERSON_ICON_ID), stop(ZOOM_LEVEL_FOR_SWITCH, BLUE_PIN_ICON_ID))), iconIgnorePlacement(true), iconAllowOverlap(true)); style.addLayer(singleLayer); Toast.makeText(SymbolSwitchOnZoomActivity.this, R.string.zoom_map_in_and_out_icon_switch_instruction, Toast.LENGTH_SHORT).show(); } } ); } @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Zoom-based icon switch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,style-optimized vector tiles,Style-optimized vector tiles remove any layers or features in the tile that are not represented by a Mapbox style.,https://docs.mapbox.com/help/glossary/style-optimized-vector-tiles/,glossary,,,"style-optimized vector tiles Style-optimized vector tiles, available through the Mapbox Vector Tiles API, remove any layers or features in the tile that are not represented by a Mapbox style. Style-optimized vector tiles are smaller, served over-the-wire, and a way to reduce the size of offline caches. For example, say you have a style that references a tileset with four layers: campsites, mountains, forestland, and buildings. The final map includes icons for campsites, a pattern for forests, and a pattern for blue mountains, but does not use buildings. In a normal Mapbox GL map, the tiles loaded include all four layers even though they aren’t all needed. A style-optimized vector tile includes only campsites, forestland, and blue mountains. It removes unused layers and features based on attributes and zoom levels. You can use style-optimized vector tilesets in Mapbox GL JS by adding ?optimize=true to the end of your style URL: var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/outdoors-v9?optimize=true' // optimize=true } ); Was this page helpful? Yes No",,style-optimized vector tiles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Manage your fontstacks,Learn how to manage fontstacks for optimal rendering.,https://docs.mapbox.com/help/troubleshooting/manage-fontstacks/,troubleshooting,,,"Manage your fontstacks A fontstack is an ordered list consisting of a primary font and optional fallback font(s). Fonts can only be set on symbol layer types. Set fonts from the Style tab of each symbol layer, under Text, in the Font input field. Each list of unique font pairings between primary and fallback font(s) will create a new fontstack. An example fontstack: 'Roboto Black', 'Arial Unicode MS Bold'; When your primary font has missing glyphs, the text will be rendered in the fallback font instead. The default fallback font set by Mapbox Studio is Arial Unicode MS Bold. Unicode fonts include more glyphs than conventional fonts, allowing for better multilingual coverage. Manage rendering time The number of fontstacks paired with the density of text per zoom on your map can significantly slow down your map's load time, especially when using multilingual labels. This is because dense multilingual text, at any set zoom level, will increase rendering time. Here are some tips to decrease your map's rendering time: Latin scripts can handle more fontstacks, while other scripts like Chinese or Hangul, can require loading dozens of glyph tiles per fontstack. Keeping labels sparse and spread across zoom levels allows for more fontstacks in your map style. For multilingual maps with dense labeling, consider using fewer fontstacks. Manage offline download size When using one of our mobile SDKs, you can often reduce the amount of space required to download an offline region dramatically by limiting the number of fontstacks in your style. To learn more about reducing offline download sizes, please see our guide to offline maps. Was this page helpful? Yes No",,Manage your fontstacks,Manage offline download size,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Iconic buildings,An overview of the iconic buildings example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/iconic-buildings/,example,No code,,"Iconic buildings This example demonstrates how you can use the ReplaceFeatureCollectionModifier to place 3D models of iconic buildings. With this modifier, you can replace your corporate office locations with a branded building model, or spawn a highly detailed 3D object in place of a monument or building. The Mapbox Maps SDK for Unity contains some 3D models for your use. Click the button on the UI canvas to fly to the location of the selected iconic building. Game object modifiers The ReplaceFeatureCollectionModifier is a Game object modifier included in the SDK. Game object modifiers are ScriptableObjects that work with meshes and game objects to further allow you to decorate, enhance, or make modifications to your game objects. To create a new modifier, right click in your project window and navigate to Create > Mapbox > Modifiers You can also create modifiers by clicking Add New in the Advanced > Modifier Options section of the AbstractMap script. ReplaceFeatureCollectionModifier overview To open the modifier for this example, navigate to MAP LAYERS > FEATURES, and then select ExtrudedBuildings under Map Features. Next, with ExtrudedBuildings selected, open then Behavior Modifiers section. Under Game Object Modifiers, double click on the ReplaceFeatureCollectionModifier named ReplaceGlobalHeroStructuresModifier. This will open the modifier in your Inspector window and you will see the following settings: Active: This boolean setting toggles the modifier on and off. Features: This is an array that holds all features to add to the scene. You can increase the value of Size to add new elements to the array. You can also right click to duplicate or copy a selected element. For this example there are seven features inside of the array. Prefab: This is the 3D object to spawn at the specified location. The title of the prefab will automatically be assigned as the title of the element. Scale down with world: This setting scales the specified prefab to the size of the tile. Prefab Locations: This is an array that holds all locations to all the buildings and features to be replaced with the supplied prefab. You can increase the value of Size to add new elements to the array. Click Search to find a feature, or paste in the latitude and longitude coordinates. Explicitly Blocked Feature IDs: This is a list of ids on the ExtrudedBuildings layer to prevent from spawning. You can leave this empty unless you find an issue where the latitude and longitude coordinates are not properly filtering out the correct building to replaced. Using this example as a guide you can place iconic buildings anywhere in the world, including your own neighborhood. Was this page helpful? Yes No",,Iconic buildings,ReplaceFeatureCollectionModifier overview,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Geocoder,Official documentation on the Mapbox Java SDK Geocoding API.,https://docs.mapbox.com/android/java/overview/geocoder/,guide,Java,,"Geocoder The Mapbox Geocoding API does two things: forward geocoding and reverse geocoding. Forward geocoding lets you convert location text into geographic coordinates, and reverse geocoding turns geographic coordinates into place names. You'll find the wrapper for the Mapbox Geocoding API in the mapbox-java-services module. MapboxGeocoding is used to request both forward and reverse geocoding information. Forward geocoding will take a String, such as a street address or point of interest, and transform it into a Point object. Reverse geocoding does the opposite, taking in a Point object and transforming it into an address. The amount of detail provided in the response varies. For example, one response might contain a full address while another response will only contain the city and country. Note Both this Geocoding API wrapper and the Places Plugin enable you to make forward and reverse geocoding queries to the Mapbox Geocoding API, but the two differ in their flexibility and the query methods. Read more about the Mapbox options that you have for location search. Before using this wrapper: Read the Mapbox Geocoding API documentation. The API documentation contains all available parameters including some that are not listed in this guide. Make sure you have included the correct permissions inside of your AndroidManifest.xml file if you plan to use this API inside of an Android application. Geocoding request Before making a geocoding request, you must build the MapboxGeocoding object by passing in two required parameters; a valid Mapbox access token and a location query (typically an address or description). Many other parameters are available to help bias and manipulate the response that you receive. Note: If you are using our geocoder to find locations around the user's location, you can use proximity() passing in their location as a Point object to bias results to around their location. Java Kotlin MapboxGeocoding mapboxGeocoding = MapboxGeocoding.builder() .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .query(""1600 Pennsylvania Ave NW"") .build(); Copy Geocoding response Once you have built your MapboxGeocoding object with all the parameters that you'd like to use in the request, you'll need to asynchronously send the request using enqueueCall(). Once the request receives a response, it will tell the callback where you can handle the response appropriately. Note: You should use mapboxGeocoding.cancelCall() within your onDestroy() lifecycle method in case your user leaves the activity or application before the callback is notified. Java Kotlin mapboxGeocoding.enqueueCall(new Callback<GeocodingResponse>() { @Override public void onResponse(Call<GeocodingResponse> call, Response<GeocodingResponse> response) { List<CarmenFeature> results = response.body().features(); if (results.size() > 0) { // Log the first results Point. Point firstResultPoint = results.get(0).center(); Log.d(TAG, ""onResponse: "" + firstResultPoint.toString()); } else { // No result for your request were found. Log.d(TAG, ""onResponse: No result found""); } } @Override public void onFailure(Call<GeocodingResponse> call, Throwable throwable) { throwable.printStackTrace(); } }); Copy Reverse geocoding The process of turning coordinates into a String address is called reverse geocoding. Instead of supplying the builder with a String address you'd pass in coordinates instead. Handling the response is like forward geocoding. While the geocoder gives one coordinate, the response will often give you multiple valid ways to describe the specific location. For example, one might be the street name while another result will be the country. The ordering of the list usually goes from most relevant to least. You can narrow the response like forward geocoding by biasing the result using the available parameters provided in the builder. Java Kotlin MapboxGeocoding reverseGeocode = MapboxGeocoding.builder() .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .query(Point.fromLngLat(-77.03655, 38.89770)) .geocodingTypes(GeocodingCriteria.TYPE_ADDRESS) .build(); // The result of this reverse geocode will give you ""Pennsylvania Ave NW"" Copy Batch geocoding Batch requests have the same parameters as normal requests, but can include more than one query by separating queries with the ; character. The mode parameter also needs to use MODE_PLACES_PERMANENT. You can do up to 50 forward or reverse geocoding queries in a single request. The response is an array of individual geocoder responses formatted the same as individual results. Each query in a batch request counts individually against your account's rate limits. Java Kotlin MapboxGeocoding client = MapboxGeocoding.builder() .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .mode(GeocodingCriteria.MODE_PLACES_PERMANENT) .query(""20001;20009;22209"") .baseUrl(mockUrl.toString()) .build(); Copy Note: Batch geocoding is only available with an Enterprise plan. On all other plan levels, one geocode is permitted per request. For more information about batch geocoding please contact us. Was this page helpful? Yes No",,Geocoder,Geocoding response,Reverse geocoding,Batch geocoding,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,Getting Started | Mapbox SDK for Unity,,https://docs.mapbox.com/mapbox-unity-sdk/docs/00-getting-started.html,,,,"Toggle navigation Show / Hide Table of Contents Getting Started Installation from Unity Package Check out the official Unity SDK page for installation steps. Installation from Git (source) git clone https://github.com/mapbox/mapbox-unity-sdk.git Run the update script. Read about how the project is configured and learn how to contribute The actual Unity project is nested in the sdkproject directory Next Steps Follow along with these tutorials Read the Unity/C# API documentation Explore Learn how Mapbox works Check out Mapbox and GIS termnology Read general Mapbox API documentation Learn about Mapbox Studio Create a custom raster style for use in Unity Issues Before reporting issues or contacting support, please follow these steps: Check that you are using the latest version of the Mapbox Maps SDK for Unity Read about Known Issues Check our public respository for existing issues If you still need help, please contact support or create an issue. Improve this Doc Back to top © 2017 Mapbox",,Getting Started,Installation from Git (source),Next Steps,Explore,Issues,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Directions,Official documentation on the Mapbox Java SDK Directions API.,https://docs.mapbox.com/android/java/overview/directions/,guide,Java,,"Directions The Mapbox Directions API delivers routes for navigating the world. Driving, walking, and cycling directions are all possible for you to request, retrieve, and use in your Android project. The Mapbox Java SDK's MapboxDirections class eases interaction with the Mapbox Directions API. The Directions API does not return estimated times of arrival (ETA). Please see the Mapbox Matrix API if you would like ETAs for your Android project. Conversely, the Matrix API does not provide directions routes and distances, which the Directions API does provide. For more extensive information about this API, see the Mapbox Directions API documentation. Along with the API documentation, you can also view the Directions API example in the Mapbox Android demo app to see a complete example of how to use the API. Installation The Directions API can be used completely on its own to get routes and other directional information. Built on top of the Directions API, the Mapbox Navigation SDK for Android enables you to interact with and use the information inside of the Directions API response. Use the Mapbox Java Services dependency if you want to use the Mapbox Directions API without using the entire Mapbox Navigation SDK. implementation 'com.mapbox.mapboxsdk:mapbox-sdk-services: 4.8.0 ' Building a request The Mapbox Directions API requires you to build a URL with various parameters to request the information that you want. This URL has required and optional parameters. The MapboxDirections.Builder() class helps you set these various parameters. The three required parameters are: an origin Point object a destination Point object a routing profile A Point object is part of the Java SDK's set of GeoJSON classes. Java Kotlin MapboxDirections client = MapboxDirections.builder() .origin(origin) .destination(destination) .overview(DirectionsCriteria.OVERVIEW_FULL) .profile(DirectionsCriteria.PROFILE_DRIVING) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .build(); Copy Profiles: Traffic: For automotive routing. This profile factors in current and historical traffic conditions to avoid slowdowns. Traffic information is available in these supported geographies. Driving: For automotive routing. This profile shows the fastest routes by preferring high-speed roads like highways. Walking: For pedestrian and hiking routing. This profile shows the shortest path by using sidewalks and trails. Cycling: For bicycle routing. This profile shows routes that are short and safer for cyclists by avoiding highways and preferring streets with bike lanes. For additional information on all the available optional parameters, see the Directions API documentation. Directions API requests for driving, walking, and cycling routes can specify up to 25 total waypoints along the route. Requests using the traffic profile can specify up to 3 waypoints. Traffic coverage for the traffic profile is available in supported geographies. Requests to this profile revert to driving profile results for areas without traffic coverage. Maximum 60 requests per minute. Computing route alternatives is not supported on the traffic profile. Handling the response You can access the Directions API's response inside of the onResponse callback. The callback is a Retrofit callback, like all the Mapbox Java SDK's other API calls. The response object will include: an array of waypoint objects. Each waypoint is an input coordinate snapped to the road and path network. The waypoints appear in the array in the order of the input coordinates. (DirectionsWaypoint is the Java class). For more information about the waypoint object, see the Directions API documentation. An array of route objects ordered by descending recommendation rank. The response object may contain at most 2 routes. (DirectionsRoute is the Java class). For more information about the route object, see the Directions API documentation. Java Kotlin client.enqueueCall(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { if (response.body() == null) { Log.e(""No routes found, make sure you set the right user and access token.""); return; } else if (response.body().routes().size() < 1) { Log.e(""No routes found""); return; } // Retrieve the directions route from the API response currentRoute = response.body().routes().get(0); } @Override public void onFailure(Call<DirectionsResponse> call, Throwable throwable) { Timber.e(""Error: "" + throwable.getMessage()); } }); Copy Directions API playground Explore and learn more about the Mapbox Directions API Read the full documentation on the Mapbox Directions API to learn more. The Java SDK's Services dependency has equivalent Java classes for the various objects and information in the full Directions API response. Each object has a .Builder() class as well. For example: Java Kotlin RouteLeg routeLeg = RouteLeg.builder() .annotation(LegAnnotation) .summary(summaryString) .build(); Copy Java Kotlin VoiceInstructions voiceInstructions = VoiceInstructions.builder() .distanceAlongGeometry(Double distanceAlongGeometry) .build(); Copy Once you have a successful Directions API response (response.body()), as discussed above, you will be able to parse through the information to access the specific information that you want. Drawing the route You might want to draw the directions route on a map if you're using the Java SDK's Directions API. Using the route's geometry to create a LineString is the key to making this happen. Java Kotlin Feature directionsRouteFeature = Feature.fromGeometry(LineString.fromPolyline(currentRoute.geometry(), PRECISION_6)); Copy Once you've created a Feature for which the geometry is a LineString, you can then use it with the FeatureCollection, GeoJsonSource, and LineLayer objects. This is called data-driven styling. For more information about how data-driven styling can be used in a map, see the data-driven styling guide. Directions example Request and receive a Directions API route between two locations. Was this page helpful? Yes No",,Directions,Building a request,Handling the response,Drawing the route,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Showing device location,Showing device location with the Mapbox Maps SDK for Android.,https://docs.mapbox.com/android/maps/overview/location-component/,guide,Java,,"Showing device location Showing the user's current location as a map annotation is a popular and often critical feature of location-based apps. The Maps SDK's LocationComponent makes use of the Maps SDK's runtime styling capabilities to display the device location icon within the map itself rather than on top as an Android view. Mapbox map layers and layer styling give you precise control over how you show a device's location on the map. Note This LocationComponent has replaced the now-deprecated Location Layer Plugin. The LocationComponent is integrated into the Maps SDK for Android so that you don't need to add any additional dependencies. It brings the same set of functionality that you were used to with the plugin. Requesting location permissions You'll need to request the Android-system location permission before using the LocationComponent. If you build your Android project targeting API level 23 or higher your application will need to request permissions during runtime. Handling this directly in your activity produces boilerplate code and can often be hard to manage. Read more about using the Mapbox Core Library for Android's PermissionsManager class. Customization The LocationComponent can be customized in many different ways. You can set the image drawables, opacities, colors, and more. See a full list of XML attributes for styling the LocationComponent via XML. The LocationComponentOptions class can be used if you prefer to customize the LocationComponent programatically. Create a LocationComponentOptions object and then use whichever LocationComponentOptions.builder()'s various methods you'd like. Then use the built LocationComponentOptions object as parameter in LocationComponentActivationOptions#locationComponentOptions() or by passing it through as a parameter of the LocationComponent#applyStyle() method at a later time. Java Kotlin LocationComponentOptions locationComponentOptions = LocationComponentOptions.builder(this) .layerBelow(layerId) .foregroundDrawable(R.drawable.drawable_name) .bearingTintColor(int color) .accuracyAlpha(float) .build(); LocationComponentActivationOptions locationComponentActivationOptions = LocationComponentActivationOptions .builder(this, style) .locationComponentOptions(locationComponentOptions) .build(); locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent(locationComponentActivationOptions); Copy Customizing device location example Use LocationComponent options to style the device location icon. Active styling options XML Option Explanation mapbox_foregroundDrawable Drawable image that would replace the blue circle. mapbox_foregroundTintColor The blue circle's color. mapbox_backgroundDrawable Drawable image that would replace the white circle. mapbox_backgroundTintColor The white circle. mapbox_bearingDrawable Drawable image that would replace the blue triangle. mapbox_bearingTintColor The blue triangle. mapbox_navigationDrawable Drawable image used for the navigation state icon. mapbox_accuracyAlpha The larger light blue circle surrounding the device location icon. mapbox_accuracyColor Color of the larger light blue circle surrounding the device location icon. mapbox_elevation The amount of space between the map and the device location icon. The elevation will adjust the size of the shadow as seen underneath the white circle. Passing 0f as the method parameter will remove the shadow effect. mapbox_compassAnimationEnabled Enable or disable smooth animation of compass values for the blue triangle. mapbox_accuracyAnimationEnabled Enable or disable smooth animation of the larger light blue accuracy circle surrounding the device location icon. Note mapbox_compassAnimationEnabled and mapbox_accuracyAnimationEnabled options are available because smooth animation of the LocationComponent can have a significant impact on a device's battery level. Disabling smooth compass and accuracy animations during scenarios where it'd be the only animation running on the device can decrease CPU usage by a significant amount. Stale styling options XML Option Explanation mapbox_foregroundDrawableStale Drawable image that would replace the grey circle's location. mapbox_foregroundStaleTintColor The grey circle's color. mapbox_backgroundDrawableStale Drawable image that would replace the white circle's location. mapbox_backgroundStaleTintColor The white circle's color. Activating MapboxMap#getLocationComponent() fetches the component and LocationComponent#activateLocationComponent() activates it. The activateLocationComponent() method requires a built LocationComponentActivationOptions class. The LocationComponentActivationOptions class offers a convenient way to set activation options such as whether to use the default LocationEngine or a built LocationComponentOptions object. Create a LocationComponentActivationOptions class with the builder pattern that is provided to you via the Maps SDK. Java Kotlin LocationComponentActivationOptions locationComponentActivationOptions = LocationComponentActivationOptions .builder(this, style) .locationComponentOptions(locationComponentOptions) .useDefaultLocationEngine(true) .build(); Copy Retrieve and activate the LocationComponent once the user has granted location permission and the map has fully loaded. Java Kotlin @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { enableLocationComponent(); } }); } @SuppressWarnings( {""MissingPermission""}) private void enableLocationComponent() { // Check if permissions are enabled and if not request if (PermissionsManager.areLocationPermissionsGranted(this)) { // Get an instance of the component LocationComponent locationComponent = mapboxMap.getLocationComponent(); // Activate with a built LocationComponentActivationOptions object locationComponent.activateLocationComponent(LocationComponentActivationOptions.builder(this, style).build()); // Enable to make component visible locationComponent.setLocationComponentEnabled(true); // Set the component's camera mode locationComponent.setCameraMode(CameraMode.TRACKING); // Set the component's render mode locationComponent.setRenderMode(RenderMode.COMPASS); } else { permissionsManager = new PermissionsManager(this); permissionsManager.requestLocationPermissions(this); } } Copy Showing device location example Add the device's location to the map. Visibility There is a single method to either enable or disable the LocationComponent's visibility after activation. The setLocationComponentEnabled() method requires a true/false boolean parameter. When set to false, this method will hide the device location icon and stop map camera animations from occurring. Java Kotlin locationComponent.setLocationComponentEnabled(true); Copy RenderMode The RenderMode class contains preset options for the device location image. Java Kotlin locationComponent.setRenderMode(RenderMode.NORMAL); Copy There are three types of RenderMode options: RenderMode Description NORMAL This mode shows the device location, ignoring both compass and GPS bearing (no arrow rendered). COMPASS This mode shows the device location, as well as an arrow that is considering the compass of the device. GPS This mode shows the device location with the icon bearing updated from the Location updates being provided to the LocationComponent. Note The actual device location icon is highly customizable with methods such as LocationComponentOptions#foregroundDrawable() and LocationComponentOptions#backgroundDrawable(). CameraMode The method LocationComponent#setCameraMode(@CameraMode.Mode int cameraMode) allows developers to set specific camera tracking instructions as the device location changes. Java Kotlin locationComponent.setCameraMode(CameraMode.TRACKING); Copy There are 7 CameraMode options available: CameraMode Description NONE No camera tracking. NONE_COMPASS Camera does not track location, but does track compass bearing. NONE_GPS Camera does not track location, but does track GPS Location bearing. TRACKING Camera tracks the device location, no bearing is considered. TRACKING_COMPASS Camera tracks the device location, tracking bearing provided by the device compass. TRACKING_GPS Camera tracks the device location, with bearing provided by a normalized Location#getBearing(). TRACKING_GPS_NORTH Camera tracks the device location, with bearing always set to north (0). Here are a few examples from the LocationModesActivity in the Maps SDK's test application: CameraMode.NORMAL CameraMode.COMPASS CameraMode.GPS Traditional camera transitions will be canceled when any of the camera modes, besides CameraMode#NONE, are engaged. Use LocationComponent#zoomWhileTracking and LocationComponent#tiltWhileTracking to manipulate the camera in a tracking state. Use these two in combination with traditional camera transitions and MapboxMap#CancelableCallback to schedule fluid transitions. When instantiating the LocationComponent for the first time, the map's max/min zoom levels will be set toLocationComponentOptions#MAX_ZOOM_DEFAULT and LocationComponentOptions#MIN_ZOOM_DEFAULT respectively. Adjust the zoom range with the LocationComponentOptions#maxZoom() and LocationComponentOptions#minZoom() methods in the LocationComponentOptions class. Gesture thresholds while camera tracking The LocationComponent is integrated with the Mapbox Gestures for Android library. The component will adjust the camera's focal point and increase thresholds to enable camera manipulation, like zooming in and out, without breaking tracking. Enabling this feature is explicitly opt-in because it overwrites custom gestures detection implementation set with MapboxMap#setGesturesManager(AndroidGesturesManager, boolean, boolean). To enable the feature use LocationComponentOptions#trackingGesturesManagement(boolean). You can adjust thresholds that need to be exceeded to break the tracking for one pointer gestures (like panning the map, double-tap to zoom in) and multi-pointer gestures (like scale gesture, two-tap to zoom out): LocationComponentOptions#trackingInitialMoveThreshold(float) adjusts the minimum single pointer movement in pixels required to break camera tracking. LocationComponentOptions#trackingMultiFingerMoveThreshold(float) adjusts minimum multi pointer movement in pixels required to break camera tracking (for example during scale gesture). If either of these thresholds are exceeded and tracking is dismissed, developers can listen to this with a OnCameraTrackingChangedListener: Java Kotlin LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.addOnCameraTrackingChangedListener(new OnCameraTrackingChangedListener() { @Override public void onCameraTrackingDismissed() { // Tracking has been dismissed } @Override public void onCameraTrackingChanged(int currentMode) { // CameraMode has been updated } }); Copy Was this page helpful? Yes No",,Showing device location,Customization,Active styling options,Stale styling options,Activating,Visibility,RenderMode,CameraMode,Gesture thresholds while camera tracking,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Satellite imagery,Learn how satellite imagery works and how to use it in your next Mapbox project.,https://docs.mapbox.com/help/how-mapbox-works/satellite-imagery/,guide,,,"Satellite imagery Mapbox Satellite is a global basemap of high resolution satellite imagery, and Mapbox Satellite Streets combines the Mapbox Satellite basemap with vector data from Mapbox Streets to bring contextual information to your map. The imagery data comes from a variety of commercial providers, as well as open data from NASA, USGS, and others. It is color-corrected and blended together into a single raster tileset. This guide provides an overview of how satellite imagery works and how to use it in your next Mapbox project. Imagery of Tropical Cyclone Debbie off the coast of Australia in the spring of 2017. How satellite imagery works Our satellite imagery comes from a variety of sources as raster data and is processed and composited together by Mapbox. Raster data All satellite imagery is stored in raster format. Rasters are a pixel-based data format that efficiently represent continuous surfaces. Information in a raster is stored in a grid structure with each unit of information, or pixel, having the same size and shape but varying in value. Digital photographs, orthophotography, and satellite images are all stored in this format. Raster formats are well-suited to analyses that look at change over space and time because each data value has an accessible location based on the grid. This allows us to access the same geographic location in two or more different rasters and compare their values. Satellite rasters When Earth-observing satellites take a picture, they read and record reflectance values collected from wavelengths along the electromagnetic spectrum. **Source**: Comparison of wavelength, frequency and energy for the electromagnetic spectrum.” Digital image. The Electromagnetic Spectrum. March 2013. Accessed June 2017. [https://imagine.gsfc.nasa.gov/science/toolbox/emspectrum1](https://imagine.gsfc.nasa.gov/science/toolbox/emspectrum1.html). The human eye can only see a small part of the light-energy that is the electromagnetic spectrum. This is called visible light, because our vision evolved to be most sensitive where the sun emits the most light, and is broadly restricted to wavelengths that make up what we call red, green, and blue. Satellite sensors perceive a far wider range of the electromagnetic spectrum. The ability of sensors to collect information outside of our normal range of vision allows us to make visible the previously invisible. The electromagnetic spectrum has such a wide range it would be impractical for a sensor to collect information from all wavelengths at the same time. Instead, different sensors prioritize the collection of information from different wavelengths of the spectrum. Each section of the spectrum that is captured and categorized by a sensor is categorized as a band of information. Bands of information vary in size and can be compiled into different types of composite images, each emphasizing a distinct physical property. Mapbox Satellite imagery primarily relies on bands 1, 2, and 3 which make up visible red, green, and blue visible light. Satellite sources Mapbox Satellite imagery comes from a variety of sources depending on zoom level and geographic availability: Zoom levels 0-8 use de-clouded data from NASA MODIS satellites. Zoom levels 9-12 use NASA/USGS Landsat 5 & 7 imagery. Zoom levels 13+ use a combination of open and proprietary sources, including Digital Globe for much of the world, USDA’s NAIP 2011–2013 in the contiguous United States, and open aerial imagery from Denmark, Finland, and parts of Germany. This layer is optimized for a balance between recency and aesthetic quality depending on data availability. Before it's added to Mapbox Satellite, all our imagery is color-corrected, optimized, and composited together into a single raster tileset by our Satellite team. For a brief introduction to what this process involves, read our Processing satellite imagery tutorial. While Mapbox Satellite focuses on showing the clearest imagery at the highest resolution possible, we also offer our Landsat Live basemap with the latest global imagery. Landsat Live imagery comes from NASA's Landsat 8 satellite and is captured within the past 16 days. Our live pipeline sources this data from the Landsat on AWS public dataset and has global coverage. Explore our live Landsat tool to see when and where imagery was last refreshed. Using satellite imagery Mapbox satellite is a composite imagery layer with global coverage to zoom 16 (1-2m resolution), regional coverage to zoom 18 (0.6-0.3m resolution), and select coverage to zoom 21+ (7.5cm+). There are several ways you can use Mapbox Satellite in your projects: Add it as a template style in Mapbox Studio. Add Mapbox Satellite as a layer in Mapbox Studio. Use Mapbox Satellite through any of Mapbox's APIs and SDKs with the tileset ID mapbox.satellite. Add Landsat Live imagery to your project using the tileset ID mapbox.landsat-live. Uploading satellite imagery If you have access to imagery that better meets your needs than our Satellite layer, you can upload it using the Mapbox Uploads API or through your Mapbox Studio account. Make sure you convert your imagery into GeoTIFF format before you upload. Once you've uploaded your data, it will be automatically converted into a custom raster tileset which you can then add to your Mapbox project. For more information on uploading satellite imagery, see our Processing satellite imagery tutorial. Tracing satellite imagery Mapbox grants users a license to trace imagery for OpenStreetMap. Producing derivative vector tilesets from imagery for commercial purposes requires is only permitted under a Mapbox Commercial Satellite license. Contact our sales team for more information. Providing satellite feedback If you notice an area where imagery needs improvement or updates for any reason, let us know by leaving your feedback with our imagery request tool. This tool adds your requests to a master list that we consult when prioritizing updates. If you wish to recommend an imagery source, please mention it in your request. Please note that imagery is not improved on a set schedule and is updated when and where it becomes available. Was this page helpful? Yes No",,Satellite imagery,Raster data,Satellite rasters,Satellite sources,Using satellite imagery,Uploading satellite imagery,Tracing satellite imagery,Providing satellite feedback,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Location based games,An overview of location based game use cases.,https://docs.mapbox.com/unity/maps/overview/location-based-games/,guide,,,"Location based games Build the next big location-based game with the Mapbox Maps SDK for Unity. The Mapbox Maps SDK for Unity allows developers to create custom styling for buildings in their Unity projects. Getting started The Mapbox Maps SDK for Unity provides a starting point for location-based games. There are two location-based game example scenes inside of the SDK: Location-based game and Astronaut game. Both make use of the LocationProvider which will automatically use the device GPS to position the game map. You can use the LocationProvider by dropping the LocationBasedGame prefab game object into a scene. It comes configured with the LocationProvider, Map, and Player objects by default. Dragging and dropping the LocationBasedGame prefab into the scene will get you started on your location-based game. If you’re new to Unity, Mapbox, or both, you might find the Pocket Droids GO video tutorial useful. The guide will walk you through creating a Pokemon GO style location based game using Mapbox's location data. Additionally, the Mapbox presentation at Unite Berlin 2108 on how to make a location-based game in 20 minutes contains useful information on creating location aware gaming experiences. Use case ideas Points of interest Once you get a map rendered, the fun begins! Use Mapbox's POI data to have interactions at important locations. For more information on how to spawn game objects on the map, see the documentation on adding markers. Racing games Mapbox's road and building data provide the building blocks to create driving games in any city in the world. You can also use real-time traffic data and navigation inside of your game to make your racer more realistic. To see examples of how vector features can be configured in Unity, see the map features documentation. RPG and strategy games Create custom styles to turn real-world cities into a base map for your strategy or role playing game. Replace buildings with your own custom 3D models, or you can use the default fantasy style building texturing provided in the Maps SDK for Unity. For more information on styling, see the map texturing documentation. Aviation games You can create compelling games using only raster data. Create a top-down fly over game using one of the default styles for your base map. In the video below, Mapbox's satellite imagery provides the background for a fly over aviation game. Notice the realistic shadows and terrain provided by the Mapbox Satellite v9 style. You can also create your own custom style in Mapbox Studio to use in Unity for a custom backdrop for your aviation game. For more information on custom maps in Unity, see the custom style documentation. Augmented reality The Maps SDK for Unity also provides the building blocks for location-based AR games. For example, Space invadAR, Mapbox's demo game, uses vector data from cities around the world to create a fun world-scale AR experience. Game object styling and interaction varies based on the type of POI. For more information on building AR games, see the example scenes in the SDK, and the documentation on AR. Level creation Mapbox has a rich dataset, but for games sometimes too much data can be noisy. Use filters to restrict game play to safe areas or only display specific building types. You can also use road and trail data to create a navmesh for your scene. For example, see how this Mapbox demo makes enemy skeletons NPCs walk paths in a park. Mapbox's location data allows you to have full control to create a fun and safe gaming experience. Build with the Maps SDK for Unity Have an interesting use case or need some help? Join the Mapbox Unity Developer Program or email us for help. Was this page helpful? Yes No",,Location based games,Use case ideas,Points of interest,Racing games,RPG and strategy games,Aviation games,Augmented reality,Level creation,Build with the Maps SDK for Unity,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Change a layer's color with buttons,Using setPaintProperty to change a layer's fill color.,https://docs.mapbox.com/mapbox-gl-js/example/color-switcher/,example,JavaScript,,Change a layer's color with buttons Using setPaintProperty to change a layer's fill color. Was this example helpful? Yes No,,Change a layer's color with buttons,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,China,"Read official documentation on the Mapbox China Plugin for Android, which maximizes the Mapbox Maps SDK for Android's performance inside China.",https://docs.mapbox.com/android/plugins/overview/china/,guide,Java,,"China Traditional map services are either blocked in China or suffer from slow internet connections. Our mapbox.cn infrastructure allows for unparalleled speed advantages for anyone using our maps in China or through Chinese mobile carriers internationally. Built on top of the Mapbox Maps SDK for Android, the plugin automatically configures the Maps SDK to make sure that the correct Mapbox API endpoints are being called. Accurate endpoints make sure that a mobile device retrieves the correct map tiles, map styles, and other location information. Additionally, the plugin handles shifting of various GeoJSON geometries (polygons, lines, points, etc.), which ensures that data is accurately placed on the map. Install the China Plugin You'll need to add the appropriate dependencies inside of your build.gradle file to start developing an application using the China Plugin. The plugin does not include the Mapbox Maps SDK for Android, so you'll need to declare both the Maps SDK and the plugin. Releases of the China Plugin tend to follow new stable releases of the Maps SDK for Android, which happen approximately every four weeks. Add the dependency Start Android Studio. Open up your application's build.gradle file. Make sure that your project's minSdkVersion is API 14 or higher. Add the plugin's dependency to your application's build.gradle file. Add the dependency for the Mapbox Maps SDK, to your application's build.gradle file. More information about installing the Maps SDK. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() maven { url ""https://mapbox.bintray.com/mapbox"" } } dependencies { // China plugin dependency implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-china: 2.2.0 ' // Mapbox Maps SDK dependency implementation 'com.mapbox.mapboxsdk:mapbox-android-sdk: 8.2.1 ' } Shrink dependency size Android offers solutions to reduce the release size of your APK. The first is to use ProGuard, which removes unused classes and methods from both your app and its dependencies (including this plugin). ProGuard is included inside Android and you should follow the official documentation to get ProGuard setup. Another option is to drop the architectures you do not need to support for your app users. The Mapbox SDK ships with four architectures: arm64-v8a armeabi-v7a x86 x86_64 All these files add up to the resulting APK size. If, for example, your app doesn't need x86 support, you could drop x86 and x86_64 to save some space. The plugin does this using ABI Splitting, a feature that lets you build an APK file for each CPU, only containing the relevant native libraries. This process is described in the Android Studio Project Site. Aside from the Mapbox Maps SDK native libraries, the shift module native code will also be dropped and optionally split up if you set your project up to do so. Using the correct objects The plugin has wrapper classes to be used in place of their ""typical"" counterparts. For example, in the Maps SDK for Android, you'd use the MapView inside your activities' layouts. When using this plugin, a lint error will appear telling you to use the ChinaMapView instead, which wraps the MapView object. The ChinaMapView class does nothing more but set default values for optimal performance inside China. This includes requesting map tiles from our Chinese servers. In the chart below, you'll find a list of the objects you'd typically use in the Maps SDK for Android and their counterparts found inside of this plugin. Mapbox Maps SDK for Android China Plugin MapView ChinaMapView SupportMapFragment ChinaSupportMapFragment As mentioned above, Android Lint will try to warn you when you are using the wrong classes. This does not occur in every instance, but, you should manually confirm that you are using the right object each time. China Map Styles Mapbox offers three government-certified map styles for China that match the look of our equivalent Mapbox Streets, Dark, and Light styles. The China styles provide up to 10x faster map loading. You can either manually hardcode the style URL inside your app or use the provided constants found inside this plugin. The table below lists the Java constant and the actual map style URL which can be hardcoded in your app. You will need a special China Mapbox access token if you want to use any of our China map styles.Contact our sales team to start the process of receiving this special access token. Java constant URL ChinaStyle.MAPBOX_STREETS_CHINESE mapbox://styles/mapbox/streets-zh-v1 ChinaStyle.MAPBOX_LIGHT_CHINESE mapbox://styles/mapbox/light-zh-v1 ChinaStyle.MAPBOX_DARK_CHINESE mapbox://styles/mapbox/dark-zh-v1 When using the constants found in this SDK, you'll always be using the latest version of the map style when the plugin gets updated. Conversely, hardcoding allows you to have more control over the map style version and determine when your apps map style gets an update. Shifting raw coordinates The plugin shifts the base map for Mapbox's default styles to follow the Chinese government's mapping requirements. This means you are required to also shift any annotations that you place on top of your map so that they will match the shifted base map coordinate system. The plugin's shifting function will convert WGS84 coordinates into GCJ-02 standards. Read the Restrictions on Geographic Data in China and Why You Can't Trust GPS in China to better understand why shifting is required. The plugin has a ShiftForChina class with the String shift(double lon, double lat) method. You can pass unshifted longitude and latitude coordinates to the shift() method. The method returns a String that is a JSONObject. Use this String of shifted coordinates to add data to your map. Java Kotlin String shiftedCoordinatesJson = shiftForChina.shift(unshiftedLong, unshiftedLat); try { JSONObject jsonObject = new JSONObject(shiftedCoordinatesJson); double shiftedLongitude = jsonObject.getDouble(""lon""); double shiftedLatitude = jsonObject.getDouble(""lat""); // You now have longitude and latitude values, which you can use how you'd like. } catch (JSONException jsonException) { jsonException.printStackTrace(); } Copy Shifting GeoJSON data The plugin's ChinaMapView class will automatically shift GeoJSON coordinates so that data is accurately displayed on China map tiles. The Mapbox Java SDK includes a CoordinateShifter interface which is implemented by the plugin's ChinaCoordinateShifter class. The ChinaCoordinateShifter class helps apply specific coordinate shifting within the Java SDK's Point GeoJSON class, which then gets applied to all the other types of GeoJSON geometries. If your data is already shifted into GCJ-02 coordinates before it is fed to the map, then make sure to use the ChinaMapView's disableGeoJsonShifting() method before any data is given to the map. You don't want pre-shifted data to be shifted again as the map ingests it. Java Kotlin chinaMapView.disableGeoJsonShifting(); Copy Use the enableGeoJsonShifting(CoordinateShifter coordinateShifter) method if you need to enable coordinate shifting. Pass in an object of a class which implements the CoordinateShifter interface. This could be Mapbox's ChinaCoordinateShifter class or a class you've created yourself. A common scenario for enabling shifting could be when shifting is disabled via disableGeoJsonShifting() because pre-shifted data is first added to the map. Shifting is then enabled via enableGeoJsonShifting() before a user is able to interact with the map to add data by tapping on the map to add a marker. Java Kotlin chinaMapView.enableGeoJsonShifting(new ChinaCoordinateShifter()); Copy Shifting device location Rather than working with raw coordinate values, the ShiftLocation class and its shift method handle Location objects. Showing a device's current location via the Maps SDK's LocationComponent is one of the most common use cases for using the ShiftLocation class. After setting up your own Mapbox LocationEngine, you'll eventually override the onSuccess() and onFailure() methods. When a new location update occurs, you'll need to manually feed the unshifted Location object into the ShiftLocation class' shift() method. shift() returns a Location object, which you can now use how you'd like. If you pass the shifted Location object to forceLocationUpdate(), the LocationComponent will place the device location ""puck"" in the correct location. Java Kotlin // Called when the location has changed. @Override public void onSuccess(LocationEngineResult result) { Location shiftedDeviceLocation = ShiftLocation.shift(result.getLastLocation()) locationComponent.forceLocationUpdate(shiftedDeviceLocation) } @Override public void onFailure(@NonNull Exception exception) { // Handle failure with whatever UI you'd like } Copy Was this page helpful? Yes No",,China,Add the dependency,Shrink dependency size,Using the correct objects,China Map Styles,Shifting raw coordinates,Shifting GeoJSON data,Shifting device location,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Add a vector tile source,Add a vector source to a map and display it as a layer.,https://docs.mapbox.com/android/maps/examples/add-a-vector-tile-source/,example,Java,,"Add a vector tile source Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.VectorSourceActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.753574"" mapbox:mapbox_cameraTargetLng=""-122.447303"" mapbox:mapbox_cameraZoom=""13""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineCap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineJoin; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Add a vector source to a map. */ public class VectorSourceActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_vector_style); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource( new VectorSource(""terrain-data"", ""mapbox://mapbox.mapbox-terrain-v2"") ); LineLayer terrainData = new LineLayer(""terrain-data"", ""terrain-data""); terrainData.setSourceLayer(""contour""); terrainData.setProperties( lineJoin(Property.LINE_JOIN_ROUND), lineCap(Property.LINE_CAP_ROUND), lineColor(Color.parseColor(""#ff69b4"")), lineWidth(1f) ); style.addLayer(terrainData); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Add a vector tile source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Share snapshot image,Send and share a map snapshot image.,https://docs.mapbox.com/android/maps/examples/share-a-snapshot/,example,Java,,"Share snapshot image Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:fab=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.536172"" mapbox:mapbox_cameraTargetLng=""126.916954"" mapbox:mapbox_cameraTilt=""60"" mapbox:mapbox_cameraZoom=""9"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/camera_share_snapshot_image_fab"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_margin=""16dp"" fab:fab_size=""normal"" /> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.snapshot; import android.content.Intent; import android.graphics.Bitmap; import android.net.Uri; import android.os.Bundle; import android.os.Environment; import android.os.StrictMode; import androidx.annotation.NonNull; import com.google.android.material.floatingactionbutton.FloatingActionButton; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.snapshotter.MapSnapshot; import com.mapbox.mapboxsdk.snapshotter.MapSnapshotter; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class SnapshotShareActivity extends AppCompatActivity { private MapView mapView; private MapSnapshotter mapSnapshotter; private FloatingActionButton cameraFab; private boolean hasStartedSnapshotGeneration; private Style style; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_snapshot_share); cameraFab = findViewById(R.id.camera_share_snapshot_image_fab); cameraFab.setImageResource(R.drawable.ic_camera); hasStartedSnapshotGeneration = false; mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); // Set a callback for when MapboxMap is ready to be used mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.SATELLITE_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { SnapshotShareActivity.this.style = style; // When user clicks the map, start the snapshotting process with the given parameters cameraFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (!hasStartedSnapshotGeneration) { hasStartedSnapshotGeneration = true; Toast.makeText(SnapshotShareActivity.this, R.string.loading_snapshot_image, Toast.LENGTH_LONG).show(); startSnapShot( mapboxMap.getProjection().getVisibleRegion().latLngBounds, mapView.getMeasuredHeight(), mapView.getMeasuredWidth()); } } }); } }); // To account for new security measures regarding file management that were released with Android Nougat. StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder(); StrictMode.setVmPolicy(builder.build()); } }); } /** * Creates bitmap from given parameters, and creates a notification with that bitmap * * @param latLngBounds of map * @param height of map * @param width of map */ private void startSnapShot(LatLngBounds latLngBounds, int height, int width) { if (!style.isFullyLoaded()) { return; } if (mapSnapshotter == null) { // Initialize snapshotter with map dimensions and given bounds MapSnapshotter.Options options = new MapSnapshotter.Options(width, height).withRegion(latLngBounds).withStyle(style.getUrl()); mapSnapshotter = new MapSnapshotter(SnapshotShareActivity.this, options); } else { // Reuse pre-existing MapSnapshotter instance mapSnapshotter.setSize(width, height); mapSnapshotter.setRegion(latLngBounds); mapSnapshotter.setRegion(latLngBounds); } mapSnapshotter.start(new MapSnapshotter.SnapshotReadyCallback() { @Override public void onSnapshotReady(MapSnapshot snapshot) { Bitmap bitmapOfMapSnapshotImage = snapshot.getBitmap(); Uri bmpUri = getLocalBitmapUri(bitmapOfMapSnapshotImage); Intent shareIntent = new Intent(); shareIntent.putExtra(Intent.EXTRA_STREAM, bmpUri); shareIntent.setType(""image/png""); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); startActivity(Intent.createChooser(shareIntent, ""Share map image"")); hasStartedSnapshotGeneration = false; } }); } private Uri getLocalBitmapUri(Bitmap bmp) { Uri bmpUri = null; File file = new File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), ""share_image_"" + System.currentTimeMillis() + "".png""); FileOutputStream out = null; try { out = new FileOutputStream(file); bmp.compress(Bitmap.CompressFormat.PNG, 90, out); try { out.close(); } catch (IOException exception) { exception.printStackTrace(); } bmpUri = Uri.fromFile(file); } catch (FileNotFoundException exception) { exception.printStackTrace(); } return bmpUri; } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); // Make sure to stop the snapshotter on pause if it exists if (mapSnapshotter != null) { mapSnapshotter.cancel(); } } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,Share snapshot image,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Toggle collision detection,Allow or deny text and icons to overlap and collide.,https://docs.mapbox.com/android/maps/examples/symbol-collision-detection/,example,Java,,"Toggle collision detection Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""36.132522"" mapbox:mapbox_cameraTargetLng=""16.156205"" mapbox:mapbox_cameraZoom=""2.494647"" /> <androidx.cardview.widget.CardView android:id=""@+id/cardView4"" android:layout_width=""match_parent"" android:layout_height=""70dp"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginBottom=""16dp"" mapbox:layout_constraintBottom_toTopOf=""@+id/cardView5"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toStartOf=""parent""> <androidx.constraintlayout.widget.ConstraintLayout android:layout_width=""match_parent"" android:layout_height=""match_parent""> <TextView android:id=""@+id/textView3"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:text=""@string/placement_explanation"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" /> <Switch android:id=""@+id/toggle_text_ignore_placement_switch"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_marginTop=""8dp"" android:layout_marginBottom=""8dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintStart_toStartOf=""@+id/textView3"" mapbox:layout_constraintTop_toBottomOf=""@+id/textView3"" /> </androidx.constraintlayout.widget.ConstraintLayout> </androidx.cardview.widget.CardView> <androidx.cardview.widget.CardView android:id=""@+id/cardView5"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginBottom=""48dp"" mapbox:layout_constraintBottom_toBottomOf=""@+id/mapView"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toStartOf=""parent""> <androidx.constraintlayout.widget.ConstraintLayout android:layout_width=""match_parent"" android:layout_height=""match_parent""> <TextView android:id=""@+id/textView4"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:text=""@string/overlap_explanation"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" /> <Switch android:id=""@+id/toggle_text_ignore_overlap_switch"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_marginTop=""8dp"" mapbox:layout_constraintStart_toStartOf=""@+id/textView4"" mapbox:layout_constraintTop_toBottomOf=""@+id/textView4"" /> </androidx.constraintlayout.widget.ConstraintLayout> </androidx.cardview.widget.CardView> <androidx.cardview.widget.CardView android:id=""@+id/cardView6"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginBottom=""24dp"" mapbox:layout_constraintBottom_toTopOf=""@+id/cardView4"" mapbox:layout_constraintEnd_toEndOf=""@+id/mapView"" mapbox:layout_constraintStart_toStartOf=""@+id/mapView""> <androidx.constraintlayout.widget.ConstraintLayout android:layout_width=""match_parent"" android:layout_height=""match_parent""> <TextView android:id=""@+id/textView5"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:text=""@string/icon_overlap_explanation"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" /> <Switch android:id=""@+id/toggle_icon_ignore_overlap_switch"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_marginTop=""8dp"" mapbox:layout_constraintStart_toStartOf=""@+id/textView5"" mapbox:layout_constraintTop_toBottomOf=""@+id/textView5"" /> </androidx.constraintlayout.widget.ConstraintLayout> </androidx.cardview.widget.CardView> <androidx.cardview.widget.CardView android:layout_width=""395dp"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginBottom=""16dp"" mapbox:layout_constraintBottom_toTopOf=""@+id/cardView6"" mapbox:layout_constraintEnd_toEndOf=""@+id/mapView"" mapbox:layout_constraintStart_toStartOf=""@+id/mapView""> <androidx.constraintlayout.widget.ConstraintLayout android:layout_width=""match_parent"" android:layout_height=""match_parent""> <TextView android:id=""@+id/textView6"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:text=""@string/icon_placement_explanation"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" /> <Switch android:id=""@+id/toggle_icon_ignore_placement_switch"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_marginTop=""8dp"" mapbox:layout_constraintStart_toStartOf=""@+id/textView6"" mapbox:layout_constraintTop_toBottomOf=""@+id/textView6"" /> </androidx.constraintlayout.widget.ConstraintLayout> </androidx.cardview.widget.CardView> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.BitmapFactory; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.CompoundButton; import android.widget.Switch; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.Layer; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.List; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textIgnorePlacement; /** * Use {@link com.mapbox.mapboxsdk.style.layers.PropertyFactory#iconIgnorePlacement(Boolean)}, * {@link com.mapbox.mapboxsdk.style.layers.PropertyFactory#iconAllowOverlap(Boolean)}, * {@link com.mapbox.mapboxsdk.style.layers.PropertyFactory#textIgnorePlacement(Boolean)}, * and {@link com.mapbox.mapboxsdk.style.layers.PropertyFactory#iconAllowOverlap(Boolean)}, * to handle icon and text collisions. */ public class SymbolCollisionDetectionActivity extends AppCompatActivity implements OnMapReadyCallback { private static final String ICON_SOURCE_ID = ""ICON_SOURCE_ID""; private static final String ICON_ID = ""ICON_ID""; private static final String ICON_LAYER_ID = ""ICON_LAYER_ID""; private MapView mapView; private MapboxMap mapboxMap; private List<Feature> symbolLayerIconFeatureList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_symbol_collision); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(final MapboxMap mapboxMap) { initIconCoordinates(); mapboxMap.setStyle(new Style.Builder().fromUri(Style.MAPBOX_STREETS) // Add the SymbolLayer icon image to the map style .withImage(ICON_ID, BitmapFactory.decodeResource( SymbolCollisionDetectionActivity.this.getResources(), R.drawable.red_marker)) // Adding a GeoJson source for the SymbolLayer icons. .withSource(new GeoJsonSource(ICON_SOURCE_ID, FeatureCollection.fromFeatures(symbolLayerIconFeatureList))) // Adding the actual SymbolLayer to the map style. An offset is added that the bottom of the red // marker icon gets fixed to the coordinate, rather than the middle of the icon being fixed to // the coordinate point. This is offset is not always needed and is dependent on the image // that you use for the SymbolLayer icon. .withLayer(new SymbolLayer(ICON_LAYER_ID, ICON_SOURCE_ID) .withProperties(PropertyFactory.iconImage(ICON_ID), iconOffset(new Float[] {0f, -9f})) ), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { SymbolCollisionDetectionActivity.this.mapboxMap = mapboxMap; setUpCheckListener(R.id.toggle_text_ignore_placement_switch, true, false); setUpCheckListener(R.id.toggle_text_ignore_overlap_switch, false, false); setUpCheckListener(R.id.toggle_icon_ignore_placement_switch, false, true); setUpCheckListener(R.id.toggle_icon_ignore_overlap_switch, false, false); } }); } /** * Add a {@link android.widget.CompoundButton.OnCheckedChangeListener} to a switch button and then * use the Maps SDK's runtime-styling to adjust overlap and placement logic. * * @param checkboxId the id of the switch button to add a listener to * @param adjustTextIgnorePlacement whether or not text placement should be ignored * @param adjustIconIgnorePlacement whether or not icon placement should be ignored */ private void setUpCheckListener(int checkboxId, boolean adjustTextIgnorePlacement, boolean adjustIconIgnorePlacement) { Switch switchUi = findViewById(checkboxId); switchUi.setText(getString(R.string.collision_disabled)); switchUi.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean checked) { switchUi.setText(checked ? getString(R.string.collision_enabled) : getString(R.string.collision_disabled)); Layer singleLayer = mapboxMap.getStyle().getLayer(adjustIconIgnorePlacement ? ICON_LAYER_ID : ""country-label""); singleLayer.setProperties( adjustTextIgnorePlacement ? textIgnorePlacement(checked) : textAllowOverlap(checked), adjustIconIgnorePlacement ? iconIgnorePlacement(checked) : iconAllowOverlap(checked) ); } }); } /** * Initialize a list of Features to use to show SymbolLayer icons. */ private void initIconCoordinates() { symbolLayerIconFeatureList = new ArrayList<>(); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(10.338784, 49.481615))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(15.081775, 49.957444))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(11.810747, 50.53269))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(16.308411, 51.35705))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(19.661215, 49.161803))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(16.799065, 46.864746))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(13.364485, 52.764672))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(8.457943, 51.203595))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(12.873831, 51.459068))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(14.836448, 52.814126))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(9.193924, 52.516561))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(12.219625, 47.143578))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(14.182242, 48.893705))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(16.717289, 50.324313))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(22.686916, 45.905823))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(7.967289, 49.904804))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(6.98598, 47.916571))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(18.925233, 44.231107))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(18.843458, 49.957444))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(-17.999544, 62.216028))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(20.151869, 46.415586))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(9.193924, 51.864868))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(16.144859, 48.732152))); symbolLayerIconFeatureList.add(Feature.fromGeometry(Point.fromLngLat(5.105139, 50.324313))); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Toggle collision detection,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,camera,"In maps that use Mapbox GL, the camera is a map's field of view.",https://docs.mapbox.com/help/glossary/camera/,glossary,,,"camera In maps that use Mapbox GL, the camera is the map's field of view. The camera's viewport is determined by the several factors: Center: The coordinates that define the center of the map. Zoom level: A number that determines how close the viewport is to the surface of the map. A zoom level of zero would display the entire world. The higher a zoom level is, the closer the viewport is to the map's surface. Pitch: The angle towards the horizon measured in degrees, with a range between 0 and 60 degrees. Zero degrees results in a two-dimensional map, as if your line of sight forms a perpendicular angle with the earth's surface. Bearing: The destination's angle of rotation, measured in degrees counter-clockwise from north, with a range between 0 and 360 degrees. Was this page helpful? Yes No",,camera,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Embedded Navigation,Navigation in a view which contains other views.,https://docs.mapbox.com/android/navigation/examples/embedded-navigation/,example,Java,,"Embedded Navigation Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <android.support.design.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.services.android.navigation.ui.v5.NavigationView android:id=""@+id/navigationView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:navigationDarkTheme=""@style/NavigationViewDark"" app:navigationLightTheme=""@style/CustomNavigationView""/> <android.support.design.widget.FloatingActionButton android:id=""@+id/fabToggleNightMode"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""top|start"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" android:tint=""@android:color/white"" app:layout_anchor=""@id/spacer"" app:layout_anchorGravity=""top|end"" app:srcCompat=""@drawable/ic_refresh""/> <TextView android:id=""@+id/speed_limit"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""top"" android:layout_marginLeft=""16dp"" android:background=""@android:color/white"" android:elevation=""3dp"" android:gravity=""center"" android:padding=""6dp"" android:textColor=""@android:color/black"" android:textSize=""35sp"" android:visibility=""gone"" app:layout_anchor=""@id/spacer"" app:layout_anchorGravity=""top""/> <View android:id=""@+id/spacer"" android:layout_width=""wrap_content"" android:layout_height=""6dp"" android:layout_gravity=""top"" android:background=""@android:color/transparent"" app:layout_anchorGravity=""top""/> </android.support.design.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.services.android.navigation.testapp.activity.navigationui; import android.content.SharedPreferences; import android.content.res.Configuration; import android.location.Location; import android.os.Bundle; import android.preference.PreferenceManager; import android.support.annotation.IdRes; import android.support.annotation.NonNull; import android.support.annotation.Nullable; import android.support.design.widget.BottomSheetBehavior; import android.support.design.widget.CoordinatorLayout; import android.support.design.widget.FloatingActionButton; import android.support.v7.app.AppCompatActivity; import android.support.v7.app.AppCompatDelegate; import android.text.SpannableString; import android.text.Spanned; import android.text.style.AbsoluteSizeSpan; import android.view.View; import android.widget.TextView; import com.mapbox.api.directions.v5.models.BannerInstructions; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Point; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.services.android.navigation.testapp.R; import com.mapbox.services.android.navigation.ui.v5.NavigationView; import com.mapbox.services.android.navigation.ui.v5.NavigationViewOptions; import com.mapbox.services.android.navigation.ui.v5.OnNavigationReadyCallback; import com.mapbox.services.android.navigation.ui.v5.listeners.BannerInstructionsListener; import com.mapbox.services.android.navigation.ui.v5.listeners.InstructionListListener; import com.mapbox.services.android.navigation.ui.v5.listeners.NavigationListener; import com.mapbox.services.android.navigation.ui.v5.listeners.SpeechAnnouncementListener; import com.mapbox.services.android.navigation.ui.v5.voice.SpeechAnnouncement; import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute; import com.mapbox.services.android.navigation.v5.routeprogress.ProgressChangeListener; import com.mapbox.services.android.navigation.v5.routeprogress.RouteProgress; import retrofit2.Call; import retrofit2.Response; public class EmbeddedNavigationActivity extends AppCompatActivity implements OnNavigationReadyCallback, NavigationListener, ProgressChangeListener, InstructionListListener, SpeechAnnouncementListener, BannerInstructionsListener { private static final Point ORIGIN = Point.fromLngLat(-77.03194990754128, 38.909664963450105); private static final Point DESTINATION = Point.fromLngLat(-77.0270025730133, 38.91057077063121); private static final int INITIAL_ZOOM = 16; private NavigationView navigationView; private View spacer; private TextView speedWidget; private FloatingActionButton fabNightModeToggle; private boolean bottomSheetVisible = true; private boolean instructionListShown = false; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { setTheme(R.style.Theme_AppCompat_Light_NoActionBar); initNightMode(); super.onCreate(savedInstanceState); setContentView(R.layout.activity_embedded_navigation); navigationView = findViewById(R.id.navigationView); fabNightModeToggle = findViewById(R.id.fabToggleNightMode); speedWidget = findViewById(R.id.speed_limit); spacer = findViewById(R.id.spacer); setSpeedWidgetAnchor(R.id.summaryBottomSheet); CameraPosition initialPosition = new CameraPosition.Builder() .target(new LatLng(ORIGIN.latitude(), ORIGIN.longitude())) .zoom(INITIAL_ZOOM) .build(); navigationView.onCreate(savedInstanceState); navigationView.initialize(this, initialPosition); } @Override public void onNavigationReady(boolean isRunning) { fetchRoute(); } @Override public void onStart() { super.onStart(); navigationView.onStart(); } @Override public void onResume() { super.onResume(); navigationView.onResume(); } @Override public void onLowMemory() { super.onLowMemory(); navigationView.onLowMemory(); } @Override public void onBackPressed() { // If the navigation view didn't need to do anything, call super if (!navigationView.onBackPressed()) { super.onBackPressed(); } } @Override protected void onSaveInstanceState(Bundle outState) { navigationView.onSaveInstanceState(outState); super.onSaveInstanceState(outState); } @Override protected void onRestoreInstanceState(Bundle savedInstanceState) { super.onRestoreInstanceState(savedInstanceState); navigationView.onRestoreInstanceState(savedInstanceState); } @Override public void onPause() { super.onPause(); navigationView.onPause(); } @Override public void onStop() { super.onStop(); navigationView.onStop(); } @Override protected void onDestroy() { super.onDestroy(); navigationView.onDestroy(); if (isFinishing()) { saveNightModeToPreferences(AppCompatDelegate.MODE_NIGHT_AUTO); AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_AUTO); } } @Override public void onCancelNavigation() { // Navigation canceled, finish the activity finish(); } @Override public void onNavigationFinished() { // Intentionally empty } @Override public void onNavigationRunning() { // Intentionally empty } @Override public void onProgressChange(Location location, RouteProgress routeProgress) { setSpeed(location); } @Override public void onInstructionListVisibilityChanged(boolean shown) { instructionListShown = shown; speedWidget.setVisibility(shown ? View.GONE : View.VISIBLE); if (instructionListShown) { fabNightModeToggle.hide(); } else if (bottomSheetVisible) { fabNightModeToggle.show(); } } @Override public SpeechAnnouncement willVoice(SpeechAnnouncement announcement) { return SpeechAnnouncement.builder().announcement(""All announcements will be the same."").build(); } @Override public BannerInstructions willDisplay(BannerInstructions instructions) { return instructions; } private void startNavigation(DirectionsRoute directionsRoute) { NavigationViewOptions.Builder options = NavigationViewOptions.builder() .navigationListener(this) .directionsRoute(directionsRoute) .shouldSimulateRoute(true) .progressChangeListener(this) .instructionListListener(this) .speechAnnouncementListener(this) .bannerInstructionsListener(this); setBottomSheetCallback(options); setupNightModeFab(); navigationView.startNavigation(options.build()); } private void fetchRoute() { NavigationRoute.builder(this) .accessToken(Mapbox.getAccessToken()) .origin(ORIGIN) .destination(DESTINATION) .alternatives(true) .build() .getRoute(new SimplifiedCallback() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { DirectionsRoute directionsRoute = response.body().routes().get(0); startNavigation(directionsRoute); } }); } /** * Sets the anchor of the spacer for the speed widget, thus setting the anchor for the speed widget * (The speed widget is anchored to the spacer, which is there because padding between items and * their anchors in CoordinatorLayouts is finicky. * * @param res resource for view of which to anchor the spacer */ private void setSpeedWidgetAnchor(@IdRes int res) { CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) spacer.getLayoutParams(); layoutParams.setAnchorId(res); spacer.setLayoutParams(layoutParams); } private void setBottomSheetCallback(NavigationViewOptions.Builder options) { options.bottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() { @Override public void onStateChanged(@NonNull View bottomSheet, int newState) { switch (newState) { case BottomSheetBehavior.STATE_HIDDEN: bottomSheetVisible = false; fabNightModeToggle.hide(); setSpeedWidgetAnchor(R.id.recenterBtn); break; case BottomSheetBehavior.STATE_EXPANDED: bottomSheetVisible = true; break; case BottomSheetBehavior.STATE_SETTLING: if (!bottomSheetVisible) { // View needs to be anchored to the bottom sheet before it is finished expanding // because of the animation fabNightModeToggle.show(); setSpeedWidgetAnchor(R.id.summaryBottomSheet); } break; default: return; } } @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) { } }); } private void setupNightModeFab() { fabNightModeToggle.setOnClickListener(view -> toggleNightMode()); } private void toggleNightMode() { int currentNightMode = getCurrentNightMode(); alternateNightMode(currentNightMode); } private void initNightMode() { int nightMode = retrieveNightModeFromPreferences(); AppCompatDelegate.setDefaultNightMode(nightMode); } private int getCurrentNightMode() { return getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK; } private void alternateNightMode(int currentNightMode) { int newNightMode; if (currentNightMode == Configuration.UI_MODE_NIGHT_YES) { newNightMode = AppCompatDelegate.MODE_NIGHT_NO; } else { newNightMode = AppCompatDelegate.MODE_NIGHT_YES; } saveNightModeToPreferences(newNightMode); recreate(); } private int retrieveNightModeFromPreferences() { SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this); return preferences.getInt(getString(R.string.current_night_mode), AppCompatDelegate.MODE_NIGHT_AUTO); } private void saveNightModeToPreferences(int nightMode) { SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this); SharedPreferences.Editor editor = preferences.edit(); editor.putInt(getString(R.string.current_night_mode), nightMode); editor.apply(); } private void setSpeed(Location location) { String string = String.format(""%d\nMPH"", (int) (location.getSpeed() * 2.2369)); int mphTextSize = getResources().getDimensionPixelSize(R.dimen.mph_text_size); int speedTextSize = getResources().getDimensionPixelSize(R.dimen.speed_text_size); SpannableString spannableString = new SpannableString(string); spannableString.setSpan(new AbsoluteSizeSpan(mphTextSize), string.length() - 4, string.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE); spannableString.setSpan(new AbsoluteSizeSpan(speedTextSize), 0, string.length() - 3, Spanned.SPAN_INCLUSIVE_INCLUSIVE); speedWidget.setText(spannableString); if (!instructionListShown) { speedWidget.setVisibility(View.VISIBLE); } } } Copy Was this page helpful? Yes No",,Embedded Navigation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,access token,Mapbox uses access tokens to associate your account with your requests to Mapbox API resources.,https://docs.mapbox.com/help/glossary/access-token/,glossary,,,"access token You need a Mapbox access token to use any of Mapbox's tools, APIs, or SDKs. Mapbox uses access tokens to associate your account with your requests to Mapbox API resources. You can find all your access tokens, create new ones, or delete existing ones on your Access tokens page. Here's what an access token looks like in a Mapbox API request (specifically, the Geocoding API): https://api.mapbox.com/geocoding/v5/mapbox.places/Los%20Angeles.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Public vs.secret tokens When you create an access token, you have the choice to give it a set of zero or more scopes. The actions allowed by a token are based on token scopes. They define which Mapbox APIs can be accessed by a token, as well as which methods can be used to access those APIs. Access tokens have either public or secret scopes. Public scopes and tokens Public scopes only allow you to retrieve data from Mapbox APIs. These tokens are safer to put in public applications, since they cannot be used to change data in your account. Tokens with public scopes begin with pk. Once a public token is created, the token can be renamed and public scopes can be added and removed. Secret scopes cannot be added to public tokens. Secret scopes and tokens Secret scopes allow creation and modification access to Mapbox APIs. They also allow access to APIs that may contain account-specific information. These tokens should be used only in secure contexts. Tokens with secret scopes begin with sk. Once you have created a secret token, you can only view it once. If you refresh or navigate away from your Access tokens page, the token itself will disappear, so copy the secret token and store it in a safe place. The token can be renamed and any scopes can be added or removed at any time. The only way to update a secret token is by using the Tokens API. Default Public Token Your account will always have at least one public access token. This token is your Default Public Token. If you refresh this token, it will be deleted and API requests using that token will no longer be authorized. Another public token will become your Default Public Token. When you're logged into your account, this token will automatically be embedded in example code on Mapbox.com. The Tokens API You can also use the Mapbox Tokens API to programmatically create, update, and delete access tokens. Related resources: How do I create an API access token? Tokens API documentation Was this page helpful? Yes No",,access token,Public scopes and tokens,Secret scopes and tokens,Default Public Token,The Tokens API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Draw GeoJSON points,Draw points from a GeoJSON collection to a map.,https://docs.mapbox.com/mapbox-gl-js/example/geojson-markers/,example,JavaScript,,Draw GeoJSON points Draw points from a GeoJSON collection to a map. Was this example helpful? Yes No,,Draw GeoJSON points,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Traffic Data,Access Traffic Data files,Learn how to access Mapbox Traffic Data.,https://docs.mapbox.com/traffic-data/overview/access/,guide,,,"Access Traffic Data files Traffic Data license Access to Mapbox Traffic Data is restricted to Enterprise customers who have purchased a Traffic Data license. Contact Mapbox Sales for more information. File location Mapbox Traffic Data is accessible through AWS S3, in a shared bucket named s3://mapbox-traffic-data-<your-account-name>-shared/. Sample data access If you would like to experiment with a sample data set before contacting Sales, you can download an example of the Mapbox Traffic Data Typical file in the Examples of this documentation. Was this page helpful? Yes No",,Access Traffic Data files,File location,Sample data access,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add live data,Add and update a source that uses real-time data.,https://docs.mapbox.com/ios/maps/examples/live-data/,example,Swift,,"Add live data Swift Objective C import Mapbox class LiveDataExample: UIViewController, MGLMapViewDelegate { var source: MGLShapeSource! var timer = Timer() override func viewDidLoad() { super.viewDidLoad() // Create a new map view using the Mapbox Dark style. let mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.darkStyleURL(withVersion: 9)) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .gray // Set the map view‘s delegate property. mapView.delegate = self view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { if let url = URL(string: ""https://wanderdrone.appspot.com/"") { // Add a source to the map. https://wanderdrone.appspot.com/ generates coordinates for simulated paths. source = MGLShapeSource(identifier: ""wanderdrone"", url: url, options: nil) style.addSource(source) // Add a Maki icon to the map to represent the drone's coordinate. The specified icon is included in the Mapbox Dark style's sprite sheet. For more information about Maki icons, see https://www.mapbox.com/maki-icons/ let droneLayer = MGLSymbolStyleLayer(identifier: ""wanderdrone"", source: source) droneLayer.iconImageName = NSExpression(forConstantValue: ""rocket-15"") droneLayer.iconHaloColor = NSExpression(forConstantValue: UIColor.white) style.addLayer(droneLayer) // Create a timer that calls the `updateUrl` function every 1.5 seconds. timer.invalidate() timer = Timer.scheduledTimer(timeInterval: 1.5, target: self, selector: #selector(updateUrl), userInfo: nil, repeats: true) } } @objc func updateUrl() { // Update the icon's position by setting the `url` property on the source. source.url = source.url } override func viewWillDisappear(_ animated: Bool) { // Invalidate the timer if the view will disappear. timer.invalidate() timer = Timer() } } Copy Was this page helpful? Yes No",,Add live data,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,User interaction,Understand how to listen for user interaction with the Mapbox Navigation UI SDK for Android.,https://docs.mapbox.com/android/navigation/overview/user-interaction/,guide,Java,,"User interaction SDKs covered: Navigation SDK Navigation UI SDK There are several UI elements included in the Navigation UI SDK by default. Below are the default behaviors for each kind of user interaction related to the navigation view and the feedback component. NavigationListener Callback Description onCancelNavigation() Will be triggered when the user clicks on the cancel ""X"" icon while navigating. onNavigationFinished() Will be triggered when MapboxNavigation has finished and the service is completely shutdown. onNavigationRunning() Will be triggered when MapboxNavigation has been initialized and the user is navigating the given route. FeedbackListener Callback Description onFeedbackOpened() Will be triggered when the feedback bottomsheet is opened by a user while navigating. onFeedbackCancelled() Will be triggered when the feedback bottomsheet is opened by a user while navigating but then dismissed without clicking on a specific FeedbackItem in the list. onFeedbackSent(FeedbackItem feedbackItem) Will be triggered when the feedback bottomsheet is opened by a user while navigating and then the user clicks on a specific FeedbackItem in the list. Was this page helpful? Yes No",,User interaction,FeedbackListener,,,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Style lines using an identity property function,Using an identity line-color property function for a visualization.,https://docs.mapbox.com/android/maps/examples/style-lines-using-an-identity-property-function/,example,Java,,"Style lines using an identity property function Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.dds.StyleLineIdentityPropertyActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.82882682974591"" mapbox:mapbox_cameraTargetLng=""-122.48383155304096"" mapbox:mapbox_cameraZoom=""15.3"" /> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.io.InputStream; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.match; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; /** * Use data-driven styling to set a line's color based on imported GeoJSON. */ public class StyleLineIdentityPropertyActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_line); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Retrieve GeoJSON from local file and add it to the map style.addSource(new GeoJsonSource(""lines"", loadGeoJsonFromAsset(""golden_gate_lines.geojson""))); // Create a LineLayer. Use lineColor and stops to draw red and blue lines on the map style.addLayer(new LineLayer(""finalLines"", ""lines"").withProperties( PropertyFactory.lineColor( match(get(""color""), rgb(0, 0, 0), stop(""red"", rgb(247, 69, 93)), stop(""blue"", rgb(51, 201, 235)))), PropertyFactory.visibility(Property.VISIBLE), PropertyFactory.lineWidth(3f) )); } }); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private String loadGeoJsonFromAsset(String filename) { try { // Load GeoJSON file InputStream is = getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (Exception exception) { Timber.e(""Exception Loading GeoJSON: %s"", exception.toString()); exception.printStackTrace(); return null; } } } Copy Was this page helpful? Yes No",,Style lines using an identity property function,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,How to use Mapbox securely,Learn how to use Mapbox securely.,https://docs.mapbox.com/help/troubleshooting/how-to-use-mapbox-securely/,troubleshooting,,,"How to use Mapbox securely Mapbox is critical infrastructure for our customers. We work hard to protect the security of your account, your data, and your users. This guide contains recommendations and resources for building secure applications, keeping your account secure, and where to go to learn more about security at Mapbox. Build secure applications There are a few guidelines you can follow to build more secure applications with Mapbox. Access tokens Manage scopes. Each access token you create will have a set of permissions that allow you to make certain types of requests to Mapbox APIs — these are called scopes. Here are some best practices for access token scopes: A client application (for example, a web application running in your browser) should only use a token with public scopes. Public tokens have read-only access rights to styles. Make all requests requiring a token with secret scopes on a server. Secret token API requests should never be exposed to the client. If you need to do potentially sensitive operations in the client (for example, uploading new data or deleting styles) use the Mapbox Tokens API to generate a temporary token for the specific workload. To protect your account and your data, do not grant more scopes than necessary to each token. For example, if you are creating a token to upload data to Mapbox with the Mapbox Uploads API, you will want to make sure you select the uploads:write and uploads:read scopes. To display a map in a web or mobile application, you should create a separate access token that does not include the secret uploads-related scopes, but does include the public styles:read and fonts:read scopes. Enable URL restrictions. You can make access tokens in your web applications more secure by adding URL restrictions. When you add a URL restriction to a token, that token will only work for requests that originate from the URLs you specify. Tokens without restrictions will work for requests originating from any URL. This feature is compatible with versions of Mapbox GL JS 0.53.1 and greater. Rotate tokens. Any public access tokens you include in a webpage will be visible to anyone who makes an effort to look for it. Access tokens can be deleted and rotated at any time if you suspect misuse. Here are some tips for managing and rotating access tokens: Store tokens in environment variables or application configurations on your server. Generate separate tokens for each application you build. This will make it easier to track usage and identify unexpected activity. Use the Mapbox Tokens API to rotate tokens on a schedule. Keep tokens private. In open source iOS and Android applications, access tokens can be further protected to prevent abuse by other developers: Avoid having access tokens in your open source iOS project's GitHub repository by making them private using Xcode. Avoid having access tokens in your open source Android project's GitHub repository by using a Gradle script. Token analytics. Keeping track of token-specific analytics will help you identify any unexpected usage. Here are some suggestions for tracking usage by access token: Use the Statistics page to browse account usage or usage for a specific access token for a week, month, year, or custom date range. Deploy distinct tokens for each of your applications, which enables you to isolate statistics by tokens for more granular usage tracking. Data security There are different privacy and security settings for different assets within your Mapbox account. Understanding privacy details will help you make the right decision for your situation. Tilesets. Tilesets are public by default. Only users on Enterprise plans can make private tilesets. Here are some details about public and private tilesets: Public tilesets: Public tilesets can be used by any Mapbox user's access token. But another user will need the tileset ID for your tileset to use it with their access token. No central, publicly accessible repository of tilesets exists. If you expose a tileset ID for a public tileset in your client-side code, another Mapbox user could use your tileset, but they would not be able to edit it. Private tilesets: Users with an Enterprise plan can restrict the tilesets you upload to your Mapbox account so they can only be loaded with an access token from the owner of the tileset's account. This means that other users cannot use their access tokens to access your tilesets. Styles. You can make styles public or private regardless of your plan level. When you create a style, it is private by default. Here are some details about public and private styles: Public styles: If a style is public, the style URL can be used by any Mapbox user with their access token. But only the owner of a style can make changes or delete a style, even if it's public. Private styles: If a style is private, the style URL can only be used with an access token from the owner's account. CSP Directives As a mitigation for Cross-Site Scripting and other types of web security vulnerabilities, you may use a Content Security Policy (CSP) to specify security policies for your website. If you do, Mapbox GL JS requires the following CSP directives: child-src blob: ; img-src data: blob: ; script-src 'unsafe-eval' ; Requesting styles from Mapbox or other services will require additional directives. For Mapbox, you can use this connect-src directive: connect-src https://*.tiles.mapbox.com https://api.mapbox.com Mapbox GL JS popups Developers shouldn't allow users to provide arbitrary data (or ""untrusted content"") to popups using setHTML. This method does not include HTML filtering or sanitization, and must be used only with trusted content. Use setText instead for security against XSS if the popup content is user-provided. API requests When retrieving TileJSON metadata with the Tilesets API, use the ?secure parameter to request resources in the response as HTTPS endpoints. Review security bulletins For recent security issues related to all Mapbox products, please see our Security bulletins page. Keep your account secure Keep your Mapbox account secure to protect your data, billing information, and other profile information. Strong passwords Use a strong password to keep your account secure. Keep passwords secret, don't reuse passwords between accounts, and use complex passwords. Consider using a password manager for your Mapbox account. Two-factor authentication You can also set up two-factor authentication for your Mapbox account. Two-factor authentication, also known as multi-factor authentication (MFA) or two-step authentication, provides an optional, but recommended, layer of security to your account. Once enabled, you'll be prompted to enter your password as well as a security code generated by an authentication app on your mobile device whenever you log in. We recommend using Google Authenticator, which is free and available for iOS and Android. For a Windows phone, use the Authenticator app. To learn how to enable two-factor authentication for your account, see the security section of our Account documentation. A recovery code is a single-use code that lets you sign in without your two-factor device. This code will help you gain access to your account in the event that you lose or replace your two-factor device. To use the code, you’ll need your username or email and your password. Find instructions for using a recovery code in our Account documentation Learn about our bug bounty program Mapbox appreciates the effort of software security researchers who work to make the Internet more secure. Our security vulnerability coordination and bug bounty program exist to reward the work of security researchers who find issues with our software and web services. Learn about or report a security issue to our bug bounty program Was this page helpful? Yes No",,How to use Mapbox securely,Access tokens,Data security,CSP Directives,Mapbox GL JS popups,API requests,Review security bulletins,Keep your account secure,Strong passwords,Two-factor authentication,Learn about our bug bounty program,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Analyze data with Turf.js and Mapbox GL JS,"Using Turf.js, add spatial analysis to our map to solve problems. This guide walks through an example of Turf.js and Mapbox GL JS in a real-world context.",https://docs.mapbox.com/help/tutorials/analysis-with-turf/,tutorial,JavaScript,,"intermediate JavaScript Analyze data with Turf.js and Mapbox GL JS Prerequisite Familiarity with front-end development concepts. This guide walks through the basics of Turf.js, a JavaScript library for spatial analysis and statistics, and how to use it to add spatial analysis to your Mapbox GL JS maps. Let's say you are part of a team that manages health and safety for the libraries in Lexington, KY. One important part of your preparedness mandate is to know which hospital is closest to each library in case there's an emergency at one of your facilities. This example will walk you through making a map of libraries and hospitals; when a user clicks on a library, the map will show which hospital is nearest. Getting started There are a few resources you'll need to get started: An access token. The token is used to associate a map with your account. You can find your access tokens on your Access Tokens page and below: mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; Mapbox GL JS. A Mapbox JavaScript API for building maps. Turf.js. Turf is the JavaScript library you'll be using today to add analysis to your map. Data. This example uses two data files: hospitals in Lexington, KY and libraries in Lexington, KY. A text editor. You'll be writing HTML, CSS, and JavaScript. Add structure For this guide, include the latest versions of Mapbox GL JS and Turf.js. Add these libraries to your HTML file by copying the snippet below. <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <script src='https://api.mapbox.com/mapbox.js/plugins/turf/ v3.0.11 /turf.min.js'></script> Now, add your map element. First, in the body, create an empty div for your map. <div id='map'></div> Next, add some CSS to a style element in the head so your map takes up the width of the page. body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } Initialize a map Now that your page has some nice structure to it, go ahead and get a map on the page using Mapbox GL JS. This is where you'll need to use your access token. Add the following script inside the <body> after the HTML. Create a new mapboxgl.Map object called map. In this example, you'll be using the Mapbox Light template style, but you could also use a custom style made with Mapbox Studio. Finally, use center and zoom to set the view on Lexington, KY. mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // container id style: 'mapbox://styles/mapbox/light-v 10 ', // stylesheet location center: [-84.5, 38.05], // starting position zoom: 12 // starting zoom } ); Sweet! Now your page has a map centered on Lexington, KY. Load data As mentioned above, this example uses two data files: libraries and hospitals in Lexington, KY, each of them is a GeoJSON FeatureCollection. In the next step, you'll add them to the style as layers and add code to make sure they're styled differently from each other. var hospitals = { type: 'FeatureCollection', features: [ { type: 'Feature', properties: { Name: 'VA Medical Center -- Leestown Division', Address: '2250 Leestown Rd' } , geometry: { type: 'Point', coordinates: [-84.539487, 38.072916] } } , { type: 'Feature', properties: { Name: 'St. Joseph East', Address: '150 N Eagle Creek Dr' } , geometry: { type: 'Point', coordinates: [-84.440434, 37.998757] } } , { type: 'Feature', properties: { Name: 'Central Baptist Hospital', Address: '1740 Nicholasville Rd' } , geometry: { type: 'Point', coordinates: [-84.512283, 38.018918] } } , { type: 'Feature', properties: { Name: 'VA Medical Center -- Cooper Dr Division', Address: '1101 Veterans Dr' } , geometry: { type: 'Point', coordinates: [-84.506483, 38.02972] } } , { type: 'Feature', properties: { Name: 'Shriners Hospital for Children', Address: '1900 Richmond Rd' } , geometry: { type: 'Point', coordinates: [-84.472941, 38.022564] } } , { type: 'Feature', properties: { Name: 'Eastern State Hospital', Address: '627 W Fourth St' } , geometry: { type: 'Point', coordinates: [-84.498816, 38.060791] } } , { type: 'Feature', properties: { Name: 'Cardinal Hill Rehabilitation Hospital', Address: '2050 Versailles Rd' } , geometry: { type: 'Point', coordinates: [-84.54212, 38.046568] } } , { type: 'Feature', properties: { Name: 'St. Joseph Hospital', ADDRESS: '1 St Joseph Dr' } , geometry: { type: 'Point', coordinates: [-84.523636, 38.032475] } } , { type: 'Feature', properties: { Name: 'UK Healthcare Good Samaritan Hospital', Address: '310 S Limestone' } , geometry: { type: 'Point', coordinates: [-84.501222, 38.042123] } } , { type: 'Feature', properties: { Name: 'UK Medical Center', Address: '800 Rose St' } , geometry: { type: 'Point', coordinates: [-84.508205, 38.031254] } } ] } ; var libraries = { type: 'FeatureCollection', features: [ { type: 'Feature', properties: { Name: 'Village Branch', Address: '2185 Versailles Rd' } , geometry: { type: 'Point', coordinates: [-84.548369, 38.047876] } } , { type: 'Feature', properties: { Name: 'Northside Branch', ADDRESS: '1733 Russell Cave Rd' } , geometry: { type: 'Point', coordinates: [-84.47135, 38.079734] } } , { type: 'Feature', properties: { Name: 'Central Library', ADDRESS: '140 E Main St' } , geometry: { type: 'Point', coordinates: [-84.496894, 38.045459] } } , { type: 'Feature', properties: { Name: 'Beaumont Branch', Address: '3080 Fieldstone Way' } , geometry: { type: 'Point', coordinates: [-84.557948, 38.012502] } } , { type: 'Feature', properties: { Name: 'Tates Creek Branch', Address: '3628 Walden Dr' } , geometry: { type: 'Point', coordinates: [-84.498679, 37.979598] } } , { type: 'Feature', properties: { Name: 'Eagle Creek Branch', Address: '101 N Eagle Creek Dr' } , geometry: { type: 'Point', coordinates: [-84.442219, 37.999437] } } ] } ; map.on('load', function() { map.addLayer( { id: 'hospitals', type: 'symbol', source: { type: 'geojson', data: hospitals } , layout: { 'icon-image': 'hospital-15', 'icon-allow-overlap': true } , paint: { } } ); map.addLayer( { id: 'libraries', type: 'symbol', source: { type: 'geojson', data: libraries } , layout: { 'icon-image': 'library-15' } , paint: { } } ); } ); Note that hospitals layer and libraries layer are added to the map after the map by wrapping them in map.on('load', function() { } ); Add interactivity Your map users will want to know the names of the libraries and hospitals displayed on the map, so next you'll add some popups. For this map, add some popups to these features that appear when the user hovers over the markers. Insert this into your script after you've created hospitals layer and libraries layer. var popup = new mapboxgl.Popup(); map.on('mousemove', function(e) { var features = map.queryRenderedFeatures(e.point, { layers: ['hospitals', 'libraries'] } ); if (!features.length) { popup.remove(); return; } var feature = features[0]; popup.setLngLat(feature.geometry.coordinates) .setHTML(feature.properties.Name) .addTo(map); map.getCanvas().style.cursor = features.length ? 'pointer' : ''; } ); Next you'll make your map of the libraries and hospitals in Lexington even more useful by adding some analysis. Add Turf Turf is a JavaScript library for adding spatial and statistical analysis to your web maps. It contains many commonly-used GIS tools -- like buffer, union, and merge -- as well as statistical analysis functions -- like sum, median, and average. Fortunately, Turf has some functions that will help you out here! You're going to update your map so that clicking on a library will show users which hospital is closest to that library. As a first step, you'll need to add a new source with the id 'nearest-hospital' when the map is loaded. map.addSource('nearest-hospital', { type: 'geojson', data: { type: 'FeatureCollection', features: [ ] } } ); You’ll make an “event handler” for when someone clicks on a library marker. When an event occurs, like a click on a marker, the event handler tells the map what to do in response. Before, you created event handlers for hovering over hospital and library markers; now you’re going to make one for clicks. This is the structure of an event handler; anything you want to happen on click goes inside of the braces { }. In this case, you want to use Turf to identify the nearest hospital to the clicked library and make that marker larger to identify it. map.on('click', function(e) { // Return any features from the 'libraries' layer whenever the map is clicked var libraryFeatures = map.queryRenderedFeatures(e.point, { layers: ['libraries'] } ); if (!libraryFeatures.length) { return; } var libraryFeature = libraryFeatures[0]; // Using Turf, find the nearest hospital to library clicked var nearestHospital = turf.nearest(libraryFeature, hospitals); // If a nearest library is found if (nearestHospital !== null) { // Update the 'nearest-library' data source to include // the nearest library map.getSource('nearest-hospital').setData( { type: 'FeatureCollection', features: [ nearestHospital ] } ); // Create a new circle layer from the 'nearest-library' data source map.addLayer( { id: 'nearest-hospital', type: 'circle', source: 'nearest-hospital', paint: { 'circle-radius': 12, 'circle-color': '#486DE0' } } , 'hospitals'); } } ); Finished product Nicely done! You have successfully created a map that calculates which hospital is closest to each library dynamically. Your finished HTML file should look like this: <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title></title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // container id style: 'mapbox://styles/mapbox/light-v 10 ', // stylesheet location center: [-84.5, 38.05], // starting position zoom: 11 // starting zoom } ); var hospitals = { type: 'FeatureCollection', features: [ { type: 'Feature', properties: { Name: 'VA Medical Center -- Leestown Division', Address: '2250 Leestown Rd' } , geometry: { type: 'Point', coordinates: [-84.539487, 38.072916] } } , { type: 'Feature', properties: { Name: 'St. Joseph East', Address: '150 N Eagle Creek Dr' } , geometry: { type: 'Point', coordinates: [-84.440434, 37.998757] } } , { type: 'Feature', properties: { Name: 'Central Baptist Hospital', Address: '1740 Nicholasville Rd' } , geometry: { type: 'Point', coordinates: [-84.512283, 38.018918] } } , { type: 'Feature', properties: { Name: 'VA Medical Center -- Cooper Dr Division', Address: '1101 Veterans Dr' } , geometry: { type: 'Point', coordinates: [-84.506483, 38.02972] } } , { type: 'Feature', properties: { Name: 'Shriners Hospital for Children', Address: '1900 Richmond Rd' } , geometry: { type: 'Point', coordinates: [-84.472941, 38.022564] } } , { type: 'Feature', properties: { Name: 'Eastern State Hospital', Address: '627 W Fourth St' } , geometry: { type: 'Point', coordinates: [-84.498816, 38.060791] } } , { type: 'Feature', properties: { Name: 'Cardinal Hill Rehabilitation Hospital', Address: '2050 Versailles Rd' } , geometry: { type: 'Point', coordinates: [-84.54212, 38.046568] } } , { type: 'Feature', properties: { Name: 'St. Joseph Hospital', Address: '1 St Joseph Dr' } , geometry: { type: 'Point', coordinates: [-84.523636, 38.032475] } } , { type: 'Feature', properties: { Name: 'UK Healthcare Good Samaritan Hospital', Address: '310 S Limestone' } , geometry: { type: 'Point', coordinates: [-84.501222, 38.042123] } } , { type: 'Feature', properties: { Name: 'UK Medical Center', Address: '800 Rose St' } , geometry: { type: 'Point', coordinates: [-84.508205, 38.031254] } } ] } ; var libraries = { type: 'FeatureCollection', features: [ { type: 'Feature', properties: { Name: 'Village Branch', Address: '2185 Versailles Rd' } , geometry: { type: 'Point', coordinates: [-84.548369, 38.047876] } } , { type: 'Feature', properties: { Name: 'Northside Branch', Address: '1733 Russell Cave Rd' } , geometry: { type: 'Point', coordinates: [-84.47135, 38.079734] } } , { type: 'Feature', properties: { Name: 'Central Library', Address: '140 E Main St' } , geometry: { type: 'Point', coordinates: [-84.496894, 38.045459] } } , { type: 'Feature', properties: { Name: 'Beaumont Branch', Address: '3080 Fieldstone Way' } , geometry: { type: 'Point', coordinates: [-84.557948, 38.012502] } } , { type: 'Feature', properties: { Name: 'Tates Creek Branch', Address: '3628 Walden Dr' } , geometry: { type: 'Point', coordinates: [-84.498679, 37.979598] } } , { type: 'Feature', properties: { Name: 'Eagle Creek Branch', Address: '101 N Eagle Creek Dr' } , geometry: { type: 'Point', coordinates: [-84.442219, 37.999437] } } ] } ; map.on('load', function() { map.addLayer( { id: 'hospitals', type: 'symbol', source: { type: 'geojson', data: hospitals } , layout: { 'icon-image': 'hospital-15', 'icon-allow-overlap': true } , paint: { } } ); map.addLayer( { id: 'libraries', type: 'symbol', source: { type: 'geojson', data: libraries } , layout: { 'icon-image': 'library-15' } , paint: { } } ); map.addSource('nearest-hospital', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } } ); } ); var popup = new mapboxgl.Popup(); map.on('mousemove', function(e) { var features = map.queryRenderedFeatures(e.point, { layers: ['hospitals', 'libraries'] } ); if (!features.length) { popup.remove(); return; } var feature = features[0]; popup.setLngLat(feature.geometry.coordinates) .setHTML(feature.properties.Name) .addTo(map); map.getCanvas().style.cursor = features.length ? 'pointer' : ''; } ); map.on('click', function(e) { var libraryFeatures = map.queryRenderedFeatures(e.point, { layers: ['libraries'] } ); if (!libraryFeatures.length) { return; } var libraryFeature = libraryFeatures[0]; var nearestHospital = turf.nearest(libraryFeature, hospitals); if (nearestHospital !== null) { map.getSource('nearest-hospital').setData( { type: 'FeatureCollection', features: [nearestHospital] } ); map.addLayer( { id: 'nearest-hospital', type: 'circle', source: 'nearest-hospital', paint: { 'circle-radius': 12, 'circle-color': '#486DE0' } } , 'hospitals'); } } ); </script> </body> </html> Next steps Turf has dozens of tools that would help extend this map even further. For example, you could also use turf.distance to determine not only which hospital is closest, but exactly how far away it is. The possibilities are virtually endless with Turf.js! Was this page helpful? Yes No",,Analyze data with Turf.js and Mapbox GL JS,Add structure,Initialize a map,Load data,Add interactivity,Add Turf,Finished product,Next steps,,,,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Create a gradient line using an expression,Use the line-gradient paint property and an expression to visualize distance from the starting point of a line.,https://docs.mapbox.com/mapbox-gl-js/example/line-gradient/,example,JavaScript,,Create a gradient line using an expression Use the line-gradient paint property and an expression to visualize distance from the starting point of a line. Was this example helpful? Yes No,,Create a gradient line using an expression,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,tileset source,This feature is in beta. Tileset sources are line-delimited GeoJSON sources used to create new tilesets using the Tilesets API.,https://docs.mapbox.com/help/glossary/tileset-source/,glossary,,,"tileset source Public beta Tileset sources are in public beta. They are subject to potential changes. A tileset source is raw geographic data formatted as line-delimited GeoJSON and uploaded to Mapbox.com. Learn more about how line-delimited GeoJSON is used by the Tilesets API in the Tileset sources troubleshooting guide. Tileset sources are necessary to use the Tilesets API to create a new vector tileset, and they are referenced via a tileset source ID. The same tileset source can be used across multiple tilesets. Was this page helpful? Yes No",,tileset source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Animate the map camera,"Animate the map's camera position, tilt, bearing, and zoom.",https://docs.mapbox.com/android/maps/examples/animate-the-map-camera/,example,Java,,"Animate the map camera Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.camera.AnimateMapCameraActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""51.50325"" mapbox:mapbox_cameraTargetLng=""-0.11968"" mapbox:mapbox_cameraZoom=""15""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.camera; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; /** * Animate the map's camera position, tilt, bearing, and zoom. */ public class AnimateMapCameraActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private MapView mapView; private MapboxMap mapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_camera_animate); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { AnimateMapCameraActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Toast instructing user to tap on the map Toast.makeText( AnimateMapCameraActivity.this, getString(R.string.tap_on_map_instruction), Toast.LENGTH_LONG ).show(); mapboxMap.addOnMapClickListener(AnimateMapCameraActivity.this); } }); } @Override public boolean onMapClick(@NonNull LatLng point) { // Toast instructing user to tap on the map Toast.makeText( AnimateMapCameraActivity.this, getString(R.string.tap_on_map_instruction), Toast.LENGTH_LONG ).show(); CameraPosition position = new CameraPosition.Builder() .target(new LatLng(51.50550, -0.07520)) // Sets the new camera position .zoom(17) // Sets the zoom .bearing(180) // Rotate the camera .tilt(30) // Set the camera tilt .build(); // Creates a CameraPosition from the builder mapboxMap.animateCamera(CameraUpdateFactory .newCameraPosition(position), 7000); return true; } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,Animate the map camera,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Offline routing,Mapbox offline navigation provides routing functionality from the Navigation SDK for iOS in non-connected environments.,https://docs.mapbox.com/ios/navigation/overview/offline-routing/,guide,,,"Offline routing Downloading offline routing packs Access to offline routing is restricted to Mapbox Enterprise customers. If you're interested in moving to an Enterprise plan, contact us! Mapbox offline navigation provides routing functionality from the Navigation SDK in non-connected environments. In areas of no cellular connectivity, or on a device with no SIM card, end users can use turn-by-turn navigation and request new routes. If they go off-route, the system can reroute and keep them headed to their destination without requiring network connectivity. Offline routing moves the routing engine and the routing data from the server onto the end user’s device, so there’s no need to make HTTP API calls for routing information. Offline routing in the Navigation SDK example app The Mapbox Navigation SDK for iOS includes a basic example of integrating offline routing in the included example app. You can refer to the example app for a complete example of integrating the steps described in this guide. Test offline routing Offline routing is restricted to Enterprise customers, and you need to get an Enterprise API token to download offline routing tiles for arbitrary regions. If you do not have an Enterprise access token but want to try out the feature and begin your integration, you can download routing tiles and generate routes on the Faroe Islands. If you don't have an Enterprise API token and try to download offline routing tiles for any region other than the Faroe Islands, you will receive an HTTP 402 response. Offline maps and offline routing To use offline routing with the Navigation SDK, we recommend that you also download offline map tiles with the Maps SDK for iOS. The Maps SDK enables you to create offline maps, access a list of offline maps stored on the device, and remove offline maps that are no longer needed. Or, you can allow your users to build up a local cache of map tiles passively as they use your app, but we recommend downloading offline map tiles for the optimal user experience. For more information on how to download offline maps, see the Offline maps documentation in the Maps SDK for iOS API reference. Integrate offline routing in your app Integrating offline routing in your app involves a few steps: Retrieve a list of available routing tile versions. To use offline routing, your application will need to download routing data from Mapbox. (Note that only Enterprise customers can download offline routing packs.) This routing data can be downloaded via the SDK by using the NavigationDirections.fetchAvailableOfflineVersions(completionHandler:). Retrieve the latest offline routing tiles for a region. The most recent version returned from the previous call should be passed into NavigationDirections.downloadTiles(in:version:session:completionHandler:). If you receive an HTTP 422 error, this means you are attempting to retrieve a region that is too large. Reduce the size of the requested region or split the request into batches. Note that Directions.downloadTiles(in:version:session:completionHandler:) only downloads routing tiles, not map tiles. Routing tiles do not correspond to a particular zoom level. Instead, road geometries are included at full resolution. Unpack the routing tiles onto local storage. Use NavigationDirections.unpackTilePack(at:outputDirectoryURL:progressHandler:completionHandler:) to unpack the routing tiles you downloaded onto local storage. Initialize the offline router. Once the routing data is downloaded and unpacked onto local storage, you will be able to make routing requests with the new NavigationDirections. Initialize the offline router with a pointer to the local location of the offline routing tiles, and store it on an instance variable or property with a strong reference. Example use Swift Objective C // create a directions client and store it as a property self.navigationDirections = NavigationDirections(accessToken: ""foo"") // fetch available routing tile versions self.navigationDirections.fetchAvailableOfflineVersions { (versions, error) in let coordinateBounds = CoordinateBounds(southWest: CLLocationCoordinate2DMake(0, 0), northEast: CLLocationCoordinate2DMake(1, 1)) // download tiles using the most recent version self.navigationDirections.downloadTiles(in: coordinateBounds, version: versions.first, completionHandler: { (url, response, error) in guard let url = url else { return assert(false, ""Unable to locate temporary file"") } let outputDirectory = Bundle.mapboxCoreNavigation.suggestedTileURL(for: version) try? FileManager.default.createDirectory(at: outputDirectory, withIntermediateDirectories: true, attributes: nil) // unpack downloaded routing tiles NavigationDirections.unpackTilePack(at: url, outputDirectory: outputDirectory!, progressHandler: { (totalBytes, bytesRemaining) in // Show unpacking progress }, completionHandler: { (result, error) in // configure the offline router with the output directory where the tiles have been unpacked self.navigationDirections.configureRouter(tilesURL: outputDirectory) { (numberOfTiles) in // Completed, dismiss UI } }) }).resume() }.resume() Copy Depending on your use case, it may be appropriate to pass true or false into the call to NavigationDirections.calculate(_:offline:completionHandler:). For example, it may be preferable for some applications to run fully offline, while others may prefer to retrieve directions from the server with up-to-date traffic information when possible. Rerouting If a reroute happens, you will need to use the offline mechanism to calculate a new route: Implement NavigationViewControllerDelegate.navigationViewController(_:shouldRerouteFrom:) or MapboxNavigationService.router(_:shouldRerouteFrom:). Return false. Start calculating the route offline using directions.calculate(options, offline:true) and update the route accordingly. Example use navigationViewController.navigationService.route = newRoute When the SDK detects that the user has diverged from the route, the offline navigator will offer a new route to their original destination. Having routing data on the client device means new routes are generated without having to go back to the server to calculate and retrieve a route. As long as the user is still within the boundaries of the offline routing data, they can trigger a re-route event or request a new route anywhere within the dataset. Estimated local storage and memory benchmarks The device will need to store both the routing data and the map data needed for visual display. For more information on managing offline download size, see the Mobile offline troubleshooting guide. Local storage estimates The road network density of given geographic areas varies widely, but we have provided a list of benchmark estimates below, created via a bounding box encompassing the region listed. This table shows non-compressed estimates since the data will need to be uncompressed on disk for faster routing. Download sizes will be smaller after compression. Example region size Routing data Map data (z1-7,12) Washington, DC 41MB 120B San Francisco (city and county) 57MB 20MB California 377MB 400MB New York (state) 475MB 300MB USA (minus HI and AK) 3.8GB 5GB United Kingdom 663MB 290MB Memory estimates For a typical route calculation in a geographic area, the amount of memory needed will vary depending on the complexity of route generation in that area. The following estimates were created using data from some of the largest cities to give a worst-case value. Region size RAM needed San Francisco (city and county) 100MB California 150MB USA (minus HI and AK) 250MB Was this page helpful? Yes No",,Offline routing,Test offline routing,Offline maps and offline routing,Integrate offline routing in your app,Example use,Rerouting,Estimated local storage and memory benchmarks,Local storage estimates,Memory estimates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add multiple shapes from a single shape source,Create style layers from a shape collection feature.,https://docs.mapbox.com/ios/maps/examples/shape-collection/,example,Swift,,"Add multiple shapes from a single shape source Download metro-line.geojson and add it to your project. For more information on styling data at runtime, see our Information for style authors guide. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.styleURL = MGLStyle.lightStyleURL mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .darkGray mapView.setCenter(CLLocationCoordinate2D(latitude: 38.897435, longitude: -77.039679), zoomLevel: 12, animated: false) mapView.delegate = self view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { // Parse the GeoJSON data. DispatchQueue.global().async { guard let url = Bundle.main.url(forResource: ""metro-line"", withExtension: ""geojson"") else { preconditionFailure(""Failed to load local GeoJSON file"") } guard let data = try? Data(contentsOf: url) else { preconditionFailure(""Failed to decode GeoJSON file"") } DispatchQueue.main.async { try? self.drawShapeCollection(data: data) } } } func drawShapeCollection(data: Data) throws { guard let style = self.mapView.style else { return } // Use [MGLShape shapeWithData:encoding:error:] to create a MGLShapeCollectionFeature from GeoJSON data. guard let feature = try? MGLShape(data: data, encoding: String.Encoding.utf8.rawValue) as? MGLShapeCollectionFeature else { fatalError(""Could not cast to specified MGLShapeCollectionFeature"") } // Create source and add it to the map style. let source = MGLShapeSource(identifier: ""transit"", shape: feature, options: nil) style.addSource(source) // Create station style layer. let circleLayer = MGLCircleStyleLayer(identifier: ""stations"", source: source) // Use a predicate to filter out non-points. circleLayer.predicate = NSPredicate(format: ""TYPE = 'Station'"") circleLayer.circleColor = NSExpression(forConstantValue: UIColor.red) circleLayer.circleRadius = NSExpression(forConstantValue: 6) circleLayer.circleStrokeWidth = NSExpression(forConstantValue: 2) circleLayer.circleStrokeColor = NSExpression(forConstantValue: UIColor.black) // Create line style layer. let lineLayer = MGLLineStyleLayer(identifier: ""rail-line"", source: source) // Use a predicate to filter out the stations. lineLayer.predicate = NSPredicate(format: ""TYPE = 'Rail line'"") lineLayer.lineColor = NSExpression(forConstantValue: UIColor.red) lineLayer.lineWidth = NSExpression(forConstantValue: 2) // Add style layers to the map view's style. style.addLayer(circleLayer) style.insertLayer(lineLayer, below: circleLayer) } } Copy Was this page helpful? Yes No",,Add multiple shapes from a single shape source,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Basic navigation app,Add basic navigation functionality to an iOS application.,https://docs.mapbox.com/ios/navigation/examples/basic/,example,Swift,,"Basic navigation app import Foundation import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections class BasicViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let origin = CLLocationCoordinate2DMake(37.77440680146262, -122.43539772352648) let destination = CLLocationCoordinate2DMake(37.76556957793795, -122.42409811526268) let options = NavigationRouteOptions(coordinates: [origin, destination]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) let navigationOptions = NavigationOptions(navigationService: navigationService) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) self.present(navigationViewController, animated: true, completion: nil) } } } Copy Was this page helpful? Yes No",,Basic navigation app,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Directions API,"With the Mapbox Directions API, you can add routing with turn-by-turn directions to your map.",https://docs.mapbox.com/help/glossary/directions-api/,glossary,,,"Directions API The Mapbox Directions API produces turn-by-turn instructions using four different Mapbox routing profiles: mapbox/driving-traffic, mapbox/driving, mapbox/walking, and mapbox/cycling. A sample Directions API request looks like: https://api.mapbox.com/directions/v5/mapbox/driving/-122.42,37.78;-77.03,38.91?access_token= YOUR_MAPBOX_ACCESS_TOKEN The Directions API has optional parameters that can be used to refine the results of a request. Related resources: Directions API documentation Getting started with the Directions API tutorial Mapbox GL JS example using the mapbox-gl-directions plugin for the Directions API Was this page helpful? Yes No",,Directions API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Vector tiles,Mapbox Boundaries v2,Reference documentation for the Boundaries v2 tileset.,https://docs.mapbox.com/vector-tiles/reference/mapbox-boundaries-v2/,reference,,,"Mapbox Boundaries v2 Access to Mapbox Boundaries Access to the Mapbox Boundaries tilesets are controlled by Mapbox account access token. If you do not have access on your account, contact a Mapbox sales representative to request access to Boundaries tilesets. Overview The Mapbox Boundaries vector tiles do not directly contain detailed feature properties such as names or parent boundary information. Such detailed data is delivered separately as offline lookup tables, allowing the vector tiles to stay small and fast. For more details on how to make use of Boundaries for data visualizations, see our getting started tutorial. Tilesets Mapbox Boundaries is composed of 15 separate tilesets, each with their own map ID. There are two types of tilesets: tilesets containing line features and tilesets containing polygon features. For area tilesets, the hierarchy is designed such that levels with lowest numbers generally contain the polygons with the largest areas and levels with the highest numbers contain the polygons with the smallest areas. Some other notes about tileset hierarchy: Administrative levels are anchored to the a0 layer which contains the top-level polygon of each area which contains an ISO 3166-1 code. Postal levels are anchored on the p4 level which is defined as ""Full-detail"" or ""The minimum required number of digits to send mail"". Tileset ID Description mapbox.enterprise-boundaries-a0-v2 States or territories that have ISO 3166-1 codes, plus Kosovo mapbox.enterprise-boundaries-a1-v2 First-level administrative areas mapbox.enterprise-boundaries-a2-v2 Second-level administrative areas mapbox.enterprise-boundaries-a3-v2 Third-level administrative areas mapbox.enterprise-boundaries-a4-v2 Fourth-level administrative areas mapbox.enterprise-boundaries-a5-v2 Fifth-level administrative areas mapbox.enterprise-boundaries-aL-v2 Administrative division lines for all levels mapbox.enterprise-boundaries-p1-v2 Postal code grouping areas mapbox.enterprise-boundaries-p2-v2 Postal code grouping areas mapbox.enterprise-boundaries-p3-v2 Postal code grouping areas mapbox.enterprise-boundaries-p4-v2 Full-detail postal code areas mapbox.enterprise-boundaries-s1-v2 First-level statistical areas mapbox.enterprise-boundaries-s2-v2 Second-level statistical areas mapbox.enterprise-boundaries-s3-v2 Third-level statistical areas mapbox.enterprise-boundaries-s4-v2 Fourth-level statistical areas Geometry types Each layer in Enterprise Boundary tilesets will contain one of 3 geometry types: Point Linestring / multilinestring Polygon / multipolygon Area Layer Reference boundaries_ { type } _ { level } Each area tileset has a layer named boundaries_ { type } _ { level }, where { type } is one of admin, postal, or stats, and { level } is a number 0 through 5. The { type } and { level } values correspond to the given tileset. id text The id field provides an identifier string for each feature. These IDs are globally unique within a given “worldview”; some are duplicated but only where they represent different versions of the same feature for different worldviews. worldview text The vector tiles contain multiple versions of some boundaries, each with a worldview value indicating the intended audience. It is important to apply a worldview filter to all your admin style layers, otherwise your map will show conflicting and overlapping boundary lines. The filter should always include both all and one of the region-specific values. Value Description all Appropriate for all worldviews (most boundaries). CN Boundaries for a mainland Chinese audience/worldview, but not officially approved for use in the PRC. IN Boundaries conforming to cartographic requirements for use in India. US Boundaries for an American audience, & which are generally appropriate outside of China & India. (Lines do not necessarily reflect official US foreign policy.) points_ { type } _ { level } Each area tileset has a layer named points_ { type } _ { level }, where { type } is one of admin, postal, or stats, and { level } is a number 0 through 5. The { type } and { level } values correspond to the given tileset. The points_* layers contain approximate center points corresponding to the polygons in the boundaries_* layers. They can be used for labeling or for visualizations using symbols. Points are generally available one zoom level lower than the polygons they correspond to. The point layers have the same two id and worldview fields as the area layers with the same meaning. Administrative Line Layer Reference boundaries_admin_lines The administrative lines tileset contains a single layer containing boundary lines for all administrative levels (a0 through a5). id text Boundary line IDs are usually composed by combining the IDs of the polygons from either side of the line (sorted alphanumerically & separated by a hyphen). admin_level text The admin_level is a number from 0 through 5 representing the lowest-numbered administrative level the boundary is a part of. disputed text Boundary lines with a disputed value of true should have a dashed or otherwise distinct style applied in styles. No single map of the world will reflect all global perspectives, but acknowledging disputes where they exist is an important aspect of good cartography. The value will always be either true or false (never null). coastal text The coastal field contains the text true or false indicating whether the boundary is along a coast or not. Most coastal boundaries are omitted from the line layer, so the values are nearly always false. parent_0 text For boundaries with an admin_level of 1 through 5, the parent_0 value contains the id of the level 0 area that contains the boundary. For boundaries with an admin_level of 0, the parent_0 is the same as the line id. worldview text Same as areas and points; see documentation above. Was this page helpful? Yes No",,Mapbox Boundaries v2,Tilesets,Geometry types,Area Layer Reference,boundaries_{type}_{level},id text,worldview text,points_{type}_{level},Administrative Line Layer Reference,boundaries_admin_lines,admin_level text,disputed text,coastal text,parent_0 text,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Understanding Android APK size,Learn how to measure and optimize your Android app’s size.,https://docs.mapbox.com/help/troubleshooting/android-apk-size/,troubleshooting,,,"Understanding Android APK size The Mapbox Maps SDK for Android is a complex and powerful framework, but it only contributes 3–4 megabytes to the ultimate size of your application. Here are a few suggested strategies for reducing the final Android app APK size when the app uses the Mapbox Maps SDK for Android. Shrink code and resources Forgotten code, menus, images, strings, and more can pile up, but your final APK might not use them all. ProGuard and DexGuard, even without obfuscation, will remove unused Java code from your code and its dependencies. Don't forget to check for and set up necessary ProGuard rules if you're using other third-party libraries! Adding shrinkResources to your app-level gradle file will remove unused resource files that live in the /res folder. Adding minifyEnabled runs ProGuard to shrink code by deleting unused code and other references. Set both to true. Both are quick wins in making sure that your compiled project only includes what it truly needs. android { ... buildTypes { release { minifyEnabled true shrinkResources true ... } } } Drop unnecessary architectures The Mapbox Maps SDK ships with three architectures: ./arm64-v8a/libmapbox-gl.so ./x86/libmapbox-gl.so ./x86_64/libmapbox-gl.so Each of these files add up to the resulting APK. If your app doesn't need x86 support, for example, you could drop x86 and x86_64 to save some space. See Leverage ABI splits below for details. Leverage ABI splits This is a feature that lets you build an APK file for each CPU, only containing the relevant native libraries. This process is described in the Android Studio Project Site. If you distribute your app via Google Play, you can use this approach through the Multiple APK Support distribution feature. Leveraging APK splits is one of the tips we give users when it comes to shrinking their APK size. Splitting results in building different APK for the different supported ABIs in an application. Google Play is optimized to only download the APK for the ABI of the device that is installing the app. Mapbox publishes an Android demo app to the Google Play store that showcases core SDK features. This app is open source and uses APK splitting for smaller binary distribution. You can learn how we do this in the build.gradle file. Find more information about multiple APKs in the Android Studio documentation. Contribute The Mapbox team is actively looking at other ways to reduce the SDK size (for example). If you have questions or ideas that you'd like to share, please get in touch with us. Was this page helpful? Yes No",,Understanding Android APK size,Drop unnecessary architectures,Leverage ABI splits,Contribute,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Build a store locator for Android,Build a store locator to integrate into an Android application.,https://docs.mapbox.com/help/tutorials/android-store-locator/,tutorial,Java,,"advanced Java Build a store locator for Android Prerequisite Familiarity with Android Studio and Java. This guide will walk you through how to use our Android Store Locator starter kit to create a custom store locator map that can be integrated into any Android application. You'll be able to browse several store locations, select a specific store to view more information, and retrieve an estimated travel distance and route from a user's location to any of the store locations. You can start with one of five different themes and customize everything from store location data to marker icons and individual store cards. Getting started Here's what you'll need to start building a store locator for Android: Starter kit files. Download or clone the Android Store Locator starter kit from GitHub. This includes all the necessary files for a functional Android Studio project. Android Studio 3.0. You will need to use the starter kit files with a version of Android Studio that is 3.0 or higher. If you try to run your application and receive an Error running android: Gradle project sync failed. Please fix your project and try again, verify that you’re using a version of Android Studio that is 3.0 or higher. Mapbox access token. You will use an access token to associate a map with your account and you can find it on the Account page. An Android device (physical or virtual). You will need either a physical Android device or an emulated Android device to preview the store locator. Note: the device’s Android SDK version number must be 16 (“Jelly Bean”) or higher. Optional: Android Drawable Importer. If you plan to add custom images to your application (for example, custom icons for markers at store locations), install the Android Drawable Importer plugin to add images to your project. Optional: SVG editing tool. If you'd like to create custom layouts or icons, you can use a program like Sketch, Figma, or Adobe Illustrator. Set up the starter kit After you've downloaded the Android Store Locator starter kit from GitHub, open the project in Android Studio 3.0 Beta. In the project, you’ll find all the source files for the entire app, including: Five UI theme variations. Sample GeoJSON data with store locations. Code for retrieving directions with the Mapbox Directions API and displaying a navigation route line on the map. Access token Before running the application, you will need to add your Mapbox access token to the strings.xml file. You can find this file in app > src > main > res > values. strings.xml <!-- Add your Mapbox access token between >< in the line below. Your token can be retrieved at https://www.mapbox.com/account/ --> <string name=""access_token"" translatable=""false""> YOUR_MAPBOX_ACCESS_TOKEN </string> MapActivity The MapActivity.java file is the primary place you'll adjust code. This activity can be found by navigating to app > src > main > java > com > mapbox > storelocator > activity. This is the file where you’ll customize your app by: Selecting a theme to start with. Setting the map's style URL. Choosing the marker icons. Customizing other UI elements and colors as needed. Note The starter kit files include detailed inline comments that tell you what customizations are possible. Choose a theme Once you have the starter kit set up, start by picking a theme. Unless adjusted, the theme picker activity will be the first thing you see when the app is launched. Choose a theme by clicking on the preview image for one of five themes made by our mobile designers. Once you’ve selected your theme, remove this activity before adding the MapActivity.java file to your final app: Delete the file — ThemePickerActivity.java is in the same directory as the MapActivity.java file (app > src > main > java > com > mapbox > storelocator > activity). Remove the ThemePickerActivity from the app’s manifest file and move the launcher intent filter to the MapActivity (or any other activity you'd like to first open when the app is launched): Manifest.xml <intent-filter> <action android:name=""android.intent.action.MAIN""/> <category android:name=""android.intent.category.LAUNCHER""/> </intent-filter> Adjust the MapActivity.java file so it no longer initializes the chosenTheme object via getIntent().getIntExtra(*SELECTED_THEME*, R.style.*AppTheme_Blue*);. Instead, set it equal to whichever theme you chose: MapActivity.java chosenTheme = R.style.YOUR_CHOSEN_THEME; // Example of a theme: AppTheme_Blue Once you've made these changes, run your app again. You should see the map using your chosen theme and some store location data. In the next step, you'll add your own data with store locations. Add your data The starter kit contains a GeoJSON file called list_of_locations.geojson where you’ll find all the current store locations that are visible on the map. GeoJSON is a file format for geospatial data and a subset of the JSON format. In this section, you'll update the sample data to reflect your actual store locations. Locate the list_of_locations.geojson file in app > src > main > assets. Take a look at how the data is formatted. Notice that each store location is a separate GeoJSON feature in the file. Each feature has four properties describing a few characteristics about the store location and geometry specifying that the feature is a single point and where that point is located in the world. You can replace the data with your own store data. If you have store location data available in GeoJSON form, you can delete the current data and replace it with your own. Note: If your data contains different properties than the default data, you will need to update the related code in both the MapActivity.java file and the LocationRecyclerViewAdapter class. We recommend using geojson.net to quickly validate and visualize your GeoJSON. If you don't have your store data in GeoJSON format, you can create a new GeoJSON file using the Mapbox Studio dataset editor. In this example, you'll create a dataset with store locations for Jeni's Splendid Ice Cream locations in the Columbus, Ohio area using the Mapbox Studio dataset editor, export a GeoJSON file, replace the GeoJSON data in the list_of_locations.geojson, adjust the bounding box and mock user location, and run your app to see the new store locations. Create a dataset If you already have a GeoJSON file of store locations, you can skip ahead to the Replace data section. There are several ways to create a new GeoJSON file. In this guide you'll use the Mapbox Studio dataset editor, a convenient in-browser application for creating and editing Mapbox datasets. In this guide, you'll use known addresses for Jeni's locations to search and add store locations to your dataset. First, create a new dataset: Log into Mapbox Studio and navigate to the Datasets page. Click the New dataset button. A new window will open. You'll use the Blank dataset option in the upper right corner. Name your dataset ""ice-cream"" and click Create. The dataset editor will automatically open. Next, you'll begin adding stores. You can use the geocoder in the dataset editor to search for a place and the draw tools to add a new point to your dataset. You can change the geometry, placement, and properties of existing features with the dataset editor’s draw tools. Click inside the Search places field and type 3998 Gramercy St, Columbus, Ohio. Click the address that matches your search in the search results. Click the Add to dataset button to add that address to your dataset. Click on the new feature and use the properties list on the left hand side to: Change the place_name field to description. Add the field name name and give it the value Easton. Add the field name hours and give it the value 11 a.m. to 11 p.m.. Add the field name phone and give it the value 614-476-5364. You could go through this process for each known store address. After you've added each store location, you can Save, return to the Datasets page, click the button next to the name of your ""ice-cream"" dataset, and click Download GeoJSON. In the interest of time, for this guide, we've provided the complete GeoJSON below for you to use in the next step: { ""features"": [ { ""type"": ""Feature"", ""properties"": { ""description"": ""3998 Gramercy St, Columbus, Ohio 43219, United States"", ""name"": ""Easton"", ""hours"": ""11 a.m. to 11 p.m."", ""phone"": ""614-476-5364"" } , ""geometry"": { ""coordinates"": [ -82.917665, 40.051791 ], ""type"": ""Point"" } , ""id"": ""address.11780104298749790"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""714 N High St, Columbus, Ohio 43215, United States"", ""name"": ""North Market"", ""hours"": ""10 a.m. to 5 p.m."", ""phone"": ""614-228-9960"" } , ""geometry"": { ""coordinates"": [ -83.00418, 39.971888 ], ""type"": ""Point"" } , ""id"": ""address.1504101080777130"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""900 Mohawk St, Columbus, Ohio 43206, United States"", ""name"": ""German Village"", ""hours"": ""Noon to 10 p.m."", ""phone"": ""614-445-6513"" } , ""geometry"": { ""coordinates"": [ -82.992495, 39.944236 ], ""type"": ""Point"" } , ""id"": ""address.18662160207305960"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""1 W Bridge St, Dublin, Ohio 43017, United States"", ""name"": ""Dublin"", ""hours"": ""11 a.m. to 11 p.m."", ""phone"": ""614-792-5364"" } , ""geometry"": { ""coordinates"": [ -83.114164, 40.099224 ], ""type"": ""Point"" } , ""id"": ""address.3847501076015100"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""2156 E Main St, Columbus, Ohio 43209, United States"", ""name"": ""Bexley"", ""hours"": ""11 a.m. to 11 p.m."", ""phone"": ""614-231-5364"" } , ""geometry"": { ""coordinates"": [ -82.941956, 39.957461 ], ""type"": ""Point"" } , ""id"": ""address.5795414383633980"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""714 N High St, Columbus, Ohio 43215, United States"", ""name"": ""Short North"", ""hours"": ""11 a.m. to 11 p.m."", ""phone"": ""614-294-5364"" } , ""geometry"": { ""coordinates"": [ -83.003353, 39.976965 ], ""type"": ""Point"" } , ""id"": ""address.748502797349860"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""160 S High St, Columbus, Ohio 43215, United States"", ""name"": ""The Commons"", ""hours"": ""11 a.m. to 8 p.m."", ""phone"": ""614-867-5512"" } , ""geometry"": { ""coordinates"": [ -82.999991, 39.958812 ], ""type"": ""Point"" } , ""id"": ""address.7894313840035430"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""1281 Grandview Ave, Columbus, Ohio 43212, United States"", ""name"": ""Grandview Heights"", ""hours"": ""11 a.m. to 11 p.m."", ""phone"": ""614-488-2680"" } , ""geometry"": { ""coordinates"": [ -83.045003, 39.983947 ], ""type"": ""Point"" } , ""id"": ""address.8328248295013750"" } , { ""type"": ""Feature"", ""properties"": { ""description"": ""8 N Liberty St, Powell, Ohio 43065, United States"", ""name"": ""Powell"", ""hours"": ""11 a.m. to 11 p.m."", ""phone"": ""614-846-1060"" } , ""geometry"": { ""coordinates"": [ -83.074985, 40.158137 ], ""type"": ""Point"" } , ""id"": ""address.8508074803994320"" } ], ""type"": ""FeatureCollection"" } Replace data Open the list_of_locations.geojson file. Delete the current contents and add the GeoJSON data from the previous step. The data that's provided in the sample code and in this example contain four properties for each store location: name description hours phone Since all the feature properties are identical to the four that were used in the initial GeoJSON data, your map will be fully functional immediately. If you have different information you would like to display as properties, you will need to update the related code in both the MapActivity.java file and the LocationRecyclerViewAdapter class. Update bounding box and location The MapActivity.java file specifies that the map be centered on New York when the app is initialized. Replace the current code with the following code snippets to update the location to Columbus, Ohio. First, change the target latitude and longitude when the app is initialized to center on Columbus in the app > res > layout > activity_map.xml file. activity_map.xml mapbox:mapbox_cameraTargetLat=""39.95"" mapbox:mapbox_cameraTargetLng=""-83"" Then, change the bounding box so the map opens displaying the Columbus area in the MapActivity.java file. MapActivity.java private static final LatLngBounds LOCKED_MAP_CAMERA_BOUNDS = new LatLngBounds.Builder() .include(new LatLng(40.1746, -83.1426)) .include(new LatLng(39.9278, -82.8814)) .build(); Finally, change the simulated user location to be near Columbus in the MapActivity.java file. MapActivity.java private static final LatLng MOCK_DEVICE_LOCATION_LAT_LNG = new LatLng(40, -83); Run the application, and you will see the map focused on Columbus, Ohio. Display distances and routes The starter kit uses the Mapbox Directions API to display estimated travel distances and routes. Once you’ve updated the GeoJSON data for store locations and the mock location, the Mapbox Directions API will automatically read your GeoJSON file to retrieve the distances and routes to each of your locations. The code that specifies how the Directions API is used can be found in the MapActivity.java file. Add custom markers You can use any image as a marker — you can use an emoji (like in the starter kit files), create your own icon, use your company's logo, or use an icon from several open source resources. Here are some recommended resources for finding marker icons: Maki icons by Mapbox Flat Icon Get Emoji In this guide, you'll use an icon from the open source project, Flat Icon. This icon, made by Eucalyp from www.flaticon.com, is licensed by CC 3.0 BY. You can download an image this icon on a white marker or download another icon from Flat Icon. When using icons from Flat Icon, be sure to credit the author appropriately. Download the icon on a white marker As mentioned in the getting started section, we recommend installing and using the Android Drawable Importer plugin to add images to your project. This plugin automatically scales and adds the image to a drawable folder for each screen size (MDPI, XHDPI, XXHDPI, etc). Add a new image to your project After installing the Android Drawable Importer plugin and downloading the icon that you would like to use for the store location markers, add the image to the app > res > drawable folder. Right-click on the drawable folder, hover over the New menu item, in the sub menu choose Batch Drawable Importer. Note: This option will only be available after installing the Android Drawable Importer. In the window that opens, click the + and choose your file. Another window will open. In this window, take note of the Target-name that is assigned to the image. For the guide, use the name new_ice_cream_icon and click Ok. In the first window, you can also click Ok. Notice that a new folder has been added to the drawable folder. It is named new_ice_cream_icon, the Target-name from the importer process, and contains several files — your new image optimized for various screens. Use the new image as a marker Now that you've successfully imported a new image, change the code that specifies what image should be used in the markers for each store location. The code that specifies which image to use for store markers lives in the MapActivity.java file. To change the image to the new_ice_cream_image: Open MapActivity.java. Find private void initializeTheme() { }. Within that method, find case R.style.AppTheme_Blue:. This is the code that specifies the styles for markers, routes, and mock user location. For both unselectedMarkerIcon and selectedMarkerIcon change R.drawable.ice_cream_icon to R.drawable.new_ice_cream_icon. Run the application again, and you should see new ice cream icon markers at all store locations. Customize card icons Besides customizing the look of the map, you can also customize the style of the cards for each store. Next you'll change the icon shown on the scrolling cards. This example swaps out the ice cream icon for a photo of a child enjoying an ice cream cone from the incredible open source project, Unsplash. The original image has been cropped and modified to an image size of 105px x 105px. Download the image Import the image Following the same process described in the section above, add the new scrolling card image to your project using the Android Drawable Importer plugin. Use the Target-name ice_cream_kid. Use the new image on the scrolling card Now that you've successfully imported a new image, change the code that specifies what image should be used in the scrolling cards. The code for the cards lives in the single_location_map_view_rv_card.xml layout. In this file you can adjust the style (including the spacing, location, and size) of different elements on the cards. This single card layout is given to the ReyclerView.java adapter, and this adapter eventually creates the scrollable list of cards at the bottom of your device’s screen. To change the image used in the scrolling cards you'll need to pass through your desired drawable when the emojiForCircle object is initialized in the onBindViewHolder() method of the LocationRecyclerViewAdapter class: Open the ReyclerView.java file in app > java > adapter. Find switch (selectedTheme) { }. Within that method, find case R.style.AppTheme_Blue:. This is the code that specifies the styles for the information shown on the scrolling cards. Set emojiForCircle equal to ResourcesCompat.getDrawable(context.getResources(), R.drawable.ice_cream_kid, null); Delete backgroundCircle = ResourcesCompat.getDrawable(context.getResources(), R.drawable.blue_circle, null);. Run the application again, and you should see the new image on the scrolling cards. Final product You've learned how the Android Store Locator starter kit works and modified a few of the key customizable elements of a store locator. Next steps Take a look at the Mapbox Maps SDK for Android documentation and examples to learn more about customizing your application or adding additional functionality. If you're interested in creating your own custom map style to replace the designer themes provided in the Store Locator starter kit, learn how to use Mapbox Studio to build a style that fits your brand with the Create a custom style tutorial. Was this page helpful? Yes No",,Build a store locator for Android,Set up the starter kit,Access token,MapActivity,Choose a theme,Add your data,Create a dataset,Replace data,Update bounding box and location,Display distances and routes,Add custom markers,Add a new image to your project,Use the new image as a marker,Customize card icons,Import the image,Use the new image on the scrolling card,,3,Final product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Help,Find resources to help you build with Mapbox.,https://docs.mapbox.com/help/,,,,"How can we help? Most viewed articles Add custom icons or markers How access tokens work Create a custom style Upload data to Mapbox Static API playground Categories How Mapbox works Learn how the Mapbox platform works. Tutorials Find a step-by-step guide to help you get started or take your project to the next level. Interactive tools Experiment with Mapbox tools. Troubleshooting Resolve common issues across Mapbox products. Accounts and pricing Browse frequently asked questions about Mapbox accounts, billing, and security issues. Glossary Find Mapbox-related terms and their definitions. Can't find the answer you're looking for? Contact support Looking for developer documentation? Documentation",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Geocoding API,"The Mapbox Geocoding API performs two main tasks, forward geocoding and reverse geocoding.",https://docs.mapbox.com/help/glossary/geocoding-api/,glossary,,,Geocoding API The Mapbox Geocoding API allows you to perform forward and reverse geocoding operations. A sample forward Geocoding API request looks like: https://api.mapbox.com/geocoding/v5/mapbox.places/San%20Francisco.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Related resources: Geocoding API documentation How Mapbox works: Geocoding Sort stores by distance tutorial Local search with the Geocoding API tutorial Was this page helpful? Yes No,,Geocoding API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Join local JSON data with vector tile geometries,Style a choropleth map by merging local JSON data with vector tile geometries.,https://docs.mapbox.com/android/maps/examples/join-local-json-data-with-vector-tile-geometries/,example,Java,,"Join local JSON data with vector tile geometries Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.dds.ChoroplethJsonVectorMixActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""38.00312"" mapbox:mapbox_cameraTargetLng=""-98.398423"" mapbox:mapbox_cameraZoom=""1""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.AsyncTask; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.Scanner; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.match; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgba; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.toNumber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; /** * Style a choropleth map by merging local JSON data with vector tile geometries */ public class ChoroplethJsonVectorMixActivity extends AppCompatActivity implements OnMapReadyCallback { private static final String STATE_UNEMPLOYMENT_INFO_JSON_FILE = ""state_unemployment_info.json""; private static final String VECTOR_SOURCE_NAME = ""states""; private static final String DATA_MATCH_PROP = ""STATE_ID""; private static final String DATA_STYLE_UNEMPLOYMENT_PROP = ""unemployment""; private MapView mapView; private MapboxMap mapboxMap; private JSONArray statesArray; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the account manager setContentView(R.layout.activity_choropleth_json_vector_mix); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap map) { this.mapboxMap = map; map.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Add Mapbox-hosted vector source for state polygons style.addSource(new VectorSource(VECTOR_SOURCE_NAME, ""mapbox://mapbox.us_census_states_2015"")); new LoadJson(ChoroplethJsonVectorMixActivity.this).execute(); } }); } /** * Create layer from the vector tile source with data-driven style * * @param stops the array of stops to use in the FillLayer */ private void addDataToMap(@NonNull Expression.Stop[] stops) { FillLayer statesJoinLayer = new FillLayer(""states-join"", VECTOR_SOURCE_NAME); statesJoinLayer.setSourceLayer(VECTOR_SOURCE_NAME); statesJoinLayer.withProperties( fillColor(match(toNumber(get(DATA_MATCH_PROP)), rgba(0, 0, 0, 1), stops)) ); // Add layer to map below the ""waterway-label"" layer if (mapboxMap != null) { mapboxMap.getStyle(style -> style.addLayerAbove(statesJoinLayer, ""waterway-label"")); } } private static class LoadJson extends AsyncTask<Void, Void, Expression.Stop[]> { private WeakReference<ChoroplethJsonVectorMixActivity> weakReference; private static final String TAG = ""ChJSonVectorMix""; LoadJson(ChoroplethJsonVectorMixActivity activity) { this.weakReference = new WeakReference<>(activity); } @Override protected Expression.Stop[] doInBackground(Void... voids) { try { ChoroplethJsonVectorMixActivity activity = weakReference.get(); if (activity != null) { InputStream inputStream = activity.getAssets().open(STATE_UNEMPLOYMENT_INFO_JSON_FILE); activity.statesArray = new JSONArray(convertStreamToString(inputStream)); // Create stops array Expression.Stop[] stops = new Expression.Stop[activity.statesArray.length()]; for (int x = 0; x < activity.statesArray.length(); x++) { try { // Generate green color value for each state/stop JSONObject singleState = activity.statesArray.getJSONObject(x); double green = singleState.getDouble(DATA_STYLE_UNEMPLOYMENT_PROP) / 14 * 255; // Add new stop to array of stops stops[x] = stop( Double.parseDouble(singleState.getString(DATA_MATCH_PROP)), rgba(0, green, 0, 1) ); } catch (JSONException exception) { throw new RuntimeException(exception); } } return stops; } } catch (Exception exception) { Timber.d(""Exception Loading GeoJSON: %s"", exception.toString()); } return null; } static String convertStreamToString(InputStream is) { Scanner scanner = new Scanner(is).useDelimiter(""\\A""); return scanner.hasNext() ? scanner.next() : """"; } @Override protected void onPostExecute(@Nullable Expression.Stop[] stopsArray) { super.onPostExecute(stopsArray); ChoroplethJsonVectorMixActivity activity = weakReference.get(); if (activity != null && stopsArray != null) { activity.addDataToMap(stopsArray); } } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Join local JSON data with vector tile geometries,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Places,"Read docs on the Mapbox Places Plugin for Android. Easily search destinations, explore what's nearby, or find favorite restaurants, coffee shops, or stores.",https://docs.mapbox.com/android/plugins/overview/places/,guide,Java,,"Places The Places Plugin for Android lets users search for a destination, explore what's nearby, or find their favorite restaurants, coffee shops, or stores. Built on top of the Mapbox Geocoding API, the plugin offers UI components that you can integrated inside your app with a few lines of code. Search options Mapbox provides two options for adding location search into your Android application: Java SDK: The Java SDK includes a Java wrapper for building Mapbox Geocoding API requests. Use the API response in your Java or Android project. Read more in the Java SDK documentation. Places Plugin for Android: This plugin is a wrapper around the Mapbox Java SDK's Geocoding API that also provides a search UI. View the Places Plugin example and place picker example. Each option provides a different set of features: Feature Java SDK Places Plugin Foward geocoding Reverse geocoding Access to raw Geocoding API response Drop-in search bar UI Built-in dropdown list of search results Place picker View results in a separate activity or fragment Note Both the Java SDK and the Places Plugin enable you to make forward and reverse geocoding queries to the Mapbox Geocoding API, but the two differ in their flexibility and the query methods. As a reminder, a forward geocoding query converts a text query into geographic coordinates. Reverse geocoding turns geographic coordinates into geographical information (for example, address, place name, place category, and geometry type). Install the Places Plugin To start developing an application using the Places Plugin, you'll need to add the appropriate dependencies inside your build.gradle file. This dependency includes the Maps SDK for Android and the Mapbox Java SDK's Geocoding API. You can find all dependencies given below on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-places- v8. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-places- v8 : 0.9.0 ' } Add Autocomplete The Autocomplete UI component offers users the ability to search addresses or places and receive information including the latitude and longitude, phone number, categories, and plenty of other information. As the user types, place predictions display at once to the user along with any searched places. There are two ways to use the Autocomplete service: Launch as an activity for result Display as a fragment Launch as an activity for result If a separate search activity makes sense in your application, you can use the PlaceAutocomplete class to build your intent and then launch the included search activity using startActivityForResult. Using this intent builder, you pass in the required access token along with a placeOptions object. Java Kotlin Intent intent = new PlaceAutocomplete.IntentBuilder() .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .placeOptions(placeOptions) .build(this); startActivityForResult(intent, REQUEST_CODE_AUTOCOMPLETE); Copy When the user finishes selecting a place inside the autocomplete activity, finish() will be called. To receive the CarmenFeature which describes the place the user selected, override the onActivityResult method, check that the request and result codes are correct, and use the PlaceAutocomplete static method getPlace passing in the intent. Java Kotlin @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == Activity.RESULT_OK && requestCode == REQUEST_CODE_AUTOCOMPLETE) { CarmenFeature feature = PlaceAutocomplete.getPlace(data); Toast.makeText(this, feature.text(), Toast.LENGTH_LONG).show(); } } Copy Display as a fragment If you need more control over the UI and would like to place the Autocomplete component inside an activity container, you can use the provided PlaceAutocompleteFragment to include the search UI. This class extends the Support Library Fragment implementation, which means the SupportFragmentManager should be used. In the code snippet provided below, it checks to make sure no more than one autocompleteFragment instance is always being used. If there isn't an instance of autocompleteFragment, it creates a new one and adds it to the container. If there is, it displays the autocompleteFragment to the user using the TAG. Java Kotlin PlaceAutocompleteFragment autocompleteFragment; if (savedInstanceState == null) { autocompleteFragment = PlaceAutocompleteFragment.newInstance(""<access_token>""); final FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); transaction.add(R.id.fragment_container, autocompleteFragment,TAG); transaction.commit(); } else { autocompleteFragment = (PlaceAutocompleteFragment) getSupportFragmentManager().findFragmentByTag(TAG); } Copy To listen for when the user selects a place or cancels out of the autocompleteFragment, you can set a PlaceSelectionListener on the fragment and the callback will be invoked when the event occurs. Java Kotlin autocompleteFragment.setOnPlaceSelectedListener(new PlaceSelectionListener() { @Override public void onPlaceSelected(CarmenFeature carmenFeature) { Toast.makeText(AutocompleteFragmentActivity.this, carmenFeature.text(), Toast.LENGTH_LONG).show(); finish(); } @Override public void onCancel() { finish(); } }); Copy Customize Autocomplete results Create a PlaceOptions object to customize the Autocomplete search results and the UI component. Once your PlaceOptions object's created you'll need to pass it in either by using the PlaceAutocompleteFragment.newInstance(<access token>, placeOptions); if you are using the fragment or new PlaceAutocomplete.IntentBuilder().placeOptions(placeOptions) otherwise. Customize search results You can narrow the search results based on the following parameters: API Description proximity Bias local results based on a provided GeoJSON Point. This oftentimes increases accuracy in the returned results. limit Limit the number of results returned. The default is 10. bbox Limit results to a bounding box. geocodingTypes This optionally can be set to filter the results returned inside the suggestions. country Limit results to one or more countries. injectedPlaces Optionally inject Carmen Features into the suggestion view so users can access points of interest quickly without typing a single character. Typical places include, the users home, work, or favorite POI. Customize the UI component There are two modes to further change the Autocomplete component UI to fit your app better: Full screen mode: will place all the search history, results, and injected places into a view which has a width equal to the app width. Card view mode: the place search history, results, and injected places in an Android Support Library CardView. API Description backgroundColor Set the autocomplete's layout background color. toolbarColor Set the autocomplete's layout toolbar color. This only applies if the mode is set to full screen. Add suggestions When users are searching for places inside your app, oftentimes, they have a few places that are visited often and thus searched. Make things simpler for them by adding specific place suggestions such as their home, work, or favorite restaurant. This feature can also be used to insert store locations, or popular places your app is advertising. To get started, you'll need to first get or create the CarmenFeature which describes this place. See an example of creating a CarmenFeature below which only includes the necessary information for your app, neglecting the large amount of additional information you could provide to describe the location. Java Kotlin CarmenFeature work = CarmenFeature.builder().text(""Directions to Work"") .geometry(Point.fromLngLat(1.0, 2.0)) .placeName(""300 Massachusetts Ave NW"") .id(""directions-work"") .properties(new JsonObject()) .build(); Copy Once this is done, you will need to pass this feature into the PlaceOptions object using either the addInjectedFeature() or injectedPlaces() methods. Clear search history Typically found inside any application which offers search history like the places plugin does by default, they will also need to occasionally clear the search history. It's recommended to add a setting in your apps preferences to do this. If the user request clearing of the search history, you can use the static method provided inside the PlaceAutocomplete class called clearRecentHistory() which will clear all the data from the saved database at once. Java Kotlin PlaceAutocomplete.clearRecentHistory(this); Copy Place Picker The Autocomplete UI component described above, searches for a place based on an address or name. The Place Picker UI component retrieves information about a selected map location. With the Place Picker, you can launch an activity for result and provide your users with a way to pick a visual location on the map. The result returned is a CarmenFeature, which can be used to get information such as the coordinate, place name, address, phone number, and more. To begin, create the Place Picker IntentBuilder, which builds an intent ready to be launched by the startActivityForResult method. Java Kotlin private static final int PLACE_SELECTION_REQUEST_CODE = 56789 ... Intent intent = new PlacePicker.IntentBuilder() .accessToken(Mapbox.getAccessToken()) .placeOptions( PlacePickerOptions.builder() .statingCameraPosition( new CameraPosition.Builder() .target(new LatLng(40.7544, -73.9862)) .zoom(16) .build()) .build()) .build(this); startActivityForResult(intent, PLACE_SELECTION_REQUEST_CODE); Copy Override the onActivityResult() method and extract information from the CarmenFeature: Java Kotlin @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE && resultCode == RESULT_OK){ // Retrieve the information from the selected location's CarmenFeature CarmenFeature carmenFeature = PlacePicker.getPlace(data); } } Copy If you'd like to show the Place Picker UI without any geocoding information, use the PlacePickerOptions class' includeReverseGeocode() method. This method takes a boolean parameter and if false is passed through, no geocoding call will be made. The selected location's coordinates will be returned in the onActivityResult callback, rather than a geocoding result's CarmenFeature. You might want an app user to choose a precise location. For example, the user needs to choose a place on the map to share with friends. But, as an app developer, you don't care about the geocoding metadata associated with those coordinates. Your app needs a way for a user to pick the place so that the coordinates can be used. A new geocoding call happens every time the map is moved with the Place Picker Plugin. These constant geocoding calls are billed to your Mapbox account. Using includeReverseGeocode(false) would provide the UI that you truly need and save you money. PlaceOptions for Place Picker Besides some of the options listed in the PlaceOptions documentation above, the Place Picker includes options for setting the initial map camera position. This is useful when you want the map location to start at the user's current location. Was this page helpful? Yes No",,Places,Install the Places Plugin,Add the dependency,Add Autocomplete,Launch as an activity for result,Display as a fragment,Customize Autocomplete results,Customize search results,Customize the UI component,Add suggestions,Clear search history,Place Picker,PlaceOptions for Place Picker,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,SVG,Scalable Vector Graphics (SVG) is a markup language for describing two-dimensional vector graphics.,https://docs.mapbox.com/help/glossary/svg/,glossary,,,SVG Scalable Vector Graphics (SVG) is a markup language for describing two-dimensional vector graphics. You can upload SVG images to your custom style in the Mapbox Studio style editor. You can click on the Images option in the top toolbar to manage the SVGs in your style. See SVG asset errors in Mapbox Studio for more information. Download sample SVG image Was this page helpful? Yes No,,SVG,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Overview,"Browse information about Mapbox accounts, billing, and security.",https://docs.mapbox.com/help/account/,guide,,,"Accounts and pricing Browse information about Mapbox accounts, billing, and security. Overview Learn how to navigate your Mapbox accounts page, understand how usage is measured, and how billing works. Account page Your Account page contains all the information and preferences related to your Mapbox account. It's also where you: Create and manage your access tokens, which enable you to use Mapbox tools, including our mobile SDKs and APIs. Read more in Token management. View statistics and gain insights into how your applications are being used by tracking the number of mobile users, API requests, and map loads associated with the applications using your access tokens. Read more in Statistics and usage. View, print, and add additional information (for example, your address) to your Pay-as-you-go invoices. Read more in Invoices and billing. Manage general account settings including profile information (like your organization name, email address, and avatar), your password, two-factor authentication, payment information for your account, and more. Read more in Settings and account management. Pricing by product Read more about how your unique workflows and applications translate to usage and invoice line items in the Pricing by product section. Related resources Learn terms related to accounts and billing in the Glossary. The Glossary includes terms like map load, monthly active users, and more. Get answers about access tokens, learn how to interpret your usage, and more in our Troubleshooting guides. Read reference documentation for the Tokens API in our API documentation. Was this page helpful? Yes No",,Overview,Pricing by product,Related resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Camera animation,Animate camera movement.,https://docs.mapbox.com/ios/maps/examples/camera-animation/,example,Swift,,"Camera animation Read the MGLMapView documentation to learn more about the many other approaches that can be used to manipulate a map's viewport. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.delegate = self mapView.styleURL = MGLStyle.outdoorsStyleURL // Mauna Kea, Hawaii let center = CLLocationCoordinate2D(latitude: 19.820689, longitude: -155.468038) // Optionally set a starting point. mapView.setCenter(center, zoomLevel: 7, direction: 0, animated: false) view.addSubview(mapView) } func mapViewDidFinishLoadingMap(_ mapView: MGLMapView) { // Wait for the map to load before initiating the first camera movement. // Create a camera that rotates around the same center point, rotating 180°. // `fromDistance:` is meters above mean sea level that an eye would have to be in order to see what the map view is showing. let camera = MGLMapCamera(lookingAtCenter: mapView.centerCoordinate, altitude: 4500, pitch: 15, heading: 180) // Animate the camera movement over 5 seconds. mapView.setCamera(camera, withDuration: 5, animationTimingFunction: CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)) } } Copy Was this page helpful? Yes No",,Camera animation,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,source layer,A source layer is an individual layer within a source.,https://docs.mapbox.com/help/glossary/source-layer/,glossary,,,"source layer A source layer is a specific layer within a vector source. A vector source can have multiple layers. Although it has a similar name, a source layer is different from the kind of layer found in a style, which is used to add styling rules to specific subsets of data. There are a few places you can find the name of a source layer: The tileset information page for a specific tileset. In the Mapbox Studio style editor using the Select data tab. In the Mapbox Studio style editor using the Layer overview option in the top toolbar's Settings tab. Tileset information page To find a source layer within a tileset: Visit your Tilesets page. Click the name of one of your tilesets. The tileset information page will open, and you can find your source layers below the Layer details heading. Select data in the Mapbox Studio style editor To find the name of source layers used in Mapbox styles: Open the style in the Mapbox Studio style editor. Click on the name of the layer in the layer list. Switch to the Select data tab. Find the source layer listed below the name of the tileset source. In the example below, the layer is named place-city-label-major and the source layer is the place_label layer within the Mapbox Streets tileset source. Layer overview in the Mapbox Studio style editor To find the name of source layers used in Mapbox styles: Open the style in the Mapbox Studio style editor. Click on the Settings button in the top toolbar. Scroll down to Layer overview section. In the example below, landuse_overlay is a source layer and national_park is a style layer. Was this page helpful? Yes No",,source layer,Select data in the Mapbox Studio style editor,Layer overview in the Mapbox Studio style editor,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Jump to a series of locations,Use the jumpTo function to showcase multiple locations.,https://docs.mapbox.com/mapbox-gl-js/example/jump-to/,example,JavaScript,,Jump to a series of locations Use the jumpTo function to showcase multiple locations. Was this example helpful? Yes No,,Jump to a series of locations,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Mark a place on the map with an annotation,Add a default marker with a callout and title using the Mapbox Maps SDK for iOS.,https://docs.mapbox.com/ios/maps/examples/marker/,example,Swift,,"Mark a place on the map with an annotation To learn about more ways to add points to a map, see the Markers and annotations guide. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 40.7326808, longitude: -73.9843407), zoomLevel: 12, animated: false) view.addSubview(mapView) // Set the delegate property of our map view to `self` after instantiating it. mapView.delegate = self // Declare the marker `hello` and set its coordinates, title, and subtitle. let hello = MGLPointAnnotation() hello.coordinate = CLLocationCoordinate2D(latitude: 40.7326808, longitude: -73.9843407) hello.title = ""Hello world!"" hello.subtitle = ""Welcome to my marker"" // Add marker `hello` to the map. mapView.addAnnotation(hello) } // Use the default marker. See also: our view annotation or custom marker examples. func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? { return nil } // Allow callout view to appear when an annotation is tapped. func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { return true } } Copy Was this page helpful? Yes No",,Mark a place on the map with an annotation,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Custom server,Generate a route using third-party data.,https://docs.mapbox.com/ios/navigation/examples/custom-server/,example,Swift,,"Custom server import Foundation import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections class CustomServerViewController: UIViewController { let routeOptions = NavigationRouteOptions(coordinates: [ CLLocationCoordinate2DMake(37.77440680146262, -122.43539772352648), CLLocationCoordinate2DMake(37.76556957793795, -122.42409811526268) ]) var navigationViewController: NavigationViewController? override func viewDidLoad() { super.viewDidLoad() Directions.shared.calculate(routeOptions) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) let navigationOptions = NavigationOptions(navigationService: navigationService) self.navigationViewController = NavigationViewController(for: route, options: navigationOptions) self.navigationViewController?.delegate = self self.present(self.navigationViewController!, animated: true, completion: nil) } } } extension CustomServerViewController: NavigationViewControllerDelegate { // Never reroute internally. Instead, // 1. Fetch a route from your server // 2. Map Match the coordinates from your server // 3. Set the route on your server func navigationViewController(_ navigationViewController: NavigationViewController, shouldRerouteFrom location: CLLocation) -> Bool { // Here, we are simulating a custom server. let routeOptions = NavigationRouteOptions(waypoints: [Waypoint(location: location), self.routeOptions.waypoints.last!]) Directions.shared.calculate(routeOptions) { (waypoints, routes, error) in guard let routeCoordinates = routes?.first?.coordinates, error == nil else { print(error!.localizedDescription) return } // // ❗️IMPORTANT❗️ // Use `Directions.calculateRoutes(matching:completionHandler:)` for navigating on a map matching response. // let matchOptions = NavigationMatchOptions(coordinates: routeCoordinates) // By default, each waypoint separates two legs, so the user stops at each waypoint. // We want the user to navigate from the first coordinate to the last coordinate without any stops in between. // You can specify more intermediate waypoints here if you’d like. for waypoint in matchOptions.waypoints.dropFirst().dropLast() { waypoint.separatesLegs = false } Directions.shared.calculateRoutes(matching: matchOptions) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { return } // Set the route self.navigationViewController?.route = route } } return true } } Copy Was this page helpful? Yes No",,Custom server,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Marker following route,"Using a map matched GeoJSON route, the marker travels along the route at consistent speed.",https://docs.mapbox.com/android/maps/examples/marker-following-route/,example,Java,,"Marker following route Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.basics.SimpleMapViewActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.6177"" mapbox:mapbox_cameraTargetLng=""-122.3915"" mapbox:mapbox_cameraZoom=""12""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.animation.ObjectAnimator; import android.animation.TypeEvaluator; import android.animation.ValueAnimator; import android.graphics.Color; import android.os.AsyncTask; import android.os.Bundle; import android.os.Handler; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import android.view.animation.LinearInterpolator; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.List; import java.util.Scanner; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Use a mapboxMap matched GeoJSON route to show a marker travels along the route. */ public class MarkerFollowingRouteActivity extends AppCompatActivity { private static final String TAG = ""MarkerFollowingRoute""; private static final String DOT_SOURCE_ID = ""dot-source-id""; private static final String LINE_SOURCE_ID = ""line-source-id""; private int count = 0; private MapView mapView; private MapboxMap mapboxMap; private Handler handler; private Runnable runnable; private GeoJsonSource dotGeoJsonSource; private ValueAnimator markerIconAnimator; private LatLng markerIconCurrentLocation; private List<Point> routeCoordinateList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_marker_following_route); // Initialize the mapboxMap view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(MapboxMap mapboxMap) { MarkerFollowingRouteActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { new LoadGeoJson(MarkerFollowingRouteActivity.this).execute(); } }); } }); } /** * Add data to the map once the GeoJSON has been loaded * * @param featureCollection returned GeoJSON FeatureCollection from the async task */ private void initData(@NonNull FeatureCollection featureCollection) { LineString lineString = (LineString) featureCollection.features().get(0).geometry(); routeCoordinateList = lineString.coordinates(); if (mapboxMap != null) { mapboxMap.getStyle(style -> { initSources(style, featureCollection); initSymbolLayer(style); initDotLinePath(style); initRunnable(); }); } } /** * Set up the repeat logic for moving the icon along the route. */ private void initRunnable() { // Animating the marker requires the use of both the ValueAnimator and a handler. // The ValueAnimator is used to move the marker between the GeoJSON points, this is // done linearly. The handler is used to move the marker along the GeoJSON points. handler = new Handler(); runnable = new Runnable() { @Override public void run() { // Check if we are at the end of the points list, if so we want to stop using // the handler. if ((routeCoordinateList.size() - 1 > count)) { Point nextLocation = routeCoordinateList.get(count + 1); if (markerIconAnimator != null && markerIconAnimator.isStarted()) { markerIconCurrentLocation = (LatLng) markerIconAnimator.getAnimatedValue(); markerIconAnimator.cancel(); } if (latLngEvaluator != null) { markerIconAnimator = ObjectAnimator .ofObject(latLngEvaluator, count == 0 || markerIconCurrentLocation == null ? new LatLng(37.61501, -122.385374) : markerIconCurrentLocation, new LatLng(nextLocation.latitude(), nextLocation.longitude())) .setDuration(300); markerIconAnimator.setInterpolator(new LinearInterpolator()); markerIconAnimator.addUpdateListener(animatorUpdateListener); markerIconAnimator.start(); // Keeping the current point count we are on. count++; // Once we finish we need to repeat the entire process by executing the // handler again once the ValueAnimator is finished. handler.postDelayed(this, 300); } } } }; handler.post(runnable); } /** * Listener interface for when the ValueAnimator provides an updated value */ private final ValueAnimator.AnimatorUpdateListener animatorUpdateListener = new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { LatLng animatedPosition = (LatLng) valueAnimator.getAnimatedValue(); if (dotGeoJsonSource != null) { dotGeoJsonSource.setGeoJson(Point.fromLngLat( animatedPosition.getLongitude(), animatedPosition.getLatitude())); } } }; /** * Add various sources to the map. */ private void initSources(@NonNull Style loadedMapStyle, @NonNull FeatureCollection featureCollection) { dotGeoJsonSource = new GeoJsonSource(DOT_SOURCE_ID, featureCollection); loadedMapStyle.addSource(dotGeoJsonSource); loadedMapStyle.addSource(new GeoJsonSource(LINE_SOURCE_ID, featureCollection)); } /** * Add the marker icon SymbolLayer. */ private void initSymbolLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addImage(""moving-pink-dot"", BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.pink_dot))); loadedMapStyle.addLayer(new SymbolLayer(""symbol-layer-id"", DOT_SOURCE_ID).withProperties( iconImage(""moving-pink-dot""), iconSize(1f), iconIgnorePlacement(true), iconAllowOverlap(true) )); } /** * Add the LineLayer for the marker icon's travel route. */ private void initDotLinePath(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayer(new LineLayer(""line-layer-id"", LINE_SOURCE_ID).withProperties( lineColor(Color.parseColor(""#F13C6E"")), lineWidth(4f) )); } @Override public void onResume() { super.onResume(); mapView.onResume(); // When the activity is resumed we restart the marker animating. if (handler != null && runnable != null) { handler.post(runnable); } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); // Check if the marker is currently animating and if so, we pause the animation so we aren't // using resources when the activities not in view. if (handler != null && runnable != null) { handler.removeCallbacksAndMessages(null); } if (markerIconAnimator != null) { markerIconAnimator.cancel(); } } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } /** * We want to load in the GeoJSON file asynchronous so the UI thread isn't handling the file * loading. The GeoJSON file we are using is stored in the assets folder, you could also get * this information from the Mapbox mapboxMap matching API during runtime. */ private static class LoadGeoJson extends AsyncTask<Void, Void, FeatureCollection> { private WeakReference<MarkerFollowingRouteActivity> weakReference; LoadGeoJson(MarkerFollowingRouteActivity activity) { this.weakReference = new WeakReference<>(activity); } @Override protected FeatureCollection doInBackground(Void... voids) { try { MarkerFollowingRouteActivity activity = weakReference.get(); if (activity != null) { InputStream inputStream = activity.getAssets().open(""matched_route.geojson""); return FeatureCollection.fromJson(convertStreamToString(inputStream)); } } catch (Exception exception) { Timber.e(exception.toString()); } return null; } static String convertStreamToString(InputStream is) { Scanner scanner = new Scanner(is).useDelimiter(""\\A""); return scanner.hasNext() ? scanner.next() : """"; } @Override protected void onPostExecute(@Nullable FeatureCollection featureCollection) { super.onPostExecute(featureCollection); MarkerFollowingRouteActivity activity = weakReference.get(); if (activity != null && featureCollection != null) { activity.initData(featureCollection); } } } /** * Method is used to interpolate the SymbolLayer icon animation. */ private static final TypeEvaluator<LatLng> latLngEvaluator = new TypeEvaluator<LatLng>() { private final LatLng latLng = new LatLng(); @Override public LatLng evaluate(float fraction, LatLng startValue, LatLng endValue) { latLng.setLatitude(startValue.getLatitude() + ((endValue.getLatitude() - startValue.getLatitude()) * fraction)); latLng.setLongitude(startValue.getLongitude() + ((endValue.getLongitude() - startValue.getLongitude()) * fraction)); return latLng; } }; } Copy Was this page helpful? Yes No",,Marker following route,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Spatial analysis,Learn how spatial analysis with Turf works and how to use Turf in your web application.,https://docs.mapbox.com/help/how-mapbox-works/geospatial-analysis/,guide,,,"Spatial analysis Spatial analysis includes a variety of techniques and processes used to understand the patterns and relationships of geographic features. Turf is an advanced geospatial JavaScript open source library that allows you to do spatial operations in the browser. Turf helps you analyze, aggregate, and transform data to visualize it in new ways and answer advanced questions. This guide provides an overview of how spatial analysis with Turf works, how to use Turf in your application, and relevant documentation to help you get started. Perform spatial operations in the browser Click points on the map to create lines that measure distanced using turf.lineDistance. How spatial analysis works Turf is a library for geospatial analysis — a large family of tasks like calculating area and distance and joining points to polygons that enable people to see patterns or relationships within their data. Spatial analysis is used in many industries: to find the nearest coffee shop, calculate travel time, and show regional statistics for utility usage. It's also a huge part of GIS, where many problems are solved with spatial analysis. Examples of spatial analysis Source: John Snow - Published by C.F. Cheffins, Lith, Southhampton Buildings, London, England, 1854 in Snow, John. On the Mode of Communication of Cholera, 2nd Ed, John Churchill, New Burlington Street, London, England, 1855. The map below is a classic example of spatial analysis, created by physician John Snow during the 1854 cholera outbreak in London. Snow plotted cholera cases in the Soho area of London around Broad Street and noticed a cluster around the water pump. This led to improved sanitation facilities and the discovery that cholera infection was water-borne rather than airborne. Today, spatial analysis is used in epidemiology, biology, statistics, economics, commerce and business, urban planning, geology, oil and gas, and in many other industries. With Turf, we can now bring these analyses to the browser and show results quickly and seamlessly. Common functions There are dozens of functions available within Turf that allow you to do spatial operations with your data. Some of the most common operations are: Buffer: returns an area that is a specified number of units around your feature. Inside: returns whether a feature is wholly within an area. Area: calculates the area of a polygon. Along: returns the position of a point at a specified distance along a line. A typical Turf operation such as the buffer function would look like this in JavaScript: var nullIsland = { type: 'Feature', geometry: { type: 'Point', coordinates: [0, 0] } , properties: { name: 'Null Island' } } ; var twoHundredMilesOut = turf.buffer(nullIsland, 200, { unit: 'miles' } ); Method types There are several different kinds of spatial analysis you can conduct with Turf. All Turf methods are organized into the following categories: Aggregation methods can run statistical operations on a set of points within a set of polygons. For example, you can compare average size of elementary schools across counties in Massachusetts with turf-collect. Measurement methods can measure distances, create features, and calculate sizes. For example, with measurement methods, you can determine not only the exact center point of the city of Austin (with turf-centroid, but you can also measure the distance between that point and city hall (with turf-distance). Transformation methods can solve spatial problems. If you want to buy a house that is both within one mile of a park and one mile of a bus stop, you can determine where those areas overlap with turf-intersect, a transformation method. Data methods can generate random points or samples from a large number of features at random. For example, you can use turf-sample to list a subset of store locations from hundreds of locations. Interpolation methods can estimate or average data and visualize the result. For example, creating contour lines (or isobands) from a set of points containing elevation information with Turf isobands. Join methods can determine spatial relationships between features. If you want to know which burglaries happened in a specific neighborhood, you can use a join method like turf-within. Using spatial analysis As a JavaScript library, you can add Turf to your webpage in the <head> of your document. You can use the CDN (the URL displayed below), or you can download the Turf library and source it locally. <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script> When you add Turf to your site, it exposes a global variable turf from which you can run any of the turf functions. For example, if you have a GeoJSON LineString feature named dc and you want to know its length in miles, you can use the turf-length function. var dc = { type: 'Feature', properties: { } , geometry: { type: 'LineString', coordinates: [ [-77.031669, 38.878605], [-77.029609, 38.881946], [-77.020339, 38.884084], [-77.025661, 38.885821], [-77.021884, 38.889563], [-77.019824, 38.892368] ] } } ; var length = turf.length(dc, { units: 'miles' } ); The variable length contains the length of dc in miles. // length === 1.6389817168470033 You can find a complete list of available functions and see them in action in the Turf API documentation. Was this page helpful? Yes No",,Spatial analysis,Examples of spatial analysis,Common functions,Method types,Using spatial analysis,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Extend Mapbox Boundaries,Extend the Mapbox Boundaries tileset.,https://docs.mapbox.com/help/tutorials/extend-mapbox-boundaries/,tutorial,No code,,"advanced No code Extend Mapbox Boundaries Prerequisite Familiarity with front-end development, command line tools, and GIS. Access to Mapbox Boundaries. Access to Mapbox Boundaries Access to the Boundaries tilesets are controlled by Mapbox account access token. If you do not have access on your account, contact a Mapbox sales representative to request access to Boundaries tilesets. In some cases, Mapbox Boundaries may cover most of your needs, but you may need a few specific school districts, neighborhoods, or sub-market boundaries for your customers. You can extend Mapbox Boundaries with any custom data and deliver the same frontend, API-driven services for data visualization, analysis, and geofencing applications around the world. This guide walks through how to format, tile, and host data to work in your application alongside Mapbox Boundaries. Getting started Here are a few resources you'll need throughout this tutorial: Access to Mapbox Boundaries. Mapbox Boundaries are available as a part of an Enterprise plan. If you do not have an Enterprise plan or if you do have an Enterprise plan and would like to add access to Mapbox Boundaries, contact a Mapbox sales representative to request access. Access to the Boundaries tilesets are controlled by Mapbox account access token. Data. In this tutorial, you'll learn how to add sub-county data from US Census to Mapbox Boundaries. Use the US Census FTP site to download all files in the US Census Subcounty directory. Note: The process outlined in this guide requires that your custom data: Uses polygon or multi-polygon geometries. Has metadata for each polygon feature denoting an identifier. QGIS. QGIS is an open source GIS application. You can download it from http://www.qgis.org/. You should be somewhat familiar with the QGIS interface before starting this tutorial. Tippecanoe. Tippecanoe is a command line tool for creating Mapbox tilesets. Mapbox CLI. You'll use the Mapbox CLI (command line interface) to upload the tileset you create with Tippecanoe to your Mapbox account. Format Data You'll do two things to format the data before creating Mapbox tilesets: Concatenate the data into one GeoJSON format file per administrative level. Generate a unique identifier as a property value named id for each feature that matches the Mapbox Boundaries format. Concatenate the data In QGIS, open all the US sub-county shapes. Then, you'll need to: Merge the subcounty Shapefiles together into one master Shapefile. Create a unique identifier named id. Project the data to EPSG:4326 (WGS84). Export the polygon data with needed properties to GeoJSON file. Export the point data with needed properties to a GeoJSON file. Generate a unique identifier Next, you'll generate a unique identifier for each feature. The globally unique identifier should have the format: The leftmost 2 characters are the ID of the admin level 0 parent polygon — this is the 2-digit ISO country code. The third character from the left is A, P, or S representing admin, postal, or stats. The fourth character from the left is a number representing the admin or postal level. The remaining characters are the ID correspond to the individual admin or postal feature. To complete steps 1 and 2 on data format, either use your own data processing pipeline (such as PostGIS, SQLServer, Oracle Spatial) or a GIS tool such as ArcGIS or the open source tool QGIS. The unique identifier will take the form [CC-AL-D*] where: CC is the two digit country code. AL is the two digit representation of admin-level (A for administrative, P for postal, S for statistical, and L for the level 0-5). D* is the administrative code for the feature. In this example, to create the unique identifier in QGIS, open the merged layer properties and create a custom expression to add a new string field. Sub counties should fall to level admin-3 in the Boundaries hierarchy — one level of detail down from counties at admin-2. Thus the unique ID should be the following formula USA3 + { admin code of sub county feature }: When you are done editing the id, save the layer edits and export the shape file as a 6-coordinate-precision GeoJSON file in coordinate system WGS84 (EPSG:4326) named admin-3-us-poly.geojson. Next create a point layer from the INTERPLONG and INTERLAT columns, which correspond to feature centroids. Export this centroid point layer to a GeoJSON file with coordinate precision 6 in coordinate system WGS84 (EPSG:4326) named admin-3-us-point.geojson. Note If you are working with data that does not have pre-calculated centroid points, calculate the centroid using a GIS tool. Create tiles To create tilesets from your custom data, use the command line tool Tippecanoe to transform your GeoJSON features to vector tiles. You'll need to create two source layers and merge them together into a single tileset source: One source layer with a unique name for all polygons with an id property. One source layer for with a unique name for centroid points with an id property. Note: you can also encode other data beyond the id property, but it will result in bigger tiles and require you to set a higher min zoom for your tileset. Create the polygon source layer Start by creating a polygon source layer. Use the following Tippecanoe command to transform the example files. Substitute the name of your layer in for the -l parameter, and adjust the minimum zoom of the tileset with the -Z parameter. Typically admin-2 features will have -Z2, admin-3 will have -Z4, admin-4 will have -Z6, and admin-5 will have -Z7. tippecanoe -P -f -o admin-3-poly-us.mbtiles -l boundaries_admin_3_us -Z4 -z12 admin-3-us-poly.geojson -y ""id"" Create the point source layer Next, create a point source layer using the following Tippecanoe command. You can adjust the -Z value to specify the minimum zoom of the tileset — this will help keep tile sizes small. Generally, you can pick a higher minimum zoom level the more dense your features are. tippecanoe -P -f -o admin-3-point-us.mbtiles -l points_admin_3_us -Z4 -z12 -r0 admin-3-us-point.geojson -y ""id"" Create a single tileset Then, join the two polygon and point layers into one vector tileset using the following command: tile-join -f -o admin-3-us.mbtiles admin-3-poly-us.mbtiles admin-3-point-us.mbtiles Upload the tileset to your Mapbox account. Start by installing the Mapbox CLI. Adjust the tileset name to use your Mapbox account name and level with a suffix to denote that it is unique from Mapbox Boundaries. pip install mapboxcli export MAPBOX_ACCESS_TOKEN=MY-UPLOAD-SCOPE-TOKEN mapbox upload ""admin-3-us.mbtiles"" ""MY-ACCOUNT-NAME.enterprise-boundaries-a3-us"" Alternative upload process Alternatively, you can upload your tileset using Mapbox Studio. Composite tiles After the tileset has been successfully added to your account, you can use the syntax below to composite Boundaries with custom boundaries in a map style. This puts all tile data into one API request, maximizing performance and minimizing API calls. Compositing also improves label placement calculations across tilesets. ""sources"": { ""composite"": { ""url"": ""mapbox://mapbox.enterprise-boundaries-a3-v2,MY-MAPBOX-ACCOUNT.enterprise-boundaries-a3-us"", ""type"": ""vector"" } } Note Find the complete list of Mapbox Boundaries tilesets in the reference documentation. Final product Here is an example style showing how the new US Admin Level 3 data works alongside the base Mapbox Boundaries product. Next steps Learn more about how you can use Mapbox Boundaries: Point-in-polygon query with Mapbox Boundaries: Determine what polygons exist at a single point using the Mapbox Tilequery API. Data-joins with Mapbox Boundaries: The data-join technique involves inner joins between local data, such as the unemployment rate by US state, to vector tile features, such as admin boundaries in Mapbox Boundaries, using data-driven style notation. Was this page helpful? Yes No",,Extend Mapbox Boundaries,Format Data,Concatenate the data,Generate a unique identifier,Create tiles,Create the polygon source layer,Create the point source layer,Create a single tileset,Composite tiles,Final product,Next steps,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Upload to Mapbox using cURL,Learn how to use the Mapbox Uploads API.,https://docs.mapbox.com/help/tutorials/upload-curl/,tutorial,cURL,,"advanced cURL Upload to Mapbox using cURL Prerequisite Familiarity with cURL. Beta feature: Upload vector tilesets with the Tilesets API The Mapbox Tilesets API has several beta endpoints that allow you to create custom vector tilesets. As an alternative to the Uploads API process outlined in this tutorial, you can use these endpoints for tiling vector data using custom configuration rules. While these endpoints are in beta, they are subject to potential changes. This guide illustrates how you can use the Mapbox Uploads API via the command line with cURL. If you would like to upload your data through a point-and-click interface, you can do so with Mapbox Studio. Getting started There are a few resources you'll need before getting started: Mapbox account. Sign up for free at mapbox.com/sign-up. A secret access token with uploads:write scope enabled. The AWS CLI (requires Python and pip). cURL. Data to upload — see our accepted file types here. Stage your file on Amazon S3 Mapbox provides an Amazon S3 bucket to stage your file while your upload is processed. All uploads must be staged in this bucket before being uploaded to your Mapbox account. To stage a file on S3, you'll need to retrieve temporary credentials from the Uploads API's credentials endpoint: curl -X POST https://api.mapbox.com/uploads/v1/username/credentials?access_token=<secret access token> In the above command, secret_access_token is your secret access token and username is your Mapbox account username. If your request URL is valid, you should receive a response that looks something like this: { ""accessKeyId"": "" { accessKeyId } "", ""bucket"": "" { bucket } "", ""key"": "" { key } "", ""secretAccessKey"": "" { secretAccessKey } "", ""sessionToken"": "" { sessionToken } "", ""url"": "" { url } "" } These credentials give you permission to stage your data on Amazon's servers and are crucial to the next step. Enter the following into your terminal to set the correct environment variables that allow you to upload your data to S3: $ export AWS_ACCESS_KEY_ID= { accessKeyId } $ export AWS_SECRET_ACCESS_KEY= { secretAccessKey } $ export AWS_SESSION_TOKEN= { sessionToken } To stage your data on S3, run the following in your terminal: $ aws s3 cp /path/to/file s3:// { bucket } / { key } --region us-east-1 You should see a response that looks like: upload: ./ { file name } to s3:// { bucket } / { key } Begin the upload process Once your file is staged on Amazon S3, you need to create an upload that defines where the Mapbox Uploads API should look for your staged data. The upload is not the file itself, but an object that tells Mapbox's servers how to find your staged file and where to put it. You give Mapbox instructions by sending a POST request with this information. Using cURL, your request will look like: curl -X POST -H ""Content-Type: application/json"" -H ""Cache-Control: no-cache"" -d ' { ""url"": ""http:// { bucket } .s3.amazonaws.com/ { key } "", ""tileset"": "" { username } . { tileset-name } "" } ' 'https://api.mapbox.com/uploads/v1/ { username } ?access_token=secret_access_token' Note: The { username } is always your Mapbox username. The { tileset-name } parameter is what you would like to call your data when it gets to Mapbox, such as bike-trails or airports. If you use the name of an existing tileset, it will be overwritten. Once a successful POST request has completed, you will receive an HTTP 201 response and a confirmation that your upload has started, which will look like this: { ""complete"": false, ""tileset"": "" { username } . { tileset-name } "", ""error"": null, ""id"": "" { upload-id } "", ""name"": "" { username } - { tileset-name } "", ""modified"": "" { timestamp } "", ""created"": "" { timestamp } "", ""owner"": "" { username } "", ""progress"": 0 } Note: The { upload-id } refers to the upload's unique identifier. This can be used to retrieve the upload status later. Finished product Once you have started the upload process, it may be a few minutes before your upload has finished processing and is complete. This is dependent on the size and complexity of your data. If your upload fails, see our uploads troubleshooting guide for more information. If the upload is successful, your new tileset will be listed on your tilesets page. At this point, your tileset is now available to use in custom map styles! Was this page helpful? Yes No",,Upload to Mapbox using cURL,Stage your file on Amazon S3,Begin the upload process,Finished product,,,,,,,,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox web services,"Mapbox web services are the lowest-level interfaces to Mapbox - they are the APIs that our JavaScript, Objective-C, and other systems are built upon.",https://docs.mapbox.com/help/glossary/mapbox-web-services/,glossary,,,"Mapbox web services The Mapbox web services are the lowest-level interfaces to Mapbox — they are the APIs that our JavaScript, Objective-C, and other systems are built upon. You can connect to Mapbox web services from any language or environment — you can use the Python requests module, the node.js request module, or another HTTP request library in the language of your choice. Was this page helpful? Yes No",,Mapbox web services,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,simplestyle,Simplestyle is an open source specification for styling GeoJSON data.,https://docs.mapbox.com/help/glossary/simplestyle/,glossary,,,simplestyle Simplestyle is an open source specification for styling GeoJSON data. Was this page helpful? Yes No,,simplestyle,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Data-driven styling for Android,Create a map for Android that styles a circle based on a data attribute.,https://docs.mapbox.com/help/tutorials/android-dds-circle-layer/,tutorial,Java,,"intermediate Java Data-driven styling for Android Prerequisite An Android application with a map view set up and familiarity with Android Studio and Java. Data-driven styling is a powerful feature within the Mapbox Maps SDK for Android that allows you to use data attributes to style your maps. With data-driven styling, you can automatically style map features based on their individual attributes. In this tutorial, you'll build a map for Android that includes a circle layer styled based on a data attribute. Getting started This guide assumes that you are familiar with Java and Android Studio. Here are the resources that you’ll need before getting started: An application including the Mapbox Maps SDK for Android. This guide also assumes that you have already begun building an Android application that uses the Mapbox Maps SDK for Android. If you're new to the Maps SDK for Android, complete the First steps with the Mapbox Maps SDK for Android guide to set up a map view first. Data. We collected data from the District of Columbia's Open Data DC that shows the location of street trees in Washington, D.C. Each tree has a DBH attribute that is the diameter at breast height, a common metric for expressing the size of trees. Download Shapefile Upload data to Mapbox In this tutorial, you will be using a vector tileset to display data in your application. You can create a vector tileset by uploading the Open Data DC Shapefile Mapbox Studio: Log into Mapbox Studio. Visit the Tilesets page. Click New tileset. Select the Shapefile you downloaded at the beginning of this tutorial and click Confirm. A popover will appear in the bottom right showing the progress of your upload. Once the upload has Succeeded, the tileset will be ready to use! Click on the name of the tileset in the popover, which will open the tileset information page. Take note of the tileset ID on the right side of the tileset information page. You will use the ID to add this tileset to your application later in this guide. Initialize a MapView Start by creating a new project in Android Studio and initializing a MapView. There are five files you'll be working with in your Android Studio project to set up a Mapbox map and add custom data to be styled using data-driven styling. The five files you'll be working with include: build.gradle: Android Studio uses a toolkit called Gradle to compile resources and source code into an APK. The build.gradle file is used to configure the build and list dependencies, including the Mapbox Maps SDK for Android. AndroidManifest.xml: The AndroidManifest.xml file is where you'll describe components of the application, including Mapbox-related permissions. activity_main.xml: The activity_main.xml file is where you'll set the properties for your MapView (for example, the center of the map view, the zoom level, and the map style used). strings.xml: You'll store your access token in the strings.xml file. MainActivity.java: MainActivity.java is a Java file where you'll specify Mapbox-specific interactions. build.gradle (App module) // in addition to the rest of your build.gradle contents // you should include the following repository and dependency repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-sdk: 8.2.1 ' } Manifest.xml <uses-permission android:name=""android.permission.ACCESS_FINE_LOCATION"" /> activity_main.xml <?xml version=""1.0"" encoding=""utf-8""?> <android.support.constraint.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""38.9098"" mapbox:mapbox_cameraTargetLng=""-77.0295"" mapbox:mapbox_cameraZoom=""15"" /> </android.support.constraint.ConstraintLayout> Copy strings.xml <string name=""access_token"" translatable=""false""> YOUR_MAPBOX_ACCESS_TOKEN </string> MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.v7.app.AppCompatActivity; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleOpacity; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; public class MainActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_main); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { VectorSource vectorSource = new VectorSource( ""trees-source"", // replace examples.8mj5l1r9 with the tileset ID // you created by uploading data to your Mapbox account ""http://api.mapbox.com/v4/examples.8mj5l1r9.json?access_token="" + getString(R.string.access_token) ); style.addSource(vectorSource); CircleLayer circleLayer = new CircleLayer(""trees-style"", ""trees-source""); // replace street-trees-DC-9gvg5l with the name of your source layer circleLayer.setSourceLayer(""street-trees-DC-9gvg5l""); circleLayer.withProperties( circleOpacity(0.6f), circleColor(Color.parseColor(""#ffffff"")), circleRadius( interpolate(exponential(1.0f), get(""DBH""), stop(0, 0f), stop(1, 1f), stop(110, 11f) ) ) ); style.addLayer(circleLayer); } }); } }); } // Add the mapView's own lifecycle methods to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Copy Copy Copy You can learn how to set up an Android Studio project with the Maps SDK for Android in the First steps with the Mapbox Maps SDK for Android guide. Run your application, and you should see a map in the Mapbox Dark style centered on Logan Circle. Load the source Next, you'll load the tileset that you added to your Mapbox Studio account into the application using the tileset ID. Find your tileset ID on the Tilesets page in Mapbox Studio by clicking the next to the tileset you uploaded. First you'll need to import the correct classes in the MainActivity.java file. This will allow you to add a vector source and create a circle layer from that data. Then, add the code that pulls in the data in your tileset and adds it as a layer to your map. In the MainActivity.java file, inside public void onStyleLoaded(@NonNull Style style) { ... } add the following code: MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.v7.app.AppCompatActivity; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleOpacity; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; public class MainActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_main); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { VectorSource vectorSource = new VectorSource( ""trees-source"", // replace examples.8mj5l1r9 with the tileset ID // you created by uploading data to your Mapbox account ""http://api.mapbox.com/v4/examples.8mj5l1r9.json?access_token="" + getString(R.string.access_token) ); style.addSource(vectorSource); CircleLayer circleLayer = new CircleLayer(""trees-style"", ""trees-source""); // replace street-trees-DC-9gvg5l with the name of your source layer circleLayer.setSourceLayer(""street-trees-DC-9gvg5l""); circleLayer.withProperties( circleOpacity(0.6f), circleColor(Color.parseColor(""#ffffff"")), circleRadius( interpolate(exponential(1.0f), get(""DBH""), stop(0, 0f), stop(1, 1f), stop(110, 11f) ) ) ); style.addLayer(circleLayer); } }); } }); } // Add the mapView's own lifecycle methods to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Copy Copy Rerun your application and you'll see the data from your tileset displayed on the dark map. Notice that the black circles are difficult to see on top of the dark map style. Next, you'll style the data to be more visible. Style the layer Now you'll change the color and opacity of each circle to make the data more visible against the dark map style. Then, you'll also change the size of each circle to reflect the DBH. Change color and opacity Start by importing the correct classes in the MainActivity.java file. In this step you'll need the circleColor and circleOpacity classes. Then, add the following code to the inside the public void onStyleLoaded(@NonNull Style style) { ... } method to specify the opacity and color that the layer should use: MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.v7.app.AppCompatActivity; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleOpacity; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; public class MainActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_main); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { VectorSource vectorSource = new VectorSource( ""trees-source"", // replace examples.8mj5l1r9 with the tileset ID // you created by uploading data to your Mapbox account ""http://api.mapbox.com/v4/examples.8mj5l1r9.json?access_token="" + getString(R.string.access_token) ); style.addSource(vectorSource); CircleLayer circleLayer = new CircleLayer(""trees-style"", ""trees-source""); // replace street-trees-DC-9gvg5l with the name of your source layer circleLayer.setSourceLayer(""street-trees-DC-9gvg5l""); circleLayer.withProperties( circleOpacity(0.6f), circleColor(Color.parseColor(""#ffffff"")), circleRadius( interpolate(exponential(1.0f), get(""DBH""), stop(0, 0f), stop(1, 1f), stop(110, 11f) ) ) ); style.addLayer(circleLayer); } }); } }); } // Add the mapView's own lifecycle methods to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Copy Copy Rerun your application, and you will see the same map view with the same point data, but now the circles will be white and semi-transparent. Specify radius based on a data attribute Finally, you'll specify that the radius of circle should be determined by the DBH value. Again, you'll start by importing the necessary classes. You'll need the Function and exponential classes to create a property function, the Stop class to establish what the circle radius should be at which DBH, and the circleRadius class to affect the circleRadius paint property. Then, replace the code used to specify paint properties for the layer, inside circleLayer.withProperties( ... ), to use an exponential property function: MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.v7.app.AppCompatActivity; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleOpacity; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; public class MainActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_main); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { VectorSource vectorSource = new VectorSource( ""trees-source"", // replace examples.8mj5l1r9 with the tileset ID // you created by uploading data to your Mapbox account ""http://api.mapbox.com/v4/examples.8mj5l1r9.json?access_token="" + getString(R.string.access_token) ); style.addSource(vectorSource); CircleLayer circleLayer = new CircleLayer(""trees-style"", ""trees-source""); // replace street-trees-DC-9gvg5l with the name of your source layer circleLayer.setSourceLayer(""street-trees-DC-9gvg5l""); circleLayer.withProperties( circleOpacity(0.6f), circleColor(Color.parseColor(""#ffffff"")), circleRadius( interpolate(exponential(1.0f), get(""DBH""), stop(0, 0f), stop(1, 1f), stop(110, 11f) ) ) ); style.addLayer(circleLayer); } }); } }); } // Add the mapView's own lifecycle methods to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Copy Rerun your application, and you will see the map with your data styled in a way that the radius of each circle is determined by the DBH value for that point. Finished product You've created a data visualization that illustrates the location and size of street trees all over Washington DC. MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.v7.app.AppCompatActivity; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleOpacity; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; public class MainActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_main); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { VectorSource vectorSource = new VectorSource( ""trees-source"", // replace examples.8mj5l1r9 with the tileset ID // you created by uploading data to your Mapbox account ""http://api.mapbox.com/v4/examples.8mj5l1r9.json?access_token="" + getString(R.string.access_token) ); style.addSource(vectorSource); CircleLayer circleLayer = new CircleLayer(""trees-style"", ""trees-source""); // replace street-trees-DC-9gvg5l with the name of your source layer circleLayer.setSourceLayer(""street-trees-DC-9gvg5l""); circleLayer.withProperties( circleOpacity(0.6f), circleColor(Color.parseColor(""#ffffff"")), circleRadius( interpolate(exponential(1.0f), get(""DBH""), stop(0, 0f), stop(1, 1f), stop(110, 11f) ) ) ); style.addLayer(circleLayer); } }); } }); } // Add the mapView's own lifecycle methods to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Next steps There are many possibilities when using data-driven styling to create beautiful and informative data visualizations for Android applications. Read more about data-driven styling more generally in our Map design guide and dig into some data-driven styling examples specifically for Android: Style circles categorically: change the color of circles in a circle layer based on a data property. Update by zoom level: display state or county population depending on zoom level. Was this page helpful? Yes No",,Data-driven styling for Android,Upload data to Mapbox,Initialize a MapView,Load the source,Style the layer,Change color and opacity,Specify radius based on a data attribute,Finished product,Next steps,,,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,vector tiles,"A vector tile is a lightweight data format for storing geospatial vector data, such as points, lines, and polygons.",https://docs.mapbox.com/help/glossary/vector-tiles/,glossary,,,"vector tiles A vector tile is a lightweight data format for storing geospatial vector data, such as points, lines, and polygons. Vector tiles are used to create Mapbox vector tilesets. Vector tiles can be used as sources for styles or queried directly to create interactive experiences with the Mapbox Mobile SDKs and Mapbox GL JS. Vector tiles encode geographic information according to the Vector tile specification. Related resources: Learn more about how vector tiles work in the vector tiles reference documentation. Was this page helpful? Yes No",,vector tiles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Reference,Learn about the Mapbox Studio interface.,https://docs.mapbox.com/studio-manual/reference/,reference,,,"Reference The navigation at the top of the Studio page shows the different sections of Mapbox Studio: Styles. Create, manage, and edit your map styles. Tilesets. Create, upload, and manage your tilesets. Datasets. Create, upload, and manage your datasets. Styles From the Styles page you can create, edit, and see information about any of your styles and find links for using your styles in web and mobile applications. For more information on styles and the Mapbox Studio style editor, see the Styles section of this manual. Read about styles Tilesets The Tilesets page is where you can add and see information about your uploaded and exported tilesets. For more information on tilesets, see the Tilesets section of this manual. Read about tilesets Datasets The Datasets page is where you can create, edit, and see information about your datasets. For more information on datasets and the Mapbox Studio dataset editor, see the Datasets section of this manual. Read about datasets Next page: Styles Learn how to create and manage styles in Mapbox Studio. Was this page helpful? Yes No",,Reference,Tilesets,Datasets,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Directions,Learn how Mapbox’s directions services work and how to add directions services to applications across platforms.,https://docs.mapbox.com/help/how-mapbox-works/directions/,guide,,,"Directions Mapbox provides a collection of APIs to add directions-related services to your application. Generate a route with trip durations, estimated distances, and turn-by-turn directions with the Mapbox Directions API, retrieve travel times between many points with the Mapbox Matrix API, retrieve duration-optimized trips between points with the Mapbox Optimization API, or align existing fuzzy routes to the routeable network with the Mapbox Map Matching API. From routing deliveries efficiently to providing navigation steps for wayfinding, Mapbox provides the tools necessary to integrate directions into your application. This guide provides an overview of how the routing network is created, how to add directions services to applications across platforms, how to provide feedback, and relevant documentation to help you get started. This example uses the Mapbox GL Directions plugin to add driving, cycling, or walking directions to a web application built with Mapbox GL JS. Type in two locations to view the raw JSON response for that query. The Mapbox Directions API returns a JSON object containing a route with trip durations, estimated distances, and turn-by-turn instructions. When using the Mapbox GL Directions plugin, all this information will be automatically added to the map when a request is complete. By default, the plugin will also display turn-by-turn instructions. This example hides the turn-by-turn instructions and displays the raw JSON response to illustrate what information is included in the directions response object. How directions work When you provide two or more points to the Mapbox Directions API, it returns a route as a GeoJSON line that you can add to your map, text for turn-by-turn instructions that you can choose to display in your application, and the distance and estimated travel times for the mode of transportation you selected. There are many other services that extend Mapbox directions that allow you to fix messy GPS traces to the network or optimize trips to multiple stops on a single journey. The routing network A directions service that can create routes and optimized trips requires a robust network of paths with distinct attributes like speed, turn restrictions, and travel mode (for example, motorway, foot path, bike lane). Mapbox's directions services use a network of roads and paths, or ways, derived from OpenStreetMap, a collaborative project to create a free and editable map of the world. Ways A way is an OpenStreetMap term used to describe an ordered list of nodes (points) which normally also has at least one tag, or description. For directions, ways can be roads, foot paths, or bicycle lanes. Contributors to OpenStreetMap have built a vast, routeable network that includes properties like speed limits, turn lane restrictions, and accessibility for bikes and pedestrians. These details provide the framework that the Open Source Routing Machine (OSRM) needs to calculate the most efficient path for your mode of transportation (driving, cycling, walking). Travel times The Mapbox Directions API, Matrix API, and Optimization API all provide estimated trip durations. The time it takes to travel from one point to another is determined by many factors, including: The profile used (walking, cycling, or driving). The speed stored in the maxspeed tag in OpenStreetMap. Traffic derived from real-time telemetry data (when the traffic profile is used). Traffic data Incorporate real-time traffic into route selection and ETA generation using the mapbox/driving-traffic profile with the Mapbox Directions API, Map Matching API, or Matrix API, or add a traffic layer to road geometries on a visual map. Read more about our traffic tileset in Our map data. The mapbox/driving-traffic profile is available globally, but the accuracy of traffic-dependent travel times vary by country. Highly accurate travel times Traffic data collected in these countries is comprehensive across geographies and times, resulting in highly accurate travel times. Australia Canada Czech Republic Estonia Gibraltar Iceland Ireland Korea, Republic of Latvia Liechtenstein Netherlands New Zealand Puerto Rico Slovakia United Kingdom United States of America Moderately accurate travel times Traffic data collected in these countries is less comprehensive. Travel times may be inaccurate, especially in heavy and unusual traffic conditions. Andorra Argentina Armenia Austria Barbados Belarus Belgium Belize Cayman Islands Chile Cyprus Denmark Dominican Republic Finland France Germany Guam Hungary Iran, Islamic Republic of Israel Italy Japan Jordan Lithuania Luxembourg Mexico Montenegro Norway Panama Paraguay Poland Portugal Romania Slovenia Spain Sweden Switzerland United Arab Emirates Uruguay Limited predictability of travel times Traffic data collected in these countries is less comprehensive. Travel times are less reliable, with partial coverage of traffic conditions. Åland Islands Albania Algeria American Samoa Anguilla Aruba Azerbaijan Bahamas Bahrain Bangladesh Bermuda Bolivia, Plurinational State of Bosnia and Herzegovina Botswana Brazil Brunei Darussalam Bulgaria Cambodia Cameroon Colombia Cook Islands Costa Rica Côte d'Ivoire Croatia Dominica Ecuador Egypt El Salvador Faroe Islands Fiji French Polynesia Georgia Ghana Greece Grenada Guatemala Haiti Holy See (Vatican City State) Honduras Hong Kong India Indonesia Iraq Jamaica Kazakhstan Kenya Kuwait Kyrgyzstan Laos Lebanon Macedonia, the Former Yugoslav Republic of Malawi Malaysia Malta Mauritius Moldova, Republic of Monaco Mongolia Morocco Myanmar Namibia Nepal New Caledonia Nicaragua Nigeria Oman Pakistan Philippines Qatar Russian Federation Saint Barthélemy Saint Kitts and Nevis Saint Lucia Saint Martin (French part) San Marino Saudi Arabia Senegal Serbia Sierra Leone Singapore Sint Maarten (Dutch part) South Africa Sri Lanka Swaziland Tajikistan Tanzania, United Republic of Thailand Trinidad and Tobago Tunisia Turkey Turks and Caicos Islands Ukraine Uzbekistan Venezuela, Bolivarian Republic of Viet Nam Virgin Islands, British Zambia Using directions services There are many tools you can use to enable directions-related services for your Mapbox web or mobile application. You can access these services directly using the web services APIs, through our Navigation SDK, or using one of several plugins and libraries to integrate these services into applications across platforms. Web services APIs There are four directions-related services that Mapbox offers: Mapbox Directions API: retrieve point to point directions including a route with durations, estimated distances, and turn-by-turn instructions. Mapbox Matrix API: retrieve all travel times between many points. Mapbox Optimization API: retrieve duration-optimized trips between input coordinates. Mapbox Map Matching API: align existing fuzzy routes to the routeable network. Read more about the required inputs for each API below. Mapbox Directions API Requesting directions from the Mapbox Directions API requires at least two waypoints — an origin and a destination — but can also include up to 23 additional waypoints between (or a total of 25 waypoints). When making a request, you can specify additional parameters such as which profile to use (walking, cycling, driving, or driving with traffic) and whether alternate routes should be included in the response. You can also add optional annotations to your request, including duration, distance, speed, and congestion. We calculate congestion by comparing night-time traffic speeds with real-time traffic speeds and assign a level of congestion given the percentage difference. You can read more about the directions response object in our API documentation. Mapbox Matrix API The Mapbox Matrix API returns travel times between many locations. Each location is either a source or destination. The number of sources and destinations are multiplied to create the matrix, or timetable, and calculate the number of elements needed to make the request. For example, given three locations A, B, C, the Matrix API will return a matrix of all travel times in seconds between all locations: A B C A A → A A → B A → C B B → A B → B B → C C C → A C → B C → C The Matrix API will always return the duration on the most efficient route for each location in the matrix, where an element is an origin-destination pair in the matrix. Durations between locations may not be symmetric (for example A to B may have a different duration than B to A), as the routes may differ by direction due to one-way streets or turn restrictions. The Matrix API returns durations in seconds. It does not return route geometries or distances. Like the Directions API, the Matrix API must be used on the same continent (does not cross over water bodies). This API allows you to build tools that efficiently check the reachability of coordinates from each other, filter locations by travel time, or run your own algorithms for solving optimization problems. Each request requires that you specify which locations are the sources and which are the destinations. There are four types of requests you can use with the Matrix API: Many to many (NxN) A many to many request is the default and generates the most results per-number-of-coordinates. This assumes all locations are sources and destinations. Without passing the source and destinations in the request, the response will still output an array of travel times between all locations. https://api.mapbox.com/directions-matrix/v1/mapbox/driving/A;B;C;D;E?access_token=.... One to many (1xN) In some cases, you may have a single source (for example, one driver) and four potential destinations (four gas stations). To calculate which destination has the shortest drive time, you need to specify the source and destination coordinates. https://api.mapbox.com/directions-matrix/v1/mapbox/driving/A;B;C;D;E?sources=0&destinations=1;2;3;4&access_token=... Many to one (Nx1) An opposite request may be necessary where you may want to find travel times of many taxis to one rider, for example. In this case, a many to one (Nx1) request can be made by listing all your sources and your one destination. https://api.mapbox.com/directions-matrix/v1/mapbox/driving/A;B;C;D;E?sources=1;2;3;4&destinations=0&access_token=.... Several to several (MxN) An uncommon but useful case is a several to several (NxM) request where you may want to be selective about how many sources and destinations you wish to find travel times to and from. https://api.mapbox.com/directions-matrix/v1/mapbox/driving/A;B;C;D;E?sources=0;1&destinations=2;3;4&access_token=.... Mapbox Optimization API The Mapbox Optimization API returns a duration-optimized trip between the input coordinates. This is also known as solving the Traveling Salesperson Problem. This API could be used to plan a route for deliveries in a city. Optimized trips can be retrieved for driving, bicycling, and walking or hiking. Mapbox Map Matching API The Mapbox Map Matching API snaps fuzzy, inaccurate traces from a GPS unit or a phone to the OpenStreetMap road and path network using the Directions API. This produces clean paths that can be displayed on a map or used for other analysis. Mapbox Navigation SDK You can add directions to a mobile application using the Mapbox Navigation SDK for iOS and Android. With the Navigation SDK, it takes only a few lines of code to display a complete navigation experience inside your app. With the Navigation SDK, you can: Generate turn-by-turn instructions. Use automatic rerouting when a user deviates from the route. Provide walking, biking, and driving directions. Provide real-time traffic. Read more about the Navigation SDK for iOS and Android. Libraries and plugins We have several tools across platforms that allow you to integrate the Mapbox Directions API into your existing applications seamlessly: Web: Mapbox GL Directions plugin for Mapbox GL JS and Mapbox-directions.js for Mapbox.js Android: Mapbox Java SDK iOS: MapboxDirections.swift These tools allow you to add routing capabilities to your application, but have limitations when it comes to customization. These tools do not provide access to the Mapbox Matrix API, Optimization API, or Map Matching API. For more flexibility, you can use our APIs directly. In addition, we offer libraries for: Python JavaScript Here's an example of the Mapbox GL Directions plugin in action: Testing the API If you would like to get a feel for how the Mapbox Directions API works without building a whole application, we also provide an API Playground. Besides providing a convenient user interface to test queries, the API playground allows you to test the API's URL and query parameters, such as mode of transportation, steps, and alternative routes. Visit the API Playground Providing directions feedback If you find issues with routing or any of the related services, you can provide feedback on our Directions Feedback page. If you are using the API directly, you can use the API Playground to test your request, response, and any parameters you would like to include in your request. Was this page helpful? Yes No",,Directions,The routing network,Travel times,Traffic data,Highly accurate travel times,Moderately accurate travel times,Limited predictability of travel times,Using directions services,Web services APIs,Mapbox Directions API,Mapbox Matrix API,Mapbox Optimization API,Mapbox Map Matching API,Mapbox Navigation SDK,Libraries and plugins,Testing the API,,,Providing directions feedback,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Tilequery API,"The Mapbox Tilequery API allows you to retrieve data about specific features from a vector tileset, based on a given latitude and longitude.",https://docs.mapbox.com/help/glossary/tilequery-api/,glossary,,,"Tilequery API The Mapbox Tilequery API allows you to retrieve data about specific features from a vector tileset, based on a given longitude and latitude. A sample Tilequery API request looks like: https://api.mapbox.com/v4/mapbox.mapbox-streets-v8/tilequery/-122.42901,37.80633.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN The Tilequery API has optional parameters that can be used to refine the results of a request. Related resources: Tilequery API documentation Tilequery API playground Create a timezone finder with the Tilequery API tutorial Find elevations with the Tilequery API tutorial Use the Tilequery API and the Geocoding API to create a healthy food finder tutorial Was this page helpful? Yes No",,Tilequery API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Data-joins with Mapbox Boundaries,Join data with v2 of the Mapbox Boundaries tileset.,https://docs.mapbox.com/help/tutorials/data-joins-with-mapbox-boundaries/,tutorial,JavaScript,,"advanced JavaScript Data-joins with Mapbox Boundaries Prerequisite Familiarity with front-end development and access to Mapbox Boundaries. Access to Mapbox Boundaries Access to the Boundaries tilesets are controlled by Mapbox account access token. If you do not have access on your account, contact a Mapbox sales representative to request access to Boundaries tilesets. Mapbox Enterprise users can add global administrative, postal, and statistical boundaries to their maps and data visualizations. This guide covers how to create a data-join using Mapbox Boundaries with Mapbox GL JS to style a choropleth map. Getting started Mapbox Boundaries are available as a part of an Enterprise plan. If you do not have an Enterprise plan or if you do have an Enterprise plan and would like to add access to Mapbox Boundaries, contact a Mapbox sales representative to request access. Access to the Boundaries tilesets are controlled by your Mapbox account access token. About data-joins The data-join technique involves inner joins between your custom local data, such as the unemployment rate by US state, to vector tile features, such as state boundaries in the appropriate Mapbox Boundaries tileset, using data-driven style notation. Create a data-join with Mapbox Boundaries Below you'll use Mapbox GL JS, local data, Mapbox Boundaries, feature state, and data-driven styling with expressions to join local data to a vector tile source and style a choropleth map. Create a map with Mapbox GL JS Begin by initializing a map with Mapbox GL JS. Make sure the access token you are using is from your account with access to Mapbox Boundaries. Here's the starter code for this example: <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Join local JSON data with Boundaries</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'> </div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // Initialize a map var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/light-v 10 ', center: [-99.9, 41.5], zoom: 1 } ); // Local data code from the next step will go here. </script> </body> </html> Local data In this example, you'll join unemployment data for the US to the admin-1 Boundaries tileset. Here you'll set the array of objects equal to a variable called localData. In your own application, you can pull local data into your application how you'd like. Here's the data used in this example as a JavaScript variable called localData that can be directly added to the HTML file's script tags alongside the code used to initialize the map: var localData = [ { STATE_ID: '01', unemployment: 13.17 } , { STATE_ID: '02', unemployment: 9.5 } , { STATE_ID: '04', unemployment: 12.15 } , { STATE_ID: '05', unemployment: 8.99 } , { STATE_ID: '06', unemployment: 11.83 } , { STATE_ID: '08', unemployment: 7.52 } , { STATE_ID: '09', unemployment: 6.44 } , { STATE_ID: '10', unemployment: 5.17 } , { STATE_ID: '12', unemployment: 9.67 } , { STATE_ID: '13', unemployment: 10.64 } , { STATE_ID: '15', unemployment: 12.38 } , { STATE_ID: '16', unemployment: 10.13 } , { STATE_ID: '17', unemployment: 9.58 } , { STATE_ID: '18', unemployment: 10.63 } , { STATE_ID: '19', unemployment: 8.09 } , { STATE_ID: '20', unemployment: 5.93 } , { STATE_ID: '21', unemployment: 9.86 } , { STATE_ID: '22', unemployment: 9.81 } , { STATE_ID: '23', unemployment: 7.82 } , { STATE_ID: '24', unemployment: 8.35 } , { STATE_ID: '25', unemployment: 9.1 } , { STATE_ID: '26', unemployment: 10.69 } , { STATE_ID: '27', unemployment: 11.53 } , { STATE_ID: '28', unemployment: 9.29 } , { STATE_ID: '29', unemployment: 9.94 } , { STATE_ID: '30', unemployment: 9.29 } , { STATE_ID: '31', unemployment: 5.45 } , { STATE_ID: '32', unemployment: 4.21 } , { STATE_ID: '33', unemployment: 4.27 } , { STATE_ID: '34', unemployment: 4.09 } , { STATE_ID: '35', unemployment: 7.83 } , { STATE_ID: '36', unemployment: 8.01 } , { STATE_ID: '37', unemployment: 9.34 } , { STATE_ID: '38', unemployment: 11.23 } , { STATE_ID: '39', unemployment: 7.08 } , { STATE_ID: '40', unemployment: 11.22 } , { STATE_ID: '41', unemployment: 6.2 } , { STATE_ID: '42', unemployment: 9.11 } , { STATE_ID: '44', unemployment: 10.42 } , { STATE_ID: '45', unemployment: 8.89 } , { STATE_ID: '46', unemployment: 11.03 } , { STATE_ID: '47', unemployment: 7.35 } , { STATE_ID: '48', unemployment: 8.92 } , { STATE_ID: '49', unemployment: 7.65 } , { STATE_ID: '50', unemployment: 8.01 } , { STATE_ID: '51', unemployment: 7.62 } , { STATE_ID: '53', unemployment: 7.77 } , { STATE_ID: '54', unemployment: 8.49 } , { STATE_ID: '55', unemployment: 9.42 } , { STATE_ID: '56', unemployment: 7.59 } ]; Mapbox Boundaries lookup table Each Boundaries tileset has its own feature lookup table in which each feature in that tileset is indexed. Lookup tables are designed to be used locally in your application. You can read more about feature lookup tables in the Get started with Mapbox Boundaries guide. The code snippet below illustrates how to import the feature lookup table from a file hosted in the application, then make the API request when the map loads, retrieve the contents of the lookup table, and print the response in the console. You will need to replace ./path/to/lookup/table with the path to the appropriate lookup table, available in the reference documentation that is provided with Boundaries access. const lookupTable = require('./path/to/lookup/table') map.on('load', function () { createViz(lookupTable); } ); function createViz(lookupData) { var dataValues = lookupData.data; console.log(dataValues); } Explore the response in the console to learn more about what is included in the lookup tables and better understand how you'll be using it in the next step. Feature state Feature state is a set of attributes that can be dynamically assigned to a feature on the map. The Mapbox GL JS feature state API can be used to dynamically style the features of a vector or GeoJSON source, enabling new ways to handle map interactivity, data joins, and time series animations. Building on the createViz function that was defined in the previous step, add the Mapbox Boundaries admin-1 tileset as a source named statesData. Note Find the complete list of Mapbox Boundaries tilesets in the reference documentation. Then, create a new function called setStates within createViz to set the feature state. To join the local unemployment data to the vector tile boundary data, you'll need a property that can be used to match like features between the local and vector data. In the Boundaries feature lookup table, the information for each US state is in an object identified with a unique string using the following convention: US (for the United States) + A1 (for Admin 1) + some number (unique for each state). In the local data, each state is represented with only a number. But this number corresponds with the numbers in the feature lookup table, so you can join the JSON unemployment data with the corresponding vector features where the object's identifier === USA1 + STATE_ID. Feature state requires knowing the id for each vector feature. This unique identifier must consist of only integers. In the Mapbox Boundaries lookup tables, id_int is this unique integer-only identifier. To get the vector tile feature id to set the feature state, you end up with id: dataValues[""USA1"" + row[""STATE_ID""]].id_int to find the object in the dataValues from the lookup table with the identifier equal to ""USA1"" + row[""STATE_ID""] and then getting the value of the id_int property. Finally, you'll wait until the statesData source has been added to the map before calling your custom setState function to set the feature state. function createViz(lookupData) { var dataValues = lookupData.data; // Add Mapbox Boundaries source for state polygons. map.addSource('statesData', { type: 'vector', url: 'mapbox://mapbox.enterprise-boundaries-a1-v2' } ); // Join the JSON unemployment data with the corresponding vector features where // feautre.id === 'USA1' + `STATE_ID`. function setStates(e) { localData.forEach(function(row) { map.setFeatureState( { source: 'statesData', sourceLayer: 'boundaries_admin_1', id: dataValues['USA1' + row.STATE_ID].id_int } , { unemployment: row.unemployment } ); } ); } // Check if `statesData` source is loaded. function setAfterLoad(e) { if (e.sourceId === 'statesData' && e.isSourceLoaded) { setStates(); map.off('sourcedata', setAfterLoad); } } // If `statesData` source is loaded, call `setStates()`. if (map.isSourceLoaded('statesData')) { setStates(); } else { map.on('sourcedata', setAfterLoad); } } Data-driven styling with expressions Now that the local data and the vector data in the Mapbox Boundaries tileset have been joined, you can style the features in the Boundaries tileset according to the unemployment value from your local data. Inside the createViz function, add a new layer using map.addLayer(). The source will be statesData (added in the previous step), and the source-layer will be boundaries_admin_1. You can use expressions to set the fill color of each feature according to the unemployment value found in the feature state. Mapbox GL JS expressions uses a Lisp-like syntax, represented using JSON arrays. Expressions follow this format: [expression_name, argument_0, argument_1, ...] The expression_name is the expression operator, for example, you would use '*' to multiply two arguments or 'case' to create conditional logic. For a complete list of all available expressions see the Mapbox Style Specification. The arguments are either literal (numbers, strings, or boolean values) or else themselves expressions. The number of arguments varies based on the expression. In this example, you'll use a combination of expressions to style the data as a choropleth map: case: Use the case expression to (1) check if the unemployment feature state property is not null, (2) if unemployment is not null, you'll assign the fill color according to the value of unemployment, (3) if it is null, you'll assign a fill color of rgba(255, 255, 255, 0). feature-state: Use the feature-state expression to retrieve the value of the unemployment property in the current feature's state. !=: Use the != expression to check if the feature state unemployment property is not equal to null. interpolate: Use the interpolate expression to assign a fill color to two different values of unemployment and infer a continuous, smooth set of fill colors between the stops. When you put all these expressions together, your code will look like this: map.addLayer( { id: 'states-join', type: 'fill', source: 'statesData', 'source-layer': 'boundaries_admin_1', paint: { 'fill-color': ['case', ['!=', ['feature-state', 'unemployment'], null], ['interpolate', ['linear'], ['feature-state', 'unemployment'], 4, 'rgba(222,235,247,1)', 14, 'rgba(49,130,189,1)'], 'rgba(255, 255, 255, 0)' ] } } , 'waterway-label'); Final product You created a choropleth map using data-joins and Mapbox Boundaries. Here's the full code: <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Join local JSON data with vector tile geometries</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/light-v 10 ', center: [-99.9, 41.5], zoom: 1 } ); // Join local JSON data with vector tile geometry // unemployment rate in 2009 // Source https://data.bls.gov/timeseries/LNS14000000 var maxValue = 14; var localData = [ { STATE_ID: '01', unemployment: 13.17 } , { STATE_ID: '02', unemployment: 9.5 } , { STATE_ID: '04', unemployment: 12.15 } , { STATE_ID: '05', unemployment: 8.99 } , { STATE_ID: '06', unemployment: 11.83 } , { STATE_ID: '08', unemployment: 7.52 } , { STATE_ID: '09', unemployment: 6.44 } , { STATE_ID: '10', unemployment: 5.17 } , { STATE_ID: '12', unemployment: 9.67 } , { STATE_ID: '13', unemployment: 10.64 } , { STATE_ID: '15', unemployment: 12.38 } , { STATE_ID: '16', unemployment: 10.13 } , { STATE_ID: '17', unemployment: 9.58 } , { STATE_ID: '18', unemployment: 10.63 } , { STATE_ID: '19', unemployment: 8.09 } , { STATE_ID: '20', unemployment: 5.93 } , { STATE_ID: '21', unemployment: 9.86 } , { STATE_ID: '22', unemployment: 9.81 } , { STATE_ID: '23', unemployment: 7.82 } , { STATE_ID: '24', unemployment: 8.35 } , { STATE_ID: '25', unemployment: 9.1 } , { STATE_ID: '26', unemployment: 10.69 } , { STATE_ID: '27', unemployment: 11.53 } , { STATE_ID: '28', unemployment: 9.29 } , { STATE_ID: '29', unemployment: 9.94 } , { STATE_ID: '30', unemployment: 9.29 } , { STATE_ID: '31', unemployment: 5.45 } , { STATE_ID: '32', unemployment: 4.21 } , { STATE_ID: '33', unemployment: 4.27 } , { STATE_ID: '34', unemployment: 4.09 } , { STATE_ID: '35', unemployment: 7.83 } , { STATE_ID: '36', unemployment: 8.01 } , { STATE_ID: '37', unemployment: 9.34 } , { STATE_ID: '38', unemployment: 11.23 } , { STATE_ID: '39', unemployment: 7.08 } , { STATE_ID: '40', unemployment: 11.22 } , { STATE_ID: '41', unemployment: 6.2 } , { STATE_ID: '42', unemployment: 9.11 } , { STATE_ID: '44', unemployment: 10.42 } , { STATE_ID: '45', unemployment: 8.89 } , { STATE_ID: '46', unemployment: 11.03 } , { STATE_ID: '47', unemployment: 7.35 } , { STATE_ID: '48', unemployment: 8.92 } , { STATE_ID: '49', unemployment: 7.65 } , { STATE_ID: '50', unemployment: 8.01 } , { STATE_ID: '51', unemployment: 7.62 } , { STATE_ID: '53', unemployment: 7.77 } , { STATE_ID: '54', unemployment: 8.49 } , { STATE_ID: '55', unemployment: 9.42 } , { STATE_ID: '56', unemployment: 7.59 } ]; const lookupTable = require('./path/to/lookup/table') map.on('load', function () { createViz(lookupTable); } ); function createViz(lookupData) { var dataValues = lookupData.data; // Add Mapbox Boundaries source for state polygons. map.addSource('statesData', { type: 'vector', url: 'mapbox://mapbox.enterprise-boundaries-a1-v2' } ); // Add layer from the vector tile source with data-driven style // Use a feature-state dependent expression to compute the green color band based on // the unemployment percentage map.addLayer( { id: 'states-join', type: 'fill', source: 'statesData', 'source-layer': 'boundaries_admin_1', paint: { 'fill-color': ['case', ['!=', ['feature-state', 'unemployment'], null], ['interpolate', ['linear'], ['feature-state', 'unemployment'], 4, 'rgba(222,235,247,1)', 14, 'rgba(49,130,189,1)'], 'rgba(255, 255, 255, 0)' ] } } , 'waterway-label'); // Join the JSON unemployment data with the corresponding vector features where // feautre.id === 'USA1' + `STATE_ID`. function setStates(e) { localData.forEach(function(row) { map.setFeatureState( { source: 'statesData', sourceLayer: 'boundaries_admin_1', id: dataValues['USA1' + row.STATE_ID].id_int } , { unemployment: row.unemployment } ); } ); } // Check if `statesData` source is loaded. function setAfterLoad(e) { if (e.sourceId === 'statesData' && e.isSourceLoaded) { setStates(); map.off('sourcedata', setAfterLoad); } } // If `statesData` source is loaded, call `setStates()`. if (map.isSourceLoaded('statesData')) { setStates(); } else { map.on('sourcedata', setAfterLoad); } } </script> </body> </html> Next steps Learn more about how you can use Mapbox Boundaries. More Mapbox Boundaries tutorials Explore our other Mapbox Boundaries tutorials: Point-in-polygon query with Mapbox Boundaries: Determine what polygons exist at a single point using the Mapbox Tilequery API. Extend Mapbox Boundaries: You can extend Mapbox Boundaries with any custom data you need for your application. This could mean adding school district, city, market, or property boundaries to your application — all with the same performance and API features of the native product. Advanced use cases You can also explore this example, which uses the concepts outlined in both this data-join tutorial and the Point-in-polygon query tutorial to create an application that features an interactive choropleth map. Was this page helpful? Yes No",,Data-joins with Mapbox Boundaries,About data-joins,Create a data-join with Mapbox Boundaries,Create a map with Mapbox GL JS,Local data,Mapbox Boundaries lookup table,Feature state,Data-driven styling with expressions,Final product,Next steps,More Mapbox Boundaries tutorials,Advanced use cases,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,runtime styling,Runtime styling allows you to dynamically change the map style displayed on your Mapbox map in real time.,https://docs.mapbox.com/help/glossary/runtime-styling/,glossary,,,"runtime styling Runtime styling allows you to dynamically change the map style displayed on your Mapbox map in real time, allowing you to customize every aspect of the map’s appearance down to the smallest detail. You can change your map in response to user interaction, context, or to build complex data visualizations by accessing the individual layers of a map at runtime. For example - you can lighten or darken a map based on the time of day, personalize colors of parks based on user activity, or even change label languages based on user preference. Anything you can design in Mapbox Studio, you can also implement dynamically through code. Runtime styling is available in all products that rely on Mapbox GL. Was this page helpful? Yes No",,runtime styling,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Visualize population density,Using a variable binding expression to calculate and display population density.,https://docs.mapbox.com/mapbox-gl-js/example/visualize-population-density/,example,JavaScript,,Visualize population density Using a variable binding expression to calculate and display population density. Was this example helpful? Yes No,,Visualize population density,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Style ocean depth data,Uses the interpolate expression with a cubic bezier curve expression to style bathymetry data.,https://docs.mapbox.com/mapbox-gl-js/example/style-ocean-depth-data/,example,JavaScript,,Style ocean depth data Uses the interpolate expression with a cubic bezier curve expression to style bathymetry data. Was this example helpful? Yes No,,Style ocean depth data,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,mapnik,"Mapnik is an open source mapping toolkit for desktop and server-based map rendering, providing algorithms and patterns for spatial data access and visualization.",https://docs.mapbox.com/help/glossary/mapnik/,glossary,,,"mapnik Mapnik is an open source mapping toolkit for desktop and server-based map rendering, providing algorithms and patterns for spatial data access and visualization. It is a collection of geographic objects like maps, layers, data sources, features, and geometries. Mapnik is used to render classic styles when requesting tiles from the Mapbox Raster Tiles API. It is also used to render maps within Mapbox Studio Classic. Note Mapbox Studio Classic, which uses classic styles, is no longer in active development. To learn more about our newer mapping tools see Mapbox Studio styles. Was this page helpful? Yes No",,mapnik,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Default styles,Use a variety of professionally designed styles with the Mapbox Maps SDK for iOS.,https://docs.mapbox.com/ios/maps/examples/default-styles/,example,Swift,,"Default styles To use one of the default styles provided by Mapbox, call the corresponding class method of MGLStyle, then pass the return value into -[MGLMapView setStyleURL:]. If you’re using an Interface Builder storyboard, set the Style URL inspectable to a URL such as mapbox://styles/mapbox/light-v9. Swift Objective C import Mapbox class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.outdoorsStyleURL) // Tint the ℹ️ button and the user location annotation. mapView.tintColor = .darkGray mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 51.50713, longitude: -0.10957), zoomLevel: 13, animated: false) view.addSubview(mapView) } } Copy Was this page helpful? Yes No",,Default styles,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Restrict map panning to an area,Prevent a map from being panned to a different place by setting maxBounds.,https://docs.mapbox.com/mapbox-gl-js/example/restrict-bounds/,example,JavaScript,,Restrict map panning to an area Prevent a map from being panned to a different place by setting maxBounds. Was this example helpful? Yes No,,Restrict map panning to an area,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Adjust text labels,"Adjust the color, size, and fonts of SymbolLayer text fields.",https://docs.mapbox.com/android/maps/examples/text-field-formatting/,example,Java,,"Adjust text labels Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:fab=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""19.948045"" mapbox:mapbox_cameraTargetLng=""-84.654463"" mapbox:mapbox_cameraZoom=""3.371717"" /> <com.getbase.floatingactionbutton.FloatingActionsMenu android:id=""@+id/multiple_text_field_actions_parent_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_margin=""16dp"" fab:fab_addButtonColorNormal=""@color/mapboxRed"" fab:fab_addButtonColorPressed=""@color/mapboxWhite"" fab:fab_addButtonPlusIconColor=""@color/mapboxWhite"" fab:fab_labelStyle=""@style/menu_labels_style""> <com.getbase.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_toggle_font"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" fab:fab_colorNormal=""@color/mapboxBlue"" fab:fab_colorPressed=""@color/mapboxWhite"" fab:fab_size=""mini"" fab:fab_title=""@string/fab_toggle_font"" /> <com.getbase.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_toggle_text_size"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" fab:fab_colorNormal=""@color/mapboxGreen"" fab:fab_colorPressed=""@color/mapboxWhite"" fab:fab_size=""mini"" fab:fab_title=""@string/fab_toggle_text_size"" /> <com.getbase.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_toggle_text_color"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" fab:fab_colorNormal=""@color/mapboxRed"" fab:fab_colorPressed=""@color/mapboxWhite"" fab:fab_size=""mini"" fab:fab_title=""@string/fab_toggle_text_color"" /> </com.getbase.floatingactionbutton.FloatingActionsMenu> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.Layer; import com.mapbox.mapboxsdk.style.layers.PropertyValue; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textFont; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textSize; /** * Use runtime styling to adjust the font, size, and color of SymbolLayer text fields. */ public class TextFieldFormattingActivity extends AppCompatActivity { private static final String[] textFonts = new String[] {""Roboto Black"", ""Arial Unicode MS Regular""}; private static final Float[] textSizes = new Float[] {25f, 13f}; private static final String[] textColors = new String[] {""#00FF08"", ""#ffd43a""}; private static final String WATER_RELATED_LAYER = ""water-""; private static final String WATER_SHADOW_LAYER_ID = ""water-shadow""; private MapView mapView; private MapboxMap mapboxMap; private boolean fontChanged; private boolean sizeChanged; private boolean colorChanged; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_text_field_formatting); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { TextFieldFormattingActivity.this.mapboxMap = mapboxMap; Toast.makeText(TextFieldFormattingActivity.this, getString(R.string.instruction_toast), Toast.LENGTH_SHORT).show(); // Set click listeners for the text adjustment buttons findViewById(R.id.fab_toggle_font).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { adjustText(textFont(fontChanged ? new String[] {textFonts[1]} : new String[] {textFonts[0]})); fontChanged = !fontChanged; } }); findViewById(R.id.fab_toggle_text_size).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { adjustText(textSize(sizeChanged ? textSizes[1] : textSizes[0])); sizeChanged = !sizeChanged; } }); findViewById(R.id.fab_toggle_text_color).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { adjustText(textColor(colorChanged ? textColors[1] : textColors[0])); colorChanged = !colorChanged; } }); } }); } }); } /** * Retrieve a specific layer and adjust a property of its text field. * * @param propertyValue the {@link com.mapbox.mapboxsdk.style.layers.PropertyFactory} to adjust for * the specific layer's text field. */ private void adjustText(@NonNull PropertyValue propertyValue) { if (mapboxMap.getStyle() != null) { for (Layer singleMapLayer : mapboxMap.getStyle().getLayers()) { if (singleMapLayer.getId().contains(WATER_RELATED_LAYER) && !singleMapLayer.getId().equals(WATER_SHADOW_LAYER_ID)) { singleMapLayer.setProperties(propertyValue); } } } else { Toast.makeText(this, R.string.map_style_not_loaded_yet, Toast.LENGTH_SHORT).show(); } } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Adjust text labels,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Default styles,Use a variety of professionally designed styles with the Mapbox Maps SDK.,https://docs.mapbox.com/android/maps/examples/use-default-styles/,example,Java,,"Default styles Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.DefaultStyleActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""50.84749"" mapbox:mapbox_cameraTargetLng=""4.35137"" mapbox:mapbox_cameraZoom=""12""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.Menu; import android.view.MenuItem; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; /** * Use a variety of professionally designed styles with the Mapbox Android SDK. */ public class DefaultStyleActivity extends AppCompatActivity { private MapView mapView; private MapboxMap mapboxMap; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_default); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { DefaultStyleActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.LIGHT); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_map_style, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { // Handle item selection switch (item.getItemId()) { case R.id.menu_streets: mapboxMap.setStyle(Style.MAPBOX_STREETS); return true; case R.id.menu_dark: mapboxMap.setStyle(Style.DARK); return true; case R.id.menu_light: mapboxMap.setStyle(Style.LIGHT); return true; case R.id.menu_outdoors: mapboxMap.setStyle(Style.OUTDOORS); return true; case R.id.menu_satellite: mapboxMap.setStyle(Style.SATELLITE); return true; case R.id.menu_satellite_streets: mapboxMap.setStyle(Style.SATELLITE_STREETS); return true; case android.R.id.home: finish(); return true; default: return super.onOptionsItemSelected(item); } } } Copy Was this page helpful? Yes No",,Default styles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Help,Help and troubleshooting articles for the Mapbox Navigation SDK for iOS.,https://docs.mapbox.com/ios/navigation/help/,,,,"Our Help page contains tutorials, troubleshooting guides, and other resources to help you get started. Tutorials Build a navigation app for iOS Integrate navigation into any iOS application. Troubleshooting Keep access tokens private in open source iOS apps Learn how to keep access tokens private in private open source iOS apps.",,Tutorials,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Animated icon movement,Use Android system interpolators to animate SymbolLayer icons movement.,https://docs.mapbox.com/android/maps/examples/value-animator-icon-animation/,example,Java,,"Animated icon movement Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:fab=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.labs.ValueAnimatorIconAnimationActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""0.282219"" mapbox:mapbox_cameraTargetLng=""117.226205"" mapbox:mapbox_cameraTilt=""55"" mapbox:mapbox_cameraZoom=""4"" mapbox:mapbox_uiRotateGestures=""false"" /> <com.getbase.floatingactionbutton.FloatingActionsMenu android:id=""@+id/interpolator_selection_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_margin=""16dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:layout_marginBottom=""8dp"" fab:fab_addButtonColorNormal=""@color/mapboxRed"" fab:fab_addButtonColorPressed=""@color/mapboxWhite"" fab:fab_addButtonPlusIconColor=""@color/mapboxWhite"" fab:fab_labelStyle=""@style/menu_labels_style"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent""> <com.getbase.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_bounce_interpolator"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" fab:fab_colorNormal=""@color/mapboxBlue"" fab:fab_colorPressed=""@color/mapboxWhite"" fab:fab_size=""mini"" fab:fab_title=""@string/bounce_interpolator"" /> <com.getbase.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_linear_interpolator"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" fab:fab_colorNormal=""@color/mapboxGreen"" fab:fab_colorPressed=""@color/mapboxWhite"" fab:fab_size=""mini"" fab:fab_title=""@string/linear_interpolator"" /> <com.getbase.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_accelerate_interpolator"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" fab:fab_colorNormal=""@color/mapboxRed"" fab:fab_colorPressed=""@color/mapboxWhite"" fab:fab_size=""mini"" fab:fab_title=""@string/accelerate_interpolator"" /> <com.getbase.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_decelerate_interpolator"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" fab:fab_colorNormal=""@color/mapboxYellow"" fab:fab_colorPressed=""@color/mapboxWhite"" fab:fab_size=""mini"" fab:fab_title=""@string/decelerate_interpolator"" /> </com.getbase.floatingactionbutton.FloatingActionsMenu> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.animation.TimeInterpolator; import android.animation.ValueAnimator; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.view.animation.AccelerateInterpolator; import android.view.animation.BounceInterpolator; import android.view.animation.DecelerateInterpolator; import android.view.animation.LinearInterpolator; import com.getbase.floatingactionbutton.FloatingActionButton; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Combine SymbolLayer icons with the Android system's ValueAnimator and interpolator * animation for a fun pin drop effect. The interpolator movement can also be used with other * types of map layers, such as a LineLayer or CircleLayer. * <p> * More info about https://developer.android.com/reference/android/view/animation/Interpolator */ public class ValueAnimatorIconAnimationActivity extends AppCompatActivity implements OnMapReadyCallback, MapView.OnDidFinishRenderingMapListener { private static final String ICON_ID = ""red-pin-icon-id""; // This float's actual value will depend on the height of the SymbolLayer icon private static final float DEFAULT_DESIRED_ICON_OFFSET = -16; private static final float STARTING_DROP_HEIGHT = -100; private static final long DROP_SPEED_MILLISECONDS = 1200; private static final String SYMBOL_LAYER_ID = ""symbol-layer-id""; private MapView mapView; private SymbolLayer pinSymbolLayer; private Style style; private TimeInterpolator currentSelectedTimeInterpolator = new BounceInterpolator(); private ValueAnimator animator; private boolean firstRunThrough = true; private boolean animationHasStarted; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_animated_pin_drop); // Initialize the map view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(new Style.Builder().fromUri(Style.LIGHT) // Add GeoJsonSource with random Features to the map. .withSource(new GeoJsonSource(""source-id"", FeatureCollection.fromFeatures(new Feature[] { Feature.fromGeometry(Point.fromLngLat( 119.86083984375, -1.834403324493515)), Feature.fromGeometry(Point.fromLngLat( 116.06637239456177, 5.970619502704659)), Feature.fromGeometry(Point.fromLngLat( 114.58740234375, 4.54357027937176)), Feature.fromGeometry(Point.fromLngLat( 118.19091796875, 5.134714634014467)), Feature.fromGeometry(Point.fromLngLat( 110.36865234374999, 1.4500404973608074)), Feature.fromGeometry(Point.fromLngLat( 109.40185546874999, 0.3076157096439005)), Feature.fromGeometry(Point.fromLngLat( 115.79589843749999, 1.5159363834516861)), Feature.fromGeometry(Point.fromLngLat( 113.291015625, -0.9667509997666298)), Feature.fromGeometry(Point.fromLngLat( 116.40083312988281, -0.3392008994314591)) }) )) .withImage(ICON_ID, BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.map_marker_push_pin_pink))), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { ValueAnimatorIconAnimationActivity.this.style = style; mapView.addOnDidFinishRenderingMapListener(ValueAnimatorIconAnimationActivity.this); } } ); } /** * Implementing this interface so that animation only starts once all tiles have been loaded * * @param fully whether or not the map is finished rendering */ @Override public void onDidFinishRenderingMap(boolean fully) { initAnimation(currentSelectedTimeInterpolator); initInterpolatorButtons(); } /** * Initialize and start the animation. * * @param desiredTimeInterpolator the type of Android system movement to animate the * SymbolLayer icons with. */ private void initAnimation(TimeInterpolator desiredTimeInterpolator) { if (animator != null) { animator.cancel(); } animator = ValueAnimator.ofFloat(STARTING_DROP_HEIGHT, -17); animator.setDuration(DROP_SPEED_MILLISECONDS); animator.setInterpolator(desiredTimeInterpolator); animator.setStartDelay(1000); animator.start(); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { if (!animationHasStarted) { initSymbolLayer(); animationHasStarted = true; } pinSymbolLayer.setProperties(iconOffset(new Float[] {0f, (Float) valueAnimator.getAnimatedValue()})); } }); } /** * Add the SymbolLayer to the map */ private void initSymbolLayer() { pinSymbolLayer = new SymbolLayer(SYMBOL_LAYER_ID, ""source-id""); pinSymbolLayer.setProperties( iconImage(ICON_ID), iconIgnorePlacement(true), iconAllowOverlap(true), iconOffset(new Float[] {0f, DEFAULT_DESIRED_ICON_OFFSET})); style.addLayer(pinSymbolLayer); } /** * Initialize the interpolator selection spinner menu */ private void initInterpolatorButtons() { FloatingActionButton bounceInterpolatorFab = findViewById(R.id.fab_bounce_interpolator); bounceInterpolatorFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (firstRunThrough) { firstRunThrough = true; } currentSelectedTimeInterpolator = new BounceInterpolator(); resetIcons(); } }); FloatingActionButton linearInterpolatorFab = findViewById(R.id.fab_linear_interpolator); linearInterpolatorFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { currentSelectedTimeInterpolator = new LinearInterpolator(); firstRunThrough = false; resetIcons(); } }); FloatingActionButton accelerateInterpolatorFab = findViewById(R.id.fab_accelerate_interpolator); accelerateInterpolatorFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { currentSelectedTimeInterpolator = new AccelerateInterpolator(); firstRunThrough = false; resetIcons(); } }); FloatingActionButton decelerateInterpolatorFab = findViewById(R.id.fab_decelerate_interpolator); decelerateInterpolatorFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { currentSelectedTimeInterpolator = new DecelerateInterpolator(); firstRunThrough = false; resetIcons(); } }); } private void resetIcons() { if (!firstRunThrough) { animationHasStarted = false; style.removeLayer(SYMBOL_LAYER_ID); initAnimation(currentSelectedTimeInterpolator); } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); if (animator != null) { animator.end(); } mapView.onStop(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,Animated icon movement,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,quadtree,A quadtree is a tree data structure.,https://docs.mapbox.com/help/glossary/quadtree/,glossary,,,"quadtree A quadtree is a tree data structure where each node has exactly 4 children. Quadtrees allow you to zoom in and out of maps. As the zoom level changes, the quads change to show more (or less) detail. Was this page helpful? Yes No",,quadtree,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,API Reference,The Mapbox GL JS API documentation to render interactive maps from vector tiles and Mapbox styles.,https://docs.mapbox.com/mapbox-gl-js/api/,API,,,"Mapbox GL JS Current version: mapbox-gl.js v 1.2.1 Mapbox GL JS is a JavaScript library that uses WebGL to render interactive maps from vector tiles and Mapbox styles. It is part of the Mapbox GL ecosystem, which includes Mapbox Mobile, a compatible renderer written in C++ with bindings for desktop and mobile platforms. Map src/ui/map.js The Map object represents the map on your page. It exposes methods and properties that enable you to programmatically change the map, and fires events as users interact with it. You create a Map by specifying a container and other options. Then Mapbox GL JS initializes the map on the page and returns your Map object. Extends Evented. new Map(options: Object) Parameters options(Object) Name Description options.container (HTMLElement | string) The HTML element in which Mapbox GL JS will render the map, or the element's string id . The specified element must have no children. options.minZoom number default 0 The minimum zoom level of the map (0-24). options.maxZoom number default 22 The maximum zoom level of the map (0-24). options.style (Object | string)? The map's Mapbox style. This must be an a JSON object conforming to the schema described in the Mapbox Style Specification , or a URL to such JSON. To load a style from the Mapbox API, you can use a URL of the form mapbox://styles/:owner/:style, where :owner is your Mapbox account name and :style is the style ID. Or you can use one of the following the predefined Mapbox styles: mapbox://styles/mapbox/streets-v10 mapbox://styles/mapbox/outdoors-v10 mapbox://styles/mapbox/light-v9 mapbox://styles/mapbox/dark-v9 mapbox://styles/mapbox/satellite-v9 mapbox://styles/mapbox/satellite-streets-v10 mapbox://styles/mapbox/navigation-preview-day-v2 mapbox://styles/mapbox/navigation-preview-night-v2 mapbox://styles/mapbox/navigation-guidance-day-v2 mapbox://styles/mapbox/navigation-guidance-night-v2 Tilesets hosted with Mapbox can be style-optimized if you append ?optimize=true to the end of your style URL, like mapbox://styles/mapbox/streets-v9?optimize=true. Learn more about style-optimized vector tiles in our API documentation. options.hash boolean default false If true , the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL. For example, http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60 . options.interactive boolean default true If false , no mouse, touch, or keyboard listeners will be attached to the map, so it will not respond to interaction. options.bearingSnap number default 7 The threshold, measured in degrees, that determines when the map's bearing will snap to north. For example, with a bearingSnap of 7, if the user rotates the map within 7 degrees of north, the map will automatically snap to exact north. options.pitchWithRotate boolean default true If false , the map's pitch (tilt) control with ""drag to rotate"" interaction will be disabled. options.clickTolerance number default 3 The max number of pixels a user can shift the mouse pointer during a click for it to be considered a valid click (as opposed to a mouse drag). options.attributionControl boolean default true If true , an AttributionControl will be added to the map. options.customAttribution (string | Array<string>)? String or strings to show in an AttributionControl . Only applicable if options.attributionControl is true . options.logoPosition string default 'bottom-left' A string representing the position of the Mapbox wordmark on the map. Valid options are top-left , top-right , bottom-left , bottom-right . options.failIfMajorPerformanceCaveat boolean default false If true , map creation will fail if the performance of Mapbox GL JS would be dramatically worse than expected (i.e. a software renderer would be used). options.preserveDrawingBuffer boolean default false If true , the map's canvas can be exported to a PNG using map.getCanvas().toDataURL() . This is false by default as a performance optimization. options.antialias boolean? If true , the gl context will be created with MSAA antialiasing, which can be useful for antialiasing custom layers. this is false by default as a performance optimization. options.refreshExpiredTiles boolean default true If false , the map won't attempt to re-request tiles once they expire per their HTTP cacheControl / expires headers. options.maxBounds LngLatBoundsLike? If set, the map will be constrained to the given bounds. options.scrollZoom (boolean | Object) default true If true , the ""scroll to zoom"" interaction is enabled. An Object value is passed as options to ScrollZoomHandler#enable . options.boxZoom boolean default true If true , the ""box zoom"" interaction is enabled (see BoxZoomHandler ). options.dragRotate boolean default true If true , the ""drag to rotate"" interaction is enabled (see DragRotateHandler ). options.dragPan boolean default true If true , the ""drag to pan"" interaction is enabled (see DragPanHandler ). options.keyboard boolean default true If true , keyboard shortcuts are enabled (see KeyboardHandler ). options.doubleClickZoom boolean default true If true , the ""double click to zoom"" interaction is enabled (see DoubleClickZoomHandler ). options.touchZoomRotate (boolean | Object) default true If true , the ""pinch to rotate and zoom"" interaction is enabled. An Object value is passed as options to TouchZoomRotateHandler#enable . options.trackResize boolean default true If true , the map will automatically resize when the browser window resizes. options.center LngLatLike default [0,0] The inital geographical centerpoint of the map. If center is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to [0, 0] Note: Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON. options.zoom number default 0 The initial zoom level of the map. If zoom is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to 0 . options.bearing number default 0 The initial bearing (rotation) of the map, measured in degrees counter-clockwise from north. If bearing is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to 0 . options.pitch number default 0 The initial pitch (tilt) of the map, measured in degrees away from the plane of the screen (0-60). If pitch is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to 0 . options.bounds LngLatBoundsLike? The initial bounds of the map. If bounds is specified, it overrides center and zoom constructor options. options.fitBoundsOptions Object? A fitBounds options object to use only when fitting the initial bounds provided above. options.renderWorldCopies boolean default true If true , multiple copies of the world will be rendered, when zoomed out. options.maxTileCacheSize number default null The maximum number of tiles stored in the tile cache for a given source. If omitted, the cache will be dynamically sized based on the current viewport. options.localIdeographFontFamily string default 'sans-serif' Defines a CSS font-family for locally overriding generation of glyphs in the 'CJK Unified Ideographs', 'Hiragana', 'Katakana' and 'Hangul Syllables' ranges. In these ranges, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold). Set to false , to enable font settings from the map's style for these glyph ranges. The purpose of this option is to avoid bandwidth-intensive glyph server requests. (see Use locally generated ideographs ) options.transformRequest RequestTransformFunction default null A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests. Expected to return an object with a url property and optionally headers and credentials properties. options.collectResourceTiming boolean default false If true , Resource Timing API information will be collected for requests made by GeoJSON and Vector Tile web workers (this information is normally inaccessible from the main Javascript thread). Information will be returned in a resourceTiming property of relevant data events. options.fadeDuration number default 300 Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds. This setting affects all symbol layers. This setting does not affect the duration of runtime styling transitions or raster tile cross-fading. options.crossSourceCollisions boolean default true If true , symbols from multiple sources can collide with each other during collision detection. If false , collision detection is run separately for the symbols in each source. options.accessToken string default null If specified, map will use this token instead of the one defined in mapboxgl.accessToken. Example var map = new mapboxgl.Map({ container: 'map', center: [-122.420679, 37.772537], zoom: 13, style: style_object, hash: true, transformRequest: (url, resourceType)=> { if(resourceType === 'Source' && url.startsWith('http://myHost')) { return { url: url.replace('http', 'https'), headers: { 'my-custom-header': true}, credentials: 'include' // Include cookies for cross-origin requests } } } }); Instance Members scrollZoom boxZoom dragRotate dragPan keyboard doubleClickZoom touchZoomRotate addControl(control, position?) removeControl(control) resize(eventData?) getBounds() getMaxBounds() setMaxBounds(bounds) setMinZoom(minZoom) getMinZoom() setMaxZoom(maxZoom) getRenderWorldCopies() setRenderWorldCopies(renderWorldCopies) getMaxZoom() project(lnglat) unproject(point) isMoving() isZooming() isRotating() on(type, layerId, listener) on(type, listener) off(type, listener) off(type, layerId, listener) queryRenderedFeatures(geometry?, options?) querySourceFeatures(sourceId, parameters?) setStyle(style, options?) getStyle() isStyleLoaded() addSource(id, source) isSourceLoaded(id) areTilesLoaded() removeSource(id) getSource(id) addImage(id, image, options) updateImage(id, image) hasImage(id) removeImage(id) loadImage(url, callback) listImages() addLayer(layer, beforeId?) moveLayer(id, beforeId?) removeLayer(id) getLayer(id) setFilter(layerId, filter, options = {}) setLayerZoomRange(layerId, minzoom, maxzoom) getFilter(layerId) setPaintProperty(layerId, name, value, options = {}) getPaintProperty(layerId, name) setLayoutProperty(layerId, name, value, options = {}) getLayoutProperty(layerId, name) setLight(light, options = {}) getLight() setFeatureState(feature, state) removeFeatureState(target, key) getFeatureState(feature) getContainer() getCanvasContainer() getCanvas() loaded() remove() triggerRepaint() showTileBoundaries showCollisionBoxes repaint getCenter() setCenter(center, eventData?) panBy(offset, options?, eventData?) panTo(lnglat, options?, eventData?) getZoom() setZoom(zoom, eventData?) zoomTo(zoom, options, eventData?) zoomIn(options?, eventData?) zoomOut(options?, eventData?) getBearing() setBearing(bearing, eventData?) rotateTo(bearing, options?, eventData?) resetNorth(options?, eventData?) resetNorthPitch(options?, eventData?) snapToNorth(options?, eventData?) getPitch() setPitch(pitch, eventData?) cameraForBounds(bounds, options?) fitBounds(bounds, options?, eventData?) fitScreenCoordinates(p0, p1, bearing, options?, eventData?) jumpTo(options, eventData?) easeTo(options, eventData?) flyTo(options, eventData?) stop() Events resize remove mousedown mouseup mouseover mousemove click dblclick mouseenter mouseleave mouseout contextmenu wheel touchstart touchend touchmove touchcancel movestart move moveend dragstart drag dragend zoomstart zoom zoomend rotatestart rotate rotateend pitchstart pitch pitchend boxzoomstart boxzoomend boxzoomcancel webglcontextlost webglcontextrestored load render idle error data styledata sourcedata dataloading styledataloading sourcedataloading styleimagemissing Related Display a map Was this section on Map helpful? Yes No accessToken src/index.js Gets and sets the map's access token. Example mapboxgl.accessToken = myAccessToken; Related Display a map Was this section on accessToken helpful? Yes No baseApiUrl src/index.js Gets and sets the map's default API URL for requesting tiles, styles, sprites, and glyphs Example mapboxgl.baseApiUrl = 'https://api.mapbox.com'; Was this section on baseApiUrl helpful? Yes No workerCount src/index.js Gets and sets the number of web workers instantiated on a page with GL JS maps. By default, it is set to half the number of CPU cores (capped at 6). Make sure to set this property before creating any map instances for it to have effect. Example mapboxgl.workerCount = 2; Was this section on workerCount helpful? Yes No maxParallelImageRequests src/index.js Gets and sets the maximum number of images (raster tiles, sprites, icons) to load in parallel, which affects performance in raster-heavy maps. 16 by default. Example mapboxgl.maxParallelImageRequests = 10; Was this section on maxParallelImageRequests helpful? Yes No supported src/index.js Test whether the browser supports Mapbox GL JS. Parameters options(Object?) Name Description options.failIfMajorPerformanceCaveat boolean default false If true , the function will return false if the performance of Mapbox GL JS would be dramatically worse than expected (e.g. a software WebGL renderer would be used). Returns boolean: Example mapboxgl.supported() // = true Related Check for browser support Was this section on supported helpful? Yes No version src/index.js The version of Mapbox GL JS in use as specified in package.json, CHANGELOG.md, and the GitHub release. Was this section on version helpful? Yes No setRTLTextPlugin src/index.js Sets the map's RTL text plugin. Necessary for supporting the Arabic and Hebrew languages, which are written right-to-left. Mapbox Studio loads this plugin by default. Parameters pluginURL(string)URL pointing to the Mapbox RTL text plugin source. callback(Function)Called with an error argument if there is an error. Example mapboxgl.setRTLTextPlugin('https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.0/mapbox-gl-rtl-text.js'); Related Add support for right-to-left scripts Was this section on setRTLTextPlugin helpful? Yes No clearStorage src/index.js Clears browser storage used by this library. Using this method flushes the Mapbox tile cache that is managed by this library. Tiles may still be cached by the browser in some cases. This API is supported on browsers where the Cache API is supported and enabled. This includes all major browsers when pages are served over https://, except Internet Explorer and Edge Mobile. When called in unsupported browsers or environments (private or incognito mode), the callback will be called with an error argument. Parameters callback(Function)Called with an error argument if there is an error. Was this section on clearStorage helpful? Yes No AnimationOptions src/ui/camera.js Options common to map movement methods that involve animation, such as Map#panBy and Map#easeTo, controlling the duration and easing function of the animation. All properties are optional. Properties duration(number): The animation's duration, measured in milliseconds. easing(Function): A function taking a time in the range 0..1 and returning a number where 0 is the initial state and 1 is the final state. offset(PointLike): of the target center relative to real map container center at the end of animation. animate(boolean): If false , no animation will occur. Was this section on AnimationOptions helpful? Yes No CameraOptions src/ui/camera.js Options common to Map#jumpTo, Map#easeTo, and Map#flyTo, controlling the desired location, zoom, bearing, and pitch of the camera. All properties are optional, and when a property is omitted, the current camera value for that property will remain unchanged. Properties center(LngLatLike): The desired center. zoom(number): The desired zoom level. bearing(number): The desired bearing, in degrees. The bearing is the compass direction that is ""up""; for example, a bearing of 90° orients the map so that east is up. pitch(number): The desired pitch, in degrees. around(LngLatLike): If zoom is specified, around determines the point around which the zoom is centered. Was this section on CameraOptions helpful? Yes No PaddingOptions src/ui/camera.js Options for setting padding on a call to Map#fitBounds. All properties of this object must be non-negative integers. Properties top(number): Padding in pixels from the top of the map canvas. bottom(number): Padding in pixels from the bottom of the map canvas. left(number): Padding in pixels from the left of the map canvas. right(number): Padding in pixels from the right of the map canvas. Was this section on PaddingOptions helpful? Yes No RequestParameters src/util/ajax.js A RequestParameters object to be returned from Map.options.transformRequest callbacks. Properties url(string): The URL to be requested. headers(Object): The headers to be sent with the request. credentials(string): 'same-origin'|'include' Use 'include' to send cookies with cross-origin requests. Was this section on RequestParameters helpful? Yes No StyleImageInterface src/style/style_image.js Interface for dynamically generated style images. This is a specification for implementers to model: it is not an exported method or class. Images implementing this interface can be redrawn for every frame. They can be used to animate icons and patterns or make them respond to user input. Style images can implement a StyleImageInterface#render method. The method is called every frame and can be used to update the image. Properties width(number) height(number) data((Uint8Array | Uint8ClampedArray)) Example var flashingSquare = { width: 64, height: 64, data: new Uint8Array(64 * 64 * 4), onAdd: function(map) { this.map = map; }, render: function() { // keep repainting while the icon is on the map this.map.triggerRepaint(); // alternate between black and white based on the time var value = Math.round(Date.now() / 1000) % 2 === 0 ? 255 : 0; // check if image needs to be changed if (value !== this.previousValue) { this.previousValue = value; var bytesPerPixel = 4; for (var x = 0; x < this.width; x++) { for (var y = 0; y < this.height; y++) { var offset = (y * this.width + x) * bytesPerPixel; this.data[offset + 0] = value; this.data[offset + 1] = value; this.data[offset + 2] = value; this.data[offset + 3] = 255; } } // return true to indicate that the image changed return true; } } } map.addImage('flashing_square', flashingSquare); Instance Members onAdd(map) render() onRemove() Related Add an animated icon to the map. Was this section on StyleImageInterface helpful? Yes No CustomLayerInterface src/style/style_layer/custom_style_layer.js Interface for custom style layers. This is a specification for implementers to model: it is not an exported method or class. Custom layers allow a user to render directly into the map's GL context using the map's camera. These layers can be added between any regular layers using Map#addLayer. Custom layers must have a unique id and must have the type of ""custom"". They must implement render and may implement prerender, onAdd and onRemove. They can trigger rendering using Map#triggerRepaint and they should appropriately handle Map.event:webglcontextlost and Map.event:webglcontextrestored. The renderingMode property controls whether the layer is treated as a ""2d"" or ""3d"" map layer. Use: ""renderingMode"": ""3d"" to use the depth buffer and share it with other layers ""renderingMode"": ""2d"" to add a layer with no depth. If you need to use the depth buffer for a ""2d"" layer you must use an offscreen framebuffer and CustomLayerInterface#prerender Properties id(string): A unique layer id. type(string): The layer's type. Must be ""custom"" . renderingMode(string): Either ""2d"" or ""3d"" . Defaults to ""2d"" . Example // Custom layer implemented as ES6 class class NullIslandLayer { constructor() { this.id = 'null-island'; this.type = 'custom'; this.renderingMode = '2d'; } onAdd(map, gl) { const vertexSource = ` uniform mat4 u_matrix; void main() { gl_Position = u_matrix * vec4(0.5, 0.5, 0.0, 1.0); gl_PointSize = 20.0; }`; const fragmentSource = ` void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }`; const vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, vertexSource); gl.compileShader(vertexShader); const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, fragmentSource); gl.compileShader(fragmentShader); this.program = gl.createProgram(); gl.attachShader(this.program, vertexShader); gl.attachShader(this.program, fragmentShader); gl.linkProgram(this.program); } render(gl, matrix) { gl.useProgram(this.program); gl.uniformMatrix4fv(gl.getUniformLocation(this.program, ""u_matrix""), false, matrix); gl.drawArrays(gl.POINTS, 0, 1); } } map.on('load', function() { map.addLayer(new NullIslandLayer()); }); Instance Members render(gl, matrix) prerender(gl, matrix) onAdd(map, gl) onRemove(map, gl) Was this section on CustomLayerInterface helpful? Yes No Geography & Geometry LngLat and LngLatBounds represent points and rectangles in geographic coordinates. Point represents points in screen coordinates. LngLat src/geo/lng_lat.js A LngLat object represents a given longitude and latitude coordinate, measured in degrees. Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON. Note that any Mapbox GL method that accepts a LngLat object as an argument or option can also accept an Array of two numbers and will perform an implicit conversion. This flexible type is documented as LngLatLike. new LngLat(lng: number, lat: number) Parameters lng(number)Longitude, measured in degrees. lat(number)Latitude, measured in degrees. Example var ll = new mapboxgl.LngLat(-73.9749, 40.7736); Static Members convert(input) Instance Members wrap() toArray() toString() toBounds(radius) Related Get coordinates of the mouse pointer Display a popup Highlight features within a bounding box Create a timeline animation Was this section on LngLat helpful? Yes No LngLatLike src/geo/lng_lat.js A LngLat object, an array of two numbers representing longitude and latitude, or an object with lng and lat or lon and lat properties. Example var v1 = new mapboxgl.LngLat(-122.420679, 37.772537); var v2 = [-122.420679, 37.772537]; var v3 = {lon: -122.420679, lat: 37.772537}; Was this section on LngLatLike helpful? Yes No LngLatBounds src/geo/lng_lat_bounds.js A LngLatBounds object represents a geographical bounding box, defined by its southwest and northeast points in longitude and latitude. If no arguments are provided to the constructor, a null bounding box is created. Note that any Mapbox GL method that accepts a LngLatBounds object as an argument or option can also accept an Array of two LngLatLike constructs and will perform an implicit conversion. This flexible type is documented as LngLatBoundsLike. new LngLatBounds(sw: LngLatLike?, ne: LngLatLike?) Parameters sw(LngLatLike?)The southwest corner of the bounding box. ne(LngLatLike?)The northeast corner of the bounding box. Example var sw = new mapboxgl.LngLat(-73.9876, 40.7661); var ne = new mapboxgl.LngLat(-73.9397, 40.8002); var llb = new mapboxgl.LngLatBounds(sw, ne); Static Members convert(input) Instance Members setNorthEast(ne) setSouthWest(sw) extend(obj) getCenter() getSouthWest() getNorthEast() getNorthWest() getSouthEast() getWest() getSouth() getEast() getNorth() toArray() toString() isEmpty() Was this section on LngLatBounds helpful? Yes No LngLatBoundsLike src/geo/lng_lat_bounds.js A LngLatBounds object, an array of LngLatLike objects in [sw, ne] order, or an array of numbers in [west, south, east, north] order. Example var v1 = new mapboxgl.LngLatBounds( new mapboxgl.LngLat(-73.9876, 40.7661), new mapboxgl.LngLat(-73.9397, 40.8002) ); var v2 = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]) var v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]]; Was this section on LngLatBoundsLike helpful? Yes No Point src/ui/map.js A Point geometry object, which has x and y properties representing screen coordinates in pixels. Was this section on Point helpful? Yes No PointLike src/ui/map.js A Point or an array of two numbers representing x and y screen coordinates in pixels. Was this section on PointLike helpful? Yes No MercatorCoordinate src/geo/mercator_coordinate.js A MercatorCoordinate object represents a projected three dimensional position. MercatorCoordinate uses the web mercator projection (EPSG:3857) with slightly different units: the size of 1 unit is the width of the projected world instead of the ""mercator meter"" the origin of the coordinate space is at the north-west corner instead of the middle For example, MercatorCoordinate(0, 0, 0) is the north-west corner of the mercator world and MercatorCoordinate(1, 1, 0) is the south-east corner. If you are familiar with vector tiles it may be helpful to think of the coordinate space as the 0/0/0 tile with an extent of 1. The z dimension of MercatorCoordinate is conformal. A cube in the mercator coordinate space would be rendered as a cube. new MercatorCoordinate(x: number, y: number, z: number) Parameters x(number)The x component of the position. y(number)The y component of the position. z(number)( default 0)The z component of the position. Example var nullIsland = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0); Static Members fromLngLat(lngLatLike, altitude) Instance Members toLngLat() toAltitude() Related Add a custom style layer Was this section on MercatorCoordinate helpful? Yes No User Interface Controls, markers, and popups add new user interface elements to the map. IControl src/ui/map.js Interface for interactive controls added to the map. This is an specification for implementers to model: it is not an exported method or class. Controls must implement onAdd and onRemove, and must own an element, which is often a div element. To use Mapbox GL JS's default control styling, add the mapboxgl-ctrl class to your control's node. Example // Control implemented as ES6 class class HelloWorldControl { onAdd(map) { this._map = map; this._container = document.createElement('div'); this._container.className = 'mapboxgl-ctrl'; this._container.textContent = 'Hello, world'; return this._container; } onRemove() { this._container.parentNode.removeChild(this._container); this._map = undefined; } } // Control implemented as ES5 prototypical class function HelloWorldControl() { } HelloWorldControl.prototype.onAdd = function(map) { this._map = map; this._container = document.createElement('div'); this._container.className = 'mapboxgl-ctrl'; this._container.textContent = 'Hello, world'; return this._container; }; HelloWorldControl.prototype.onRemove = function () { this._container.parentNode.removeChild(this._container); this._map = undefined; }; Instance Members getDefaultPosition() onRemove(map) onAdd(map) Was this section on IControl helpful? Yes No NavigationControl src/ui/control/navigation_control.js A NavigationControl control contains zoom buttons and a compass. new NavigationControl(options: Object?) Parameters options(Object?) Name Description options.showCompass Boolean default true If true the compass button is included. options.showZoom Boolean default true If true the zoom-in and zoom-out buttons are included. options.visualizePitch Boolean default false If true the pitch is visualized by rotating X-axis of compass. Example var nav = new mapboxgl.NavigationControl(); map.addControl(nav, 'top-left'); Related Display map navigation controls Add a third party vector tile source Was this section on NavigationControl helpful? Yes No GeolocateControl src/ui/control/geolocate_control.js A GeolocateControl control provides a button that uses the browser's geolocation API to locate the user on the map. Not all browsers support geolocation, and some users may disable the feature. Geolocation support for modern browsers including Chrome requires sites to be served over HTTPS. If geolocation support is not available, the GeolocateControl will not be visible. The zoom level applied will depend on the accuracy of the geolocation provided by the device. The GeolocateControl has two modes. If trackUserLocation is false (default) the control acts as a button, which when pressed will set the map's camera to target the user location. If the user moves, the map won't update. This is most suited for the desktop. If trackUserLocation is true the control acts as a toggle button that when active the user's location is actively monitored for changes. In this mode the GeolocateControl has three states: active - the map's camera automatically updates as the user's location changes, keeping the location dot in the center. passive - the user's location dot automatically updates, but the map's camera does not. disabled Extends Evented. new GeolocateControl(options: Object?) Parameters options(Object?) Name Description options.positionOptions Object default {enableHighAccuracy:false,timeout:6000} A Geolocation API PositionOptions object. options.fitBoundsOptions Object default {maxZoom:15} A fitBounds options object to use when the map is panned and zoomed to the user's location. The default is to use a maxZoom of 15 to limit how far the map will zoom in for very accurate locations. options.trackUserLocation Object default false If true the Geolocate Control becomes a toggle button and when active the map will receive updates to the user's location as it changes. options.showUserLocation Object default true By default a dot will be shown on the map at the user's location. Set to false to disable. Example map.addControl(new mapboxgl.GeolocateControl({ positionOptions: { enableHighAccuracy: true }, trackUserLocation: true })); Instance Members trigger() Events geolocate error trackuserlocationstart trackuserlocationend Related Locate the user Was this section on GeolocateControl helpful? Yes No AttributionControl src/ui/control/attribution_control.js An AttributionControl control presents the map's attribution information. new AttributionControl(options: Object?) Parameters options(Object?)( default {}) Name Description options.compact boolean? If true force a compact attribution that shows the full attribution on mouse hover, or if false force the full attribution control. The default is a responsive attribution that collapses when the map is less than 640 pixels wide. options.customAttribution (string | Array<string>)? String or strings to show in addition to any other attributions. Example var map = new mapboxgl.Map({attributionControl: false}) .addControl(new mapboxgl.AttributionControl({ compact: true })); Was this section on AttributionControl helpful? Yes No ScaleControl src/ui/control/scale_control.js A ScaleControl control displays the ratio of a distance on the map to the corresponding distance on the ground. new ScaleControl(options: Object?) Parameters options(Object?) Name Description options.maxWidth number default '100' The maximum length of the scale control in pixels. options.unit string default 'metric' Unit of the distance ( 'imperial' , 'metric' or 'nautical' ). Example var scale = new mapboxgl.ScaleControl({ maxWidth: 80, unit: 'imperial' }); map.addControl(scale); scale.setUnit('metric'); Instance Members setUnit(unit) Was this section on ScaleControl helpful? Yes No FullscreenControl src/ui/control/fullscreen_control.js A FullscreenControl control contains a button for toggling the map in and out of fullscreen mode. new FullscreenControl(options: Object?) Parameters options(Object?) Name Description options.container HTMLElement? container is the compatible DOM element which should be made full screen. By default, the map container element will be made full screen. Example map.addControl(new mapboxgl.FullscreenControl({container: document.querySelector('body')})); Related View a fullscreen map Was this section on FullscreenControl helpful? Yes No Popup src/ui/popup.js A popup component. Extends Evented. new Popup(options: Object?) Parameters options(Object?) Name Description options.closeButton boolean default true If true , a close button will appear in the top right corner of the popup. options.closeOnClick boolean default true If true , the popup will closed when the map is clicked. options.anchor string? A string indicating ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,Mapbox GL JS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Troubleshoot your Atlas installation,Troubleshoot your Atlas installation.,https://docs.mapbox.com/atlas/overview/troubleshooting/,troubleshooting,,,"Troubleshoot your Atlas installation If you have any issues while installing or running Atlas, the following troubleshooting strategies may help you diagnose and fix the problem. Out-of-memory Docker errors When developing locally with Atlas, you will sometimes get out-of-memory errors. Docker is conservative about garbage collection, meaning you will sometimes need to use the Docker prune command to clean up unused Docker assets. To learn more about how to use the prune command, visit the Docker documentation on pruning. ""No space left on device"" errors The Atlas installer setup command uses docker load. You need enough disk space in both /var/lib/docker and /tmp to run setup. We recommend at least 20 GB of space for both directories. If you receive the error message Error processing tar file(exit status 1): ... no space left on device, increase the disk space in either the /var/lib/docker or /tmp directories. ""Docker daemon is not running"" errors When the setup command is running, you might see the error: The Docker daemon is not running. Please start Docker before proceeding. If this occurs, reboot your instance with the command sudo reboot. Then you can run the setup command again. View server logs To view your Docker logs to diagnose issues, run the command docker-compose logs -f and pipe the output of this command into a new log file. The -f flag lets you follow the log output. To view other flag options for this command, see the docker-compose logs documentation. Expired license error message Your Account page will display the expiration date of your Atlas user license so that you know when to get the renewal process started. If your Atlas license has expired, you will see an expiration error when you try to start Atlas. If you see this message, contact us to discuss renewing your Atlas license. Cannot verify certificate On certain older systems Mapbox's certificate issued by DigiCert is not recognized. You can download a certificate authority bundle and configure wget to trust the certificate by executing these commands: $ mkdir ~/ca_certs $ openssl s_client -showcerts -servername mapbox-atlas.s3.amazonaws.com \ -connect mapbox-atlas.s3.amazonaws.com:443 </dev/null > ~/ca_certs/mapbox.crt $ echo ca_directory=~/ca_certs >> ~/.wgetrc Submit feedback about Atlas If you have any technical issues with installing or running Mapbox Atlas, send an email to support@mapbox.com with the following information: Operating system name and version What were you doing when you ran into the problem? What specific commands did you run or actions did you take? What was the expected outcome? What was the actual outcome? Any relevant error logs in the browser console Any relevant application error logs Was this page helpful? Yes No",,Troubleshoot your Atlas installation,"""No space left on device"" errors","""Docker daemon is not running"" errors",View server logs,Expired license error message,Cannot verify certificate,Submit feedback about Atlas,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Local search with the Geocoding API,This tutorial guides you through the process of creating a local search app using optional parameters from the Mapbox Geocoding API.,https://docs.mapbox.com/help/tutorials/local-search-geocoding-api/,tutorial,JavaScript,,"intermediate JavaScript Local search with the Geocoding API Prerequisite Familiarity with front-end development concepts. The Mapbox Geocoding API allows you to make forward geocodes, which means that a text query like University of California Berkeley gets turned into longitude and latitude coordinates. But sometimes it's not enough to find query results. Often, you want the geocoder to find query results that are biased toward a location, limited to a specific area, or both. The Mapbox geocoder has built-in ranking that influences what results are returned, and in what order. (Read more about how search results are ranked in the How geocoding works guide.) You can also make your Geocoding API requests even more specific by including optional query parameters. In this tutorial, you will use the Geocoding API's proximity and bbox parameters to create a local search app for UC Berkeley that limits results to the Berkeley area and biases results around the campus itself.   View finished map. Getting started To complete this tutorial, you will need: A Mapbox account and access token. Sign up for an account at mapbox.com/signup. Your access tokens are on your Account page. Mapbox GL JS. Mapbox GL JS is a JavaScript API for building web maps. A text editor. Use the text editor of your choice for writing HTML, CSS, and JavaScript. Geocoding API query structure All Mapbox API queries must specify the API being used and the API version: https://api.mapbox.com/ { api_service } / { version } The API service used in this tutorial is geocoding and the version is v5. https://api.mapbox.com/geocoding/v5 Calls to the Geocoding API must also include the endpoint being used, which will either be mapbox.places or mapbox.places-permanent. (mapbox.places-permanent allows for permanent storage of results and for batch geocoding, and is only available to Enterprise customers that have a license for permanent geocodes.) The following examples use the mapbox.places endpoint. https://api.mapbox.com/geocoding/v5/mapbox.places Required parameters A query to the Geocoding API must contain search text. The search text is either a text string for forward geocodes, or a set of coordinates for reverse geocodes. This forward geocoding example's search text is San Francisco: https://api.mapbox.com/geocoding/v5/mapbox.places/San%20Francisco.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Regardless of whether you're performing a forward or reverse geocode, the search text needs to be followed by .json, since the response will be returned as a GeoJSON object. Optional parameters Now comes the fun part! The Geocoding API's optional parameters allow you to customize your query so that you receive the results that are the most relevant to you. For the full list of the optional parameters that a forward geocoding request can use, see the Geocoding API documentation. This tutorial will use two optional parameters that are especially useful for biasing results to a specific geographic location: proximity and bbox. View the results of an API request To see the results of the example queries in the following sections, copy the API call and paste it into your browser's address bar. Add your own Mapbox access token to the end of each example. You will see the response to the API query output in GeoJSON format. The proximity parameter The proximity parameter allows you to bias the response in favor of results that are closer to a specified location. This makes sure that the query results that are closer to this location are prioritized over ones that are further away. The parameter must be formatted as two comma-separated coordinates in longitude,latitude order. To find the coordinates of a location, you can use the Mapbox Search Playground. # Prioritizes Peets' locations in San Francisco https://api.mapbox.com/geocoding/v5/mapbox.places/peets.json?proximity=-122.3995752,37.7881856&access_token= YOUR_MAPBOX_ACCESS_TOKEN # Prioritizes Peets' locations in and around Berkeley https://api.mapbox.com/geocoding/v5/mapbox.places/peets.json?proximity=-122.2727469,37.8715926&access_token= YOUR_MAPBOX_ACCESS_TOKEN Since the proximity parameter is not exclusive, it does not restrict results to an area, but relevant results that are close to the provided coordinates are returned before relevant results that are further away. The bbox parameter The bbox parameter allows you to limit results to only those contained within a supplied bounding box. Bounding boxes need to be formatted as four coordinates separated by commas, in minLon,minLat,maxLon,maxLat order. You can use any coordinates for a bounding box, as long as they describe a box shape. To find the coordinates for a bounding box, you can use the Mapbox Search Playground. # Search for Starbucks in the Washington DC area https://api.mapbox.com/geocoding/v5/mapbox.places/starbucks.json?bbox=-77.083056,38.908611,-76.997778,38.959167&access_token= YOUR_MAPBOX_ACCESS_TOKEN The bbox parameter is exclusive, meaning that it will exclude any results that fall outside of the specified boundary. Build the Geocoding API query Now that you have seen how to use some of the Geocoding API's optional parameters to bias results around a location and restrict results to an area, you can use them in an app. This tutorial walks you through the process of creating an app that restricts results to a set area, and then biases the results around a landmark. In this case, the set area will be Berkeley, California, and the landmark will be the UC Berkeley campus. Using cURL, a Geocoding API query that uses proximity to bias results around the Berkeley campus and uses bbox to limit results to the Berkeley area would look like: # Search text is ""coffee"" # `proximity` is set to the coordinates of the campus # `bbox` is set to encompass Berkeley CA https://api.mapbox.com/geocoding/v5/mapbox.places/coffee.json?proximity=-122.25948,37.87221&bbox=-122.30937,37.84214,-122.23715,37.89838&access_token= YOUR_MAPBOX_ACCESS_TOKEN Geocoding plugins and libraries The Geocoding API's optional parameters give you powerful ways to customize your queries, but it can be unwieldy to use raw cURL API calls in your applications. The Mapbox geocoder is available through several plugins and wrapper libraries that can help you integrate it into an app: Mapbox GL JS Geocoder Mapbox.js Geocoder Mapbox Java SDK MapboxGeocoder.swift Mapbox JavaScript SDK React Geocoder This tutorial uses the Mapbox GL JS Geocoder plugin. Create your app To create the local search app, you will create an HTML file and initialize the map. Then you will add the Mapbox GL JS Geocoder plugin and set the bbox and proximity parameters. Once the app is running, you will use your browser's developer tools to see how the browser interprets the Geocoder plugin's API request. Set up your HTML file Open your text editor and create a new file named index.html. Set up this new HTML file by pasting the following code into your text editor. This code creates the structure of the page. There is a <div> element with the ID map in the <body> of the page. This <div> is the container in which the map will be displayed on the page. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Local search app</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> </body> </html> Initialize the map Next, you will add the Mapbox GL JS code that initializes a map, which will be displayed in the <div> you created in the last step. In index.html, place the following snippet above the closing </body> tag. Make sure that you set the mapbox.accessToken variable equal to your Mapbox access token. <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Container ID style: 'mapbox://styles/mapbox/streets-v 11 ', // Map style to use center: [-122.25948, 37.87221], // Starting position [lng, lat] zoom: 12, // Starting zoom level } ); </script> This Mapbox GL JS code sets a style for the map, gives it coordinates on which to center, and sets a zoom level. Save your changes. Open the HTML file in your browser to see the rendered map. Add a marker to the map The next step is to add a marker to the map at the campus's coordinates to show the landmark's location. After the initialization code that you wrote in the last step, add the following snippet to add a marker to the map: var marker = new mapboxgl.Marker() // initialize a new marker .setLngLat([-122.25948, 37.87221]) // Marker [lng, lat] coordinates .addTo(map); // Add the marker to the map Save your changes and refresh the page in your browser. There will be a marker on the map at the specified coordinates. Add the geocoder The next step is to add a geocoder using the Mapbox GL JS Geocoder plugin. To do this, first you need to add links to the geocoder's JavaScript and CSS to the head of the HTML file. <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.min.js'></script> <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.css' type='text/css' /> Once these links have been added, you will be able to use the Mapbox GL JS Geocoder plugin in your app. Next, add the following code above the closing </script> tag in your HTML file. var geocoder = new MapboxGeocoder( { // Initialize the geocoder accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style } ); // Add the geocoder to the map map.addControl(geocoder); The app you are building for this tutorial limits search results to a specific location. To give your users a visual reminder of this fact, you will use the placeholder parameter in the Geocoder to set custom text to display in the search bar. Add the following line to the plugin, after the access token: placeholder: 'Search for places in Berkeley' Save your changes. Refresh the page in your browser, and you will see that a geocoder search box with custom text has been added to the map. When you type a search term into the box and select a result, the map flies to that location. Add the bbox and proximity parameters Inside the map.addControl statement you added in the last step, after the placeholder parameter, add the bbox and proximity parameters. In the Mapbox GL JS Geocoder plugin, the bbox parameter must be formatted as an array. The proximity parameter must be formatted as an object with a longitude property and a latitude property. (For more information on how to format query parameters, see the Mapbox GL JS Geocoder plugin documentation.) With the addition of these parameters, the entire statement will look like: var geocoder = new MapboxGeocoder( { // Initialize the geocoder accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style placeholder: 'Search for places in Berkeley', // Placeholder text for the search bar bbox: [-122.30937, 37.84214, -122.23715, 37.89838], // Boundary for Berkeley proximity: { longitude: -122.25948, latitude: 37.87221 } // Coordinates of UC Berkeley } ); Save the HTML file and refresh the page in your browser. Now, when you enter a search into the geocoder's search box, you will not receive any results outside of the bounding box. And the results that the geocoder returns are weighted according to their proximity to the Berkeley campus. Place markers at selected results Adding a custom marker style The Mapbox GL Geocoder sets a marker at the search result location by default. This example adds a custom marker as a new layer instead. If you want to use the default marker provided by the geocoder, remove the line marker: false, from the new geocoder instantiation. The final step for creating this app is to place a custom marker on the map at the location of a selected search result. The logic for doing this needs to be wrapped in a map.on('load') event so that it is not triggered before the map itself has been loaded. Before the closing </script> tag, paste the following JavaScript: // After the map style has loaded on the page, // add a source layer and default styling for a single point map.on('load', function() { map.addSource('single-point', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } } ); map.addLayer( { id: 'point', source: 'single-point', type: 'circle', paint: { 'circle-radius': 10, 'circle-color': '#448ee4' } } ); // Listen for the `result` event from the Geocoder // `result` event is triggered when a user makes a selection // Add a marker at the result's coordinates geocoder.on('result', function(e) { map.getSource('single-point').setData(e.result.geometry); } ); } ); Save the HTML file and refresh the page in your browser. When search and select a result, a marker will be placed at the result's coordinates. View the API call in developer tools To see what's going on behind the scenes when you use the Mapbox GL JS Geocoder plugin, you can view the raw API call using your browser's developer tools. This can be useful for debugging a query if the returned results are not what you expect. How do I open developer tools? The following instructions are for Chrome's developer tools layout. For other browsers, some details may vary but in general the workflow will be similar. Read your browser's help page for details on how to open the developer tools and find the network information. Load the page you created in this tutorial in your browser, or refresh it if it's already open. Open the browser's developer tools. (In Chrome, you can do this by typing command + option + i or command + option + j.) Type a text phrase into the app's geocoder search bar and select a result. (The example below is for the search term ""coffee"".) Click on the Network tab. In the Filter search bar, type in ""geocoding"". This will narrow the list of network calls down to those made by the Mapbox Geocoding API. You will likely see more than one Geocoding API call in the list, each representing a different stage of the search text. Click on the option that has the complete search text (for example, ""coffee"" instead of ""coff""). In the Request URL section, you will see a request that is like the cURL API request that you created in the Build the Geocoding API query section of this tutorial: https://api.mapbox.com/geocoding/v5/mapbox.places/coffee.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN &proximity=-122.259%2C37.872&bbox=-122.30937%2C37.84214%2C-122.23715%2C37.89838&limit=5 The difference between the query returned by the browser and the one you created earlier is that this one also includes the limit parameter, with the default value of 5 passed in. Finished product You have completed a local search app that, when a user enters a query into the geocoder search box, biases the results around the UC Berkeley campus and excludes any results that are located outside the Berkeley area.   View finished map. The final HTML file will look like the following: <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Local search app</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.min.js'></script> <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.css' type='text/css' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Container ID style: 'mapbox://styles/mapbox/streets-v 11 ', // Map style to use center: [-122.25948, 37.87221], // Starting position [lng, lat] zoom: 12, // Starting zoom level } ); var marker = new mapboxgl.Marker() // Initialize a new marker .setLngLat([-122.25948, 37.87221]) // Marker [lng, lat] coordinates .addTo(map); // Add the marker to the map var geocoder = new MapboxGeocoder( { // Initialize the geocoder accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style placeholder: 'Search for places in Berkeley', // Placeholder text for the search bar bbox: [-122.30937, 37.84214, -122.23715, 37.89838], // Boundary for Berkeley proximity: { longitude: -122.25948, latitude: 37.87221 } // Coordinates of UC Berkeley } ); // Add the geocoder to the map map.addControl(geocoder); // After the map style has loaded on the page, // add a source layer and default styling for a single point map.on('load', function() { map.addSource('single-point', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } } ); map.addLayer( { id: 'point', source: 'single-point', type: 'circle', paint: { 'circle-radius': 10, 'circle-color': '#448ee4' } } ); // Listen for the `result` event from the Geocoder // `result` event is triggered when a user makes a selection // Add a marker at the result's coordinates geocoder.on('result', function(ev) { map.getSource('single-point').setData(ev.result.geometry); } ); } ); </script> </body> </html> Next steps There are a lot of things you could do to build this app out more. You could: Use Turf.js to analyze the distances of the various results from the UC Berkeley campus. (See the Sort stores by distance tutorial.) Experiment with the Mapbox GL JS Geocoder plugin's filter function to get even more granular results. (See the Limit geocoder results to a named region example.) Was this page helpful? Yes No",,Local search with the Geocoding API,Geocoding API query structure,Required parameters,Optional parameters,The proximity parameter,The bbox parameter,Build the Geocoding API query,Geocoding plugins and libraries,Create your app,Set up your HTML file,Initialize the map,Add a marker to the map,Add the geocoder,Add the bbox and proximity parameters,Place markers at selected results,View the API call in developer tools,,2,Finished product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,classic style,A classic style is a map style made with Mapbox Studio Classic.,https://docs.mapbox.com/help/glossary/classic-style/,glossary,,,"classic style Note Mapbox Studio Classic, which uses classic styles, is no longer in active development. To learn more about our newer mapping tools see Mapbox Studio styles. In Mapbox Studio Classic, a classic style contains CartoCSS stylesheets, thin metadata (name, description, attribution, etc.), and a reference to a source. After you upload a classic style to Mapbox.com, it will appear on your Classic styles page. Was this page helpful? Yes No",,classic style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display a popup,Add a Popup to the map.,https://docs.mapbox.com/mapbox-gl-js/example/popup/,example,JavaScript,,Display a popup Add a Popup to the map. Was this example helpful? Yes No,,Display a popup,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Faster-route detection,Faster-route detection in the Mapbox Navigation SDK for Android. Read all about it in this official Mapbox documentation.,https://docs.mapbox.com/android/navigation/overview/faster-route/,guide,Java,,"Faster-route detection SDKs covered: Navigation SDK Navigation UI SDK The Navigation SDK includes a faster-route detection class. This class checks each location update as well as the progress along the current route to determine if a new route should be retrieved. Fetching faster routes is disabled by default in the Navigation SDK. To enable either the default logic or your own custom logic, you can create a MapboxNavigationOptions object and set MapboxNavigationOptions#enableFasterRouteDetection(boolean); to true. MapboxNavigationOptions is then passed into the constructor of MapboxNavigation. Faster-route detection and the Navigation UI SDK This guide does not describe any specific options in the Navigation UI SDK. You need to enable faster-route detection using the core Navigation SDK directly. Default faster-route detection After enabling faster-route detection, the default logic in FasterRouteDetector checks for a faster DirectionsRoute every two minutes, only if both of the following conditions are true: The current route duration remaining is more than 600 seconds The current step duration remaining is more than 70 seconds When a new DirectionsRoute is retrieved, it is considered faster if all the following conditions are true: The upcoming step is the same as the current upcoming step The first step of the new route is more than 70 seconds in duration It is at least 10 percent faster than the duration remaining of the current route FasterRouteListener You are able to listen to the retrieval of a faster DirectionsRoute with FasterRouteListener. This listener will fire if a new route is retrieved and meets the given criteria of FasterRoute#isFasterRoute. Java Kotlin navigation.addFasterRouteListener(new FasterRouteListener() { @Override public void fasterRouteFound(DirectionsRoute directionsRoute) { // Update MapboxNavigation here navigation.startNavigation(directionsRoute); } }); Copy Custom logic for fetching faster routes If you would like to provide your own logic to replace the default logic above, you can do so by subclassing FasterRoute and passing your class to MapboxNavigation with MapboxNavigation#setFasterRouteEngine(FasterRoute). When to check for a faster route FasterRoute#shouldCheckFasterRoute(Location, RouteProgress) will determine when a new DirectionsResponse should be retrieved by the RouteEngine. This method will be called every time the Navigation SDK gets a Location update from the LocationEngine. What qualifies as a faster route FasterRoute#isFasterRoute(DirectionsResponse, RouteProgress) will be used to determine if the route retrieved is faster than the one that's being navigated. This method will be called every time a response is received from the RouteEngine. Was this page helpful? Yes No",,Faster-route detection,FasterRouteListener,Custom logic for fetching faster routes,When to check for a faster route,What qualifies as a faster route,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Get started with Mapbox Boundaries,Get started with v2 of the Mapbox Boundaries tileset.,https://docs.mapbox.com/help/tutorials/get-started-mapbox-boundaries/,tutorial,No code,,"intermediate No code Get started with Mapbox Boundaries Prerequisite Familiarity with front-end development and access to Mapbox Boundaries. Note Access to the Mapbox Boundaries tilesets are controlled by Mapbox account access token. If you do not have access on your account, contact a Mapbox sales representative to request access to Boundaries tilesets. Mapbox Enterprise users can add global administrative, postal, and statistical boundaries to their maps and data visualizations. This guide covers how to use Mapbox Boundaries in a web application and navigate feature lookup tables. Getting started Mapbox Boundaries are available as a part of an Enterprise plan. If you do not have an Enterprise plan or if you do have an Enterprise plan and would like to add access to Mapbox Boundaries, contact a Mapbox sales representative to request access. Access to the Boundaries tilesets are controlled by your Mapbox account access token. Add to an application Once you have access to Mapbox Boundaries, you can use them in an application as you would use any other tileset. About Mapbox Boundaries Below you'll find a few pieces of key information that you'll need to navigate the Mapbox Boundaries tileset. Tileset IDs Mapbox Boundaries are stored as vector tiles and distributed via the Mapbox Vector Tiles API, with a unique tileset for each admin, stats, and postal level. Tileset IDs for Boundaries tilesets are in the form mapbox.enterprise-boundaries- { a|p|s } { level } - { version }. Here are a few examples: mapbox.enterprise-boundaries-a0-v2: The tileset for admin (a) level 0 (0) boundaries (which contain countries) in version two (v2) of Mapbox Boundaries. mapbox.enterprise-boundaries-p1-v2: The tileset for postal (p) level 1 (1) boundaries in version two (v2) of Mapbox Boundaries. mapbox.enterprise-boundaries-s3-v2: The tileset for stats (s) level 3 (3) boundaries in version two (v2) of Mapbox Boundaries. Find the complete list of Mapbox Boundaries tilesets and read more about tileset hierarchies in the reference documentation. Feature IDs Each feature also has a unique ID that is used to identify a feature polygon. Once Boundaries are added to your account, you will be able to access the reference documentation containing the feature IDs and all identifying metadata. Minimum zoom levels and bounding boxes z_min: The z_min value for each feature indicates the minimum zoom level at which a feature is available in a tileset. Use this to set the camera to a minimum zoom level to see the feature. centroid point: Centroid point features are guaranteed to appear at zoom level z_min + 1. Centroid point features can be used to display a marker, symbol, or label at the center of a Boundaries feature. Access vector tiles containing centroid points for a specific admin, postal, or stat level using the tileset ID as described above and specifying the source layer points_ { admin|postal|stats } _ { level }. For example, the vector tile source layer points_postal_4 contains centroid point data for the mapbox.enterprise-boundaries-p4-v2 tileset. bounds: Feature bounds are the smallest rectangular envelope that a feature fits into denoted as an array of [min_long, min_lat, max_long, max_lat]. Example To use a Mapbox Boundaries tileset in your application, make a request from the Mapbox Vector Tiles API for the relevant tileset. For example, in Mapbox GL JS, load the tileset using the code below: // Be sure to use an access token from an account // that has access to Boundaries mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/light-v 10 ', center: [-99.9, 41.5], zoom: 1 } ); map.on('load', function() { // Add source for admin-0 Boundaries map.addSource('admin-0', { type: 'vector', url: 'mapbox://mapbox.enterprise-boundaries-a0-v2' } ); // Add a layer with boundary lines map.addLayer( { id: 'admin-0-line', type: 'line', source: 'admin-0', 'source-layer': 'boundaries_admin_0', paint: { 'line-color': 'red', 'line-width': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 10] } } , 'waterway-label'); // Add a layer with points map.addLayer( { id: 'admin-0-circle', type: 'circle', source: 'admin-0', 'source-layer': 'points_admin_0', paint: { 'circle-color': 'white', 'circle-stroke-color': 'black', 'circle-stroke-width': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 6], 'circle-radius': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 20] } } , 'waterway-label'); } ); The code above will yield a map with all country boundaries in red with a circle at the center of each country. Feature lookup tables Each boundary feature is indexed in a lookup table. Lookup tables are designed to be used locally in your application. User data can be joined to Mapbox Boundaries in your application to create a visualization, such as a choropleth map of unemployment by state. About feature lookup tables The Mapbox Boundaries lookup tables include this metadata about each polygon feature: id: globally unique identifier for the feature. id_int: an integer-only identifier for a feature that can be used to accomplish data-joins with Mapbox GL JS's feature state. type: either admin, postal or stats to represent the Administrative, Postal or Statistical boundaries types in Mapbox Boundaries. level: a numeric value between 0 and 5 to represent the level of boundaries within the type. layer: a shortened concatenation of type and level with feature's administrative (a), postal (p), or statistical (s) hierarchy and level (0-5). For example, administrative level 1 would have a level of a1. tilesetname: tileset ID for the tileset containing the feature, see the reference documentation for more details. worldview: alternate display of administrative units depending on regional map display requirements (US, CN, or IN). unit_code: the country-specific identifier for the feature, such as postcode or FIPS code. name: local feature name. name_ascii: local feature name converted to ascii characters. names: any translation or aliases for that boundary. description: a text qualifier of the level respective to each country's boundary hierarchy. For example, US admin-1 boundaries have a description of states while Italian admin-1 boundaries have a description of regions. wikidata_id: the associated Wikidata ID for the boundary. source_date: recency of boundary data. parent_0: the level-0 parent of a feature which corresponds to the country code. parent_1: the level-1 parent of a feature, if it exists. parent_2: the level-2 parent of a feature, if it exists. parent_3: the level-3 parent of a feature, if it exists. parent_4: the level-4 parent of a feature, if it exists. z_min: minimum zoom level at which a polygon feature appears in a tileset. centroid: The centroid of the boundary in [long, lat] format. bounds: an array of the features bounding box as [minlong, minlat, maxlong, maxlat]. polylayername: name of the source-layer within the tileset containing feature polygon geometry. pointlayername: name of the source-layer within the tileset containing feature centroid. Lookup tables are available as JSON. Sample workflow The feature lookup tables are designed to be used alongside the Mapbox Boundaries tilesets. A typical workflow for a business intelligence application is: A user identifies geographic dimensions in a data source, such as state, zip, country, or longitude & latitude. A user makes a query from application data store. Data store joins geographic dimension query results to metadata in the feature lookup table, such as name, unit_code, or level. Data store groups and aggregates results by geographic dimension and sends to the client visualization tool. Generate a Mapbox GL layer from the Mapbox Style Specification to create a visual from query results. The visual style definition works the same across all Mapbox GL products, including Mapbox GL JS on the web, and Mapbox GL Native on iOS, Android, macOS, and Qt. Example Read the Visualize the USA’s economic recovery with client-side data joins blog post, which illustrates how the steps in the sample workflow can work in your application. Next steps Learn more about how you can use Mapbox Boundaries: Point-in-polygon query with Mapbox Boundaries: Determine what polygons exist at a single point using the Mapbox Tilequery API. Data-joins with Mapbox Boundaries: The data-join technique involves inner joins between local data, such as the unemployment rate by US state, to vector tile features, such as admin boundaries in Mapbox Boundaries, using data-driven style notation. Extend Mapbox Boundaries: You can extend Mapbox Boundaries with any custom data you need for your application. This could mean adding school district, city, market, or property boundaries to your application — all with the same performance and API features of the native product. Was this page helpful? Yes No",,Get started with Mapbox Boundaries,Add to an application,About Mapbox Boundaries,Tileset IDs,Feature IDs,Minimum zoom levels and bounding boxes,Example,Feature lookup tables,About feature lookup tables,Sample workflow,Next steps,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Tilesets API recipe reference,"This feature is in beta. Learn about the correct format and syntax for Tilesets API recipes, or tile transformation documents.",https://docs.mapbox.com/help/troubleshooting/tileset-recipe-reference/,troubleshooting,,,"Tilesets API recipe reference Public beta The Tilesets API features and workflows discussed in this guide are in public beta. All features and workflows are subject to potential future changes. Current version: 1 Tileset recipes are tile transformation documents that tell the Tilesets API how to turn tileset source data into vector tiles. Recipes must be constructed according to the rules in this recipe reference. Recipe top-level fields A recipe is a JSON object that must contain the following top-level fields: Required fields Description Data type version The version of the Tilesets API recipe reference that the recipe uses. The current version number is 1. Any version value other than the current version or a previous version will result in an error. Integer layers The LayerObject is an object in which the keys are the names of the layer and their values are objects that represent the configuration and options for the layer. Object { ""version"": 1, ""layers"": { ... } } LayerObject A layer object is the primary way of describing how a vector tile layer should be created. It specifies where to retrieve source data, the precision of the data through zoom levels, and how to transform features and render them into tiles. The following fields are the top-level options for a single layer: Required fields Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Describes the lowest zoom level for the tileset. Integer maxzoom Describes the highest zoom level for the tileset. More info. Integer You can further refine the resulting tileset with the following optional fields: Optional fields Description Data type features Specifies the output on a per feature basis. More info. Object tiles Specifies the output on a per tile basis. More info. Object The following describes every available field for a LayerObject and the JSON type that field must be. { ""minzoom"": Integer, ""maxzoom"": Integer, ""features"": { ""id"": { ""attribute_id"": String, ""add_to_attributes"": String, ""output_id"": Boolean } , ""attributes"": { ""zoom_element"": Array, ""set"": Object, ""allowed_output"": Array } , ""filter"": Object, ""simplification"": Number, ""union"": [ { ""group_by"": Array, ""aggregate"": Array, ""maintain_direction"": Boolean, ""where"": Array } ] } , ""tiles"": { ""extent"": Integer, ""buffer_size"": Integer, ""limit"": Array } } Basic example The simplest example tileset recipe includes a layer name, a tileset source ID, a minimum zoom value, and a maximum zoom. { ""version"": 1, ""layers"": { ""trees"": { ""source"": ""mapbox://tileset-source/ { username } /trees-data"", ""minzoom"": 4, ""maxzoom"": 8 } } } Multi-layer recipes Recipes can also be arrays of recipe objects. This format can be used to create multi-layer tilesets. Recipes can have a maximum of 20 layers defined. { ""version"": 1, ""layers"": { ""trees"": { ... } , ""parks"": { ... } , ""paths"": { ... } } } Layer name configuration The layer name key is required for each LayerObject (e.g. ""trees"", ""parks"", and ""paths"" in the above example). This is the unique identifier for the layer of data in your final tileset. For any map each layer name must be unique. The layer name must be a string with only underscores (_) and alphanumeric characters. Source configuration A source refers to a tileset source, which is a collection of geographic data stored as line-delimited GeoJSON on Mapbox.com. Tileset sources can be created via the Create a tileset source endpoint of the Tilesets API. Zoom level configuration The minzoom and maxzoom configurations control the zoom levels at which your data will be tiled. They are required for a recipe. These values must be integers. The minzoom must be less than or equal to maxzoom, and both must be between the values of 0 and 16. Zoom levels play a large role in your output tileset. The higher the zoom level, the higher fidelity your data is as users zoom in. This also comes at a cost. Increasing zoom level fidelity creates exponentially more tiles! It’s important to consider the cases your map is trying to solve when choosing zoom levels. If your users are going to be viewing the map at a global extent it’s not necessary to choose a high zoom. If your users are going to be viewing the map at a city or street level, high zooms will be helpful for the most accurate data. If you know the precision to which you want your data to be represented, this table shows the approximate precision corresponding to various minzoom and maxzoom choices: Zoom level Precision in feet Precision in meters 0 32000 ft 10000 m 1 16000 ft 5000 m 2 8000 ft 2500 m 3 4000 ft 1250 m 4 2000 ft 600 m 5 1000 ft 300 m 6 500 ft 150 m 7 250 ft 80 m 8 125 ft 40 m 9 64 ft 20 m 10 32 ft 10 m 11 16 ft 5 m 12 8 ft 2 m 13 4 ft 1 m 14 2 ft 0.5 m 15 1 ft 0.25 m 16 0.5 ft 0.125 m Feature configuration The features configuration object is used to describe how features are individually processed into vector tiles. This field contains the following elements, which are evaluated in the order of the list provided below: Optional fields Description Data type id A JSON object that describes both how to identify a feature in a recipe and how that feature will be identified in the resulting tile. See the feature IDs section for more details. Object attributes A JSON object that controls how attributes are modified and which attributes are allowed in the resulting tileset. Object filter A filter expression determining which features should be retained. If no filter is defined, the default filter is true and all features will be retained. Array simplification An integer value that is greater than zero that controls the level of simplification that occurs for features. This integer value is relative to the extent provided for the tiles, with a larger value resulting in more simplification. Integer Feature IDs The id configuration gives you control over what field is used as the feature ID during tiling. It also allows you to specify where to put this ID in the resulting tileset as an attribute. The following fields are allowed in the id object: Optional field Description Data type attribute_id By default, the standard ID field in the tileset source GeoJSON will be used as IDs. But it is possible to use a specific attribute key for an ID instead. If this configuration option is provided, the attribute with a key that matches the string provided here will be used as the ID. String In this example, the recipe indicates that the iso_2 property in each feature should be the feature ID in the resulting tileset: { ""features"": { ""id"": { ""attribute_id"": ""iso_2"" } } } Optional field Description Data type add_to_attributes Adds your original ID field to the attributes of features using the key name provided. This is helpful in retrieving original string IDs that have been converted to integers in the vector tile feature. String In this example, the recipe saves the top-level ID field in the attribute road_id of the final vector tile. This is particularly helpful for saving top-level string IDs that will otherwise be converted to integers in the final vector tile. { ""features"": { ""id"": { ""add_to_attributes"": ""road_id"" } } } Optional field Description Data type output_id By default this value is true. Places the ID into the ID field of the vector tile. If you do not want numeric IDs in this field, change to false. Boolean If output_id is true, the ID is saved to the id field within a feature of a vector tile. The current Mapbox Vector Tile Specification does not allow for string-based IDs in features, so if this value is true any string IDs will be converted to an integer using a hash. In this example, the recipe adds feature IDs to feature attributes using the attribute my_id, but does not place the ID in the final vector tile ID field. { ""features"": { ""id"": { ""add_to_attributes"": ""my_id"", ""output_id"": false } } } Feature filters The filter configuration is a single filter expression that results in a true or false evaluation for each feature as configured by the minzoom and maxzoom. This is the primary way to control which features are allowed into the final tileset on a per-feature basis. If no filter is provided, by default this results in a value of true for all features. Filter expressions In various configurations throughout the recipe, you have the ability to select relevant features by their attributes. This is possible with filter expressions, which use the Mapbox GL JS expression syntax defined in the Mapbox GL JS Style Spec. Each filter is a JSON array that is evaluated for a boolean or value result using the following operations: Type assertion: array, boolean, number, object, string, typeof Type conversion: to-boolean, to-number, to-string Quoting: literal Feature characteristics: geometry-type, id, zoom Data retrieval: properties, at, get, has, length Comparison: ==, !=, <, >, <=, >=, step Boolean operations !, all, any Conditionals: case, coalesce, match Local variables let, var String manipulation concat, downcase, upcase Arithmetic -, +, /, *, ^, %, abs, ceil, floor, e, ln, ln2, log10, log2, max, min, round, sqrt Trigonometry acos, asin, atan, cos, sin, tan, pi Feature attributes The attributes configuration allows for manipulation of attribute data, generation of new attributes, and removal of attributes. The available options are described below, and implemented in the order they are listed: Optional field Description Data type zoom_element A JSON array that provides a list of attributes that are specified per zoom level in the source data. Array<String> For each attributes with a specified zoom_element, the final output attribute at zoom level N will be the Nth element in the array in the source data. If no zoom_element is defined, no attributes are altered. If the zoom level is greater than or equal to the number of elements in the array, the last element is used. Consider the following attributes for a single GeoJSON feature: { ""type"": ""Feature"", ""geometry"": { ... } , ""properties"": { ""name"": [ null, null, ""Main"", ""Main St."", ""Main Street"" ] } } In this example, the zoom_element array includes name. Using the attributes from the GeoJSON above, this feature would have no name attribute at zoom levels 0 and 1, would have ""Main"" at zoom level 2, ""Main St."" at zoom level 3, and ""Main Street"" at zoom levels 4 and above. { ""features"": { ""attributes"": { ""zoom_element"": [ ""name"" ] } } } Optional field Description Data type set A JSON object mapping the names of attributes to be generated to filter expressions that return the new attribute values. Particularly helpful for generating ranking schemes to be used in styling expressions. Object Consider the following attributes for a single GeoJSON feature: { ""type"": ""Feature"", ""geometry"": { ... } , ""properties"": { ""place"": ""state"", ""name"": ""California"" } } In this example, the set attribute defines a new attribute to be included in the final tileset, labelrank, that is derived from the existing data's place attribute. Using the ""match"" expression, it assigns a value to features based on the value of ""place"". If ""place"" is equal to ""country"", then the labelrank attribute for the resulting feature will have a value of 0, and so on. It also provides a default value of 5 for any features that have a ""place"" value that does not match any of the values explicitly provided. { ""features"": { ""attributes"": { ""set"": { ""labelrank"": [ ""match"", [ ""get"", ""place"" ], ""country"", 0, ""state"", 1, ""region"", 2, ""province"", 2, ""district"", 3, ""county"", 3, ""municipality"", 4, ""city"", 4, 5 ] } } } } Optional field Description Data type allowed_output A JSON array of attributes that controls which attributes will be carried over into the resulting tileset. Array<String> If an allowed_output array is provided only the attributes specified in the array will be saved to the tileset. This does not prevent the attributes that are not excluded by allowed_output from being used in filter expressions and other steps throughout the publish job. In this example, features in the resulting tileset will only have two attributes, name_en & name_es: { ""features"": { ""attributes"": { ""allowed_output"": [ ""name_en"", ""name_es"" ] } } } Feature simplification Optional field Description Data type simplification Indicates the desired level of simplification. Larger values result in more simplification, in which some vertices are removed. The default value is 4. The maximum value is 4096. Integer The simplification value describes the maximum distance that a point can be from the straight line that connects its two neighbors and still be considered to be on the line, and can therefore be removed safely. Any point with a distance that is larger than the simplification value is considered to be away from the line, and must be preserved. As you increase the simplification value, the number of vertices in each feature decreases. The Tilesets API recipe validator will reject any simplification value that is more than 4096. If you do not add a value for simplification, the Tilesets API will use 4, the default value. The resulting shape depends on the original shape of your feature. For instance, if your original feature is circular and you increase simplification, the result will look more like a polygon. If your original feature is a curved line and you increase simplification, the result will look more like a straight line. The Tilesets API uses the Ramer–Douglas–Peucker algorithm to simplify features. Tile configurations The tiles object contains the following elements, which are evaluated as each tile is being assembled from its component features: Optional field Description Data type buffer_size Controls the size of the buffer that will be created in your vector tiles. Number buffer_size represents a percentage of the size of a tile. The default buffer size is 0.5. Note that the value of this attribute cannot be larger than 100. Buffers are particularly helpful for label point layers to avoid cutting labels of at tile boundaries. Optional field Description Data type layer_size Specifies the size limit in kibibytes of each layer. Integer The default value is 500 KiB. The value cannot be larger than 500 or smaller than 1. Configuring layer_size can be helpful for improving rendering speed. Optional field Description Data type remove_filled Control which ""filled"" features are removed by specifying a filter-expression. Array<Expression> During tile creation it is possible for polygons to completely cover a tile and the area surrounding its buffer. These are called as ""filled features"". If all features within a tile are filled features, it may be useful for some tilesets to not create any tiles at all and expect that clients will look to higher zoom levels. To do this, you can use the remove_filled recipe. The syntax utilizes a filter-expression to allow control over what features exactly should be removed. ""tiles"": { ""remove_filled"": expression } No tile will be created if: All features within the tile are considered filled features All features are matched by the filter-expression provided in remove_filled The following example removes all tiles that contain only filled features: ""tiles"": { ""remove_filled"": true } The following example removes all tiles that contain only filled features after zoom level 5: ""tiles"": { ""remove_filled"": ["">"", [ ""zoom"" ], 5] } Optional field Description Data type limit A limitation rule that reduces the number of features for the specified type to a specific number, choosing the lowest or highest-numbered features according to some attribute. Array<Expression> The limit field must be an array of limitation rules, each of which is evaluated in sequence to potentially limit the total number of features to be included in the final tile. Rules that limit the total number of features in a tile have one of following forms: [ ""lowest_where"", filter-expression , number , attribute ] [ ""highest_where"", filter-expression , number , attribute ] Rules that limit the number of features within a specified distance have one of the following forms: [ ""lowest_where_in_distance"", filter-expression , number , attribute ] [ ""highest_where_in_distance"", filter-expression , number , attribute ] The number is a divisor of the total tile area. So, for instance, if the number is 256, the features will be spaced such that 256 of them are spaced evenly across the tile. The features with the lowest or highest value of attribute within each cluster are prioritized. The difference is that lowest_where and highest_where choose any number of features that match the filter-expression, even if these features are right on top of each other, while lowest_where_in_distance and highest_where_in_distance choose any number of features that match the filter-expression while still being acceptably spatially-separated. Optional field Description Data type order Specify the order of a sequence of features in the final output tile. String You can order the sequence of features in the final output tile by a specified attribute. The attribute values must be comparable (all strings or all numbers). This example orders the features by the sequence attribute: ""tiles"": { ""order"": ""sequence"" } Feature union Optional field Description Data type union Join features based on whether or not a defined spedified attribute matches. Object You can union features together if a specified set of their attributes match. The simplest case unions all features that have exactly the same attributes: ""tiles"": { ""union"": [ { } ] } The union specification object can contain an expression to union only features that match the specified expression as well as having matching attributes: ""where"": expression Expression options: group_by: [attribute, attribute, attribute] - Use group_by to union features that have specified attributes that match, instead of requiring all attributes to match. aggregate: { attribute: type, attribute: type } - Use aggregate to accumulate the specified attributes from the unioned features instead of arbitrarily keeping the attributes from one of the unioned features. Acceptable types of aggregation include sum (to add), comma (to concatenate with a comma), or concat (to concatenate the feature data without a delimiter). maintain_direction: boolean - Use maintain_direction: false to make more compact unions of LineStrings for which directionality doesn't matter. This is done by reversing some of the LineStrings if that helps to connect them. For example, you could specify the following to union only features where highway=motorway: ""tiles"": { ""union"": [ { ""where"": [ ""=="", [ ""get"", ""highway"" ], ""motorway"" ], ""maintain_direction"": true } ] } This example uses maintain_direction: true (the default) because motorway roads are generally mapped as pairs of roadways whose direction indicates their one-way direction. Using union with zoom based properties You can use union on zoom-element properties. If you are using union with a zoom-element property, the union will occur after the feature has been assigned the value based on the zoom level. More resources For a list of example recipes that correspond to common tileset use-cases, see the Tileset recipe examples page. The Get started with the Tilesets API and CLI tutorial walks you through the process of creating a new tileset, including creating and using a tileset recipe, with the Tilesets CLI. The Tilesets API has several endpoints that can be used to validate, update, and read a tileset's recipe. Learn more in the Tilesets API documentation. Was this page helpful? Yes No",,Tilesets API recipe reference,LayerObject,Basic example,Multi-layer recipes,Layer name configuration,Source configuration,Zoom level configuration,Feature configuration,Feature IDs,Feature filters,Filter expressions,Feature attributes,Feature simplification,Tile configurations,Feature union,More resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Add a new layer below labels,"Using the second argument of addLayer, you can be more precise.",https://docs.mapbox.com/android/maps/examples/add-a-new-layer-below-labels/,example,Java,,"Add a new layer below labels Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.GeojsonLayerInStackActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""33.749909"" mapbox:mapbox_cameraTargetLng=""-84.381546"" mapbox:mapbox_cameraZoom=""8.471903""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.graphics.Color; import android.os.Bundle; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.net.URI; import java.net.URISyntaxException; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; /** * Using the second argument of addLayer, you can add a layer below existing one */ public class GeojsonLayerInStackActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_geojson_layer_in_stack); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { try { GeoJsonSource urbanAreasSource = new GeoJsonSource(""urban-areas"", new URI(""https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_urban_areas.geojson"")); style.addSource(urbanAreasSource); FillLayer urbanArea = new FillLayer(""urban-areas-fill"", ""urban-areas""); urbanArea.setProperties( fillColor(Color.parseColor(""#ff0088"")), fillOpacity(0.4f) ); style.addLayerBelow(urbanArea, ""water""); } catch (URISyntaxException uriSyntaxException) { uriSyntaxException.printStackTrace(); } } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Add a new layer below labels,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Localize the geocoder to a given language,Localize the mapbox-gl-geocoder to set the UI language and improve result relevance in that language.,https://docs.mapbox.com/mapbox-gl-js/example/mapbox-gl-geocoder-with-language/,example,JavaScript,,Localize the geocoder to a given language Localize the mapbox-gl-geocoder to set the UI language and improve result relevance in that language. Was this example helpful? Yes No,,Localize the geocoder to a given language,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,| Mapbox SDK for Unity,,https://docs.mapbox.com/mapbox-unity-sdk/api/,,,,Toggle navigation Show / Hide Table of Contents <-- choose module Improve this Doc Back to top © 2017 Mapbox,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Maneuver instructions,Learn how instructions work in the Mapbox Navigation SDK for iOS.,https://docs.mapbox.com/ios/navigation/overview/instructions/,guide,,,"Maneuver instructions Core Navigation tracks the device location and listens for other significant events that are used to trigger visual and spoken maneuver instructions. These include events related to progress along a route, before and after reroutes, arrival at waypoints, and more. Drop-in UI The drop-in UI uses logic from Mapbox Core Navigation to trigger a comprehensive system of visual and spoken instructions by default. There are default styling rules for visual instructions and default settings for voice instructions. Instructions can be customized to synchronize your application's behavior with instructions coming from the Mapbox Navigation SDK and customizing the style of visual instructions to fit with your application. Visual instruction events By default, visual instructions will be displayed when NavigationServiceDelegate.navigationService(_:didPassVisualInstructionPoint:routeProgress:) is called and Notification.Name.routeControllerDidPassVisualInstructionPoint is posted when the user passes the appropriate point at which to display a visual instruction. A visual instruction point occurs near the beginning of a step. There may be additional visual instruction points along the step as additional information, like turn lanes, become relevant. Spoken instruction events By default, spoken instructions will be played when NavigationServiceDelegate.navigationService(_:didPassSpokenInstructionPoint:routeProgress:) is called and Notification.Name.routeControllerDidPassSpokenInstructionPoint is posted when the user passes the appropriate point at which to announce a spoken instruction. A spoken instruction point occurs near the end of a step. There may be additional spoken instruction points, as time allows, at a comfortable distance before the end of the step and near the beginning of the step. A single spoken instruction point may correspond to an instruction about two maneuvers in that are nearby. Customization in the drop-in UI For customizing the language used in visual and spoken instructions, see Localization and internationalization. You can change the appearance of various UI elements. For example, you can customize the bottom banner by passing a ContainerViewController into NavigationOptions(styles:navigationService:voiceController:bottomBanner:). let customBottomBanner: ContainerViewController = CustomBottomBannerController(delegate: someDelegate) let options = NavigationOptions(bottomBanner: customBottomBanner) let navViewController = NavigationViewController(options: options) For more information on customizing the style of visual instructions, see App styling. Custom instructions Visual instructions You can use VisualInstructionDelegate.label(_:willPresent:as:) to adjust the predefined contents of visual instruction provided by the Directions API, but you cannot currently trigger an arbitrary message outside the visual instructions that are triggered by default. func label(_ label: InstructionLabel, willPresent instruction: VisualInstruction, as presented: NSAttributedString) -> NSAttributedString? { let range = NSRange(location: 0, length: presented.length) let mutable = NSMutableAttributedString(attributedString: presented) mutable.mutableString.applyTransform(.latinToKatakana, reverse: false, range: range, updatedRange: nil) return mutable } Spoken instructions An application can call RouteVoiceController.speak(_:) at any time to interrupt any in-progress spoken instruction with a custom spoken instruction. func voiceController(_ voiceController: RouteVoiceController, willSpeak instruction: SpokenInstruction, routeProgress: RouteProgress) -> SpokenInstruction? { return SpokenInstruction(distanceAlongStep: instruction.distanceAlongStep, text: ""New Instruction!"", ssmlText: ""<speak>New Instruction!</speak>"") } For more information on supported SSML tags see Amazon's SSML Tags Supported by Amazon Polly guide. Device notifications The application should import the UserNotifications framework and request authorization to present user notifications before beginning turn-by-turn navigation. If authorized, the Navigation SDK automatically displays user notifications while the screen is locked. Was this page helpful? Yes No",,Maneuver instructions,Visual instruction events,Spoken instruction events,Customization in the drop-in UI,Custom instructions,Visual instructions,Spoken instructions,Device notifications,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Mock navigation,Mock a navigation session using a mock location engine.,https://docs.mapbox.com/android/navigation/examples/mock-navigation/,example,Java,,"Mock navigation Activity View on GitHub package com.mapbox.services.android.navigation.testapp.activity; import android.annotation.SuppressLint; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.location.Location; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.design.widget.BaseTransientBottomBar; import android.support.design.widget.FloatingActionButton; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.Toast; import com.mapbox.android.core.location.LocationEngine; import com.mapbox.android.core.location.LocationEngineCallback; import com.mapbox.android.core.location.LocationEngineResult; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Point; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.annotations.MarkerOptions; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.services.android.navigation.testapp.R; import com.mapbox.services.android.navigation.testapp.Utils; import com.mapbox.services.android.navigation.testapp.activity.notification.CustomNavigationNotification; import com.mapbox.services.android.navigation.ui.v5.route.NavigationMapRoute; import com.mapbox.services.android.navigation.v5.instruction.Instruction; import com.mapbox.services.android.navigation.v5.location.replay.ReplayRouteLocationEngine; import com.mapbox.services.android.navigation.v5.milestone.Milestone; import com.mapbox.services.android.navigation.v5.milestone.MilestoneEventListener; import com.mapbox.services.android.navigation.v5.milestone.RouteMilestone; import com.mapbox.services.android.navigation.v5.milestone.Trigger; import com.mapbox.services.android.navigation.v5.milestone.TriggerProperty; import com.mapbox.services.android.navigation.v5.navigation.MapboxNavigation; import com.mapbox.services.android.navigation.v5.navigation.MapboxNavigationOptions; import com.mapbox.services.android.navigation.v5.navigation.NavigationEventListener; import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute; import com.mapbox.services.android.navigation.v5.navigation.RefreshCallback; import com.mapbox.services.android.navigation.v5.navigation.RefreshError; import com.mapbox.services.android.navigation.v5.navigation.RouteRefresh; import com.mapbox.services.android.navigation.v5.offroute.OffRouteListener; import com.mapbox.services.android.navigation.v5.routeprogress.ProgressChangeListener; import com.mapbox.services.android.navigation.v5.routeprogress.RouteProgress; import com.mapbox.turf.TurfConstants; import com.mapbox.turf.TurfMeasurement; import java.lang.ref.WeakReference; import butterknife.BindView; import butterknife.ButterKnife; import butterknife.OnClick; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; public class MockNavigationActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener, ProgressChangeListener, NavigationEventListener, MilestoneEventListener, OffRouteListener, RefreshCallback { private static final int BEGIN_ROUTE_MILESTONE = 1001; private static final double TWENTY_FIVE_METERS = 25d; // Map variables @BindView(R.id.mapView) MapView mapView; @BindView(R.id.newLocationFab) FloatingActionButton newLocationFab; @BindView(R.id.startRouteButton) Button startRouteButton; private MapboxMap mapboxMap; // Navigation related variables private LocationEngine locationEngine; private MapboxNavigation navigation; private DirectionsRoute route; private NavigationMapRoute navigationMapRoute; private Point destination; private Point waypoint; private RouteRefresh routeRefresh; private boolean isRefreshing = false; private static class MyBroadcastReceiver extends BroadcastReceiver { private final WeakReference<MapboxNavigation> weakNavigation; MyBroadcastReceiver(MapboxNavigation navigation) { this.weakNavigation = new WeakReference<>(navigation); } @Override public void onReceive(Context context, Intent intent) { MapboxNavigation navigation = weakNavigation.get(); navigation.stopNavigation(); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_mock_navigation); ButterKnife.bind(this); routeRefresh = new RouteRefresh(Mapbox.getAccessToken(), this); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); Context context = getApplicationContext(); CustomNavigationNotification customNotification = new CustomNavigationNotification(context); MapboxNavigationOptions options = MapboxNavigationOptions.builder() .navigationNotification(customNotification) .build(); navigation = new MapboxNavigation(this, Mapbox.getAccessToken(), options); navigation.addMilestone(new RouteMilestone.Builder() .setIdentifier(BEGIN_ROUTE_MILESTONE) .setInstruction(new BeginRouteInstruction()) .setTrigger( Trigger.all( Trigger.lt(TriggerProperty.STEP_INDEX, 3), Trigger.gt(TriggerProperty.STEP_DISTANCE_TOTAL_METERS, 200), Trigger.gte(TriggerProperty.STEP_DISTANCE_TRAVELED_METERS, 75) ) ).build()); customNotification.register(new MyBroadcastReceiver(navigation), context); } @OnClick(R.id.startRouteButton) public void onStartRouteClick() { boolean isValidNavigation = navigation != null; boolean isValidRoute = route != null && route.distance() > TWENTY_FIVE_METERS; if (isValidNavigation && isValidRoute) { // Hide the start button startRouteButton.setVisibility(View.INVISIBLE); // Attach all of our navigation listeners. navigation.addNavigationEventListener(this); navigation.addProgressChangeListener(this); navigation.addMilestoneEventListener(this); navigation.addOffRouteListener(this); ((ReplayRouteLocationEngine) locationEngine).assign(route); navigation.setLocationEngine(locationEngine); mapboxMap.getLocationComponent().setLocationComponentEnabled(true); navigation.startNavigation(route); mapboxMap.removeOnMapClickListener(this); } } @OnClick(R.id.newLocationFab) public void onNewLocationClick() { newOrigin(); } private void newOrigin() { if (mapboxMap != null) { LatLng latLng = Utils.getRandomLatLng(new double[] {-77.1825, 38.7825, -76.9790, 39.0157}); ((ReplayRouteLocationEngine) locationEngine).assignLastLocation( Point.fromLngLat(latLng.getLongitude(), latLng.getLatitude()) ); mapboxMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, 12)); } } @SuppressLint(""MissingPermission"") @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; this.mapboxMap.addOnMapClickListener(this); mapboxMap.setStyle(Style.MAPBOX_STREETS, style -> { LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent(this, style); locationComponent.setRenderMode(RenderMode.GPS); locationComponent.setLocationComponentEnabled(false); navigationMapRoute = new NavigationMapRoute(navigation, mapView, mapboxMap); Snackbar.make(findViewById(R.id.container), ""Tap map to place waypoint"", BaseTransientBottomBar.LENGTH_LONG).show(); locationEngine = new ReplayRouteLocationEngine(); newOrigin(); }); } @Override public boolean onMapClick(@NonNull LatLng point) { if (destination == null) { destination = Point.fromLngLat(point.getLongitude(), point.getLatitude()); } else if (waypoint == null) { waypoint = Point.fromLngLat(point.getLongitude(), point.getLatitude()); } else { Toast.makeText(this, ""Only 2 waypoints supported"", Toast.LENGTH_LONG).show(); } mapboxMap.addMarker(new MarkerOptions().position(point)); calculateRoute(); return false; } @SuppressLint(""MissingPermission"") private void calculateRoute() { locationEngine.getLastLocation(new LocationEngineCallback<LocationEngineResult>() { @Override public void onSuccess(LocationEngineResult result) { findRouteWith(result); } @Override public void onFailure(@NonNull Exception exception) { Timber.e(exception); } }); } private void findRouteWith(LocationEngineResult result) { Location userLocation = result.getLastLocation(); if (userLocation == null) { Timber.d(""calculateRoute: User location is null, therefore, origin can't be set.""); return; } Point origin = Point.fromLngLat(userLocation.getLongitude(), userLocation.getLatitude()); if (TurfMeasurement.distance(origin, destination, TurfConstants.UNIT_METERS) < 50) { startRouteButton.setVisibility(View.GONE); return; } final NavigationRoute.Builder navigationRouteBuilder = NavigationRoute.builder(this) .accessToken(Mapbox.getAccessToken()); navigationRouteBuilder.origin(origin); navigationRouteBuilder.destination(destination); if (waypoint != null) { navigationRouteBuilder.addWaypoint(waypoint); } navigationRouteBuilder.enableRefresh(true); navigationRouteBuilder.build().getRoute(new Callback<DirectionsResponse>() { @Override public void onResponse(@NonNull Call<DirectionsResponse> call, @NonNull Response<DirectionsResponse> response) { Timber.d(""Url: %s"", call.request().url().toString()); if (response.body() != null) { if (!response.body().routes().isEmpty()) { MockNavigationActivity.this.route = response.body().routes().get(0); navigationMapRoute.addRoutes(response.body().routes()); startRouteButton.setVisibility(View.VISIBLE); } } } @Override public void onFailure(@NonNull Call<DirectionsResponse> call, @NonNull Throwable throwable) { Timber.e(throwable, ""onFailure: navigation.getRoute()""); } }); } /* * Navigation listeners */ @Override public void onMilestoneEvent(RouteProgress routeProgress, String instruction, Milestone milestone) { Timber.d(""Milestone Event Occurred with id: %d"", milestone.getIdentifier()); Timber.d(""Voice instruction: %s"", instruction); } @Override public void onRunning(boolean running) { if (running) { Timber.d(""onRunning: Started""); } else { Timber.d(""onRunning: Stopped""); } } @Override public void userOffRoute(Location location) { Toast.makeText(this, ""off-route called"", Toast.LENGTH_LONG).show(); } @Override public void onProgressChange(Location location, RouteProgress routeProgress) { mapboxMap.getLocationComponent().forceLocationUpdate(location); if (!isRefreshing) { isRefreshing = true; routeRefresh.refresh(routeProgress); } Timber.d(""onProgressChange: fraction of route traveled: %f"", routeProgress.fractionTraveled()); } /* * Activity lifecycle methods */ @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); navigation.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onRefresh(DirectionsRoute directionsRoute) { navigation.startNavigation(directionsRoute); isRefreshing = false; } @Override public void onError(RefreshError error) { isRefreshing = false; } private static class BeginRouteInstruction extends Instruction { @Override public String buildInstruction(RouteProgress routeProgress) { return ""Have a safe trip!""; } } } Copy Was this page helpful? Yes No",,Mock navigation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Zoomable map,An overview of the zoomable map example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/zoomable-map/,example,C#,,"Zoomable map The Zoomable Map example allows you to create a runtime zoomable and pannable map. This example is a starting point for creating a traditional web-based zoomable map. Place custom markers Placing custom markers on zoomable and non-zoomable maps is mostly a similar process, with one exception. Since the zoom level of a zoomable map can change at runtime, the marker positions need to be updated in every frame. The Zoomable Map example handles this with a script called SpawnOnMap. SpawnOnMap provides an outline of placing custom markers. It uses the Start() function to calculate initial marker positions, then uses Update() to update those positions every time the map changes (either from zooming or panning). ... void Start() { _locations = new Vector2d[_locationStrings.Length]; _spawnedObjects = new List<GameObject>(); for (int i = 0; i < _locationStrings.Length; i++) { var locationString = _locationStrings[i]; _locations[i] = Conversions.StringToLatLon(locationString); var instance = Instantiate(_markerPrefab); instance.transform.localPosition = _map.GeoToWorldPosition(_locations[i], true); + instance.transform.localScale = new Vector3(_spawnScale, _spawnScale, _spawnScale); _spawnedObjects.Add(instance); } } private void Update() { int count = _spawnedObjects.Count; for (int i = 0; i < count; i++) { var spawnedObject = _spawnedObjects[i]; var location = _locations[i]; spawnedObject.transform.localPosition = _map.GeoToWorldPosition(location, true); } } ... Using the SpawnOnMap example script To use the SpawnOnMap script, add it as a Component to a Map GameObject. Below is a description of the variables. Variables Description Map Map object on which to place custom markers. Location Strings List of locations in latitude, longitude where the markers will spawn. Spawn Scale Scale of spawned markers. Applied as uniform scale in all directions. Custom Prefab Prefab that will be spawned on the map as the marker. Understand quadtree tile provider Web Mercator tile services use a quadtree structure to provide tiles at different zoom levels. The QuadTreeTileProvider script leverages this quadtree structure to request tiles for the area of interest. QuadTreeTileProvider uses the location in latitude, longitude, the camera's viewport, and the map's zoom level to determine the area of interest. QuadTreeTileProvider provides a way to create a zoomable map without moving the camera in the scene. The map's root and individual UnityTile objects are scaled appropriately to provide zooming capability, similar to traditional web-based maps. QuadTreeTileProvider also provides an API call to update the map when the location and/or zoom level changes. Benefits and limitations Using this map gives you a runtime, zoomable map instead of a static map. It takes care of the tile scaling and map scaling for you so you can look at a map at different zoom levels. It also decouples the camera from the map for zooming. By default this example only provides a top-down 2D view of the map, without vector data. Was this page helpful? Yes No",,Zoomable map,Using the SpawnOnMap example script,Understand quadtree tile provider,Benefits and limitations,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Satellite,Mapbox Satellite is a global basemap of high-resolution satellite imagery.,https://docs.mapbox.com/help/glossary/mapbox-satellite/,glossary,,,"Mapbox Satellite Mapbox Satellite is a global basemap of high-resolution satellite imagery. The imagery data comes from a variety of commercial providers, as well as open data from NASA, USGS, and others. It’s color-corrected and blended together into a single raster tileset. Mapbox Satellite is available for free to all users at zoom levels 0-19 in the Mapbox Studio style editor and with our APIs and SDKs by using the style URL mapbox://styles/mapbox/satellite-v9 or tileset ID mapbox.satellite. Was this page helpful? Yes No",,Mapbox Satellite,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Change your map’s label language,Learn about available languages and how to change your map’s language.,https://docs.mapbox.com/help/troubleshooting/change-language/,troubleshooting,,,"Change your map’s label language When building a map from a Mapbox template style, map labels will appear in English by default. You can change the language of your map's labels directly in the Mapbox Studio style editor or dynamically using Mapbox GL JS, the Mapbox Maps SDK for Android, or the Mapbox Maps SDK for iOS. This guide also outlines changing label language in Mapbox Studio Classic. Languages available All Mapbox template maps use the Mapbox Streets vector tileset for map features. In this tileset, there are different name fields for each of the label layers: name — the name or names used locally for the place name_en — English (if available) name_es — Spanish (if available) name_fr — French (if available) name_de — German (if available) name_ru — Russian (if available) name_zh — Chinese (if available) name_zh-Hans — Simplified Chinese (if available) name_pt — Portuguese (if available) name_ar — Arabic (if available) name_ja — Japanese (if available) name_ko — Korean (if available) Note For the Spanish, French, and German labels, there are additional fallback conditions. Where the local name is in a non-Latin writing system and no Spanish/French/German translation is available, these fields will show an English or international version of the name if possible, otherwise they will show the local name. Note The name_zh field contains Mandarin using simplified Chinese characters for our custom label layers: #country_label, #state_label, and #marine_label. All other label layers are sourced from OpenStreetMap and may contain one of several dialects and either simplified or traditional Chinese characters in the name_zh field. The name_zh-Hans field is similar, except any traditional Chinese characters are automatically transformed to Simplified Chinese. Right-to-left language support Mapbox GL JS The mapbox-gl-rtl-text plugin adds support for text written in the Arabic and Hebrew languages. Mapbox Studio Mapbox Studio loads the mapbox-gl-rtl-text plugin by default. Change label language in Mapbox Studio Layer by layer Create a new style or edit an existing one in Mapbox Studio. Select the layer that contains the labels you'd like to edit. Under the Text tab, click the value next to Text field. A panel will appear with all language options for the layer. Click the desired language; the map will update on select. Multiple layers at once Instead of changing each label layer individually, you can use the Filter layers panel to change all the label layer's languages at once. Click the Filter layers panel and then Filter by value. Choose Text fields from the list of categories and select each instance of { name_en } from the list. As you choose each of these, you will see your list of layers grow. Click on the top of the layer list, hold down the Shift key, and click on the last layer in the list. Once all the layers have been selected, you will be prompted to choose a value for all the layers. Your browser doesn't support embedded videos. Change label language dynamically Mapbox GL JS If you are comfortable with JavaScript, you can change the language of your labels dynamically by using the .setLayoutProperty() method in Mapbox GL JS. See the language switcher Mapbox GL JS example for more details. You can also use the Mapbox GL Language plugin to automatically change the layers of a map style to use the text-field that matches the browser language. Read more about this and other capabilities of the Mapbox GL Language plugin on GitHub. Mapbox Maps SDK for Android With the Mapbox Maps SDK for Android, you can change the language of labels on your map dynamically at runtime. For example, here's how you would change a map's city labels to Russian: Layer singleMapLayer = map.getStyle().getLayer(""settlement-label""); singleMapLayer.setProperties(textField("" { name_ru } "")); You could also use the Mapbox Localization Plugin for Android if you want to change the language of the entire map all at once. This plugin detects the set language of the Android device and then changes all map text to that language. The plugin also enables you to change the entire map to a specific language. This could be useful if you want to provide your user the ability to switch the map to a specific language at a specific time, rather than locking the map to the device's set default language or a particular language. Mapbox Maps SDK for iOS With the Mapbox Maps SDK for iOS, you can automatically change the language of labels to the system's preferred language at runtime. swift objective-c func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { style.localizeLabels(into: nil) } Copy You can also change labels to a specific language, either throughout the map or only for certain kinds of labels: swift objective-c // 'style' in this case refers to an MGLStyle object. let layer = style.layer(withIdentifier: ""place-city-sm"") as! MGLSymbolStyleLayer let spanish = Locale(identifier: ""es"") layer.text = layer.text.mgl_expressionLocalized(into: spanish) Copy See the Maps SDK for iOS documentation for more information. Change label language in Mapbox Studio Classic Most of the Mapbox preset styles in Mapbox Studio Classic will have a @name variable in the CartoCSS. This is where you can set the language. Below are the options and an example of how to set the value of @name to '[name_en]' or English labels. // Language options: name (local), name_en, name_fr, name_es, name_de @name: '[name_en]'; Swap out any of the language options inside the brackets to change your labels to that language. Next, you must set all the labels with the property text-name with the value @name. For example: #country_label[zoom>=3] { text-name: @name; ... } Was this page helpful? Yes No",,Change your map’s label language,Right-to-left language support,Mapbox GL JS,Mapbox Studio,Change label language in Mapbox Studio,Layer by layer,Multiple layers at once,Change label language dynamically,Mapbox Maps SDK for Android,Mapbox Maps SDK for iOS,Change label language in Mapbox Studio Classic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display HTML clusters with custom properties,"This advanced example uses Mapbox GL JS clustering with HTML markers and custom property expressions. To use HTML or SVG for clusters in place of a Mapbox GL layer, you have to manually synchronize the clustered source with a pool of marker objects that updates continuously while the map view change",https://docs.mapbox.com/mapbox-gl-js/example/cluster-html/,example,JavaScript,,"Display HTML clusters with custom properties This advanced example uses Mapbox GL JS clustering with HTML markers and custom property expressions. To use HTML or SVG for clusters in place of a Mapbox GL layer, you have to manually synchronize the clustered source with a pool of marker objects that updates continuously while the map view changes. Was this example helpful? Yes No",,Display HTML clusters with custom properties,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,CircleLayer clusters,Use GeoJSON and circle layers to visualize point data in clusters.,https://docs.mapbox.com/android/maps/examples/circle-layer-clustering/,example,Java,,"CircleLayer clusters Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.dds.CircleLayerClusteringActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.Bundle; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonOptions; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import java.net.URI; import java.net.URISyntaxException; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.content.ContextCompat; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.all; import static com.mapbox.mapboxsdk.style.expressions.Expression.division; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.gte; import static com.mapbox.mapboxsdk.style.expressions.Expression.has; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.lt; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.toNumber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconSize; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textField; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textSize; /** * Use GeoJSON and circle layers to visualize point data as circle clusters. */ public class CircleLayerClusteringActivity extends AppCompatActivity { private MapView mapView; private MapboxMap mapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_circle_layer_clustering); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap map) { mapboxMap = map; map.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { mapboxMap.animateCamera(CameraUpdateFactory.newLatLngZoom(new LatLng( 12.099, -79.045), 3)); addClusteredGeoJsonSource(style); style.addImage( ""cross-icon-id"", BitmapUtils.getBitmapFromDrawable(getResources().getDrawable(R.drawable.ic_cross)), true ); Toast.makeText(CircleLayerClusteringActivity.this, R.string.zoom_map_in_and_out_instruction, Toast.LENGTH_SHORT).show(); } }); } }); } @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private void addClusteredGeoJsonSource(@NonNull Style loadedMapStyle) { // Add a new source from the GeoJSON data and set the 'cluster' option to true. try { loadedMapStyle.addSource( // Point to GeoJSON data. This example visualizes all M1.0+ earthquakes from // 12/22/15 to 1/21/16 as logged by USGS' Earthquake hazards program. new GeoJsonSource(""earthquakes"", new URI(""https://www.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson""), new GeoJsonOptions() .withCluster(true) .withClusterMaxZoom(14) .withClusterRadius(50) ) ); } catch (URISyntaxException uriSyntaxException) { Timber.e(""Check the URL %s"", uriSyntaxException.getMessage()); } // Use the earthquakes GeoJSON source to create three layers: One layer for each cluster category. // Each point range gets a different fill color. int[][] layers = new int[][] { new int[] {150, ContextCompat.getColor(this, R.color.mapboxRed)}, new int[] {20, ContextCompat.getColor(this, R.color.mapboxGreen)}, new int[] {0, ContextCompat.getColor(this, R.color.mapbox_blue)} }; //Creating a marker layer for single data points SymbolLayer unclustered = new SymbolLayer(""unclustered-points"", ""earthquakes""); unclustered.setProperties( iconImage(""cross-icon-id""), iconSize( division( get(""mag""), literal(4.0f) ) ), iconColor( interpolate(exponential(1), get(""mag""), stop(2.0, rgb(0, 255, 0)), stop(4.5, rgb(0, 0, 255)), stop(7.0, rgb(255, 0, 0)) ) ) ); loadedMapStyle.addLayer(unclustered); for (int i = 0; i < layers.length; i++) { //Add clusters' circles CircleLayer circles = new CircleLayer(""cluster-"" + i, ""earthquakes""); circles.setProperties( circleColor(layers[i][1]), circleRadius(18f) ); Expression pointCount = toNumber(get(""point_count"")); // Add a filter to the cluster layer that hides the circles based on ""point_count"" circles.setFilter( i == 0 ? all(has(""point_count""), gte(pointCount, literal(layers[i][0])) ) : all(has(""point_count""), gte(pointCount, literal(layers[i][0])), lt(pointCount, literal(layers[i - 1][0])) ) ); loadedMapStyle.addLayer(circles); } //Add the count labels SymbolLayer count = new SymbolLayer(""count"", ""earthquakes""); count.setProperties( textField(Expression.toString(get(""point_count""))), textSize(12f), textColor(Color.WHITE), textIgnorePlacement(true), textAllowOverlap(true) ); loadedMapStyle.addLayer(count); } } Copy Was this page helpful? Yes No",,CircleLayer clusters,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Indoor Map,Display an indoor map of a building with toggles to switch between floor levels.,https://docs.mapbox.com/android/maps/examples/floor-plan/,example,Java,,"Indoor Map Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""38.89770"" mapbox:mapbox_cameraTargetLng=""-77.03655"" mapbox:mapbox_cameraZoom=""18""/> <LinearLayout android:id=""@+id/floor_level_buttons"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom|end"" android:layout_margin=""16dp"" android:background=""@color/mapboxBlue"" android:orientation=""vertical""> <Button android:id=""@+id/second_level_button"" android:layout_width=""50dp"" android:layout_height=""wrap_content"" android:background=""?android:attr/selectableItemBackground"" android:text=""2"" android:textColor=""@color/mapboxWhite""/> <Button android:id=""@+id/ground_level_button"" android:layout_width=""50dp"" android:layout_height=""wrap_content"" android:background=""?android:attr/selectableItemBackground"" android:text=""G"" android:textColor=""@color/mapboxWhite""/> </LinearLayout> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.view.animation.AlphaAnimation; import android.widget.Button; import com.mapbox.geojson.Point; import com.mapbox.geojson.Polygon; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.turf.TurfJoins; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.List; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Display an indoor map of a building with toggles to switch between floor levels */ public class IndoorMapActivity extends AppCompatActivity { private GeoJsonSource indoorBuildingSource; private List<List<Point>> boundingBoxList; private View levelButtons; private MapView mapView; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_indoor_map); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { levelButtons = findViewById(R.id.floor_level_buttons); final List<Point> boundingBox = new ArrayList<>(); boundingBox.add(Point.fromLngLat(-77.03791, 38.89715)); boundingBox.add(Point.fromLngLat(-77.03791, 38.89811)); boundingBox.add(Point.fromLngLat(-77.03532, 38.89811)); boundingBox.add(Point.fromLngLat(-77.03532, 38.89708)); boundingBoxList = new ArrayList<>(); boundingBoxList.add(boundingBox); mapboxMap.addOnCameraMoveListener(new MapboxMap.OnCameraMoveListener() { @Override public void onCameraMove() { if (mapboxMap.getCameraPosition().zoom > 16) { if (TurfJoins.inside(Point.fromLngLat(mapboxMap.getCameraPosition().target.getLongitude(), mapboxMap.getCameraPosition().target.getLatitude()), Polygon.fromLngLats(boundingBoxList))) { if (levelButtons.getVisibility() != View.VISIBLE) { showLevelButton(); } } else { if (levelButtons.getVisibility() == View.VISIBLE) { hideLevelButton(); } } } else if (levelButtons.getVisibility() == View.VISIBLE) { hideLevelButton(); } } }); indoorBuildingSource = new GeoJsonSource( ""indoor-building"", loadJsonFromAsset(""white_house_lvl_0.geojson"")); style.addSource(indoorBuildingSource); // Add the building layers since we know zoom levels in range loadBuildingLayer(style); } }); Button buttonSecondLevel = findViewById(R.id.second_level_button); buttonSecondLevel.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { indoorBuildingSource.setGeoJson(loadJsonFromAsset(""white_house_lvl_1.geojson"")); } }); Button buttonGroundLevel = findViewById(R.id.ground_level_button); buttonGroundLevel.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { indoorBuildingSource.setGeoJson(loadJsonFromAsset(""white_house_lvl_0.geojson"")); } }); } }); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private void hideLevelButton() { // When the user moves away from our bounding box region or zooms out far enough the floor level // buttons are faded out and hidden. AlphaAnimation animation = new AlphaAnimation(1.0f, 0.0f); animation.setDuration(500); levelButtons.startAnimation(animation); levelButtons.setVisibility(View.GONE); } private void showLevelButton() { // When the user moves inside our bounding box region or zooms in to a high enough zoom level, // the floor level buttons are faded out and hidden. AlphaAnimation animation = new AlphaAnimation(0.0f, 1.0f); animation.setDuration(500); levelButtons.startAnimation(animation); levelButtons.setVisibility(View.VISIBLE); } private void loadBuildingLayer(@NonNull Style style) { // Method used to load the indoor layer on the map. First the fill layer is drawn and then the // line layer is added. FillLayer indoorBuildingLayer = new FillLayer(""indoor-building-fill"", ""indoor-building"").withProperties( fillColor(Color.parseColor(""#eeeeee"")), // Function.zoom is used here to fade out the indoor layer if zoom level is beyond 16. Only // necessary to show the indoor map at high zoom levels. fillOpacity(interpolate(exponential(1f), zoom(), stop(16f, 0f), stop(16.5f, 0.5f), stop(17f, 1f)))); style.addLayer(indoorBuildingLayer); LineLayer indoorBuildingLineLayer = new LineLayer(""indoor-building-line"", ""indoor-building"").withProperties( lineColor(Color.parseColor(""#50667f"")), lineWidth(0.5f), lineOpacity(interpolate(exponential(1f), zoom(), stop(16f, 0f), stop(16.5f, 0.5f), stop(17f, 1f)))); style.addLayer(indoorBuildingLineLayer); } private String loadJsonFromAsset(String filename) { // Using this method to load in GeoJSON files from the assets folder. try { InputStream is = getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (IOException ex) { ex.printStackTrace(); return null; } } } Copy Was this page helpful? Yes No",,Indoor Map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Highlight features within a bounding box,Hold the Shift key and drag the map to query features using queryRenderedFeatures.,https://docs.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/,example,JavaScript,,Highlight features within a bounding box Hold the Shift key and drag the map to query features using queryRenderedFeatures. Was this example helpful? Yes No,,Highlight features within a bounding box,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Tilesets API recipe examples,This feature is in beta. Use these example tiling recipes to learn how to transform custom data into tilesets using the Mapbox Tilesets API.,https://docs.mapbox.com/help/troubleshooting/tileset-recipe-examples/,troubleshooting,,,"Tilesets API recipe examples Public beta The Tilesets API features and workflows discussed in this guide are in public beta. All features and workflows are subject to potential future changes. When converting custom data into Mapbox vector tiles, there are many possible ways that the data might be transformed. To tell the Tilesets API how exactly to tile your data, you will need to provide a recipe file. This guide includes example use-cases and their corresponding recipes, plus notes about the purpose of each option. Read the recipe reference before relying on the examples recipes below so you can write recipes specifically for your data. Basic recipe using zoom levels This is the least complex recipe you can write. There are four required fields: { ""version"": 1, ""layers"": { ""source"": ""mapbox://tileset-source/ { username } / { id } "", ""minzoom"": 0, ""maxzoom"": 8 } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. Integer maxzoom Specify the maximum zoom at which your tileset will be available. (These tiles can be overzoomed to higher.) Integer To learn more about zoom levels and how to configure them properly for your data, have a look at the Recipe reference's section on Zoom level configuration. Points of Interest Points of Interest (POIs) must be visible and not overcrowded to allow users to quickly distinguish each point. They are likely going to be labels on a map or points or circles with labels. Here’s a recipe suitable for POI data at low to medium zooms. { ""version"": 1, ""layers"": { ""my_points_layer"": { ""source"": ""mapbox://tileset-source/ { username } /pois"", ""minzoom"": 0, ""maxzoom"": 10, ""tiles"": { ""limit"": [ [ ""lowest_where_in_distance"", true, 256, ""name"" ] ] } } } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. Integer maxzoom Specify the maximum zoom at which the tileset will be available. A value of 10 provides up to 10 meters of precision, which is enough for relative locations of features like POIs. Integer tiles.limit.lowest_where_in_distance This property is used to keep the number of points in each tile to a minimum, which avoids having too many points for the POIs readable. 256 features per tile max. Array<Expression> Example data This example recipe is compatible with the NYC Points of Interest dataset available on Data.gov. Download example POI data Natural Earth Data populated places This example uses a global point dataset of populated places from Natural Earth Data to build a label layer. POIs must be visible and not overcrowded to allow users to quickly distinguish each point. They are likely going to be labels on a map, or points or circles with labels. Here’s a recipe suitable for this dataset at low to medium zoom levels. { ""version"": 1, ""layers"": { ""city_labels"": { ""source"": ""mapbox://tileset-source/ { username } /populated-places"", ""minzoom"" : 0, ""maxzoom"" : 7, ""features"" : { ""attributes"" : { ""allowed_output"" : [ ""name_en"", ""SCALERANK"" ] } } , ""tiles"" : { ""limit"" : [ [ ""lowest_where_in_distance"", true, 50, ""SCALERANK"" ] ] } } } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. A value of 0 here ensures that cities will be visible at a global level. Integer maxzoom Specify the maximum zoom at which your tileset will be available. A value of 7 here allows users to zoom in and will show more cities, but we have no need for these labels at higher zoom levels in this particular case. Integer features.attributes.allowed_output Specify which data attributes to carry through to the final tileset. Here we only keep the two attributes name_en and SCALERANK to keep tile sizes low (we don't need other fields for a label tileset). Note that the filter has to preserve SCALERANK as well as name_en, even though only name_en is needed for display. SCALERANK is necessary so that the limit filter can reference it. Array<String> tiles.limit Use the limit filter to keep the number of cities per tile low. It will only keep points if another point is not already in its place with a higher SCALERANK value. Array<Expression> Example data Download the city data used in this recipe from Natural Earth Data. To transform the data from Natural Earth into a format that is compatible with a Tilesets API recipe, use the following Tippecanoe command: $ tippecanoe-json-tool ../tippecanoe/ne_10m_populated_places.json > cities.json High density points for data visualization (data reduction) { ""version"": 1, ""layers"": { ""dots"": { ""source"": ""mapbox://tileset-source/ { username } /high-density-points-data"", ""minzoom"": 0, ""maxzoom"": 15, ""tiles"": { ""limit"": [ [ ""lowest_where_in_distance"", true, 50000, null ] ] } } } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. A value of 0 here ensures that dots will be visible at a global level. Integer maxzoom Specify the maximum zoom at which your tileset will be available. A value of 15 here allows users to zoom in and will show more points as they do so. Integer tiles.limit A filter array that will keep up to 50,000 features in the tile while ensuring that the geographic density of the features is distributed evenly across the tiles. Array<Expression> Feature limits in vector tiles The theoretical maximum value for a vector tile of normal extent (non configurable) is 16,777,216 point features. But a vector tile with this many features would hit the Tilesets API's 500 KB size limit, and the job request will not complete successfully. To avoid hitting this limit, you either need to reduce the number of point features included in your tileset source or define more aggressive filters in your recipe. Union road features based on common attributes This example uses a TIGER road export and performs a join on roads that have the same name. In the final tileset, this will turn multiple features into a single, continuous feature. Performing a union operation on features based on attributes is helpful for keeping tileset size down and preventing unnecessary dropped features. { ""version"": 1, ""layers"": { ""roads"": { ""source"": ""mapbox://tileset-source/ { username } /tiger-data"", ""minzoom"": 5, ""maxzoom"": 11, ""features"": { ""filter"": [ ""all"", [ "">="", [ ""get"", ""MTFCC"" ], ""S1000"" ], [ ""<="", [ ""get"", ""MTFCC"" ], ""S2000"" ] ] } , ""tiles"": { ""union"": [ { ""group_by"": [ ""FULLNAME"" ], ""maintain_direction"": false } ] } } } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. A value of 5 here ensures that the roads will be visible only when a user zooms in. Integer maxzoom Specify the maximum zoom at which your tileset will be available. A value of 11 here ensures that the roads will not be visible if a user zooms in significantly. Integer features.filter Keep all features with an MTFCC attribute that has a value between S1000 and S2000 (TIGER's classifications for roads). This filter-expression performs a lexical comparison on this string attribute. Array<Expression> tiles.union Use the group_by method to union any features that have an identical FULLNAME attribute. Set maintain_direction to false so that block faces can be connected together no matter which direction their house numbering runs. Array<Object> Natural Earth: countries and polygon simplification This recipe would be good for global extent interaction with country polygons. You would not need highly detailed country borders in this case, so you would use the simplification option in the features configuration to keep the number of nodes small in the final tiles. { ""version"": 1, ""layers"": { ""countries"": { ""source"": ""mapbox://tileset-source/ { username } /country-polygons"", ""minzoom"": 0, ""maxzoom"": 5, ""features"": { ""simplification"": 20 } } } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. A value of 0 here ensures that the countries will be visible at a global level. Integer maxzoom Specify the maximum zoom at which your tileset will be available. A value of 5 here ensures that the countries will be visible as the user zooms in a little bit, but will not be visible if they zoom in significantly. Integer features.simplification Specify an integer value that is greater than zero to control the level of simplification that occurs for features. The value provided is relative to the extent provided for the tiles, with a larger value resulting in more simplification. A value of 20 here indicates a moderate amount of simplification that will become more apparent as a user zooms in on country boundaries. Integer Natural Earth: roads This is a complex example that uses Natural Earth Data’s roads. The recipe generates a ranked quality attribute for each feature based on the road type defined in the source data. Then it filters attributes by these newly created quality attributes to keep only specific quality features per zoom level. For example, the ""Bypass"" road type is the fourth ranked item (zero-indexed at 3). With the verbose filter definition below, you will only see ""Bypass"" style streets show up at zoom level 3 or greater. { ""version"": 1, ""layers"": { ""roads"": { ""source"": ""mapbox://tileset-source/ { username } /road-data"", ""minzoom"": 0, ""maxzoom"": 5, ""features"": { ""attributes"": { ""set"": { ""quality"": [ ""match"", [ ""get"", ""type"" ], ""Ferry Route"", 0, ""Major Highway"", 1, ""Secondary Highway"", 2, ""Bypass"", 3, ""Beltway"", 4, ""Road"", 5, ""Track"", 5, 6 ] } } , ""filter"": [ ""<="", [ ""get"", ""quality"" ], [ ""zoom"" ] ] } } } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. A value of 0 here ensures that the roads will be visible at a global level. Integer maxzoom Specify the maximum zoom at which your tileset will be available. A value of 5 here ensures that the roads will be visible as the user zooms in a little bit, but will not be visible if they zoom in significantly. Integer features.attributes.set A JSON object that maps the names of attributes to be generated to filter expressions and returns the new attribute values for the final tileset. Here it is being used to generate a new quality attribute based on the type field included in the original data. Object features.filter A verbose filter definition. Its use here excludes any feature from tiles where their quality attribute is greater than the current zoom level. For example, features with a quality attribute of ""Bypass"" will not be visible at zoom levels lower than or equal to 3. Array<Expression> Building footprints This recipe can be used to create a tileset that contains building footprints. It uses the Rhode Island buildings dataset from Microsoft data. We can conclude that an appropriate value for maxzoom is 15 because this represents a one foot resolution on the ground. We have chosen a value of 13 for minzoom based on the following considerations and assumptions: It is reasonable to have about 50,000 features in a tile A building lot is approximately 5,000 square feet So a tile at the minimum zoom should be about 50000 * 5000 = 250,000,000 square feet Sqrt(250,000,000) ~= 15811 360.0 / (2 ** 13) / .00000274 ~= 16038, which is pretty close to that (.00000274 is the length in feet of a degree at the equator) { ""version"": 1, ""layers"": { ""building_footprints"": { ""source"": ""mapbox://tileset-source/ { username } /buildings"", ""minzoom"": 13, ""maxzoom"": 15 } } } Field Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Specify the minimum zoom at which your tileset will be available. A value of 13 here ensures that the buildings will be visible when a user has zoomed in significantly. Integer maxzoom Specify the maximum zoom at which your tileset will be available. A value of 15 here ensures that the buildings will be visible when a user has zoomed in significantly. Integer Example data Rhode Island buildings Convert the downloaded data to line-delimited GeoJSON with the tippecanoe-json-tool command. $ unzip -p RhodeIsland.zip | tippecanoe-json-tool > RhodeIsland.json Intricate road network This lengthy example creates a road network tileset from a road's tileset source. It applies 4 filter criteria based on the zoom, highway, and place attributes of the source's features. It then creates new streetrank and labelrank attributes for each filter using the set operator and specifies that the priority attribute should be used to define the zoom_element of the features in the final tileset. Finally, it limits the output tiles such that: No tile will have more than 20 highway features and will determine which features to keep based on their streetrank (regardless of whether or not features overlap). No tile will have more than 200 name features and will determine which features to keep based on their labelrank value (and will also drop features that overlap based on their lablerank). { ""version"": 1, ""layers"": { ""road_network"": { ""source"": ""mapbox://tileset-source/username/roads"", ""minzoom"": 0, ""maxzoom"": 14, ""features"": { ""filter"": [ ""any"", [ ""all"", [ "">="", [ ""zoom"" ], 0 ], [ ""match"", [ ""get"", ""highway"" ], ""motorway"", true, ""trunk"", true, ""primary"", true, false ] ], [ ""all"", [ "">="", [ ""zoom"" ], 6 ], [ ""match"", [ ""get"", ""highway"" ], ""secondary"", true, ""tertiary"", true, false ] ], [ ""all"", [ "">="", [ ""zoom"" ], 11 ], [ ""match"", [ ""get"", ""highway"" ], ""residential"", true, ""unclassified"", true, false ] ], [ ""all"", [ "">="", [ ""zoom"" ], 13 ], [ ""match"", [ ""get"", ""highway"" ], ""service"", true, false ] ], [ ""has"", ""place"" ] ], ""attributes"": { ""set"": { ""streetrank"": [ ""match"", [ ""get"", ""highway"" ], ""motorway"", 0, ""trunk"", 0, ""primary"", 0, ""secondary"", 1, ""tertiary"", 1, ""residential"", 2, ""unclassified"", 2, ""service"", 3, 4 ], ""labelrank"": [ ""match"", [ ""get"", ""place"" ], ""country"", 0, ""state"", 1, ""region"", 2, ""province"", 2, ""district"", 3, ""county"", 3, ""municipality"", 4, ""city"", 4, 5 ] } , ""zoom_element"": [ ""priority"" ] } } , ""tiles"": { ""limit"": [ [ ""lowest_where"", [ ""has"", ""highway"" ], 20, ""streetrank"" ], [ ""lowest_where_in_distance"", [ ""has"", ""name"" ], 200, ""labelrank"" ] ] } } } } Was this page helpful? Yes No",,Tilesets API recipe examples,Points of Interest,Natural Earth Data populated places,High density points for data visualization (data reduction),Union road features based on common attributes,Natural Earth: countries and polygon simplification,Natural Earth: roads,Building footprints,Intricate road network,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Working with firewalls,General troubleshooting tips and some configuration guidance for working with Mapbox behind a firewall.,https://docs.mapbox.com/help/troubleshooting/firewalls/,troubleshooting,,,"Working with firewalls If you're interacting with the Mapbox REST APIs behind a firewall and having trouble getting a response, you can try adding the domain api.mapbox.com to an allow list (sometimes called a whitelist). Mapbox uses distributed and dynamically-allocated servers rather than a fixed set of IP addresses. Normally you can add mapbox.com to an allow list, but in some cases you may also need to add specific domains including: mapbox.com www.mapbox.com api.mapbox.com api.tiles.mapbox.com a.tiles.mapbox.com b.tiles.mapbox.com c.tiles.mapbox.com d.tiles.mapbox.com Was this page helpful? Yes No",,Working with firewalls,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Tilesets,Learn how to create and manage tilesets in Mapbox Studio.,https://docs.mapbox.com/studio-manual/reference/tilesets/,reference,,,"Tilesets Tilesets are the primary data format for Mapbox maps. Whether you start with your own custom data or you create a dataset first, converting your data into a tileset will allow you to add it to a Mapbox map and style it using the Mapbox Studio style editor. Mapbox Studio topics covered in this section: Upload Dataset Tileset Template style Custom style Add data to style Style data Publish What is a tileset? A tileset is a collection of raster or vector data broken up into a uniform grid of square tiles at up to 22 preset zoom levels. Tilesets are used in Mapbox libraries and SDKs as a core piece of making maps visible on mobile or in the browser; they are also the main mechanism we use for determining map views. Tilesets are highly cacheable and load quickly. Mapbox relies heavily on both raster and vector tilesets to keep our maps fast and efficient. Manage tilesets The Tilesets page is where you can add and manage your uploaded tilesets. The Tilesets page shows you a list of all your uploaded tilesets, plus the five Mapbox-provided tilesets: Mapbox Streets, Mapbox Satellite, Mapbox Terrain, Terrain (RGB-encoded dem), and Mapbox Traffic. Unlike the tilesets you upload, the Mapbox Streets and Mapbox Terrain tilesets have layers that group certain features together. Any tilesets you upload will appear below the tilesets Mapbox provides. New tileset Click the New tileset button to create a new tileset. You can either Upload a file or Create from dataset. Note When a vector data file is uploaded to Mapbox, it is converted to vector tile format. When a raster data file (like an image) is uploaded to Mapbox, it becomes a set of tiled PNGs. Upload a file When uploading a file, the uploads pane will appear in the lower right corner of the page. This pane shows the tileset ID and status of your upload — the circle will be blue while the file is processing and green once the file has been uploaded. For more information about uploading data to your Mapbox account, see the Uploads page. Create from dataset Click the Create from dataset tab to create a tileset from a dataset. A modal will appear with a list of all datasets associated with your account. Choose a dataset from the list and click Export dataset. You will have the choice to either Export to a new tileset or, if that dataset is already connected to a tileset, the option to Update a connected tileset. Tileset menu For each tileset, you can either click on the name of the tileset to go to its information page or click the button for more options: Replace Replace the current data in your tileset with new data. The tileset ID will stay the same and the new data will be reflected in all styles that reference this tileset. Make private You can restrict the tilesets you upload to your Mapbox account so they can only be loaded with one of your access tokens. This means that other users cannot use their access tokens to access your tilesets. Your tilesets will continue to be accessible only using access tokens from your Mapbox account. This feature is only available to Enterprise customers. For more details, contact sales. Delete You can permanently delete a tileset from your account at any time. Deleted tilesets may not be recovered. Tileset ID From this menu, you can also copy the tileset ID to be used with Mapbox SDKs and APIs. Tileset information page Each tileset has an information page that provides additional information about the tileset. For vector tilesets, you'll see a list of source layers within the tileset. Your custom tilesets will only have one layer; Mapbox Streets and Mapbox Terrain include multiple layers. Each layer in the listing has information on geometry type, zoom levels of the data, and data attributes and value types. From this page you can also replace the data in the tileset, make the tileset private, and delete the tileset. The right sidebar of the page includes additional information about the tileset, including: The tileset ID of the tileset. The format of the tileset. The type of the tileset (raster or vector). The size of the tileset. The zoom extent of the tileset, or which zoom levels have been rendered — vector tilesets can be styled up to zoom level 22, but data will be simplified to the highest rendered zoom level. Next page: Datasets Learn how to create and manage datasets in Mapbox Studio. Was this page helpful? Yes No",,Tilesets,Manage tilesets,New tileset,Upload a file,Create from dataset,Tileset menu,Replace,Make private,Delete,Tileset ID,Tileset information page,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for iOS,iOS,Basic blue-line AR navigation,Project a blue route line on the view of the road through your device.,https://docs.mapbox.com/ios/vision/examples/basic-blue-line-ar-navigation/,example,Swift,,"Basic blue-line AR navigation Swift Objective C import UIKit import MapboxVision import MapboxVisionAR import MapboxDirections import MapboxCoreNavigation /** * ""AR Navigation"" example demonstrates how to display navigation route projected on the surface of the road. */ class ARNavigationViewController: UIViewController { private var videoSource: CameraVideoSource! private var visionManager: VisionManager! private var visionARManager: VisionARManager! private let visionARViewController = VisionARViewController() override func viewDidLoad() { super.viewDidLoad() addARView() // create a video source obtaining buffers from camera module videoSource = CameraVideoSource() videoSource.add(observer: self) // create VisionManager with video source visionManager = VisionManager.create(videoSource: videoSource) // create VisionARManager and register as its delegate to receive AR related events visionARManager = VisionARManager.create(visionManager: visionManager, delegate: self) let origin = CLLocationCoordinate2D() let destination = CLLocationCoordinate2D() let options = NavigationRouteOptions(coordinates: [origin, destination], profileIdentifier: .automobile) // query a navigation route between location coordinates and pass it to VisionARManager Directions.shared.calculate(options) { [weak self] (waypoints, routes, error) in guard let route = routes?.first else { return } self?.visionARManager.set(route: Route(route: route)) } } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) visionManager.start() videoSource.start() } override func viewDidDisappear(_ animated: Bool) { super.viewDidDisappear(animated) videoSource.stop() visionManager.stop() // free up resources by destroying modules when they're not longer used visionARManager.destroy() } private func addARView() { addChild(visionARViewController) view.addSubview(visionARViewController.view) visionARViewController.didMove(toParent: self) } } extension ARNavigationViewController: VisionARManagerDelegate { func visionARManager(_ visionARManager: VisionARManager, didUpdateARCamera camera: ARCamera) { DispatchQueue.main.async { [weak self] in // pass the camera parameters for projection calculation self?.visionARViewController.present(camera: camera) } } func visionARManager(_ visionARManager: VisionARManager, didUpdateARLane lane: ARLane?) { DispatchQueue.main.async { [weak self] in // display AR lane representing navigation route self?.visionARViewController.present(lane: lane) } } } extension ARNavigationViewController: VideoSourceObserver { func videoSource(_ videoSource: VideoSource, didOutput videoSample: VideoSample) { DispatchQueue.main.async { [weak self] in // display received sample buffer by passing it to ar view controller self?.visionARViewController.present(sampleBuffer: videoSample.buffer) } } } Copy Was this page helpful? Yes No",,Basic blue-line AR navigation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,World-scale AR manual alignment,An overview of the world-scale AR manual alignment example provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/world-scale-manual-align-ar/,example,No code,,"World-scale AR manual alignment The world-scale AR manual alignment example allows for overlaying 3D maps and location data onto the AR camera feed using Unity’s AR interface and location services. This article outlines the setup and purpose of each major part of this example. Depending on your device and GPS signal, features in the AR scene may not be aligned properly with the features in the real world. This example scene is a good starting point for aligning your AR scene when the GPS signal is not strong enough. Concepts AR Session: In AR apps, the scene’s main camera is positioned automatically to match the real-world device’s position, but only from the moment the app is initialized. Map Alignment: To make an AR session location aware, the WorldAlignmentKitManual prefab aligns a 3D map around the AR camera. Customization: Once the Map is aligned, you have access to all Mapbox’s data and customization to build world-scale experiences. Getting started To open the example, navigate to MapboxAR > Examples > Scenes > WorldScaleAR-ManualAlignment and double-click to open. You’ll see a split screen in the Game view. The bottom half of the screen is for aligning the position with the real world. Some layers that aren’t included by default in a Unity project are needed to run this scene. Select WorldAlignmentKitManual in the Hierarchy view. To add new layers, click Layer and select Add Layer. Next, add: ARGameObject Map Path Both The WorldAlignmentKitManual contains: ARRoot: The UnityInterface Prefab for building cross-platform AR apps. MapCamera: A top-down view of the map, used to view GPS traces, AR position, and the current map alignment. ArAlignedMap: The map, aligned to AR Root using your devices location services. Renders blue debug color buildings by default. DebugCanvas: This contains a detailed debug log of location services and AR activity. To view it, press the LOG icon in play mode and on devices. This is included as a Unity UI element to make debugging easier on-location. It also contains a pointer button to relocalize the map. LocationProvider: Provides GPS data to the map, and spoofs data for testing in the editor. Running in the editor Once you set up your project layers, play the scene. In the Editor, the map is positioned based on EditorLocationProvider settings, a component attached to WorldAlignmentKitManual > LocationProvider > Editor in the hierarchy. In the Scene view, you'll see the map and the blue debug buildings. In the Game view, you'll see both the blue debug buildings, and a top down view of the map which shows the position indicated by a red pointer. Editing the Scene Make the scene more interesting by styling the buildings. With the following settings, you can transform the buildings from the debug blue color to one of the styles included with the Maps SDK for Unity. On the AbstractMap script, select the buildings Vector Layer Visualizer in the FEATURES section. Set the Texturing Style to Custom. Set the Texturing Type to Atlas With Color Palette. Select MapboxStylesRoofsPerRenderer for the Top Material. Select MapboxStylesFacadesPerRenderer for the Side Material. Select DefaultAtlasInfo for Atlas Info. Select Warm for the Color Palette. Before building to your device, see the screenshot below to confirm the settings and run the scene in the Editor. For detailed information on how styling works read the styling documentation. Running on a device First, check that your device supports ARKit or ARCore. Build settings differ for iOS and Android. Check your Player Settings before you build: iOS: ARKit supports the METAL graphics API only. Select Metal or Auto Graphics API. iOS: Be sure to include a Camera Usage Description and Location Usage Description Android: Use OPENGL ES or Auto Graphics API. Once the AR plane is detected, the map will be visualized with the styles that you set in the previous step. Then, you can manually align your map to your actual location. Use the lower part of the screen to specify your exact position. Use the upper part of screen to align the AR buildings with real buildings. To reset your location, press the pointer button on the right. Press the LOG icon on the left for debugging information. Was this page helpful? Yes No",,World-scale AR manual alignment,Getting started,Running in the editor,Editing the Scene,Running on a device,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Fit camera in bounding box,Position the camera so that all the given markers are in view.,https://docs.mapbox.com/android/maps/examples/fit-camera-in-bounding-box/,example,Java,,"Fit camera in bounding box Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.camera.BoundingBoxCameraActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.431"" mapbox:mapbox_cameraTargetLng=""-120.981"" mapbox:mapbox_cameraZoom=""4""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.camera; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Fit a map to a bounding box */ public class BoundingBoxCameraActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private MapView mapView; private MapboxMap mapboxMap; private static final LatLng locationOne = new LatLng(36.532128, -93.489121); private static final LatLng locationTwo = new LatLng(25.837058, -106.646234); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_camera_bounding_box); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { BoundingBoxCameraActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { addMarkerIconsToMap(style); // Toast instructing user to tap on the map to start animation and set bounds Toast.makeText( BoundingBoxCameraActivity.this, getString(R.string.tap_on_map_instruction), Toast.LENGTH_LONG ).show(); mapboxMap.addOnMapClickListener(BoundingBoxCameraActivity.this); } }); } private void addMarkerIconsToMap(@NonNull Style loadedMapStyle) { loadedMapStyle.addImage(""icon-id"", BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.red_marker))); loadedMapStyle.addSource(new GeoJsonSource(""source-id"", FeatureCollection.fromFeatures(new Feature[] { Feature.fromGeometry(Point.fromLngLat(locationOne.getLongitude(), locationOne.getLatitude())), Feature.fromGeometry(Point.fromLngLat(locationTwo.getLongitude(), locationTwo.getLatitude())), }))); loadedMapStyle.addLayer(new SymbolLayer(""layer-id"", ""source-id"").withProperties( iconImage(""icon-id""), iconOffset(new Float[]{0f,-8f}) )); } @Override public boolean onMapClick(@NonNull LatLng point) { LatLngBounds latLngBounds = new LatLngBounds.Builder() .include(locationOne) // Northeast .include(locationTwo) // Southwest .build(); mapboxMap.easeCamera(CameraUpdateFactory.newLatLngBounds(latLngBounds, 50), 5000); return true; } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,Fit camera in bounding box,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Show changes over time with Mapbox GL JS,Build a map application with Mapbox GL JS to visualize changes in data over time.,https://docs.mapbox.com/help/tutorials/show-changes-over-time/,tutorial,JavaScript,,"advanced JavaScript Show changes over time with Mapbox GL JS Prerequisite Familiarity with front-end development concepts. Some advanced JavaScript required. Property functions vs. property expressions This tutorial uses property expressions. This new feature was introduced in Mapbox GL JS v0.41.0. Property expressions can help you achieve similar effects as property functions, but with much more flexibility and functionality. While property functions are available, they will ultimately be deprecated and replaced by property expressions. Read more about property expressions in the Mapbox Style Specification and in the Get started with Mapbox GL JS expressions guide. This tutorial will show how to build a map that shows data change over time using Mapbox GL JS. The source data you'll be working with in this guide is from NYC OpenData and contains more than 15,000 motor vehicle collisions in New York City that occurred in January 2016. If you're new to Mapbox GL JS you might want to read Mapbox GL JS fundamentals first. Get started There are a few resources you'll need before getting started: An access token from your Mapbox account. The access token is used to associate a map with your account and you can find it on your Account page. Data. This GeoJSON file contains 15,273 geocoded motor vehicle collision incidents from January 2016, pulled from NYC OpenData. Download data A text editor for writing HTML, CSS, and JavaScript. Add a map Before you start adding your NYC collision data, you need to create a map to put it on. Start by creating an HTML file and then initialize the map object on the page. This guide will require several files, so we recommend creating a project folder on your computer to keep them together. Create an HTML file In your project folder, create an index.html file. Set up the document by adding Mapbox GL JS and CSS to your head. <meta charset='utf-8' /> <title>NYC motor vehicle collisions</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> Next, create a map container and a container for your legend and data interactivity elements in body. <div id='map'></div> <div id='console'> <h1>Motor vehicle collisions</h1> <p>Data: <a href='https://data.cityofnewyork.us/Public-Safety/NYPD-Motor-Vehicle-Collisions/h9gi-nx95'>Motor vehicle collision injuries and deaths</a> in NYC, Jan 2016</p> </div> Apply some CSS to create the page layout. Create a pair of style tags at the end of your head, then add: body { margin: 0; padding: 0; font-family: 'Helvetica Neue', Helvetica, Arial, Sans-serif; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } h1 { font-size: 20px; line-height: 30px; } h2 { font-size: 14px; line-height: 20px; margin-bottom: 10px; } a { text-decoration: none; color: #2dc4b2; } #console { position: absolute; width: 240px; margin: 10px; padding: 10px 20px; background-color: white; } Initialize the map Once you have the structure done, you can initialize the map with Mapbox GL JS. Insert a pair of script tags at the end of body — you will write all the following code (JavaScript) between these tags. Start by creating a new map object using new mapboxgl.Map() and store it in a variable called map. mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // container element id style: 'mapbox://styles/mapbox/light-v 10 ', center: [-74.0059, 40.7128], // initial map center in [lon, lat] zoom: 12 } ); If you load the page, it should look like this: Load your data Once you get the page structure and map done and onto the page, it's time to load in your data, get it styled, and add a legend. Fortunately, Mapbox GL JS has some handy functions that can help! First, make sure that the collisions1601.geojson file you downloaded is in your project folder. Add a layer To add data to your map using Mapbox GL JS, you will need to add a layer that includes a source. In this example, you will use the GeoJSON file you downloaded above as your source. Note Be sure to save and store the GeoJSON file in the same domain as your project. You will also need to run this application from a local web server, otherwise you will receive a Cross-origin Resource Sharing (CORS) error. Python's SimpleHTTPServer is included on many computers and is a good choice if this is your first time running a local server. In this example, you'll use expressions to set the style of the points based on a property in the data. This kind of data-driven styling allows you to add an extra dimension to you map visualization, helping convey a particular insight or message to your readers. In this case, you can make the map more informative by applying styles based on the Casualty property in the data, which is the total number of people injured or killed in the collision. The code below changes both the size and color of the points based on the Casualty field. Both of the expressions used below are 'interpolate' expressions. This kind of expression interpolates continuously between pairs of input and output values. In this instance, 'linear' interpolation can be used for circle-radius and circle-color to make sure that interpolation occurs smoothly and linearly between the pairs of stops. Also, note the map.on('load', function() { } ) code below — this tells your browser to wait until the map is finished loading before trying to add new things to it. Any code that adds layers should be inside of this callback function. map.on('load', function() { map.addLayer( { id: 'collisions', type: 'circle', source: { type: 'geojson', data: './collisions1601.geojson' // replace this with the url of your own geojson } , paint: { 'circle-radius': [ 'interpolate', ['linear'], ['number', ['get', 'Casualty']], 0, 4, 5, 24 ], 'circle-color': [ 'interpolate', ['linear'], ['number', ['get', 'Casualty']], 0, '#2DC4B2', 1, '#3BB3C3', 2, '#669EC4', 3, '#8B88B6', 4, '#A2719B', 5, '#AA5E79' ], 'circle-opacity': 0.8 } } ); } ); Create a legend To describe the data you added, create a legend to communicate what each color and size means. Begin by creating a new div with class session inside the console div you added earlier. <div class='session'> <h2>Casualty</h2> <div class='row colors'> </div> <div class='row labels'> <div class='label'>0</div> <div class='label'>1</div> <div class='label'>2</div> <div class='label'>3</div> <div class='label'>4</div> <div class='label'>5+</div> </div> </div> Next, apply some CSS to define how the new session class should be styled. Create a color gradient using the same colors as the stops of the circle-color values you defined in your layer. This should go inside the style tags you added earlier. .session { margin-bottom: 20px; } .row { height: 12px; width: 100%; } .colors { background: linear-gradient(to right, #2dc4b2, #3bb3c3, #669ec4, #8b88b6, #a2719b, #aa5e79); margin-bottom: 5px; } .label { width: 15%; display: inline-block; text-align: center; } After adding the CSS and refreshing your browser, you should see the following: Add a time slider With the data symbolized by casualty, your map is already telling a compelling story. To make it more compelling, you can add a time slider to allow your readers to filter the collision data by time of day. Add a map filter Besides providing the value of a paint or layout property, you can use expressions as filters. By adding a == expression as a filter with the structure ""filter"": ['==', ['type',['get', 'key']],'value'], you can single out all features where the 'key' is equal to the 'value' of the specified type. Add the following code to the end of the addLayer() options you wrote earlier: filter: ['==', ['number', ['get', 'Hour']], 12] Refresh the map. You should see a lot fewer collisions! Create a slider bar You don't only want to show collisions that happened at noon, though — you want the user to be able to control what hour of the day the map shows. To do this, you can add a time slider in the console div by adding a new session div after legend. There are 24 hours in a day labeled by the integers 0-23 in the dataset, so you'll set the input's min and max attributes to 0 and 23, respectively, and the initial value to 12, or 12PM. Add the following code below the other session div you added in a previous step: <div class='session' id='sliderbar'> <h2>Hour: <label id='active-hour'>12PM</label></h2> <input id='slider' class='row' type='range' min='0' max='23' step='1' value='12' /> </div> Add interactivity Now, add some code to connect the slider with the map. Begin by adding an event listener to the slider called onInput, which listens for any change in the slider's value. Next, use Mapbox GL JS's setFilter(layer, filter) method to change your layer's filter property whenever the input event fires. Finally, add a bit of math to add PM or AM to the time displayed next to your slider. Add this right after addLayer() in your script: document.getElementById('slider').addEventListener('input', function(e) { var hour = parseInt(e.target.value); // update the map map.setFilter('collisions', ['==', ['number', ['get', 'Hour']], hour]); // converting 0-23 hour to AMPM format var ampm = hour >= 12 ? 'PM' : 'AM'; var hour12 = hour % 12 ? hour % 12 : 12; // update text in the UI document.getElementById('active-hour').innerText = hour12 + ampm; } ); Here's what it will look like: Filter by day of the week Another useful metric for gathering insights about collisions in NYC is the day of the week when accidents occur. With the following code, you can add radio buttons that filter on days of the week. Create a radio button group First, add the following radio button group in your HTML inside the console div. <div class='session'> <h2>Day of the week</h2> <div class='row' id='filters'> <input id='all' type='radio' name='toggle' value='all' checked='checked'> <label for='all'>All</label> <input id='weekday' type='radio' name='toggle' value='weekday'> <label for='weekday'>Weekday</label> <input id='weekend' type='radio' name='toggle' value='weekend'> <label for='weekend'>Weekend</label> </div> </div> Add interactivity Create a new change event listener in your code, like you did for the slider, then place it after the slider event. To show collisions on all days, use a != expression that filters for the 'placeholder' value. This filter is added so that filterDay never evaluates to null. It will become clearer why this is necessary by the end of the tutorial. To filter for weekday and weekend values, use a match expression. Match expressions allow you to specify input and output values. The pattern that the expression below follows is: ['match', ['get', property], inputValue, outputValue if match, outputValue if not a match] Add the following code after the slider event you added in the previous step: document.getElementById('filters').addEventListener('change', function(e) { var day = e.target.value; // update the map filter if (day === 'all') { filterDay = ['!=', ['string', ['get', 'Day']], 'placeholder']; } else if (day === 'weekday') { filterDay = ['match', ['get', 'Day'], ['Sat', 'Sun'], false, true]; } else if (day === 'weekend') { filterDay = ['match', ['get', 'Day'], ['Sat', 'Sun'], true, false]; } else { console.log('error'); } map.setFilter('collisions', ['all', filterDay]); } ); Refresh your page and try the week of the day buttons. Combine the filters As you may have discovered, toggling between weekday and weekend will automatically override the hour filter. You can fix this by using a combining filter (documentation). Combining filters To combine multiple filters, you will append them to a new 'all' expression. Using this 'all' expression makes sure that both filters result in true. Add two variables at the beginning of the map load event handler to store the 'hour' and 'day of the week' filters and apply them independently. This way when you want to update one part of the filter, you can update that variable, then apply setFilter(my layer, ['all', filterHour, filterDay]) to reset the filter. First, add two variables at the beginning of the map load event handler you created earlier. This is where the placeholder filter becomes necessary since you cannot have null in a combining filter. var filterHour = ['==', ['number', ['get', 'Hour']], 12]; var filterDay = ['!=', ['string', ['get', 'Day']], 'placeholder']; Then, in addLayer, replace the value of filter with: ['all', filterHour, filterDay]. Next, in the slider onInput event, replace map.setFilter('collisions', ['==', ['number', ['get', 'Hour']], hour]); with this code: filterHour = ['==', ['number', ['get', 'Hour']], hour]; map.setFilter('collisions', ['all', filterHour, filterDay]); Lastly, polish the week of the day onChange event by replacing it with this code: document.getElementById('filters').addEventListener('change', function(e) { var day = e.target.value; if (day === 'all') { // `null` would not work for combining filters filterDay = ['!=', ['string', ['get', 'Day']], 'placeholder']; } /* the rest of the if statement */ map.setFilter('collisions', ['all', filterHour, filterDay]); } ); Finished product You created a map showing NYC collision data from January 2016, complete with data-driven styles, a legend, a time slider, and a day of the week filter. Next steps With this guide, you have the tools to create your own interactive time series data visualizations with Mapbox GL JS. Explore more Mapbox GL JS resources on our Help page and see the full Mapbox GL JS documentation and examples for more inspiration and guidance. Was this page helpful? Yes No",,Show changes over time with Mapbox GL JS,Add a map,Create an HTML file,Initialize the map,Load your data,Add a layer,Create a legend,Add a time slider,Add a map filter,Create a slider bar,Add interactivity,Filter by day of the week,Create a radio button group,Combine the filters,Combining filters,Finished product,Next steps,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,annotation,An annotation is a defined location on a map in the Mapbox Maps SDK for iOS.,https://docs.mapbox.com/help/glossary/annotation/,glossary,,,"annotation Within the Mapbox Maps SDK for iOS, an annotation is a defined location on a map, represented by a custom UIView or UIImage. You can use annotations to represent point data, such as restaurants in a city, bus stops along a route, or earthquake locations. There are multiple ways you can add an annotation to your maps. For more information about adding annotations, see the Adding points to a map guide in the Mapbox Maps SDK for iOS documentation. Was this page helpful? Yes No",,annotation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Variable label placement,Use text-variable-anchor to allow high priority labels to shift position to stay on the map.,https://docs.mapbox.com/mapbox-gl-js/example/variable-label-placement/,example,JavaScript,,Variable label placement Use text-variable-anchor to allow high priority labels to shift position to stay on the map. Was this example helpful? Yes No,,Variable label placement,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Location-based game,An overview of the location-based game example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/location-based-game/,example,No code,,"Location-based game The location-based game example shows how to position and orient a Player GameObject on a map using a GPS device or using the editor directly. The scene set a pin on a 2D map that includes building outline data and other procedurally generated geo features from Mapbox’s data that you can toggle and style as needed. This example uses a custom map style from Mapbox Studio, but it can be swapped with any other map style. Add a Player The Player GameObject is a 3D model representing the player’s location on the map. Player moves and rotates along with LocationProvider, a GameObject that captures real or simulated location. Any GameObject can represent the player in this scene. To use a different 3D model: Remove the original Player object, add the new model into the scene, and position it at 0,0,0. Add the Immediate Position With Location Provider and Rotate With Location Provider components to this GameObject. Attach the Map object to the Map field in Immediate Position With Location Provider. The custom Player will show up on the map and move accordingly. Understand the LocationProvider script The LocationProvider GameObject holds a collection of scripts to determine a player’s location, either in the real world (with GPS, on a device) or simulated in Unity (with manually added coordinates). Without these scripts, the location would be hard-coded in the AbstractMap script. There are several different Location Provider scripts: DeviceLocationProvider: Uses GPS data on a device. The Player GameObject follows the location on the map reported by the GPS device update. EditorLocationProvider: Similar to DeviceLocationProvider, but for testing inside Unity. LocationArrayEditorLocationProvider: Allows the Player GameObject to be moved across a set of points entered as latitude, longitude coordinates in an array. TransformLocationProvider: Makes the Player GameObject follow the position and rotation of another GameObject. DeviceLocationProviderAndroidNative: Uses GPS data optimized for Android devices. Benefits and limitations With the Location Based Game example, you can create a zoomable, pannable map that a Player can move around. Use it to look at real world map data from a top-down view, like a paper map. But, it is not ideal for building 3D scenes with a more flexible camera view. This is like the Zoomable Map example, which acts similarly to Location Based Game, but does not have a Player GameObject. Was this page helpful? Yes No",,Location-based game,Understand the LocationProvider script,Benefits and limitations,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Introduction,"Introduction to Mapbox GL JS, a JavaScript library that uses WebGL to render interactive maps from vector tiles and Mapbox styles.",https://docs.mapbox.com/mapbox-gl-js/overview/,API,,,"Mapbox GL JS Current version: v 1.2.1 View changelog Custom map styles Fast vector maps Compatible with other Mapbox tools Install Contribute on GitHub Mapbox GL JS is a JavaScript library that uses WebGL to render interactive maps from vector tiles and Mapbox styles. It is part of the Mapbox GL ecosystem, which includes Mapbox Mobile, a compatible renderer written in C++ with bindings for desktop and mobile platforms. Quickstart To get started, you need an access token and a style URL. You can choose from one of our professionally designed styles or create your own using Mapbox Studio. Mapbox CDN Module bundler Include the JavaScript and CSS files in the <head> of your HTML file. <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl.css' rel='stylesheet' /> Copy Include the following code in the <body> of your HTML file. <div id='map' style='width: 400px; height: 300px;'></div> <script> mapboxgl.accessToken = 'undefined'; var map = new mapboxgl.Map({ container: 'map', style: 'mapbox://styles/mapbox/streets-v9' }); </script> Copy CSP Directives As a mitigation for Cross-Site Scripting and other types of web security vulnerabilities, you may use a Content Security Policy (CSP) to specify security policies for your website. If you do, Mapbox GL JS requires the following CSP directives: worker-src blob: ; child-src blob: ; img-src data: blob: ; Requesting styles from Mapbox or other services will require additional directives. For Mapbox, you can use this connect-src directive: connect-src https://*.tiles.mapbox.com https://api.mapbox.com https://events.mapbox.com For strict CSP environments without worker-src blob: ; child-src blob: enabled, there's a separate Mapbox GL JS bundle (mapbox-gl-csp.js and mapbox-gl-csp-worker.js) which requires setting the path to the worker manually: <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl-csp.js'></script> <script> mapboxgl.workerUrl = ""https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl-csp-worker.js""; ... </script> Copy Mapbox CSS The CSS referenced in the Quickstart is used to style DOM elements created by Mapbox code. Without the CSS, elements like Popups and Markers won't work. Including it with a <link> in the head of the document via the Mapbox CDN is the simplest and easiest way to provide the CSS, but it is also bundled in the Mapbox module, meaning that if you have a bundler that can handle CSS, you can import the CSS from mapbox-gl/dist/mapbox-gl.css. Note too that if the CSS isn't available by the first render, as soon as the CSS is provided, the DOM elements that depend on this CSS should recover. Was this page helpful? Yes No",,Mapbox GL JS,CSP Directives,Mapbox CSS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Traffic Data,Data format,Learn how data from Mapbox Traffic Data is formatted.,https://docs.mapbox.com/traffic-data/overview/data/,guide,,,"Data format Mapbox Traffic Data consists of two different types of files: Typical: The Typical traffic data file contains speeds that show normal traffic conditions throughout the week. The Typical traffic data set is an estimate for traffic speeds at a specific location, at a specific time, based on historical observations. This data shows traffic expectations during a normal week. Live: The Live traffic data file contains speeds that have been directly observed in the 15 minutes prior to data generation. The Live traffic data set is most useful in the event of unexpected traffic — for instance, during severe weather events or accidents. Speeds are associated with either pairs of adjacent OpenStreetMap node IDs or OpenLR strings, depending on customer preference. Each pair of OpenStreetMap IDs marks the start and end of the road segment. OpenLR strings are base64-encoded binary representations of the OpenLR location reference for the road segment, which usually only includes the location reference points at the start and end of the way. Intermediate location reference points are included for roads longer than 15km. All speeds are given in kilometers per hour. Quadkeys Data is stored in files specific to a Zoom 7 quadkey, as described in the OpenStreetMap zoom levels specification. Each Zoom 7 tile is large enough to capture a major metropolitan area, small US state, or small European country. You can view tiles using the What the Tile interactive tool. Data updates Mapbox Traffic Data files are updated on a regular cadence: Typical traffic is updated weekly. Each week, you should overwrite the results of the previous week with the new data. Live traffic is updated every five minutes, based on data that is less than 15 minutes old. Typical data file Typical predictions are stored for every five-minute period of a typical week. For every road segment, there will be 2,016 typical speed predictions (7 days × 24 hours × 12 five-minute periods). Typical file S3 naming schema Typical speed data is stored as gzipped CSV files, divided into separate files by Z7 quadkey and time zone using the following naming schema: s3://<bucket_name>/typical-speeds/<Z7_quadkey>/<time_zone>/<Z7_quadkey>-<time_zone>.csv.gz For example, if your company username was ABC, and you were using Typical traffic data for the New York area, the filename would be: s3://mapbox-traffic-data-abc-shared/typical-speeds/0320101/America-New_York/0320101-America-New_York.csv.gz The time_zone for each file is defined by the IANA time zone database. Note that the slashes (/) used by IANA are replaced with dashes (-) in Traffic Data filenames. In the example filename above, the IANA timezone America/New_York becomes America-New_York. Typical file contents In their uncompressed form, each CSV file contains one line per road segment:segment_identifier,speed_1,speed_2,…,speed_2016 segment_identifier: Either a comma-separated pair of OpenStreetMap node IDs or an OpenLR string. speed_1,speed_2,…,speed_2016: 2,016 comma-separated integer speeds in kilometers per hour, starting at 0:00 Sunday in the file’s time zone. Each value shows the usual speed during a five-minute period of a typical week within that road segment. The following example uses OpenStreetMap node IDs as segment identifiers: osm_start_node osm_end_node speed_1 speed_2 ... speed_2016 113054533 113096757 54 54 ... 57 170190194 170190194 93 93 ... 98 172637811 172637810 70 64 ... 66 Alternatively, the files with OpenLR segment identifiers will have a single column for the OpenLR string instead of the osm_start_node and osm_end_node columns. The headers in this example are for demonstration purposes. The Typical files that you download will not have headers. Find a specific time in the Typical file To find a speed for a specific five-minute increment, you must count the segment identifier columns and the number of five-minute increments between Sunday at 00:00 and the time for which you are looking. For example, if you were looking for the typical speed for a segment between 9:00 and 9:05 AM on Monday in a file with OpenStreetMap nodes, you would add the two columns for the nodes and the 396 five-minute intervals between Sunday at 0:00 AM and Monday at 9:00 AM, leading you to took at the 399th column for this data. Data considerations for the Typical file Not all segments in a tile have an estimated speed. Segments without enough data for an accurate prediction are omitted. Segments that overlap a time zone boundary or Z7 tile boundary may appear in two files. Speed estimates correspond only to the traffic that matches the ordering of the segment identifier. Node pairs that carry bidirectional traffic will have up to two different rows in each file, each row corresponding to the ordering of the node pair. For example, if you have a two-way road with a segment between nodes ""123"" and ""456"", the estimates may be different when traveling from ""123"" to ""456"" than they are when traveling from ""456"" to ""123"". Typical file size The compressed file size varies depending on the density of the area covered by the tile. A dense urban tile can be approximately 2 GB. Most tiles are much smaller than this. Live data file Live traffic speeds are generated in real time based on speeds that have been directly observed in the 15 minutes prior to data generation. The Live traffic data file is updated every five minutes. Since Live data is not available for all roads, we recommend falling back to Typical speeds when Live data is not available. Offline routing, planning, and simulation should only use Typical speeds. Live file S3 naming schema Live traffic data files are delivered to a shared S3 as one file per Z7 quadkey. s3://<bucket_name>/live-speeds/latest/<Z7_quadkey>.csv Live file contents We deliver our most recent Live traffic estimates for a Z7 quadkey as an uncompressed CSV file. The Live CSV file contains one line per road segment, each with two or three columns. Each line contains:segment_identifier,speed segment_identifier: Either a comma-separated pair of OpenStreetMap node IDs or an OpenLR string. speed: The estimated road segment speed, in kilometers per hour. The following example uses OpenStreetMap node IDs as segment identifiers: osm_start_node osm_end_node speed 113054533 113096757 54 170190194 4525170049 93 172637810 172637809 70 Alternatively, the files with OpenLR segment identifiers will have a single column for the OpenLR string instead of the osm_start_node and osm_end_node columns. The headers in this example are for demonstration purposes. The Live file that you download will not have headers. Data considerations for the Live file The Live file only provides speeds for segments for which the volume and quality of data allow a high confidence estimate. Segments that overlap a time zone boundary or Z7 tile boundary may appear in two files. Speed estimates correspond only to the traffic that matches the ordering of the segment identifier. Node pairs that carry bidirectional traffic will have up to two different rows in each file, each row corresponding to the ordering of the node pair. For example, if you have a two-way road with a segment between nodes ""123"" and ""456"", the estimates may be different when traveling from ""123"" to ""456"" than they are when traveling from ""456"" to ""123"". Live file size The CSV file size for Live data is 5 MB per tile on average, which covers only roads with live traffic estimates. The file size will vary based on how populous a tile is, as well as the time of day. For example, the file for New York City's tile during rush hour could be 12 to 15 MB. An empty file indicates that Mapbox telemetry volumes are too low to estimate a speed for any road segment in the region at the current time. Was this page helpful? Yes No",,Data format,Data updates,Typical data file,Typical file S3 naming schema,Typical file contents,Find a specific time in the Typical file,Data considerations for the Typical file,Typical file size,Live data file,Live file S3 naming schema,Live file contents,Data considerations for the Live file,Live file size,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,API,Accounts service,Overview of the Mapbox Accounts service APIs.,https://docs.mapbox.com/api/accounts/,API,,,"Accounts service The Mapbox Accounts service is composed of the following APIs: Tokens An access token provides access to Mapbox resources on behalf of a user. The Mapbox Tokens API provides you with a programmatic way to create, update, delete, and retrieve tokens, as well as list a user's tokens and token scopes. All user accounts have a default public token. Additional tokens can be created to grant additional, or more limited, privileges. The actions allowed by a token are based on scopes. A scope is a string that often is a resource type and action separated by a colon. For example, the styles:read scope allows read access to styles. Tokens will have access to different scopes depending on their account level and other features of their account. To create additional tokens using the Mapbox Tokens API, you need to have an authorizing token that has the tokens:write scope, as well as all the scopes you want to add to the newly created token. To create the authorization token, visit your Account Dashboard, and click Create a token. Token format Mapbox uses JSON Web Tokens (JWT) as the token format. Each token is a string delimited by dots into three parts: header, payload, and signature. Header. A literal value of either pk (public token), sk (secret token), or tk (temporary token). Payload. A base64-encoded JSON object containing the identity and authorities of the token. pk and sk tokens contain a reference to metadata that holds the rights granted for the token. tk tokens contain the contents of the metadata directly in the payload. Signature. Signed by Mapbox and used to verify the token has not been tampered with. Token metadata object Every token has a metadata object that contains information about the capabilities of the token. The token metadata object contains the following properties: Property Description id The token's unique identifier. usage The type of token. One of: pk (public), sk (secret), or tk (temporary). client The client for the token. This is always api. default Indicates whether the token is a default token. scopes An array that contains the scopes granted to the token. note A human-readable description of the token. created The date and time the token was created. modified The date and time the token was last modified. allowedUrls An array that contains the URLs that the token is restricted to. token The token itself. Example token metadata object { ""id"": ""cijucimbe000brbkt48d0dhcx"", ""usage"": ""pk"", ""client"": ""api"", ""default"": false, ""note"": ""My website"", ""scopes"": [""styles:read"", ""fonts:read""], ""created"": ""2018-01-25T19:07:07.621Z"", ""modified"": ""2018-01-26T00:39:57.941Z"", ""allowedUrls"": [""https://docs.mapbox.com""], ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" } Support for allowed URLs The allowed URLs feature is compatible with many Mapbox tools, with some limitations. For web applications using Mapbox GL JS, it requires version 0.53.1+. It is not compatible with Mapbox native SDKs. Adding a URL restriction to a token makes it unusable by a mobile application. A separate token should be maintained for mobile applications. See the Adding URL restrictions to access tokens guide to learn more about this feature for web requests. List tokens get /tokens/v2/{username} tokens:read token scope List all the tokens that belong to an account. This endpoint supports pagination. Required parameter Description username The username of the account for which to list tokens. You can further refine the results from this endpoint with the following optional parameters: Optional parameters Description default If this parameter is set to true, the response will only include the account's default token. If this parameter is set to false, the response will include all of the account's tokens except for the default token. limit The maximum number of tokens to return. sortby Sort the tokens in the response by their created or modified timestamps. start The token after which to start the listing. The token key is found in the Link header of a response. See the pagination section for details. usage Use this parameter to return either only public tokens (pk) or secret tokens (sk). By default, this endpoint returns both types of token. Example request: List tokens $ curl ""https://api.mapbox.com/tokens/ v2 / {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:read scope. "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: List tokens The response body will contain all the tokens that belong to the username specified in the query, each containing the properties described in the token metadata object section. If a listed token's usage property is sk, the token property will not be included in the response. Example response: List tokens [ { ""client"": ""api"", ""note"": ""a public token"", ""usage"": ""pk"", ""id"": ""cijucimbe000brbkt48d0dhcx"", ""default"": false, ""scopes"": [""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com"", ""https://account.mapbox.com""], ""created"": ""2016-01-25T19:07:07.621Z"", ""modified"":""2016-01-26T00:39:57.941Z"", ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" }, { ""client"": ""api"", ""note"": ""a secret token"", ""usage"": ""sk"", ""id"": ""juorumy001cutm5r4fl2y1b"", ""default"": false, ""scopes"": [""styles:list""], ""created"": ""2016-01-26T00:50:13.701Z"", ""modified"": ""2016-01-26T00:50:13.701Z"" } ] Create a token post /tokens/v2/{username} tokens:write token scope Creates a new token. Every requested scope must be present in the access token used to allow the request. It is not possible to create a token with access to more scopes than the token that created it. Note that while it is possible to create a token with no scopes, you will not be able to update this token later to include any scopes. Required parameter Description username The username of the account for which to list scopes. The request body must be a JSON object that contains the following properties: Parameter Description note Create a description for the token. scopes Specify the scopes that the new token will have. The authorizing token needs to have the same scopes as, or more scopes than, the new token you are creating. allowedUrls URLs that this token is allowed to work with. Available token scopes The scopes included in the token decide whether the token is public or secret. A public token may only contains public scopes, while a secret token can contain both public and secret scopes. Public tokens: styles:tiles, styles:read, fonts:read, datasets:read Secret tokens: scopes:list, map:read, map:write, user:read, user:write, uploads:read, uploads:list, uploads:write, styles:write, styles:list, tokens:read, tokens:write, datasets:list, datasets:write, tilesets:list, tilesets:read, tilesets:write, analytics:read (if user has a Commercial or Enterprise account) Example request: Create a token # Create a public token with ""styles:read"" and ""fonts:read"" scopes and a ""https://docs.mapbox.com"" allowed URL $ curl -H ""Content-Type: application/json"" -X POST -d '{""note"": ""My top secret project"",""scopes"": [""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com""]}' 'https://api.mapbox.com/tokens/ v2 / {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. ' Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Create a token The response body for a successful request will be a new public or secret token. Example response: Create a token { ""client"": ""api"", ""note"": ""My top secret project"", ""usage"": ""pk"", ""id"": ""cijucimbe000brbkt48d0dhcx"", ""default"": false, ""scopes"": [""styles:read"", ""fonts:read""], ""created"": ""2016-01-25T19:07:07.621Z"", ""modified"":""2016-01-25T19:07:07.621Z"", ""allowedUrls"": [""https://docs.mapbox.com""], ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" } Create a temporary token post /tokens/v2/{username} tokens:write token scope Creates a new temporary token that automatically expires at a set time. You can create a temporary token using a secret token that has the tokens:write scope. You can also create a temporary token using another temporary token as long as the authorizing token has tokens:write scope. Temporary tokens can't be updated or revoked after they are created. Required parameter Description username The username of the account for which to create a temporary token. The request body must be a JSON object that contains the following properties: Request body properties Description expires Specify when the temporary token will expire. Cannot be a time in the past or more than one hour in the future. If the authorizing token is temporary, the expires time for the new temporary token cannot be later than that of the authorizing temporary token. scopes Specify the scopes that the new temporary token will have. The authorizing token needs to have the same scopes as, or more scopes than, the new temporary token you are creating. Example request: Create a temporary token # Request a temporary token with ""styles:read"" and ""font:read"" scopes $ curl -H ""Content-Type: application/json"" -X POST -d '{""expires"": "" 2019-08-21T01:28:50.447Z "",""scopes"": [""styles:read"", ""fonts:read""]}' 'https://api.mapbox.com/tokens/ v2 / {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. ' Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Example request body: Create a temporary token { ""expires"": ""2016-09-15T19:27:53.000Z"", ""scopes"": [""styles:read"", ""fonts:read""] } Response: Create a temporary token The response body for a successful request will be a new temporary token. Unlike public and secret tokens, a temporary token contains its metadata inside the payload of the token instead of referencing a metadata object that persists on the server. Example response: Create a temporary token { ""token"": ""tk.eyJ1IjoibWFwYm94IiwiZXhwIjoxNDczOTY3NjczLCJpYXQiOjE0NzM5Njc2NDMsInNjb3BlcyI6WyJzdHlsZXM6cmVhZCIsImZvbnRzOnJlYWQiXSwiY2xpZW50IjoiYXBpIn0.ZepsWvpjTMlpePE4IQBs0g"" } Update a token patch /tokens/v2/{username}/{token_id} tokens:write token scope Update the note, the scopes, the allowedUrls, or all three in a token's metadata. When updating scopes for an existing token, the token sent along with the request must also have the scopes you're requesting. It is not possible to create a token with access to more scopes than the token that updated it. Required parameter Description token_id The ID of the token that you want to update. The request body must be a JSON object that contains one or both of the following properties: Request body properties Description note Update the token's description. scopes Update the token's scopes. The authorizing token needs to have the same scopes as, or more scopes than, the token you are updating. A public token may only be updated to include other public scopes. A secret token may be updated to contain public and secret scopes. allowedUrls Update the restricted token's allowed URLs. Example request: Update a token # Update a token to have ""fonts:read"" scope and a ""https://docs.mapbox.com"" allowed URL $ curl -H 'Content-Type: application/json' -X PATCH -d '{""scopes"": [""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com""]}' 'https://api.mapbox.com/tokens/ v2 / {username} /{token_id}?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. ' Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Update a token The response body for a successful request will be a new temporary token. Example response: Update a token { ""client"": ""api"", ""note"": ""My top secret project"", ""usage"": ""pk"", ""id"": ""cijucimbe000brbkt48d0dhcx"", ""default"": false, ""scopes"": [""styles:tiles"", ""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com""], ""created"": ""2016-01-25T19:07:07.621Z"", ""modified"":""2016-01-25T19:07:07.621Z"", ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" } Delete a token delete /tokens/v2/{username}/{token_id} tokens:write token scope Delete an access token. This will revoke its authorization and remove its access to Mapbox APIs. Applications using the revoked token will need to get a new access token before they can access Mapbox APIs. Note that cached resources may continue to be accessible for a little while after a token is deleted. No new or updated resources will be accessible with the deleted token. Required parameter Description token_id The ID of the token that you want to delete. Example request: Delete a token $ curl -X DELETE ""https://api.mapbox.com/tokens/ v2 / {username} / { token_id } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Delete a token HTTP 204 Retrieve a token get /tokens/v2?access_token={access_token} Retrieve an access token and check whether it is valid. If the token is invalid, an explanation is returned as the code property in the response body. Required parameter Description access_token The access token to retrieve. Example request: Retrieve a token $ curl ""https://api.mapbox.com/tokens/ v2 ?access_token= YOUR_MAPBOX_ACCESS_TOKEN "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Retrieve a token The body of the token is parsed and included as the token property in object form. The returned object contains the following properties: Property Description code Indicates whether the token is valid. If the token is invalid, describes the reason. One of: Code Description TokenValid The token is valid and active. TokenMalformed The token cannot be parsed. TokenInvalid The signature for the token does not validate. TokenExpired The token was temporary and has expired. TokenRevoked The token's authorization has been deleted. token The token object. Contains the following properties: token.usage The token type. One of pk, sk, or tk. token.user The user to whom the token belongs. token.authorization The token's unique identifier. token.expires tk tokens only. The expiration time of the token. token.created tk tokens only. The creation time of the token. token.scopes tk tokens only. The token's assigned scopes. token.client tk tokens only. Always ""api"". Example response: Retrieve a token For a public token: { ""code"": ""TokenValid"", ""token"": { ""usage"": ""pk"", ""user"": ""mapbox"", ""authorization"": ""cijucimbe000brbkt48d0dhcx"" } } For a temporary token: { ""code"": ""TokenExpired"", ""token"": { ""usage"": ""tk"", ""user"": ""mapbox"", ""expires"": ""2016-09-15T19:27:53.000Z"", ""created"": ""2016-09-15T19:27:23.000Z"", ""scopes"": [""styles:read"", ""fonts:read""], ""client"": ""api"" } } List scopes get /scopes/v1/{username}?access_token={access_token} scopes:list token scope List scopes for a user. All potential scopes a user has access to are listed. Public tokens may only contain scopes with the public property set to true. Secret tokens may contain any scope. Required parameter Description username The username of the account for which to list scopes. Example request: List scopes $ curl ""https://api.mapbox.com/scopes/v1/ {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with scopes:list scope. "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: List scopes The response body will contain an object for each scope the user has access to, each with the following properties: Property Description id The identifier of the scope. description A description of permissions granted by the scope. public true if the scope is available for public tokens. Example response (truncated): List scopes [ { ""id"": ""scopes:list"", ""description"": ""List all available scopes."" }, { ""id"": ""styles:read"", ""public"": true, ""description"": ""Read styles."" } ] Tokens API errors Response body code or message HTTP status code Description TokenInvalid, TokenMalformed 200 Check the access token used in the query when retrieving a token. TokenExpired 200 The temporary token has expired and needs to be regenerated when retrieving a token. TokenRevoked 200 The token has been revoked and needs to be regenerated when retrieving a token. Unauthorized 401 The token used in the query was not valid, or no token was used in the query. If a temporary token was used, it may be expired. Not found 404 The access token used in the query needs the tokens:read (to list) or tokens:write scope (to create, update, or delete). This error may also indicate that a token is not associated with a user plan. No such user 404 Check the username used in the query. access token is required 422 No access token was used in the query. usage must be pk or sk 422 The usage parameter must be one of pk (public token) or sk (secret token). expires is in the past 422 You can't create a temporary token with an expires parameter that occurs in the past. expires is more than one hour in the future 422 When creating a temporary token, the expiration must be no more than one hour in the future. expires may not be greater than the expiration of the authorizing token 422 When creating a temporary token using another temporary token, the expiration of the created token cannot be greater than that of the creating token. scopes are invalid 422 You cannot create a new token with scopes that exceed those of the token you are using to create it. resources are invalid 422 When creating or updating a token, the resources in the body are malformed, empty, or require higher permissions that those of the creating token. Internal Server Error 500 This error can occur if the start value is not valid. Tokens API restrictions and limits Requests must be over HTTPS. HTTP is not supported. The Tokens API is limited to 100 requests per minute per account. Each token is limited to 100 allowed URLs. Temporary tokens cannot have allowed URLs, but public tokens and secret tokens can. Was this section on Tokens helpful? Yes No",,Accounts service,Token format,Token metadata object,Example token metadata object,List tokens,Example request: List tokens,Response: List tokens,Example response: List tokens,Create a token,Available token scopes,Example request: Create a token,Response: Create a token,Example response: Create a token,Create a temporary token,Example request: Create a temporary token,Example request body: Create a temporary token,Response: Create a temporary token,,Example response: Create a temporary token,Update a token,Example request: Update a token,Response: Update a token,Example response: Update a token,Delete a token,Example request: Delete a token,Response: Delete a token,Retrieve a token,Example request: Retrieve a token,Response: Retrieve a token,Example response: Retrieve a token,List scopes,Example request: List scopes,Response: List scopes,Example response (truncated): List scopes,Tokens API errors,Tokens API restrictions and limits,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Map features,An overview of rendering vector features in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/overview/map-features/,guide,,,"Map features Map layers The Map Layers section of the AbstractMap script is where you can control how vector features are rendered on your map. Data Source: This setting is where you can specify the tileset to use for your map layer. Buildings With Building Ids: This tileset combines Mapbox-Streets-v7 vector data with our experimental 3D buildings data, which assigns unique IDs to building features to avoid visual artifacts for buildings at tile borders. Mapbox Streets: This is the Mapbox-Streets-v7 tileset. This tileset will be the most appropriate choice for common use cases. Custom: Use this setting for bringing your custom tileset into Unity. You can create a composite data source for your layer by adding multiple comma-separated tileset IDs in the Map Ids field. This allows you to use multiple custom tilesets, or add your custom tileset as well as the default Mapbox Streets tileset. For more information on how to use custom data with the Maps SDK for Unity, refer to the custom data documentation. Features Map features is where you can specify how to render specific layers from the tilesets assigned as a Data Source. With a Data Source selected, click on FEATURES and then on Add Features. A selection dialogue will appear with the following: Buildings, Roads, Landuse, Points, and Custom. These settings refer to the layers contained in the selected Data Source. Select a layer for the required feature. Buildings Add 3D buildings to your map with the following steps: Select Buildings for the map feature. Preset settings for the feature type selected will be populated. Click on the Name to rename the feature. Enter Play mode. The 3D buildings from the building layer on the Mapbox-Streets-v7 tileset will be rendered on your map. See the sections below for details on the default settings, and how to further customize the 3D buildings in your scene. Filters Using filters you can make settings to conditionally render vector features contained in the building layer. Modeling In this section you can make settings to fine tune your meshes. Primitive Type: Vector data is made up of lines, polygons, points, or custom data. The primitive type defines the type of vector feature you are trying to access. In the case of buildings this will be “polygon” since building footprints are essentially polygons extruded by a height value. Extrusion Type: The extrusion type setting provides a way to specify max, min, or fixed heights for buildings. The available options are below. You will see different settings in the inspector depending on these dropdown selections. None: No extrusion. Property Height: Extrudes features using the property value. Min Height: Extrudes features using the property value. If height is not uniform, this sets the height based on property's minimum height value. This results in flat rooftops. Max Height: Extrudes features using the property value. If height is not uniform, this sets the height based on property's maximum height. This results in flat rooftops. Range Height: Extrudes features using the property value. Values are clamped to the min and max values if they are lower or greater than the min and max values respectively. Absolute Height: Extrudes all features using a fixed value. Geometry Type: Settings to extrude roofs, sidewalls, or both. Property Name: The name of the property on the building layer of the tileset that is used for extrusion. By default it is set to height. For more information see the Mapbox Streets v7 tileset layer reference. Scale Factor: The height scale factor by which you would like to extrude the buildings. For example, if this is set to 2, the building extrusions will be done at twice the original scale. Snap to Terrain: This makes sure buildings snap properly to the terrain when using a terrain with elevation. When this is not checked, the buildings might spawn above or below the terrain. Combine Meshes: Check this option if you want to combine all the building meshes on a tile into a single game object. While this helps improve runtime performance, it may not offer you flexibility to make changes on individual buildings (for example, changing the color or texture of a particular building). It may also make it impossible to use a raycast to find the address of a building. Collider Type: This option is used to add a collider to the extruded buildings. The available types of colliders that you can apply to your buildings are Box Collider, Mesh Collider, or Sphere Collider. Note that if you have Combine Meshes selected, this option will add a collider to the entire tile instead of to individual buildings. Texturing Use the Texturing settings to configure material options for the building geometry. Custom: Choose this setting to specify custom materials and texturing type. Simple: The Simple style combines stylized vector designs with scriptable palettes to create a procedurally colored style. Light: The Light style uses colored materials to create a light, greyscale shading for your map. Dark: The Dark style uses colored materials to create a dark, greyscale shading for your map. Realistic: This is the default texturing for buildings. This combines modern and urban designs with physically based rendering materials to create a contemporary cityscape. Fantasy: The Fantasy style combines old world medieval designs with physically based rendering materials to create a fantasy-style city visualization. Satellite: The Satellite style uses high-resolution satellite imagery as a texture set. The comprehensive set of road, label, and POI information brings clarity and context to the crisp detail in our high-resolution satellite imagery. Color: The Color style is for user-defined color and opacity. Use this setting to specify a custom color. Behavior modifiers Behavior modifiers are ScriptableObjects that work with meshes and game objects to further allow you to decorate, enhance, or make modifications to your game objects. Was this page helpful? Yes No",,Map features,Features,Buildings,Filters,Modeling,Texturing,Behavior modifiers,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,Platform Support | Mapbox SDK for Unity,,https://docs.mapbox.com/mapbox-unity-sdk/docs/02-known-issues.html,,,,"Toggle navigation Show / Hide Table of Contents Please Note: Current support is limited to Unity 2017.1+ Platform Support Minimum iOS version supported is 8 Minimum Android version supported is 15 For UWP, please read these special notes. Hololens builds are currently not working as expected General If you experience issues with tiles not refreshing as expected, please remember to clear the disk cache You can do this from the Mapbox menu or with MapboxAccess.Instance.ClearCache(); Vector Tile Vector tile overzooming buffer hardcoded (to zero) Buildings are split along tile borders (features duplicated across boundaries) Building parts are not associated with specific buildings (other than spatially) Global Elevation Data Some tiles are missing elevation data (mapbox.terrain-rgb)—these tiles will be treated as flat terrain by the TerrainFactory Directions Cannot cancel direction queries Traffic Traffic visualizer is not offsetting data for both sides of the street Tile Error Callbacks When a client sends a Cancel() / Recycle() request to a UnityTile instance, the OnTileError event handler method is unsubscribed from the OnTileError event. Followed by that, a ""request aborted"" exception is sent as a part of the response to the requested Tile. But, the UnityTile instance cannot listen to this exception since, it has already unsubscribed from the OnTileError event Improve this Doc Back to top © 2017 Mapbox",,Platform Support,Vector Tile,Global Elevation Data,Directions,Traffic,Tile Error Callbacks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Maps SDK for Unity,"The Mapbox Maps SDK for Unity is an open source toolset for building location based augmented and virtual reality applications with Unity, using real map data.",https://docs.mapbox.com/help/glossary/mapbox-maps-sdk-for-unity/,glossary,,,"Mapbox Maps SDK for Unity The Mapbox Maps SDK for Unity is a set of tools to build Unity applications from real map data. It consists of a robust API for interfacing with Mapbox web services and converting map resources into game objects as well as a robust graphical user interface built on top of the Unity platform. To include the Mapbox Maps SDK for Unity in your application, please visit the documentation pages for installation instructions, API reference, and tutorials: Mapbox Maps SDK for Unity overview API documentation Tutorials Pricing for Unity apps Was this page helpful? Yes No",,Mapbox Maps SDK for Unity,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Download an offline map,Download an offline pack and track its progress.,https://docs.mapbox.com/ios/maps/examples/offline-pack/,example,Swift,,"Download an offline map See our mobile offline help page for more information about uses and limitations. For a more comprehensive example that manages offline packs, see MBXOfflinePacksTableViewController. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! var progressView: UIProgressView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.darkStyleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .gray mapView.delegate = self view.addSubview(mapView) mapView.setCenter(CLLocationCoordinate2D(latitude: 22.27933, longitude: 114.16281), zoomLevel: 13, animated: false) // Setup offline pack notification handlers. NotificationCenter.default.addObserver(self, selector: #selector(offlinePackProgressDidChange), name: NSNotification.Name.MGLOfflinePackProgressChanged, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(offlinePackDidReceiveError), name: NSNotification.Name.MGLOfflinePackError, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(offlinePackDidReceiveMaximumAllowedMapboxTiles), name: NSNotification.Name.MGLOfflinePackMaximumMapboxTilesReached, object: nil) } func mapViewDidFinishLoadingMap(_ mapView: MGLMapView) { // Start downloading tiles and resources for z13-16. startOfflinePackDownload() } deinit { // Remove offline pack observers. NotificationCenter.default.removeObserver(self) } func startOfflinePackDownload() { // Create a region that includes the current viewport and any tiles needed to view it when zoomed further in. // Because tile count grows exponentially with the maximum zoom level, you should be conservative with your `toZoomLevel` setting. let region = MGLTilePyramidOfflineRegion(styleURL: mapView.styleURL, bounds: mapView.visibleCoordinateBounds, fromZoomLevel: mapView.zoomLevel, toZoomLevel: 16) // Store some data for identification purposes alongside the downloaded resources. let userInfo = [""name"": ""My Offline Pack""] let context = NSKeyedArchiver.archivedData(withRootObject: userInfo) // Create and register an offline pack with the shared offline storage object. MGLOfflineStorage.shared.addPack(for: region, withContext: context) { (pack, error) in guard error == nil else { // The pack couldn’t be created for some reason. print(""Error: \(error?.localizedDescription ?? ""unknown error"")"") return } // Start downloading. pack!.resume() } } // MARK: - MGLOfflinePack notification handlers @objc func offlinePackProgressDidChange(notification: NSNotification) { // Get the offline pack this notification is regarding, // and the associated user info for the pack; in this case, `name = My Offline Pack` if let pack = notification.object as? MGLOfflinePack, let userInfo = NSKeyedUnarchiver.unarchiveObject(with: pack.context) as? [String: String] { let progress = pack.progress // or notification.userInfo![MGLOfflinePackProgressUserInfoKey]!.MGLOfflinePackProgressValue let completedResources = progress.countOfResourcesCompleted let expectedResources = progress.countOfResourcesExpected // Calculate current progress percentage. let progressPercentage = Float(completedResources) / Float(expectedResources) // Setup the progress bar. if progressView == nil { progressView = UIProgressView(progressViewStyle: .default) let frame = view.bounds.size progressView.frame = CGRect(x: frame.width / 4, y: frame.height * 0.75, width: frame.width / 2, height: 10) view.addSubview(progressView) } progressView.progress = progressPercentage // If this pack has finished, print its size and resource count. if completedResources == expectedResources { let byteCount = ByteCountFormatter.string(fromByteCount: Int64(pack.progress.countOfBytesCompleted), countStyle: ByteCountFormatter.CountStyle.memory) print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” completed: \(byteCount), \(completedResources) resources"") } else { // Otherwise, print download/verification progress. print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” has \(completedResources) of \(expectedResources) resources — \(progressPercentage * 100)%."") } } } @objc func offlinePackDidReceiveError(notification: NSNotification) { if let pack = notification.object as? MGLOfflinePack, let userInfo = NSKeyedUnarchiver.unarchiveObject(with: pack.context) as? [String: String], let error = notification.userInfo?[MGLOfflinePackUserInfoKey.error] as? NSError { print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” received error: \(error.localizedFailureReason ?? ""unknown error"")"") } } @objc func offlinePackDidReceiveMaximumAllowedMapboxTiles(notification: NSNotification) { if let pack = notification.object as? MGLOfflinePack, let userInfo = NSKeyedUnarchiver.unarchiveObject(with: pack.context) as? [String: String], let maximumCount = (notification.userInfo?[MGLOfflinePackUserInfoKey.maximumCount] as AnyObject).uint64Value { print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” reached limit of \(maximumCount) tiles."") } } } Copy Was this page helpful? Yes No",,Download an offline map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Interactive tools,Experiment with Mapbox tools.,https://docs.mapbox.com/help/interactive-tools/,,,,"Interactive tools Experiment with Mapbox tools. Data Tilequery API playground Retrieve features from vector tiles with the Mapbox Tilequery API. Mobile apps Marker playground Add a marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, React Native, or web application. Mapbox offline tile count estimator Estimate the number of tiles required to download an offline region using the Mapbox Maps SDK for Android and iOS. Print Mapbox Static Images API playground Generate an image of a map using the Mapbox Static Images API. Specify the map style, coordinates, zoom level, image size, and more. Web apps Mapbox GL JS usage playground Interact with a Mapbox GL JS map to understand the relationship between billing units including map loads, map views, and tile requests. Marker playground Add a marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, React Native, or web application.",,Data,Print,Web apps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Geographic Analytics,Data flow and Visualization details,How the extension works under the hood.,https://docs.mapbox.com/geographic-analytics/overview/visualization/,guide,,,"Data flow and Visualization details The Geographic Analytics Extension provides many visualizations. Each visualization style listed below is one of the drop-down options found in the Configure Map Appearance menu. This section will explain how the extension processes data and uses that data to create visualizations. Data flow The Geographic Analytics Extension works by tapping into the data that powers your Tableau worksheets. This data is temporarily cached for downstream processing, but is overwritten on a new selection or a visualization update. Once connected, it utilizes a library called Turf to calculate the bounding box of the selected data. This is recalculated on every worksheet interaction, which is how it produces the zoom-to-selection function. Visualization Types Clustering Clustering is the default visualization. This works by passing the data into Mapbox GL and requesting a style-type of cluster. This cluster is powered by a library called Supercluster that figures out how close points are to each other within a certain radius and then creates a single point (the cluster) out of those points. The more points, the larger the cluster. This is computed for all points as you move around the map. As you zoom in, the clusters disassemble into their constituent points. You can read more about Supercluster on the Mapbox blog and on the Supercluster GitHub repository. Grids Grids are calculated using a Turf method called hexGrid and squareGrid. This takes the bounding box of the data (collected when the Geographic Analytics Extension connects to the Worksheet) and a distance setting (in miles or kilometers), and outputs a grid covering that area. The extension then uses a secondary method called collection. This takes the grids that it generates and compares it to the points from the worksheet. Once the extension has collected the points that are within each cell, it then computes the Measures and assigns them to each cell. Grids can also be extruded, which takes the value that is assigned to the color and moves the grid into 3D. This is where the Extrusion Height is used, as you can adjust the minimum height so that your data is visible and variance between cells can be observed. To trigger extrusion, click the Awesome button. To reset, click the Reset button. Voronoi Voronoi are calculated like Grids - they take in data and pass it through a Turf method called voronoi. Since each Voronoi cell contains one data point - there is no collection, color is the selected measure assigned to that point. Data elevation Data elevation, in GIS terms, is an isoband. Isobands are traditionally used to show changes in data, typically elevation, in two dimensions. They are computed from a grid that expresses how data changes over space which then generates rings that show a specific value and rate of change. The closer the rings, the faster the rate of change; the further, the slower. This is an intensive calculation that may cause the extension to hang or become unresponsive, depending on your settings. Creating an isoband is a two step process. First, the extension will take the data from the worksheet and process it using a Turf method called interpolate. This takes the points from the worksheet and snaps them to a grid of width X, which is the width you established in the configuration screen. This process will interpolate the change in your selected measure via a process called inverse distance weighting. Remember: Before creating a data elevation, consider the fact that all computations are happening within a browser. The tighter the grid, the longer it will take to process. The method has to do the interpolation and then snap points to the grid, which can be intensive if the grid is too tight over too large a geographic area. Second, the grid must be processed into bands representing areas of change and when breaks are exceeded. This is performed by a Turf method called isobands. It takes the grid from the first step and then finds the breaks in the data where changes occur. These steps are controlled by your Classification method and the number of breaks you select. For example: if your data range is 0-100, and you have four equidistant breaks, you will see three lines that show where you cross 25, 50, and 75 (calculated from the interpolated grid). Before choosing Data Elevation, you may want to switch to a Square or Hex grid to see how tightly packed your grid might be. Once you have found a grid that works, experiment with your breaks. Once you have completed both of those steps, switch to Data Elevation and it should do well. Was this page helpful? Yes No",,Data flow and Visualization details,Visualization Types,Clustering,Grids,Voronoi,Data elevation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Examples,Examples for Mapbox Studio.,https://docs.mapbox.com/studio-manual/examples/,,,,Map design Add 3D buildings Use a fill extrusion layer to add 3D buildings to a map in Mapbox Studio. Apply conditional labels Check if a data property exists and if it does not display a different label. Add a custom icon Upload an SVG and add it to the map as a custom icon. Add a hillshade layer Add a raster-dem source as a hillshade layer for detailed slope and shading. Data visualization Create a choropleth map Add a fill layer and use expressions to style a choropleth map. Convert units Use a formula to convert elevation values from meters to feet. Style a heatmap layer Add and style a heatmap layer.,,Map design,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Map Matching,Match raw GPS points to the map so they aligns with the roads/pathways.,https://docs.mapbox.com/android/java/examples/use-map-matching/,example,Java,,"Map Matching Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical"" tools:context="".examples.javaservices.MapMatchingActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""34.01591350351023"" mapbox:mapbox_cameraTargetLng=""-118.4945560781314"" mapbox:mapbox_cameraZoom=""14.5""/> </LinearLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.graphics.Color; import android.os.AsyncTask; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.api.matching.v5.MapboxMapMatching; import com.mapbox.api.matching.v5.models.MapMatchingMatching; import com.mapbox.api.matching.v5.models.MapMatchingResponse; import com.mapbox.core.exceptions.ServicesException; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.ColorUtils; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.List; import java.util.Objects; import java.util.Scanner; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.api.directions.v5.DirectionsCriteria.PROFILE_DRIVING; import static com.mapbox.core.constants.Constants.PRECISION_6; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Match raw GPS points to the map so they align with roads and pathways. */ public class MapMatchingActivity extends AppCompatActivity { private static final String TAG = ""MapMatchingActivity""; private MapView mapView; private MapboxMap map; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_javaservices_map_matching); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { map = mapboxMap; map.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { new LoadGeoJson(MapMatchingActivity.this).execute(); } }); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private static class LoadGeoJson extends AsyncTask<Void, Void, FeatureCollection> { private WeakReference<MapMatchingActivity> weakReference; LoadGeoJson(MapMatchingActivity activity) { this.weakReference = new WeakReference<>(activity); } @Override protected FeatureCollection doInBackground(Void... voids) { try { MapMatchingActivity activity = weakReference.get(); if (activity != null) { InputStream inputStream = activity.getAssets().open(""trace.geojson""); return FeatureCollection.fromJson(convertStreamToString(inputStream)); } } catch (Exception exception) { Timber.e(""Exception Loading GeoJSON: %s"", exception.toString()); } return null; } static String convertStreamToString(InputStream is) { Scanner scanner = new Scanner(is).useDelimiter(""\\A""); return scanner.hasNext() ? scanner.next() : """"; } @Override protected void onPostExecute(@Nullable FeatureCollection featureCollection) { super.onPostExecute(featureCollection); MapMatchingActivity activity = weakReference.get(); if (activity != null && featureCollection != null) { activity.drawLines(featureCollection); } } } private void drawLines(@NonNull FeatureCollection featureCollection) { List<Feature> features = featureCollection.features(); if (features != null && features.size() > 0) { Feature feature = features.get(0); drawBeforeMapMatching(feature); requestMapMatched(feature); } } private void drawBeforeMapMatching(Feature feature) { map.getStyle(style -> { style.addSource(new GeoJsonSource(""pre-matched-source-id"", feature)); style.addLayer(new LineLayer(""pre-matched-layer-id"", ""pre-matched-source-id"").withProperties( lineColor(ColorUtils.colorToRgbaString(Color.parseColor(""#c14a00""))), lineWidth(6f), lineOpacity(1f) )); }); } private void requestMapMatched(Feature feature) { List<Point> points = ((LineString) Objects.requireNonNull(feature.geometry())).coordinates(); try { // Setup the request using a client. MapboxMapMatching client = MapboxMapMatching.builder() .accessToken(Objects.requireNonNull(Mapbox.getAccessToken())) .profile(PROFILE_DRIVING) .coordinates(points) .build(); // Execute the API call and handle the response. client.enqueueCall(new Callback<MapMatchingResponse>() { @Override public void onResponse(@NonNull Call<MapMatchingResponse> call, @NonNull Response<MapMatchingResponse> response) { if (response.code() == 200) { drawMapMatched(Objects.requireNonNull(response.body()).matchings()); } else { // If the response code does not response ""OK"" an error has occurred. Timber.e(""MapboxMapMatching failed with %s"", response.code()); } } @Override public void onFailure(Call<MapMatchingResponse> call, Throwable throwable) { Timber.e(throwable, ""MapboxMapMatching error""); } }); } catch (ServicesException servicesException) { Timber.e(servicesException, ""MapboxMapMatching error""); } } private void drawMapMatched(@NonNull List<MapMatchingMatching> matchings) { Style style = map.getStyle(); if (style != null && !matchings.isEmpty()) { style.addSource(new GeoJsonSource(""matched-source-id"", Feature.fromGeometry(LineString.fromPolyline( Objects.requireNonNull(matchings.get(0).geometry()), PRECISION_6))) ); style.addLayer(new LineLayer(""matched-layer-id"", ""matched-source-id"") .withProperties( lineColor(ColorUtils.colorToRgbaString(Color.parseColor(""#3bb2d0""))), lineWidth(6f)) ); } } } Copy Was this page helpful? Yes No",,Map Matching,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Faster-route detection,Faster-route detection in the Mapbox Navigation SDK for Android. Read all about it in this official Mapbox documentation.,https://docs.mapbox.com/android/navigation/overview/faster-route/,guide,Java,,"Faster-route detection SDKs covered: Navigation SDK Navigation UI SDK The Navigation SDK includes a faster-route detection class. This class checks each location update as well as the progress along the current route to determine if a new route should be retrieved. Fetching faster routes is disabled by default in the Navigation SDK. To enable either the default logic or your own custom logic, you can create a MapboxNavigationOptions object and set MapboxNavigationOptions#enableFasterRouteDetection(boolean); to true. MapboxNavigationOptions is then passed into the constructor of MapboxNavigation. Faster-route detection and the Navigation UI SDK This guide does not describe any specific options in the Navigation UI SDK. You need to enable faster-route detection using the core Navigation SDK directly. Default faster-route detection After enabling faster-route detection, the default logic in FasterRouteDetector checks for a faster DirectionsRoute every two minutes, only if both of the following conditions are true: The current route duration remaining is more than 600 seconds The current step duration remaining is more than 70 seconds When a new DirectionsRoute is retrieved, it is considered faster if all the following conditions are true: The upcoming step is the same as the current upcoming step The first step of the new route is more than 70 seconds in duration It is at least 10 percent faster than the duration remaining of the current route FasterRouteListener You are able to listen to the retrieval of a faster DirectionsRoute with FasterRouteListener. This listener will fire if a new route is retrieved and meets the given criteria of FasterRoute#isFasterRoute. Java Kotlin navigation.addFasterRouteListener(new FasterRouteListener() { @Override public void fasterRouteFound(DirectionsRoute directionsRoute) { // Update MapboxNavigation here navigation.startNavigation(directionsRoute); } }); Copy Custom logic for fetching faster routes If you would like to provide your own logic to replace the default logic above, you can do so by subclassing FasterRoute and passing your class to MapboxNavigation with MapboxNavigation#setFasterRouteEngine(FasterRoute). When to check for a faster route FasterRoute#shouldCheckFasterRoute(Location, RouteProgress) will determine when a new DirectionsResponse should be retrieved by the RouteEngine. This method will be called every time the Navigation SDK gets a Location update from the LocationEngine. What qualifies as a faster route FasterRoute#isFasterRoute(DirectionsResponse, RouteProgress) will be used to determine if the route retrieved is faster than the one that's being navigated. This method will be called every time a response is received from the RouteEngine. Was this page helpful? Yes No",,Faster-route detection,FasterRouteListener,Custom logic for fetching faster routes,When to check for a faster route,What qualifies as a faster route,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Get started with Mapbox Boundaries,Get started with v2 of the Mapbox Boundaries tileset.,https://docs.mapbox.com/help/tutorials/get-started-mapbox-boundaries/,tutorial,No code,,"intermediate No code Get started with Mapbox Boundaries Prerequisite Familiarity with front-end development and access to Mapbox Boundaries. Note Access to the Mapbox Boundaries tilesets are controlled by Mapbox account access token. If you do not have access on your account, contact a Mapbox sales representative to request access to Boundaries tilesets. Mapbox Enterprise users can add global administrative, postal, and statistical boundaries to their maps and data visualizations. This guide covers how to use Mapbox Boundaries in a web application and navigate feature lookup tables. Getting started Mapbox Boundaries are available as a part of an Enterprise plan. If you do not have an Enterprise plan or if you do have an Enterprise plan and would like to add access to Mapbox Boundaries, contact a Mapbox sales representative to request access. Access to the Boundaries tilesets are controlled by your Mapbox account access token. Add to an application Once you have access to Mapbox Boundaries, you can use them in an application as you would use any other tileset. About Mapbox Boundaries Below you'll find a few pieces of key information that you'll need to navigate the Mapbox Boundaries tileset. Tileset IDs Mapbox Boundaries are stored as vector tiles and distributed via the Mapbox Vector Tiles API, with a unique tileset for each admin, stats, and postal level. Tileset IDs for Boundaries tilesets are in the form mapbox.enterprise-boundaries- { a|p|s } { level } - { version }. Here are a few examples: mapbox.enterprise-boundaries-a0-v2: The tileset for admin (a) level 0 (0) boundaries (which contain countries) in version two (v2) of Mapbox Boundaries. mapbox.enterprise-boundaries-p1-v2: The tileset for postal (p) level 1 (1) boundaries in version two (v2) of Mapbox Boundaries. mapbox.enterprise-boundaries-s3-v2: The tileset for stats (s) level 3 (3) boundaries in version two (v2) of Mapbox Boundaries. Find the complete list of Mapbox Boundaries tilesets and read more about tileset hierarchies in the reference documentation. Feature IDs Each feature also has a unique ID that is used to identify a feature polygon. Once Boundaries are added to your account, you will be able to access the reference documentation containing the feature IDs and all identifying metadata. Minimum zoom levels and bounding boxes z_min: The z_min value for each feature indicates the minimum zoom level at which a feature is available in a tileset. Use this to set the camera to a minimum zoom level to see the feature. centroid point: Centroid point features are guaranteed to appear at zoom level z_min + 1. Centroid point features can be used to display a marker, symbol, or label at the center of a Boundaries feature. Access vector tiles containing centroid points for a specific admin, postal, or stat level using the tileset ID as described above and specifying the source layer points_ { admin|postal|stats } _ { level }. For example, the vector tile source layer points_postal_4 contains centroid point data for the mapbox.enterprise-boundaries-p4-v2 tileset. bounds: Feature bounds are the smallest rectangular envelope that a feature fits into denoted as an array of [min_long, min_lat, max_long, max_lat]. Example To use a Mapbox Boundaries tileset in your application, make a request from the Mapbox Vector Tiles API for the relevant tileset. For example, in Mapbox GL JS, load the tileset using the code below: // Be sure to use an access token from an account // that has access to Boundaries mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/light-v 10 ', center: [-99.9, 41.5], zoom: 1 } ); map.on('load', function() { // Add source for admin-0 Boundaries map.addSource('admin-0', { type: 'vector', url: 'mapbox://mapbox.enterprise-boundaries-a0-v2' } ); // Add a layer with boundary lines map.addLayer( { id: 'admin-0-line', type: 'line', source: 'admin-0', 'source-layer': 'boundaries_admin_0', paint: { 'line-color': 'red', 'line-width': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 10] } } , 'waterway-label'); // Add a layer with points map.addLayer( { id: 'admin-0-circle', type: 'circle', source: 'admin-0', 'source-layer': 'points_admin_0', paint: { 'circle-color': 'white', 'circle-stroke-color': 'black', 'circle-stroke-width': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 6], 'circle-radius': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 20] } } , 'waterway-label'); } ); The code above will yield a map with all country boundaries in red with a circle at the center of each country. Feature lookup tables Each boundary feature is indexed in a lookup table. Lookup tables are designed to be used locally in your application. User data can be joined to Mapbox Boundaries in your application to create a visualization, such as a choropleth map of unemployment by state. About feature lookup tables The Mapbox Boundaries lookup tables include this metadata about each polygon feature: id: globally unique identifier for the feature. id_int: an integer-only identifier for a feature that can be used to accomplish data-joins with Mapbox GL JS's feature state. type: either admin, postal or stats to represent the Administrative, Postal or Statistical boundaries types in Mapbox Boundaries. level: a numeric value between 0 and 5 to represent the level of boundaries within the type. layer: a shortened concatenation of type and level with feature's administrative (a), postal (p), or statistical (s) hierarchy and level (0-5). For example, administrative level 1 would have a level of a1. tilesetname: tileset ID for the tileset containing the feature, see the reference documentation for more details. worldview: alternate display of administrative units depending on regional map display requirements (US, CN, or IN). unit_code: the country-specific identifier for the feature, such as postcode or FIPS code. name: local feature name. name_ascii: local feature name converted to ascii characters. names: any translation or aliases for that boundary. description: a text qualifier of the level respective to each country's boundary hierarchy. For example, US admin-1 boundaries have a description of states while Italian admin-1 boundaries have a description of regions. wikidata_id: the associated Wikidata ID for the boundary. source_date: recency of boundary data. parent_0: the level-0 parent of a feature which corresponds to the country code. parent_1: the level-1 parent of a feature, if it exists. parent_2: the level-2 parent of a feature, if it exists. parent_3: the level-3 parent of a feature, if it exists. parent_4: the level-4 parent of a feature, if it exists. z_min: minimum zoom level at which a polygon feature appears in a tileset. centroid: The centroid of the boundary in [long, lat] format. bounds: an array of the features bounding box as [minlong, minlat, maxlong, maxlat]. polylayername: name of the source-layer within the tileset containing feature polygon geometry. pointlayername: name of the source-layer within the tileset containing feature centroid. Lookup tables are available as JSON. Sample workflow The feature lookup tables are designed to be used alongside the Mapbox Boundaries tilesets. A typical workflow for a business intelligence application is: A user identifies geographic dimensions in a data source, such as state, zip, country, or longitude & latitude. A user makes a query from application data store. Data store joins geographic dimension query results to metadata in the feature lookup table, such as name, unit_code, or level. Data store groups and aggregates results by geographic dimension and sends to the client visualization tool. Generate a Mapbox GL layer from the Mapbox Style Specification to create a visual from query results. The visual style definition works the same across all Mapbox GL products, including Mapbox GL JS on the web, and Mapbox GL Native on iOS, Android, macOS, and Qt. Example Read the Visualize the USA’s economic recovery with client-side data joins blog post, which illustrates how the steps in the sample workflow can work in your application. Next steps Learn more about how you can use Mapbox Boundaries: Point-in-polygon query with Mapbox Boundaries: Determine what polygons exist at a single point using the Mapbox Tilequery API. Data-joins with Mapbox Boundaries: The data-join technique involves inner joins between local data, such as the unemployment rate by US state, to vector tile features, such as admin boundaries in Mapbox Boundaries, using data-driven style notation. Extend Mapbox Boundaries: You can extend Mapbox Boundaries with any custom data you need for your application. This could mean adding school district, city, market, or property boundaries to your application — all with the same performance and API features of the native product. Was this page helpful? Yes No",,Get started with Mapbox Boundaries,Add to an application,About Mapbox Boundaries,Tileset IDs,Feature IDs,Minimum zoom levels and bounding boxes,Example,Feature lookup tables,About feature lookup tables,Sample workflow,Next steps,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Tilesets API recipe reference,"This feature is in beta. Learn about the correct format and syntax for Tilesets API recipes, or tile transformation documents.",https://docs.mapbox.com/help/troubleshooting/tileset-recipe-reference/,troubleshooting,,,"Tilesets API recipe reference Public beta The Tilesets API features and workflows discussed in this guide are in public beta. All features and workflows are subject to potential future changes. Current version: 1 Tileset recipes are tile transformation documents that tell the Tilesets API how to turn tileset source data into vector tiles. Recipes must be constructed according to the rules in this recipe reference. Recipe top-level fields A recipe is a JSON object that must contain the following top-level fields: Required fields Description Data type version The version of the Tilesets API recipe reference that the recipe uses. The current version number is 1. Any version value other than the current version or a previous version will result in an error. Integer layers The LayerObject is an object in which the keys are the names of the layer and their values are objects that represent the configuration and options for the layer. Object { ""version"": 1, ""layers"": { ... } } LayerObject A layer object is the primary way of describing how a vector tile layer should be created. It specifies where to retrieve source data, the precision of the data through zoom levels, and how to transform features and render them into tiles. The following fields are the top-level options for a single layer: Required fields Description Data type source The source data to use for this layer. Tileset sources are created with the Create a tileset source endpoint of the Tilesets API. String minzoom Describes the lowest zoom level for the tileset. Integer maxzoom Describes the highest zoom level for the tileset. More info. Integer You can further refine the resulting tileset with the following optional fields: Optional fields Description Data type features Specifies the output on a per feature basis. More info. Object tiles Specifies the output on a per tile basis. More info. Object The following describes every available field for a LayerObject and the JSON type that field must be. { ""minzoom"": Integer, ""maxzoom"": Integer, ""features"": { ""id"": { ""attribute_id"": String, ""add_to_attributes"": String, ""output_id"": Boolean } , ""attributes"": { ""zoom_element"": Array, ""set"": Object, ""allowed_output"": Array } , ""filter"": Object, ""simplification"": Number, ""union"": [ { ""group_by"": Array, ""aggregate"": Array, ""maintain_direction"": Boolean, ""where"": Array } ] } , ""tiles"": { ""extent"": Integer, ""buffer_size"": Integer, ""limit"": Array } } Basic example The simplest example tileset recipe includes a layer name, a tileset source ID, a minimum zoom value, and a maximum zoom. { ""version"": 1, ""layers"": { ""trees"": { ""source"": ""mapbox://tileset-source/ { username } /trees-data"", ""minzoom"": 4, ""maxzoom"": 8 } } } Multi-layer recipes Recipes can also be arrays of recipe objects. This format can be used to create multi-layer tilesets. Recipes can have a maximum of 20 layers defined. { ""version"": 1, ""layers"": { ""trees"": { ... } , ""parks"": { ... } , ""paths"": { ... } } } Layer name configuration The layer name key is required for each LayerObject (e.g. ""trees"", ""parks"", and ""paths"" in the above example). This is the unique identifier for the layer of data in your final tileset. For any map each layer name must be unique. The layer name must be a string with only underscores (_) and alphanumeric characters. Source configuration A source refers to a tileset source, which is a collection of geographic data stored as line-delimited GeoJSON on Mapbox.com. Tileset sources can be created via the Create a tileset source endpoint of the Tilesets API. Zoom level configuration The minzoom and maxzoom configurations control the zoom levels at which your data will be tiled. They are required for a recipe. These values must be integers. The minzoom must be less than or equal to maxzoom, and both must be between the values of 0 and 16. Zoom levels play a large role in your output tileset. The higher the zoom level, the higher fidelity your data is as users zoom in. This also comes at a cost. Increasing zoom level fidelity creates exponentially more tiles! It’s important to consider the cases your map is trying to solve when choosing zoom levels. If your users are going to be viewing the map at a global extent it’s not necessary to choose a high zoom. If your users are going to be viewing the map at a city or street level, high zooms will be helpful for the most accurate data. If you know the precision to which you want your data to be represented, this table shows the approximate precision corresponding to various minzoom and maxzoom choices: Zoom level Precision in feet Precision in meters 0 32000 ft 10000 m 1 16000 ft 5000 m 2 8000 ft 2500 m 3 4000 ft 1250 m 4 2000 ft 600 m 5 1000 ft 300 m 6 500 ft 150 m 7 250 ft 80 m 8 125 ft 40 m 9 64 ft 20 m 10 32 ft 10 m 11 16 ft 5 m 12 8 ft 2 m 13 4 ft 1 m 14 2 ft 0.5 m 15 1 ft 0.25 m 16 0.5 ft 0.125 m Feature configuration The features configuration object is used to describe how features are individually processed into vector tiles. This field contains the following elements, which are evaluated in the order of the list provided below: Optional fields Description Data type id A JSON object that describes both how to identify a feature in a recipe and how that feature will be identified in the resulting tile. See the feature IDs section for more details. Object attributes A JSON object that controls how attributes are modified and which attributes are allowed in the resulting tileset. Object filter A filter expression determining which features should be retained. If no filter is defined, the default filter is true and all features will be retained. Array simplification An integer value that is greater than zero that controls the level of simplification that occurs for features. This integer value is relative to the extent provided for the tiles, with a larger value resulting in more simplification. Integer Feature IDs The id configuration gives you control over what field is used as the feature ID during tiling. It also allows you to specify where to put this ID in the resulting tileset as an attribute. The following fields are allowed in the id object: Optional field Description Data type attribute_id By default, the standard ID field in the tileset source GeoJSON will be used as IDs. But it is possible to use a specific attribute key for an ID instead. If this configuration option is provided, the attribute with a key that matches the string provided here will be used as the ID. String In this example, the recipe indicates that the iso_2 property in each feature should be the feature ID in the resulting tileset: { ""features"": { ""id"": { ""attribute_id"": ""iso_2"" } } } Optional field Description Data type add_to_attributes Adds your original ID field to the attributes of features using the key name provided. This is helpful in retrieving original string IDs that have been converted to integers in the vector tile feature. String In this example, the recipe saves the top-level ID field in the attribute road_id of the final vector tile. This is particularly helpful for saving top-level string IDs that will otherwise be converted to integers in the final vector tile. { ""features"": { ""id"": { ""add_to_attributes"": ""road_id"" } } } Optional field Description Data type output_id By default this value is true. Places the ID into the ID field of the vector tile. If you do not want numeric IDs in this field, change to false. Boolean If output_id is true, the ID is saved to the id field within a feature of a vector tile. The current Mapbox Vector Tile Specification does not allow for string-based IDs in features, so if this value is true any string IDs will be converted to an integer using a hash. In this example, the recipe adds feature IDs to feature attributes using the attribute my_id, but does not place the ID in the final vector tile ID field. { ""features"": { ""id"": { ""add_to_attributes"": ""my_id"", ""output_id"": false } } } Feature filters The filter configuration is a single filter expression that results in a true or false evaluation for each feature as configured by the minzoom and maxzoom. This is the primary way to control which features are allowed into the final tileset on a per-feature basis. If no filter is provided, by default this results in a value of true for all features. Filter expressions In various configurations throughout the recipe, you have the ability to select relevant features by their attributes. This is possible with filter expressions, which use the Mapbox GL JS expression syntax defined in the Mapbox GL JS Style Spec. Each filter is a JSON array that is evaluated for a boolean or value result using the following operations: Type assertion: array, boolean, number, object, string, typeof Type conversion: to-boolean, to-number, to-string Quoting: literal Feature characteristics: geometry-type, id, zoom Data retrieval: properties, at, get, has, length Comparison: ==, !=, <, >, <=, >=, step Boolean operations !, all, any Conditionals: case, coalesce, match Local variables let, var String manipulation concat, downcase, upcase Arithmetic -, +, /, *, ^, %, abs, ceil, floor, e, ln, ln2, log10, log2, max, min, round, sqrt Trigonometry acos, asin, atan, cos, sin, tan, pi Feature attributes The attributes configuration allows for manipulation of attribute data, generation of new attributes, and removal of attributes. The available options are described below, and implemented in the order they are listed: Optional field Description Data type zoom_element A JSON array that provides a list of attributes that are specified per zoom level in the source data. Array<String> For each attributes with a specified zoom_element, the final output attribute at zoom level N will be the Nth element in the array in the source data. If no zoom_element is defined, no attributes are altered. If the zoom level is greater than or equal to the number of elements in the array, the last element is used. Consider the following attributes for a single GeoJSON feature: { ""type"": ""Feature"", ""geometry"": { ... } , ""properties"": { ""name"": [ null, null, ""Main"", ""Main St."", ""Main Street"" ] } } In this example, the zoom_element array includes name. Using the attributes from the GeoJSON above, this feature would have no name attribute at zoom levels 0 and 1, would have ""Main"" at zoom level 2, ""Main St."" at zoom level 3, and ""Main Street"" at zoom levels 4 and above. { ""features"": { ""attributes"": { ""zoom_element"": [ ""name"" ] } } } Optional field Description Data type set A JSON object mapping the names of attributes to be generated to filter expressions that return the new attribute values. Particularly helpful for generating ranking schemes to be used in styling expressions. Object Consider the following attributes for a single GeoJSON feature: { ""type"": ""Feature"", ""geometry"": { ... } , ""properties"": { ""place"": ""state"", ""name"": ""California"" } } In this example, the set attribute defines a new attribute to be included in the final tileset, labelrank, that is derived from the existing data's place attribute. Using the ""match"" expression, it assigns a value to features based on the value of ""place"". If ""place"" is equal to ""country"", then the labelrank attribute for the resulting feature will have a value of 0, and so on. It also provides a default value of 5 for any features that have a ""place"" value that does not match any of the values explicitly provided. { ""features"": { ""attributes"": { ""set"": { ""labelrank"": [ ""match"", [ ""get"", ""place"" ], ""country"", 0, ""state"", 1, ""region"", 2, ""province"", 2, ""district"", 3, ""county"", 3, ""municipality"", 4, ""city"", 4, 5 ] } } } } Optional field Description Data type allowed_output A JSON array of attributes that controls which attributes will be carried over into the resulting tileset. Array<String> If an allowed_output array is provided only the attributes specified in the array will be saved to the tileset. This does not prevent the attributes that are not excluded by allowed_output from being used in filter expressions and other steps throughout the publish job. In this example, features in the resulting tileset will only have two attributes, name_en & name_es: { ""features"": { ""attributes"": { ""allowed_output"": [ ""name_en"", ""name_es"" ] } } } Feature simplification Optional field Description Data type simplification Indicates the desired level of simplification. Larger values result in more simplification, in which some vertices are removed. The default value is 4. The maximum value is 4096. Integer The simplification value describes the maximum distance that a point can be from the straight line that connects its two neighbors and still be considered to be on the line, and can therefore be removed safely. Any point with a distance that is larger than the simplification value is considered to be away from the line, and must be preserved. As you increase the simplification value, the number of vertices in each feature decreases. The Tilesets API recipe validator will reject any simplification value that is more than 4096. If you do not add a value for simplification, the Tilesets API will use 4, the default value. The resulting shape depends on the original shape of your feature. For instance, if your original feature is circular and you increase simplification, the result will look more like a polygon. If your original feature is a curved line and you increase simplification, the result will look more like a straight line. The Tilesets API uses the Ramer–Douglas–Peucker algorithm to simplify features. Tile configurations The tiles object contains the following elements, which are evaluated as each tile is being assembled from its component features: Optional field Description Data type buffer_size Controls the size of the buffer that will be created in your vector tiles. Number buffer_size represents a percentage of the size of a tile. The default buffer size is 0.5. Note that the value of this attribute cannot be larger than 100. Buffers are particularly helpful for label point layers to avoid cutting labels of at tile boundaries. Optional field Description Data type layer_size Specifies the size limit in kibibytes of each layer. Integer The default value is 500 KiB. The value cannot be larger than 500 or smaller than 1. Configuring layer_size can be helpful for improving rendering speed. Optional field Description Data type remove_filled Control which ""filled"" features are removed by specifying a filter-expression. Array<Expression> During tile creation it is possible for polygons to completely cover a tile and the area surrounding its buffer. These are called as ""filled features"". If all features within a tile are filled features, it may be useful for some tilesets to not create any tiles at all and expect that clients will look to higher zoom levels. To do this, you can use the remove_filled recipe. The syntax utilizes a filter-expression to allow control over what features exactly should be removed. ""tiles"": { ""remove_filled"": expression } No tile will be created if: All features within the tile are considered filled features All features are matched by the filter-expression provided in remove_filled The following example removes all tiles that contain only filled features: ""tiles"": { ""remove_filled"": true } The following example removes all tiles that contain only filled features after zoom level 5: ""tiles"": { ""remove_filled"": ["">"", [ ""zoom"" ], 5] } Optional field Description Data type limit A limitation rule that reduces the number of features for the specified type to a specific number, choosing the lowest or highest-numbered features according to some attribute. Array<Expression> The limit field must be an array of limitation rules, each of which is evaluated in sequence to potentially limit the total number of features to be included in the final tile. Rules that limit the total number of features in a tile have one of following forms: [ ""lowest_where"", filter-expression , number , attribute ] [ ""highest_where"", filter-expression , number , attribute ] Rules that limit the number of features within a specified distance have one of the following forms: [ ""lowest_where_in_distance"", filter-expression , number , attribute ] [ ""highest_where_in_distance"", filter-expression , number , attribute ] The number is a divisor of the total tile area. So, for instance, if the number is 256, the features will be spaced such that 256 of them are spaced evenly across the tile. The features with the lowest or highest value of attribute within each cluster are prioritized. The difference is that lowest_where and highest_where choose any number of features that match the filter-expression, even if these features are right on top of each other, while lowest_where_in_distance and highest_where_in_distance choose any number of features that match the filter-expression while still being acceptably spatially-separated. Optional field Description Data type order Specify the order of a sequence of features in the final output tile. String You can order the sequence of features in the final output tile by a specified attribute. The attribute values must be comparable (all strings or all numbers). This example orders the features by the sequence attribute: ""tiles"": { ""order"": ""sequence"" } Feature union Optional field Description Data type union Join features based on whether or not a defined spedified attribute matches. Object You can union features together if a specified set of their attributes match. The simplest case unions all features that have exactly the same attributes: ""tiles"": { ""union"": [ { } ] } The union specification object can contain an expression to union only features that match the specified expression as well as having matching attributes: ""where"": expression Expression options: group_by: [attribute, attribute, attribute] - Use group_by to union features that have specified attributes that match, instead of requiring all attributes to match. aggregate: { attribute: type, attribute: type } - Use aggregate to accumulate the specified attributes from the unioned features instead of arbitrarily keeping the attributes from one of the unioned features. Acceptable types of aggregation include sum (to add), comma (to concatenate with a comma), or concat (to concatenate the feature data without a delimiter). maintain_direction: boolean - Use maintain_direction: false to make more compact unions of LineStrings for which directionality doesn't matter. This is done by reversing some of the LineStrings if that helps to connect them. For example, you could specify the following to union only features where highway=motorway: ""tiles"": { ""union"": [ { ""where"": [ ""=="", [ ""get"", ""highway"" ], ""motorway"" ], ""maintain_direction"": true } ] } This example uses maintain_direction: true (the default) because motorway roads are generally mapped as pairs of roadways whose direction indicates their one-way direction. Using union with zoom based properties You can use union on zoom-element properties. If you are using union with a zoom-element property, the union will occur after the feature has been assigned the value based on the zoom level. More resources For a list of example recipes that correspond to common tileset use-cases, see the Tileset recipe examples page. The Get started with the Tilesets API and CLI tutorial walks you through the process of creating a new tileset, including creating and using a tileset recipe, with the Tilesets CLI. The Tilesets API has several endpoints that can be used to validate, update, and read a tileset's recipe. Learn more in the Tilesets API documentation. Was this page helpful? Yes No",,Tilesets API recipe reference,LayerObject,Basic example,Multi-layer recipes,Layer name configuration,Source configuration,Zoom level configuration,Feature configuration,Feature IDs,Feature filters,Filter expressions,Feature attributes,Feature simplification,Tile configurations,Feature union,More resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Add a new layer below labels,"Using the second argument of addLayer, you can be more precise.",https://docs.mapbox.com/android/maps/examples/add-a-new-layer-below-labels/,example,Java,,"Add a new layer below labels Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.GeojsonLayerInStackActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""33.749909"" mapbox:mapbox_cameraTargetLng=""-84.381546"" mapbox:mapbox_cameraZoom=""8.471903""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.graphics.Color; import android.os.Bundle; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.net.URI; import java.net.URISyntaxException; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; /** * Using the second argument of addLayer, you can add a layer below existing one */ public class GeojsonLayerInStackActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_geojson_layer_in_stack); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { try { GeoJsonSource urbanAreasSource = new GeoJsonSource(""urban-areas"", new URI(""https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_urban_areas.geojson"")); style.addSource(urbanAreasSource); FillLayer urbanArea = new FillLayer(""urban-areas-fill"", ""urban-areas""); urbanArea.setProperties( fillColor(Color.parseColor(""#ff0088"")), fillOpacity(0.4f) ); style.addLayerBelow(urbanArea, ""water""); } catch (URISyntaxException uriSyntaxException) { uriSyntaxException.printStackTrace(); } } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Add a new layer below labels,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Localize the geocoder to a given language,Localize the mapbox-gl-geocoder to set the UI language and improve result relevance in that language.,https://docs.mapbox.com/mapbox-gl-js/example/mapbox-gl-geocoder-with-language/,example,JavaScript,,Localize the geocoder to a given language Localize the mapbox-gl-geocoder to set the UI language and improve result relevance in that language. Was this example helpful? Yes No,,Localize the geocoder to a given language,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Zoomable map,An overview of the zoomable map example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/zoomable-map/,example,C#,,"Zoomable map The Zoomable Map example allows you to create a runtime zoomable and pannable map. This example is a starting point for creating a traditional web-based zoomable map. Place custom markers Placing custom markers on zoomable and non-zoomable maps is mostly a similar process, with one exception. Since the zoom level of a zoomable map can change at runtime, the marker positions need to be updated in every frame. The Zoomable Map example handles this with a script called SpawnOnMap. SpawnOnMap provides an outline of placing custom markers. It uses the Start() function to calculate initial marker positions, then uses Update() to update those positions every time the map changes (either from zooming or panning). ... void Start() { _locations = new Vector2d[_locationStrings.Length]; _spawnedObjects = new List<GameObject>(); for (int i = 0; i < _locationStrings.Length; i++) { var locationString = _locationStrings[i]; _locations[i] = Conversions.StringToLatLon(locationString); var instance = Instantiate(_markerPrefab); instance.transform.localPosition = _map.GeoToWorldPosition(_locations[i], true); + instance.transform.localScale = new Vector3(_spawnScale, _spawnScale, _spawnScale); _spawnedObjects.Add(instance); } } private void Update() { int count = _spawnedObjects.Count; for (int i = 0; i < count; i++) { var spawnedObject = _spawnedObjects[i]; var location = _locations[i]; spawnedObject.transform.localPosition = _map.GeoToWorldPosition(location, true); } } ... Using the SpawnOnMap example script To use the SpawnOnMap script, add it as a Component to a Map GameObject. Below is a description of the variables. Variables Description Map Map object on which to place custom markers. Location Strings List of locations in latitude, longitude where the markers will spawn. Spawn Scale Scale of spawned markers. Applied as uniform scale in all directions. Custom Prefab Prefab that will be spawned on the map as the marker. Understand quadtree tile provider Web Mercator tile services use a quadtree structure to provide tiles at different zoom levels. The QuadTreeTileProvider script leverages this quadtree structure to request tiles for the area of interest. QuadTreeTileProvider uses the location in latitude, longitude, the camera's viewport, and the map's zoom level to determine the area of interest. QuadTreeTileProvider provides a way to create a zoomable map without moving the camera in the scene. The map's root and individual UnityTile objects are scaled appropriately to provide zooming capability, similar to traditional web-based maps. QuadTreeTileProvider also provides an API call to update the map when the location and/or zoom level changes. Benefits and limitations Using this map gives you a runtime, zoomable map instead of a static map. It takes care of the tile scaling and map scaling for you so you can look at a map at different zoom levels. It also decouples the camera from the map for zooming. By default this example only provides a top-down 2D view of the map, without vector data. Was this page helpful? Yes No",,Zoomable map,Using the SpawnOnMap example script,Understand quadtree tile provider,Benefits and limitations,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Satellite,Mapbox Satellite is a global basemap of high-resolution satellite imagery.,https://docs.mapbox.com/help/glossary/mapbox-satellite/,glossary,,,"Mapbox Satellite Mapbox Satellite is a global basemap of high-resolution satellite imagery. The imagery data comes from a variety of commercial providers, as well as open data from NASA, USGS, and others. It’s color-corrected and blended together into a single raster tileset. Mapbox Satellite is available for free to all users at zoom levels 0-19 in the Mapbox Studio style editor and with our APIs and SDKs by using the style URL mapbox://styles/mapbox/satellite-v9 or tileset ID mapbox.satellite. Was this page helpful? Yes No",,Mapbox Satellite,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Change your map’s label language,Learn about available languages and how to change your map’s language.,https://docs.mapbox.com/help/troubleshooting/change-language/,troubleshooting,,,"Change your map’s label language When building a map from a Mapbox template style, map labels will appear in English by default. You can change the language of your map's labels directly in the Mapbox Studio style editor or dynamically using Mapbox GL JS, the Mapbox Maps SDK for Android, or the Mapbox Maps SDK for iOS. This guide also outlines changing label language in Mapbox Studio Classic. Languages available All Mapbox template maps use the Mapbox Streets vector tileset for map features. In this tileset, there are different name fields for each of the label layers: name — the name or names used locally for the place name_en — English (if available) name_es — Spanish (if available) name_fr — French (if available) name_de — German (if available) name_ru — Russian (if available) name_zh — Chinese (if available) name_zh-Hans — Simplified Chinese (if available) name_pt — Portuguese (if available) name_ar — Arabic (if available) name_ja — Japanese (if available) name_ko — Korean (if available) Note For the Spanish, French, and German labels, there are additional fallback conditions. Where the local name is in a non-Latin writing system and no Spanish/French/German translation is available, these fields will show an English or international version of the name if possible, otherwise they will show the local name. Note The name_zh field contains Mandarin using simplified Chinese characters for our custom label layers: #country_label, #state_label, and #marine_label. All other label layers are sourced from OpenStreetMap and may contain one of several dialects and either simplified or traditional Chinese characters in the name_zh field. The name_zh-Hans field is similar, except any traditional Chinese characters are automatically transformed to Simplified Chinese. Right-to-left language support Mapbox GL JS The mapbox-gl-rtl-text plugin adds support for text written in the Arabic and Hebrew languages. Mapbox Studio Mapbox Studio loads the mapbox-gl-rtl-text plugin by default. Change label language in Mapbox Studio Layer by layer Create a new style or edit an existing one in Mapbox Studio. Select the layer that contains the labels you'd like to edit. Under the Text tab, click the value next to Text field. A panel will appear with all language options for the layer. Click the desired language; the map will update on select. Multiple layers at once Instead of changing each label layer individually, you can use the Filter layers panel to change all the label layer's languages at once. Click the Filter layers panel and then Filter by value. Choose Text fields from the list of categories and select each instance of { name_en } from the list. As you choose each of these, you will see your list of layers grow. Click on the top of the layer list, hold down the Shift key, and click on the last layer in the list. Once all the layers have been selected, you will be prompted to choose a value for all the layers. Your browser doesn't support embedded videos. Change label language dynamically Mapbox GL JS If you are comfortable with JavaScript, you can change the language of your labels dynamically by using the .setLayoutProperty() method in Mapbox GL JS. See the language switcher Mapbox GL JS example for more details. You can also use the Mapbox GL Language plugin to automatically change the layers of a map style to use the text-field that matches the browser language. Read more about this and other capabilities of the Mapbox GL Language plugin on GitHub. Mapbox Maps SDK for Android With the Mapbox Maps SDK for Android, you can change the language of labels on your map dynamically at runtime. For example, here's how you would change a map's city labels to Russian: Layer singleMapLayer = map.getStyle().getLayer(""settlement-label""); singleMapLayer.setProperties(textField("" { name_ru } "")); You could also use the Mapbox Localization Plugin for Android if you want to change the language of the entire map all at once. This plugin detects the set language of the Android device and then changes all map text to that language. The plugin also enables you to change the entire map to a specific language. This could be useful if you want to provide your user the ability to switch the map to a specific language at a specific time, rather than locking the map to the device's set default language or a particular language. Mapbox Maps SDK for iOS With the Mapbox Maps SDK for iOS, you can automatically change the language of labels to the system's preferred language at runtime. swift objective-c func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { style.localizeLabels(into: nil) } Copy You can also change labels to a specific language, either throughout the map or only for certain kinds of labels: swift objective-c // 'style' in this case refers to an MGLStyle object. let layer = style.layer(withIdentifier: ""place-city-sm"") as! MGLSymbolStyleLayer let spanish = Locale(identifier: ""es"") layer.text = layer.text.mgl_expressionLocalized(into: spanish) Copy See the Maps SDK for iOS documentation for more information. Change label language in Mapbox Studio Classic Most of the Mapbox preset styles in Mapbox Studio Classic will have a @name variable in the CartoCSS. This is where you can set the language. Below are the options and an example of how to set the value of @name to '[name_en]' or English labels. // Language options: name (local), name_en, name_fr, name_es, name_de @name: '[name_en]'; Swap out any of the language options inside the brackets to change your labels to that language. Next, you must set all the labels with the property text-name with the value @name. For example: #country_label[zoom>=3] { text-name: @name; ... } Was this page helpful? Yes No",,Change your map’s label language,Right-to-left language support,Mapbox GL JS,Mapbox Studio,Change label language in Mapbox Studio,Layer by layer,Multiple layers at once,Change label language dynamically,Mapbox Maps SDK for Android,Mapbox Maps SDK for iOS,Change label language in Mapbox Studio Classic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Local search with the Geocoding API,This tutorial guides you through the process of creating a local search app using optional parameters from the Mapbox Geocoding API.,https://docs.mapbox.com/help/tutorials/local-search-geocoding-api/,tutorial,JavaScript,,"intermediate JavaScript Local search with the Geocoding API Prerequisite Familiarity with front-end development concepts. The Mapbox Geocoding API allows you to make forward geocodes, which means that a text query like University of California Berkeley gets turned into longitude and latitude coordinates. But sometimes it's not enough to find query results. Often, you want the geocoder to find query results that are biased toward a location, limited to a specific area, or both. The Mapbox geocoder has built-in ranking that influences what results are returned, and in what order. (Read more about how search results are ranked in the How geocoding works guide.) You can also make your Geocoding API requests even more specific by including optional query parameters. In this tutorial, you will use the Geocoding API's proximity and bbox parameters to create a local search app for UC Berkeley that limits results to the Berkeley area and biases results around the campus itself.   View finished map. Getting started To complete this tutorial, you will need: A Mapbox account and access token. Sign up for an account at mapbox.com/signup. Your access tokens are on your Account page. Mapbox GL JS. Mapbox GL JS is a JavaScript API for building web maps. A text editor. Use the text editor of your choice for writing HTML, CSS, and JavaScript. Geocoding API query structure All Mapbox API queries must specify the API being used and the API version: https://api.mapbox.com/ { api_service } / { version } The API service used in this tutorial is geocoding and the version is v5. https://api.mapbox.com/geocoding/v5 Calls to the Geocoding API must also include the endpoint being used, which will either be mapbox.places or mapbox.places-permanent. (mapbox.places-permanent allows for permanent storage of results and for batch geocoding, and is only available to Enterprise customers that have a license for permanent geocodes.) The following examples use the mapbox.places endpoint. https://api.mapbox.com/geocoding/v5/mapbox.places Required parameters A query to the Geocoding API must contain search text. The search text is either a text string for forward geocodes, or a set of coordinates for reverse geocodes. This forward geocoding example's search text is San Francisco: https://api.mapbox.com/geocoding/v5/mapbox.places/San%20Francisco.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Regardless of whether you're performing a forward or reverse geocode, the search text needs to be followed by .json, since the response will be returned as a GeoJSON object. Optional parameters Now comes the fun part! The Geocoding API's optional parameters allow you to customize your query so that you receive the results that are the most relevant to you. For the full list of the optional parameters that a forward geocoding request can use, see the Geocoding API documentation. This tutorial will use two optional parameters that are especially useful for biasing results to a specific geographic location: proximity and bbox. View the results of an API request To see the results of the example queries in the following sections, copy the API call and paste it into your browser's address bar. Add your own Mapbox access token to the end of each example. You will see the response to the API query output in GeoJSON format. The proximity parameter The proximity parameter allows you to bias the response in favor of results that are closer to a specified location. This makes sure that the query results that are closer to this location are prioritized over ones that are further away. The parameter must be formatted as two comma-separated coordinates in longitude,latitude order. To find the coordinates of a location, you can use the Mapbox Search Playground. # Prioritizes Peets' locations in San Francisco https://api.mapbox.com/geocoding/v5/mapbox.places/peets.json?proximity=-122.3995752,37.7881856&access_token= YOUR_MAPBOX_ACCESS_TOKEN # Prioritizes Peets' locations in and around Berkeley https://api.mapbox.com/geocoding/v5/mapbox.places/peets.json?proximity=-122.2727469,37.8715926&access_token= YOUR_MAPBOX_ACCESS_TOKEN Since the proximity parameter is not exclusive, it does not restrict results to an area, but relevant results that are close to the provided coordinates are returned before relevant results that are further away. The bbox parameter The bbox parameter allows you to limit results to only those contained within a supplied bounding box. Bounding boxes need to be formatted as four coordinates separated by commas, in minLon,minLat,maxLon,maxLat order. You can use any coordinates for a bounding box, as long as they describe a box shape. To find the coordinates for a bounding box, you can use the Mapbox Search Playground. # Search for Starbucks in the Washington DC area https://api.mapbox.com/geocoding/v5/mapbox.places/starbucks.json?bbox=-77.083056,38.908611,-76.997778,38.959167&access_token= YOUR_MAPBOX_ACCESS_TOKEN The bbox parameter is exclusive, meaning that it will exclude any results that fall outside of the specified boundary. Build the Geocoding API query Now that you have seen how to use some of the Geocoding API's optional parameters to bias results around a location and restrict results to an area, you can use them in an app. This tutorial walks you through the process of creating an app that restricts results to a set area, and then biases the results around a landmark. In this case, the set area will be Berkeley, California, and the landmark will be the UC Berkeley campus. Using cURL, a Geocoding API query that uses proximity to bias results around the Berkeley campus and uses bbox to limit results to the Berkeley area would look like: # Search text is ""coffee"" # `proximity` is set to the coordinates of the campus # `bbox` is set to encompass Berkeley CA https://api.mapbox.com/geocoding/v5/mapbox.places/coffee.json?proximity=-122.25948,37.87221&bbox=-122.30937,37.84214,-122.23715,37.89838&access_token= YOUR_MAPBOX_ACCESS_TOKEN Geocoding plugins and libraries The Geocoding API's optional parameters give you powerful ways to customize your queries, but it can be unwieldy to use raw cURL API calls in your applications. The Mapbox geocoder is available through several plugins and wrapper libraries that can help you integrate it into an app: Mapbox GL JS Geocoder Mapbox.js Geocoder Mapbox Java SDK MapboxGeocoder.swift Mapbox JavaScript SDK React Geocoder This tutorial uses the Mapbox GL JS Geocoder plugin. Create your app To create the local search app, you will create an HTML file and initialize the map. Then you will add the Mapbox GL JS Geocoder plugin and set the bbox and proximity parameters. Once the app is running, you will use your browser's developer tools to see how the browser interprets the Geocoder plugin's API request. Set up your HTML file Open your text editor and create a new file named index.html. Set up this new HTML file by pasting the following code into your text editor. This code creates the structure of the page. There is a <div> element with the ID map in the <body> of the page. This <div> is the container in which the map will be displayed on the page. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Local search app</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> </body> </html> Initialize the map Next, you will add the Mapbox GL JS code that initializes a map, which will be displayed in the <div> you created in the last step. In index.html, place the following snippet above the closing </body> tag. Make sure that you set the mapbox.accessToken variable equal to your Mapbox access token. <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Container ID style: 'mapbox://styles/mapbox/streets-v 11 ', // Map style to use center: [-122.25948, 37.87221], // Starting position [lng, lat] zoom: 12, // Starting zoom level } ); </script> This Mapbox GL JS code sets a style for the map, gives it coordinates on which to center, and sets a zoom level. Save your changes. Open the HTML file in your browser to see the rendered map. Add a marker to the map The next step is to add a marker to the map at the campus's coordinates to show the landmark's location. After the initialization code that you wrote in the last step, add the following snippet to add a marker to the map: var marker = new mapboxgl.Marker() // initialize a new marker .setLngLat([-122.25948, 37.87221]) // Marker [lng, lat] coordinates .addTo(map); // Add the marker to the map Save your changes and refresh the page in your browser. There will be a marker on the map at the specified coordinates. Add the geocoder The next step is to add a geocoder using the Mapbox GL JS Geocoder plugin. To do this, first you need to add links to the geocoder's JavaScript and CSS to the head of the HTML file. <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.min.js'></script> <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.css' type='text/css' /> Once these links have been added, you will be able to use the Mapbox GL JS Geocoder plugin in your app. Next, add the following code above the closing </script> tag in your HTML file. var geocoder = new MapboxGeocoder( { // Initialize the geocoder accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style } ); // Add the geocoder to the map map.addControl(geocoder); The app you are building for this tutorial limits search results to a specific location. To give your users a visual reminder of this fact, you will use the placeholder parameter in the Geocoder to set custom text to display in the search bar. Add the following line to the plugin, after the access token: placeholder: 'Search for places in Berkeley' Save your changes. Refresh the page in your browser, and you will see that a geocoder search box with custom text has been added to the map. When you type a search term into the box and select a result, the map flies to that location. Add the bbox and proximity parameters Inside the map.addControl statement you added in the last step, after the placeholder parameter, add the bbox and proximity parameters. In the Mapbox GL JS Geocoder plugin, the bbox parameter must be formatted as an array. The proximity parameter must be formatted as an object with a longitude property and a latitude property. (For more information on how to format query parameters, see the Mapbox GL JS Geocoder plugin documentation.) With the addition of these parameters, the entire statement will look like: var geocoder = new MapboxGeocoder( { // Initialize the geocoder accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style placeholder: 'Search for places in Berkeley', // Placeholder text for the search bar bbox: [-122.30937, 37.84214, -122.23715, 37.89838], // Boundary for Berkeley proximity: { longitude: -122.25948, latitude: 37.87221 } // Coordinates of UC Berkeley } ); Save the HTML file and refresh the page in your browser. Now, when you enter a search into the geocoder's search box, you will not receive any results outside of the bounding box. And the results that the geocoder returns are weighted according to their proximity to the Berkeley campus. Place markers at selected results Adding a custom marker style The Mapbox GL Geocoder sets a marker at the search result location by default. This example adds a custom marker as a new layer instead. If you want to use the default marker provided by the geocoder, remove the line marker: false, from the new geocoder instantiation. The final step for creating this app is to place a custom marker on the map at the location of a selected search result. The logic for doing this needs to be wrapped in a map.on('load') event so that it is not triggered before the map itself has been loaded. Before the closing </script> tag, paste the following JavaScript: // After the map style has loaded on the page, // add a source layer and default styling for a single point map.on('load', function() { map.addSource('single-point', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } } ); map.addLayer( { id: 'point', source: 'single-point', type: 'circle', paint: { 'circle-radius': 10, 'circle-color': '#448ee4' } } ); // Listen for the `result` event from the Geocoder // `result` event is triggered when a user makes a selection // Add a marker at the result's coordinates geocoder.on('result', function(e) { map.getSource('single-point').setData(e.result.geometry); } ); } ); Save the HTML file and refresh the page in your browser. When search and select a result, a marker will be placed at the result's coordinates. View the API call in developer tools To see what's going on behind the scenes when you use the Mapbox GL JS Geocoder plugin, you can view the raw API call using your browser's developer tools. This can be useful for debugging a query if the returned results are not what you expect. How do I open developer tools? The following instructions are for Chrome's developer tools layout. For other browsers, some details may vary but in general the workflow will be similar. Read your browser's help page for details on how to open the developer tools and find the network information. Load the page you created in this tutorial in your browser, or refresh it if it's already open. Open the browser's developer tools. (In Chrome, you can do this by typing command + option + i or command + option + j.) Type a text phrase into the app's geocoder search bar and select a result. (The example below is for the search term ""coffee"".) Click on the Network tab. In the Filter search bar, type in ""geocoding"". This will narrow the list of network calls down to those made by the Mapbox Geocoding API. You will likely see more than one Geocoding API call in the list, each representing a different stage of the search text. Click on the option that has the complete search text (for example, ""coffee"" instead of ""coff""). In the Request URL section, you will see a request that is like the cURL API request that you created in the Build the Geocoding API query section of this tutorial: https://api.mapbox.com/geocoding/v5/mapbox.places/coffee.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN &proximity=-122.259%2C37.872&bbox=-122.30937%2C37.84214%2C-122.23715%2C37.89838&limit=5 The difference between the query returned by the browser and the one you created earlier is that this one also includes the limit parameter, with the default value of 5 passed in. Finished product You have completed a local search app that, when a user enters a query into the geocoder search box, biases the results around the UC Berkeley campus and excludes any results that are located outside the Berkeley area.   View finished map. The final HTML file will look like the following: <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Local search app</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.min.js'></script> <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.css' type='text/css' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Container ID style: 'mapbox://styles/mapbox/streets-v 11 ', // Map style to use center: [-122.25948, 37.87221], // Starting position [lng, lat] zoom: 12, // Starting zoom level } ); var marker = new mapboxgl.Marker() // Initialize a new marker .setLngLat([-122.25948, 37.87221]) // Marker [lng, lat] coordinates .addTo(map); // Add the marker to the map var geocoder = new MapboxGeocoder( { // Initialize the geocoder accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style placeholder: 'Search for places in Berkeley', // Placeholder text for the search bar bbox: [-122.30937, 37.84214, -122.23715, 37.89838], // Boundary for Berkeley proximity: { longitude: -122.25948, latitude: 37.87221 } // Coordinates of UC Berkeley } ); // Add the geocoder to the map map.addControl(geocoder); // After the map style has loaded on the page, // add a source layer and default styling for a single point map.on('load', function() { map.addSource('single-point', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } } ); map.addLayer( { id: 'point', source: 'single-point', type: 'circle', paint: { 'circle-radius': 10, 'circle-color': '#448ee4' } } ); // Listen for the `result` event from the Geocoder // `result` event is triggered when a user makes a selection // Add a marker at the result's coordinates geocoder.on('result', function(ev) { map.getSource('single-point').setData(ev.result.geometry); } ); } ); </script> </body> </html> Next steps There are a lot of things you could do to build this app out more. You could: Use Turf.js to analyze the distances of the various results from the UC Berkeley campus. (See the Sort stores by distance tutorial.) Experiment with the Mapbox GL JS Geocoder plugin's filter function to get even more granular results. (See the Limit geocoder results to a named region example.) Was this page helpful? Yes No",,Local search with the Geocoding API,Geocoding API query structure,Required parameters,Optional parameters,The proximity parameter,The bbox parameter,Build the Geocoding API query,Geocoding plugins and libraries,Create your app,Set up your HTML file,Initialize the map,Add a marker to the map,Add the geocoder,Add the bbox and proximity parameters,Place markers at selected results,View the API call in developer tools,Finished product,2,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display a popup,Add a Popup to the map.,https://docs.mapbox.com/mapbox-gl-js/example/popup/,example,JavaScript,,Display a popup Add a Popup to the map. Was this example helpful? Yes No,,Display a popup,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,classic style,A classic style is a map style made with Mapbox Studio Classic.,https://docs.mapbox.com/help/glossary/classic-style/,glossary,,,"classic style Note Mapbox Studio Classic, which uses classic styles, is no longer in active development. To learn more about our newer mapping tools see Mapbox Studio styles. In Mapbox Studio Classic, a classic style contains CartoCSS stylesheets, thin metadata (name, description, attribution, etc.), and a reference to a source. After you upload a classic style to Mapbox.com, it will appear on your Classic styles page. Was this page helpful? Yes No",,classic style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Highlight features within a bounding box,Hold the Shift key and drag the map to query features using queryRenderedFeatures.,https://docs.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/,example,JavaScript,,Highlight features within a bounding box Hold the Shift key and drag the map to query features using queryRenderedFeatures. Was this example helpful? Yes No,,Highlight features within a bounding box,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Opacity fade,Adjust the opacity of a satellite raster layer based on zoom level.,https://docs.mapbox.com/android/maps/examples/satellite-opacity-on-zoom/,example,Java,,"Opacity fade Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.basics.SimpleMapViewActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""30.044"" mapbox:mapbox_cameraTargetLng=""31.235"" mapbox:mapbox_cameraZoom=""10"" mapbox:mapbox_cameraZoomMin=""6"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.RasterLayer; import com.mapbox.mapboxsdk.style.sources.RasterSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.linear; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.rasterOpacity; /** * Create an effect of seamlessly fading from one map style to another with runtime styling opacity. * Go from the Mapbox Streets style to a satellite photo raster layer as the map camera zooms in. * This is similar to how Snap uses Mapbox for Snap Maps. */ public class SatelliteOpacityOnZoomActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_satellite_opacity_on_zoom); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Create a data source for the satellite raster image and add the source to the map style.addSource(new RasterSource(""SATELLITE_RASTER_SOURCE_ID"", ""mapbox://mapbox.satellite"", 512)); // Create a new map layer for the satellite raster images and add the satellite layer to the map. // Use runtime styling to adjust the satellite layer's opacity based on the map camera's zoom level style.addLayer( new RasterLayer(""SATELLITE_RASTER_LAYER_ID"", ""SATELLITE_RASTER_SOURCE_ID"").withProperties( rasterOpacity(interpolate(linear(), zoom(), stop(15, 0), stop(18, 1) )))); // Create a new camera position and animate the map camera to show the fade in/out UI of the satellite layer mapboxMap.animateCamera( CameraUpdateFactory.newCameraPosition(new CameraPosition.Builder() .zoom(19) .build()), 9000); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Opacity fade,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Style circles categorically,Using a categorical circle-color property function for a visualization.,https://docs.mapbox.com/android/maps/examples/style-circles-categorically/,example,Java,,"Style circles categorically Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.basics.SimpleMapViewActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.753574"" mapbox:mapbox_cameraTargetLng=""-122.447303"" mapbox:mapbox_cameraZoom=""12"" /> </RelativeLayout> Copy Activity View on GitHub Java Kotlin package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.match; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; /** * Use data-driven styling to set circles' colors based on imported vector data. */ public class StyleCirclesCategoricallyActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_style_circles_categorically); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource(new VectorSource( ""ethnicity-source"", ""http://api.mapbox.com/v4/examples.8fgz4egr.json?access_token="" + Mapbox.getAccessToken() )); CircleLayer circleLayer = new CircleLayer(""population"", ""ethnicity-source""); circleLayer.setSourceLayer(""sf2010""); circleLayer.withProperties( circleRadius( interpolate( exponential(1.75f), zoom(), stop(12, 2f), stop(22, 180f) )), circleColor( match(get(""ethnicity""), rgb(0, 0, 0), stop(""white"", rgb(251, 176, 59)), stop(""Black"", rgb(34, 59, 83)), stop(""Hispanic"", rgb(229, 94, 94)), stop(""Asian"", rgb(59, 178, 208)), stop(""Other"", rgb(204, 204, 204))))); style.addLayer(circleLayer); } }); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Style circles categorically,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Mock navigation,Mock a navigation session using a mock location engine.,https://docs.mapbox.com/android/navigation/examples/mock-navigation/,example,Java,,"Mock navigation Activity View on GitHub package com.mapbox.services.android.navigation.testapp.activity; import android.annotation.SuppressLint; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.location.Location; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.design.widget.BaseTransientBottomBar; import android.support.design.widget.FloatingActionButton; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.Toast; import com.mapbox.android.core.location.LocationEngine; import com.mapbox.android.core.location.LocationEngineCallback; import com.mapbox.android.core.location.LocationEngineResult; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Point; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.annotations.MarkerOptions; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.services.android.navigation.testapp.R; import com.mapbox.services.android.navigation.testapp.Utils; import com.mapbox.services.android.navigation.testapp.activity.notification.CustomNavigationNotification; import com.mapbox.services.android.navigation.ui.v5.route.NavigationMapRoute; import com.mapbox.services.android.navigation.v5.instruction.Instruction; import com.mapbox.services.android.navigation.v5.location.replay.ReplayRouteLocationEngine; import com.mapbox.services.android.navigation.v5.milestone.Milestone; import com.mapbox.services.android.navigation.v5.milestone.MilestoneEventListener; import com.mapbox.services.android.navigation.v5.milestone.RouteMilestone; import com.mapbox.services.android.navigation.v5.milestone.Trigger; import com.mapbox.services.android.navigation.v5.milestone.TriggerProperty; import com.mapbox.services.android.navigation.v5.navigation.MapboxNavigation; import com.mapbox.services.android.navigation.v5.navigation.MapboxNavigationOptions; import com.mapbox.services.android.navigation.v5.navigation.NavigationEventListener; import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute; import com.mapbox.services.android.navigation.v5.navigation.RefreshCallback; import com.mapbox.services.android.navigation.v5.navigation.RefreshError; import com.mapbox.services.android.navigation.v5.navigation.RouteRefresh; import com.mapbox.services.android.navigation.v5.offroute.OffRouteListener; import com.mapbox.services.android.navigation.v5.routeprogress.ProgressChangeListener; import com.mapbox.services.android.navigation.v5.routeprogress.RouteProgress; import com.mapbox.turf.TurfConstants; import com.mapbox.turf.TurfMeasurement; import java.lang.ref.WeakReference; import butterknife.BindView; import butterknife.ButterKnife; import butterknife.OnClick; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; public class MockNavigationActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener, ProgressChangeListener, NavigationEventListener, MilestoneEventListener, OffRouteListener, RefreshCallback { private static final int BEGIN_ROUTE_MILESTONE = 1001; private static final double TWENTY_FIVE_METERS = 25d; // Map variables @BindView(R.id.mapView) MapView mapView; @BindView(R.id.newLocationFab) FloatingActionButton newLocationFab; @BindView(R.id.startRouteButton) Button startRouteButton; private MapboxMap mapboxMap; // Navigation related variables private LocationEngine locationEngine; private MapboxNavigation navigation; private DirectionsRoute route; private NavigationMapRoute navigationMapRoute; private Point destination; private Point waypoint; private RouteRefresh routeRefresh; private boolean isRefreshing = false; private static class MyBroadcastReceiver extends BroadcastReceiver { private final WeakReference<MapboxNavigation> weakNavigation; MyBroadcastReceiver(MapboxNavigation navigation) { this.weakNavigation = new WeakReference<>(navigation); } @Override public void onReceive(Context context, Intent intent) { MapboxNavigation navigation = weakNavigation.get(); navigation.stopNavigation(); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_mock_navigation); ButterKnife.bind(this); routeRefresh = new RouteRefresh(Mapbox.getAccessToken(), this); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); Context context = getApplicationContext(); CustomNavigationNotification customNotification = new CustomNavigationNotification(context); MapboxNavigationOptions options = MapboxNavigationOptions.builder() .navigationNotification(customNotification) .build(); navigation = new MapboxNavigation(this, Mapbox.getAccessToken(), options); navigation.addMilestone(new RouteMilestone.Builder() .setIdentifier(BEGIN_ROUTE_MILESTONE) .setInstruction(new BeginRouteInstruction()) .setTrigger( Trigger.all( Trigger.lt(TriggerProperty.STEP_INDEX, 3), Trigger.gt(TriggerProperty.STEP_DISTANCE_TOTAL_METERS, 200), Trigger.gte(TriggerProperty.STEP_DISTANCE_TRAVELED_METERS, 75) ) ).build()); customNotification.register(new MyBroadcastReceiver(navigation), context); } @OnClick(R.id.startRouteButton) public void onStartRouteClick() { boolean isValidNavigation = navigation != null; boolean isValidRoute = route != null && route.distance() > TWENTY_FIVE_METERS; if (isValidNavigation && isValidRoute) { // Hide the start button startRouteButton.setVisibility(View.INVISIBLE); // Attach all of our navigation listeners. navigation.addNavigationEventListener(this); navigation.addProgressChangeListener(this); navigation.addMilestoneEventListener(this); navigation.addOffRouteListener(this); ((ReplayRouteLocationEngine) locationEngine).assign(route); navigation.setLocationEngine(locationEngine); mapboxMap.getLocationComponent().setLocationComponentEnabled(true); navigation.startNavigation(route); mapboxMap.removeOnMapClickListener(this); } } @OnClick(R.id.newLocationFab) public void onNewLocationClick() { newOrigin(); } private void newOrigin() { if (mapboxMap != null) { LatLng latLng = Utils.getRandomLatLng(new double[] {-77.1825, 38.7825, -76.9790, 39.0157}); ((ReplayRouteLocationEngine) locationEngine).assignLastLocation( Point.fromLngLat(latLng.getLongitude(), latLng.getLatitude()) ); mapboxMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, 12)); } } @SuppressLint(""MissingPermission"") @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; this.mapboxMap.addOnMapClickListener(this); mapboxMap.setStyle(Style.MAPBOX_STREETS, style -> { LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent(this, style); locationComponent.setRenderMode(RenderMode.GPS); locationComponent.setLocationComponentEnabled(false); navigationMapRoute = new NavigationMapRoute(navigation, mapView, mapboxMap); Snackbar.make(findViewById(R.id.container), ""Tap map to place waypoint"", BaseTransientBottomBar.LENGTH_LONG).show(); locationEngine = new ReplayRouteLocationEngine(); newOrigin(); }); } @Override public boolean onMapClick(@NonNull LatLng point) { if (destination == null) { destination = Point.fromLngLat(point.getLongitude(), point.getLatitude()); } else if (waypoint == null) { waypoint = Point.fromLngLat(point.getLongitude(), point.getLatitude()); } else { Toast.makeText(this, ""Only 2 waypoints supported"", Toast.LENGTH_LONG).show(); } mapboxMap.addMarker(new MarkerOptions().position(point)); calculateRoute(); return false; } @SuppressLint(""MissingPermission"") private void calculateRoute() { locationEngine.getLastLocation(new LocationEngineCallback<LocationEngineResult>() { @Override public void onSuccess(LocationEngineResult result) { findRouteWith(result); } @Override public void onFailure(@NonNull Exception exception) { Timber.e(exception); } }); } private void findRouteWith(LocationEngineResult result) { Location userLocation = result.getLastLocation(); if (userLocation == null) { Timber.d(""calculateRoute: User location is null, therefore, origin can't be set.""); return; } Point origin = Point.fromLngLat(userLocation.getLongitude(), userLocation.getLatitude()); if (TurfMeasurement.distance(origin, destination, TurfConstants.UNIT_METERS) < 50) { startRouteButton.setVisibility(View.GONE); return; } final NavigationRoute.Builder navigationRouteBuilder = NavigationRoute.builder(this) .accessToken(Mapbox.getAccessToken()); navigationRouteBuilder.origin(origin); navigationRouteBuilder.destination(destination); if (waypoint != null) { navigationRouteBuilder.addWaypoint(waypoint); } navigationRouteBuilder.enableRefresh(true); navigationRouteBuilder.build().getRoute(new Callback<DirectionsResponse>() { @Override public void onResponse(@NonNull Call<DirectionsResponse> call, @NonNull Response<DirectionsResponse> response) { Timber.d(""Url: %s"", call.request().url().toString()); if (response.body() != null) { if (!response.body().routes().isEmpty()) { MockNavigationActivity.this.route = response.body().routes().get(0); navigationMapRoute.addRoutes(response.body().routes()); startRouteButton.setVisibility(View.VISIBLE); } } } @Override public void onFailure(@NonNull Call<DirectionsResponse> call, @NonNull Throwable throwable) { Timber.e(throwable, ""onFailure: navigation.getRoute()""); } }); } /* * Navigation listeners */ @Override public void onMilestoneEvent(RouteProgress routeProgress, String instruction, Milestone milestone) { Timber.d(""Milestone Event Occurred with id: %d"", milestone.getIdentifier()); Timber.d(""Voice instruction: %s"", instruction); } @Override public void onRunning(boolean running) { if (running) { Timber.d(""onRunning: Started""); } else { Timber.d(""onRunning: Stopped""); } } @Override public void userOffRoute(Location location) { Toast.makeText(this, ""off-route called"", Toast.LENGTH_LONG).show(); } @Override public void onProgressChange(Location location, RouteProgress routeProgress) { mapboxMap.getLocationComponent().forceLocationUpdate(location); if (!isRefreshing) { isRefreshing = true; routeRefresh.refresh(routeProgress); } Timber.d(""onProgressChange: fraction of route traveled: %f"", routeProgress.fractionTraveled()); } /* * Activity lifecycle methods */ @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); navigation.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onRefresh(DirectionsRoute directionsRoute) { navigation.startNavigation(directionsRoute); isRefreshing = false; } @Override public void onError(RefreshError error) { isRefreshing = false; } private static class BeginRouteInstruction extends Instruction { @Override public String buildInstruction(RouteProgress routeProgress) { return ""Have a safe trip!""; } } } Copy Was this page helpful? Yes No",,Mock navigation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Transition from Mapbox.js to Mapbox GL JS,Learn about transitioning from using Mapbox.js to using Mapbox GL JS in your apps.,https://docs.mapbox.com/help/troubleshooting/transition-from-mapbox-js-to-mapbox-gl-js/,troubleshooting,,,"Transition from Mapbox.js to Mapbox GL JS Mapbox provides many tools to build maps into your website or web-based application, including Mapbox GL JS and Mapbox.js. Mapbox GL JS and Mapbox.js are both open source JavaScript libraries you can use to display your Mapbox maps, add interactivity, and customize the map experience in your application. There are some important differences between the two libraries, though, that will impact how you use them to build your apps. Mapbox.js No longer in active development Supports raster tiles Tiles are generated by the server Map styles can't be changed in the browser, but map overlays can be styled dynamically Mapbox GL JS In active development — we are adding new features, improving existing features, and fixing bugs Supports vector tiles Maps are rendered client-side by the browser Map data and styles can be changed dynamically If you’re using the Mapbox.js library, making the switch to Mapbox GL JS can lead to improvements with the performance of your existing applications. The advantages provided by Mapbox GL JS make the work required to switch from Mapbox.js to Mapbox GL JS worth the effort. The purpose of this guide is to highlight equivalent resources and transferrable resources that Mapbox users can take advantage of when they switch from Mapbox.js to Mapbox GL JS. While every use case is unique, this document will give you a good overview of the kind of work that will be necessary to make this transition. Equivalent resources When you transition from using Mapbox.js to using Mapbox GL JS, you will likely want to recreate your app's original functionality as closely as possible. This means that you will need to take advantage of resources that allow you to have the same action or effect in Mapbox GL JS that you had when using Mapbox.js. The following list of common Leaflet and Mapbox.js resources and their Mapbox GL JS equivalents will help you know which tools to use as you switch libraries. Initialize a map Constructing a new map object in Mapbox GL JS involves many of the same pieces of information that are needed to initialize a map in Mapbox.js. You need your Mapbox access token, a center point (an array of coordinates), a zoom level (a number between 0 and 22), and an HTML element in which to place the map (specified by referencing the HTML element's id). Both Mapbox.js and Mapbox GL JS also allow you to specify the style of the map. How the style is specified is the biggest difference you will see when initializing your map. Mapbox.js expects a tileset ID, which references a tileset. Mapbox GL JS expects a style URL, which refers to a style.json file (a JSON object that conforms to the Mapbox Style Specification and specifies what data to use and how to style that data). It is not possible to convert a tileset to style JSON. Refer to the initialization syntax below to see the differences in action. Mapbox.js In Mapbox.js, you can initialize a new map with the following JavaScript: var map = L.mapbox.map('map', 'mapbox.streets') // HTML container ID, Mapbox tileset .setView([40, -74.50], 9); // starting coordinates as [lat, lng], zoom level The L.mapbox.map method, inherited from Leaflet L.map, references map, the HTML container ID for the map. It uses the .setView method to set the map view’s starting position in [latitude,longitude] format as well as the initial zoom level. While Mapbox.js uses [latitude, longitude] coordinate order, Mapbox GL JS uses [longitude, latitude] order. It also references mapbox://styles/mapbox/streets-v10, a Mapbox map style added as a styleLayer. The map you see in your browser is composed of raster tiles. It is essentially a set of images that are arranged to display the whole world (at low zoom levels) or the area you are viewing (at higher zoom levels). View the Initialize a map example Mapbox GL JS In Mapbox GL JS, you can initialize a new map with the following JavaScript: var map = new mapboxgl.Map( { container: 'map', // HTML container ID style: 'mapbox://styles/mapbox/streets-v9', // style URL center: [-21.9270884, 64.1436456], // starting position as [lng, lat] zoom: 13 } ); The new mapboxgl.Map method references map, which again is the ID of the HTML container for the map. It also references the style URL for Mapbox Streets v9, a default Mapbox style. That style URL refers to Mapbox Streets v9's style.json file for information on how to style the data on the map. Finally, it sets the map's [longitude, latitude] starting position and the map's initial zoom level. Remember that Mapbox GL JS uses [longitude, latitude] coordinate format, while Mapbox.js uses [latitude, longitude] format. The map you see in your browser is rendered dynamically by combining vector tiles with the style.json file of the style that was referenced in the initialization code. View the Display a map example Add a marker The way that markers are added to a map in Mapbox GL JS is different than the way they are added in Mapbox.js. Mapbox.js allows you to use markers that are styled using simplestyle-spec to set the icon and color of the marker. With Mapbox GL JS, you do not use simplestyle to style markers. Instead, you can use the default marker style, or you can specify a background image for the marker div using CSS. Mapbox.js The Mapbox.js L.mapbox.marker.icon method, which inherits from L.Marker in Leaflet, lets you add a marker to a map and style it in the same step. The resulting marker is an actual image on top of the map. L.marker([37.9, -77], { // [lat, lng] coordinates to place the marker at icon: L.mapbox.marker.icon( { 'marker-size': 'large', // specify the size of the marker 'marker-symbol': 'bus', // specify the symbol to use in the marker 'marker-color': '#fa0' // specify the color of the marker } ) } ).addTo(map); // add the marker to the map View the Single marker example Mapbox GL JS The Mapbox GL JS new maboxgl.Marker.addTo method attaches the new marker image to the map as a DOM element. The default Mapbox marker is a light blue, droplet-shaped SVG marker. Since this default marker is a DOM element, you can override its styling with CSS if you choose to. (This technique is demonstrated in the Add custom icons with markers example.) var marker = new mapboxgl.Marker() .setLngLat([30.5, 50.5]) // [lng, lat] coordinates to place the marker at .addTo(map); // add the marker to the map This method works well for adding individual markers to a map. If you are using a lot of markers for point data, adding the data as symbol or circle layers provides better performance. But if you add the data to your map using map.addLayer, these new circle or symbol layers are specified in the style.json file and are not DOM elements. View the Add custom markers in Mapbox GL JS tutorial Add a layer One major difference between Mapbox.js and Mapbox GL JS is how these libraries treat feature layers. This has a big impact on how you will reference and use layers in your maps. Mapbox.js In Mapbox.js, a new layer can be added to a map with the following JavaScript: var featureLayer = L.mapbox.featureLayer('mapbox.dc-markers') .addTo(map); The L.mapbox.featureLayer method, which is inherited from Leaflet’s L.FeatureGroup method, allows you to add a new layer to your map. The source can be GeoJSON, or it can be a URL pointing to a tileset or map style. The new layer is added to your map as a DOM element. If you are using a GeoJSON source with Mapbox.js, you may be styling features using simplestyle. While you can't style features in Mapbox GL JS layers using simplestyle, you can repurpose the simplestyle-related properties in your GeoJSON to style features with data-driven styling in Mapbox GL JS. Use featureLayer with a GeoJSON source: View the Distance between two markers example Style layer features with simplestyle: View the L.mapbox.simplestyle with L.geoJson example Mapbox GL JS In Mapbox GL JS, each layer provides rules about how the renderer will draw certain data in the browser. The renderer uses these layers to draw the map on the screen. Every time you add a layer to a Mapbox GL JS map, you need to specify both a source and a layer: The source determines the geometry and will include any data properties (such as the name of a point or the rank of points of interest). The layer properties influences the appearance of the layer. This includes the type of layer (circle, symbol, fill, etc.), any paint or layout properties to specify the appearance of features, and the source (the geometries that these styles should be applied to). This makes adding a layer is a two-step process: first adding the source data with the map.addSource method, then rendering the layer properties on the map with the map.addLayer method. map.addSource('single-point', { type: 'geojson', // specify the kind of data being added data: { type: 'FeatureCollection', features: [] } } ); map.addLayer( { id: 'point', // the layer's ID source: 'single-point', type: 'circle', // the layer type paint: { 'circle-radius': 10, 'circle-color': '#007cbf' } } ); Note The process of specifying a source and then adding a layer can also be done in one step by specifying a source within the map.addLayer method. In Mapbox GL JS, new layers are added to the top of the style by default. You can also use a layer ID to specify a layer for the new layer to go on top of using addLayer's optional before parameter. This is not possible with Mapbox.js because the rendered map is a flat picture for which you cannot influence the order of the layers. View the Make a heatmap with Mapbox GL JS tutorial Transferable resources Moving from Mapbox.js to Mapbox GL JS will necessarily mean that you will need to recreate your maps using the new framework. Most developers, though, find that many of the resources that they used with Mapbox.js can also be used with Mapbox GL JS with little or no modification. Resource Transferable? Notes Default Mapbox style ✅ If you use a Default Mapbox style, you can update to the Mapbox GL JS version of that style. For example, if you used the Mapbox Classic Streets style with Mapbox.js, you could use Mapbox Streets v9 in your Mapbox GL JS app. Custom data ✅ If you use custom data in Mapbox.js or Leaflet, it can probably be repurposed in Mapbox GL JS. For more information about using data sources in Mapbox GL JS, see the Mapbox Style Specification. Custom markers ✅ In Mapbox GL JS, markers are rendered by the GPU, not the browser, so any images you want to use as markers have to be loaded into a sprite and referenced in your map’s style JSON. You can add custom markers to a sprite in Mapbox Studio. Custom classic style ❌ Custom classic styles made with Mapbox Studio Classic cannot be used with Mapbox GL JS. Recreate your Classic style in Mapbox Studio to take advantage of Studio’s advanced styling features. In a few cases, there are Leaflet or Mapbox.js features without exact equivalents in Mapbox GL JS. Our support staff can help you determine how to create the effect you’re trying to achieve, so contact us if you have questions. Learn more about using Mapbox GL JS To learn more about Mapbox GL JS and how to use it, explore the following resources: Mapbox GL JS examples Mapbox GL JS API reference Improve the performance of Mapbox GL JS maps Working with large GeoJSON sources in Mapbox GL JS Was this page helpful? Yes No",,Transition from Mapbox.js to Mapbox GL JS,Initialize a map,Mapbox.js,Mapbox GL JS,Add a marker,Add a layer,Transferable resources,Learn more about using Mapbox GL JS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Improve the performance of Mapbox GL JS maps,Learn how to improve the performance of your Mapbox GL JS maps.,https://docs.mapbox.com/help/troubleshooting/mapbox-gl-js-performance/,troubleshooting,,,"Improve the performance of Mapbox GL JS maps Model of performance The performance of your Mapbox GL JS maps can be measured as render time, source update time, or layer update time. Render time The render time refers to how quickly Mapbox GL JS draws a map on your screen as you move around or zoom in and out of the map. Render time is a function of the number of sources, the number of layers, and the number of vertices in the features they contain: render time = constant time + [ number of sources * per source time ] + [ number of layers * per layer time ] + [ number of vertices * per vertex time ] Source update time The source update time refers to how quickly changes to a GeoJSON source are visible on the map. Source update time is a function of the number of layers that use the updated source and the number of vertices in the features it contains: source update time = constant time + [ number of layers using the source * per layer time ] + [ number of vertices * per vertex time ] Layer update time The layer update time refers to how quickly changes to a layer, using runtime styling, are visible on the map. Layer update time is a function of the number of vertices in the features the layer contains: layer update time = constant time + [ # of vertices in the layer's source * per vertex time ] Strategies for improving performance When looking for opportunities to improve the performance of your map, look for ways in which you can reduce the number of layers, number of sources, or the complexity of the features in the data that is being rendered. Combine layers Combining layers that use similar styles or that can be styled using data-driven styling will reduce the number of layers, in turn reducing the render time. This strategy works well for layers with many features of the same type (fill, line, circle, symbol, or fill-extrusion) that are either styled similarly or whose styles vary by the value of a specific data field. For more on data-driven styling see the Map design guide and our Graduated circle map tutorial with Mapbox GL JS data-driven styles tutorial. Use vector tileset sources Use vector tileset sources over GeoJSON data sources when possible. The renderer splits features in vector tilesets into tiles which allows GL JS to load only the features that are visible on the map. Feature geometries are also simplified meaning there are fewer vertices resulting in reduced render, source update, and layer update times. This strategy works well when working with large datasets that don't need to be updated quickly. You can create vector tilesets using the Mapbox Uploads API or by uploading data on the Mapbox Studio Tilesets page. Combine vector tile sources Combining sources will reduce the number of sources and, as a result, the render time. This strategy works well when you have data coming from many individual data files. You can combine vector tile sources by either using composited sources or by creating a single vector tileset source with multiple source layers. If you are creating vector tilesets by uploading data to Mapbox Studio, you can create a style and add vector tileset sources using the Mapbox Studio style editor. Vector sources are composited by default in the Mapbox Studio style editor. You can create a single vector tileset source with multiple source layers using the Mapbox Studio Classic desktop application or the command line tool, Tippecanoe. Remove unused features Only include features that are being used in the current style. This will reduce the number of vertices, in turn reducing both render time and source update time. This works well when you are using one of our template styles. You can remove unused features using style-optimized vector tiles. Style-optimized vector tiles are smaller and a way to reduce the size of offline caches. This feature of the Mapbox Vector Tiles API removes any layers or features in the tile that are not used in the style. You can use style-optimized vector tilesets in Mapbox GL JS by adding ?optimize=true to the end of your style URL: var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/outdoors-v10?optimize=true' // optimize=true } ); Example Say you have a style that references a tileset with four layers: campsites, mountains, forestland, and buildings. The final map includes icons for campsites, a pattern for forests, and a pattern for blue mountains, but does not use buildings. In a normal Mapbox GL map, the tiles loaded include all four layers even though they aren’t all needed. A style-optimized vector tile includes only campsites, forestland, and blue mountains. It removes unused layers and features based on attributes and zoom levels. The illustration on the left is a normal vector tileset and the one on the right is a style-optimized vector tileset. Optimize expressions Expressions offer enormous flexibility when filtering and styling map data. There are often several ways to achieve the same visual effect with expressions, but each approach has different performance implications. There are a few guidelines for identifying the most performant expression. Filter by zoom levels Add explicit minzoom and maxzoom values to style layers to prevent filters from being used for evaluation at zoom levels where all geometries will be false. For example, in the Mapbox Streets style, there is a state-label layer. The data for this layer comes from the place_label source layer. Features with a class equal to state only exist at zoom levels between 3 and 9. By specifying a minzoom of 3 and a maxzoom of 9, you avoid applying the filter to many features that you already know will not have the state class. More performant { ""id"": ""state-label"", ""type"": ""symbol"", ""source"": ""composite"", ""source-layer"": ""place_label"", ""minzoom"": 3, ""maxzoom"": 9, ""filter"": [ ""=="", [ ""get"", ""class"" ], ""state"" ] /* layout and paint properties */ } Less performant { ""id"": ""state-label"", ""type"": ""symbol"", ""source"": ""composite"", ""source-layer"": ""place_label"", ""filter"": [ ""=="", [ ""get"", ""class"" ], ""state"" ] /* layout and paint properties */ } Reduce the number of filters If you find yourself applying a significant number of filters to achieve a particular result, consider making adjustments to the data. For example, splitting geometries into multiple source layers to avoid the need for complex filter expressions. You can also adjust your styling strategy. Split your styling objectives into more than one layer so you can use more precise expressions for each layer. There are trade offs between simplifying filters using this approach and reducing layers by using data-driven expressions. Read more about reducing layers using data-driven styling above. Make sure expressions do not produce errors Before applying a condition to a data property, make sure the feature you are applying the condition to has that data property. The errors thrown when attempting to apply a conditional for a property that doesn't exist can have a significant effect on performance. For example, the Mapbox Streets style uses the all expression to filter the roads source layer to display highway shields. This expression first checks if a feature in the source layer has a particular property (reflen), then filters all features that do have the reflen property for those that are less than or equal to six. More performant ""filter"": [ ""all"", [""has"", ""reflen""], [ ""<="", [ ""get"", ""reflen"" ], 6 ], [ ""step"", [ ""zoom"" ], [ ""=="", [ ""geometry-type"" ], ""Point"" ], 11, [ "">"", [ ""get"", ""len"" ], 5000 ], 12, [ "">"", [ ""get"", ""len"" ], 2500 ], 13, [ "">"", [ ""get"", ""len"" ], 1000 ], 14, true ] ] Less performant ""filter"": [ ""all"", /* no `has` expression */ [ ""<="", [ ""get"", ""reflen"" ], 6 ], [ ""step"", [ ""zoom"" ], [ ""=="", [ ""geometry-type"" ], ""Point"" ], 11, [ "">"", [ ""get"", ""len"" ], 5000 ], 12, [ "">"", [ ""get"", ""len"" ], 2500 ], 13, [ "">"", [ ""get"", ""len"" ], 1000 ], 14, true ] ] Order filter conditions from more specific to less specific This will reduce number of geometries going through the next nested filter. Below is another example from the Mapbox Streets style. The Mapbox Streets style includes several tunnel layers. Data used for tunnel layers comes from the road source layer. The road source layer includes many features that are not tunnels. The expression below is used to filter the road source layer for the tunnel-primary-secondary-tertiary style layer: First it narrows from all road features to only features where structure is equal to tunnel. Then, it filters those tunnel features to only include features with primary, secondary, or tertiary classes. This condition is less specific than the first condition. In the entire road source layer, there are far more features with a class of primary, secondary, or tertiary than there are features where structure is equal to tunnel. Finally, it filters those primary, secondary, and tertiary tunnel features to only include lines (not, for example, labels). This condition is less specific than the first two conditions. In the entire road source layer, there are far more features that are lines than there are features with the class or structure listed above. More performant ""filter"": [ ""all"", [ ""=="", [ ""get"", ""structure"" ], ""tunnel"" ], [ ""match"", [ ""get"", ""class"" ], [ ""primary"", ""secondary"", ""tertiary"" ], true, false ], [ ""=="", [ ""geometry-type"" ], ""LineString"" ] ] Less performant ""filter"": [ ""all"", [ ""=="", [ ""geometry-type"" ], ""LineString"" ], [ ""match"", [ ""get"", ""class"" ], [ ""primary"", ""secondary"", ""tertiary"" ], true, false ] [ ""match"", [ ""get"", ""structure"" ], ""tunnel"", true, false ] ] Simplify expressions The simpler a filter or expression is, the better. For example, [""=="", [""get"", ""foo""], ""bar""] is simpler than [""match"", [""get"", ""foo""], ""bar"", true, false]. The match expression is implemented differently than the == expression. It builds a lookup object for matching, and while looking up objects in JS is fast, it is still slower than a simple comparison (which adds up if you do hundreds of thousands of matches for large amounts of data). More performant [ ""=="", [ ""get"", ""structure"" ], ""tunnel"" ] Less performant [ ""match"", [ ""get"", ""structure"" ], ""tunnel"", true, false ] Like match, the case and step expressions can also be simplified when they don't include multiple branches. Style denser features first It's common to group features (for example, landuse) into a single layer and use a data expression on paint properties to differentiate between them. Reorder dense or more visible data so their draw order is prioritized. In the example below, features with the shadow class are more visible than features with the highlight class. To optimize performance, assign a fill-color to shadow features first and highlight features will be assigned the fallback value. More performant ""fill-color"": [ ""match"", [""get"", ""class""], ""shadow"", ""hsl(56, 59%, 22%)"", ""hsl(0, 0%, 100%)"" ] Less performant ""fill-color"": [ ""match"", [""get"", ""class""], ""highlight"", ""hsl(0, 0%, 100%)"", ""hsl(56, 59%, 22%)"" ] Use a separate GeoJSON source for data that needs to be updated rapidly When using a GeoJSON source, any update to it requires Mapbox GL JS to reprocess the entire set of data. If updates must happen quickly and only ever affect a small number of features in a GeoJSON source (for example, changing a few features' property values or moving a single point's location), it may be beneficial to use two sources instead: one with the full, large dataset, used by layers that don't update, and a second one containing only the dynamic, or updated, features used by layers that are specifically showing those features. That way, when you update the dynamic source, you're only reprocessing a small number of features. Example If you have a large dataset with many features, and you want to create a hover effect for a single point at a time, you can use one large source for the regular features and a separate source with only one feature and the hover styles to improve update times. Use feature state Updating data is costly and can negatively impact performance. The feature-state expression allows you to insert new data into a feature at runtime, which will reduce the layer update time. When you need to make hover or selected styles for map features, use the map.setFeatureState method to avoid re-parsing all the geometries at each state change. Note that feature-state can only be used with paint properties that support data-driven styling. Similar layers Layers with matching properties type, source, source-layer, zoom, filter and layout are automatically grouped and rendered faster. For example, you could use a second water layer to create dimension, and because all properties except for those defined in paint are shared they qualify to be grouped and will render faster. Find opportunities for layers that may qualify to be grouped, and make sure they use the same type, source, source-layer, zoom, filter and layout to be grouped and rendered faster. { ""id"": ""water"", ""type"": ""fill"" ""layout"": { } , ""paint"": { ""fill-color"": ""blue"" } } , { ""id"": ""water"", ""type"": ""fill"" ""layout"": { } , ""paint"": { ""fill-color"": ""navy"", ""fill-translate"": [""literal"", [-1, -1]] } } Was this page helpful? Yes No",,Improve the performance of Mapbox GL JS maps,Render time,Source update time,Layer update time,Strategies for improving performance,Combine layers,Use vector tileset sources,Combine vector tile sources,Remove unused features,Optimize expressions,Filter by zoom levels,Reduce the number of filters,Make sure expressions do not produce errors,Order filter conditions from more specific to less specific,Simplify expressions,Style denser features first,Use a separate GeoJSON source for data that needs to be updated rapidly,,Use feature state,Similar layers,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Route progress,Learn how to use a user's progress information along a route with the Mapbox Navigation SDK for iOS.,https://docs.mapbox.com/ios/navigation/overview/route-progress/,guide,,,"Route progress Tracking a user's progress along a route is key to providing helpful and prompt navigation instructions. The RouteProgress class contains all the user's progress information along the route, including current leg and step information. This object allows you to get distance measurements, the percentage of route complete, current step index, and more. The RouteController tracks the user’s progress along a route, continuously provides an updated RouteProgress object, and posts notifications as the user reaches significant points along the route. Information about progress There are three classes that contain information on route progress at different levels of granularity: route, leg, and step. Route: The blue line represents a route. A route stretches between the origin and destination. Leg: The larger circles with a pink stroke represent waypoints, or stops, along the route. A leg is the part of the route between two waypoints. Step: The smaller circles with a green stroke represent maneuvers. A step is the part of the leg between two maneuvers. Read more about what properties are available in these three progress classes in the API reference documentation: RouteProgress: This class contains all progress information at any given time during a navigation session. This progress includes information for the current route, leg and step the user is traversing along. With every new valid location update, the route progress will be updated latest information. You can listen for routeControllerProgressDidChange notifications or implement the corresponding delegate method, NavigationServiceDelegate.navigationService(_:didUpdate:with:rawLocation:) to be notified when the route progress object changes. RouteLegProgress: This class is specific to the current leg the user is on. If there is only one leg in the directions route, much of this information will be the same as the parent RouteProgress. RouteStepProgress: This class is specific to the current step the user is on. Was this page helpful? Yes No",,Route progress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Create a custom style,Alter a template style to create a custom map style.,https://docs.mapbox.com/help/tutorials/create-a-custom-style/,tutorial,No code,,"beginner No code Create a custom style This guide will walk through how to create a custom style in the Mapbox Studio style editor. The Mapbox Studio Basic style is customizable, which lets you create a map style that conforms to your company's branding. This tutorial will show you how to customize the Mapbox Basic style by changing colors, fonts, and label properties. After you have completed the tutorial, you will have created a map style that reflects the Mapbox brand colors at any zoom level and at any place across the world. Getting started You will need a few resources to get started: Mapbox account. Sign up for a free account on Mapbox. Style guidelines. It is often helpful to start a new custom map style with some broad style guidelines. Mapbox's brand has three primary colors (blue, gray, and pink) and a broader set of secondary colors. Every hue includes a dark, light, and faint variation. This tutorial will use a combination of these colors to style the background, water, buildings, and labels in a custom map style. Create a new style Log in to your Mapbox account and navigate to the Styles page. This is where all your map styles are listed. A style is a set of rules that defines how Mapbox draws your map on the page. It includes references to your data, map images (icons, markers, and patterns), fonts, and defines how all your data should be styled on the map. For more information about styles, read the Styles section of the Mapbox Studio Manual. To create a new style from your Styles page, click the New style button. Find the Basic Template style and click Customize Basic Template. The Mapbox Studio style editor will open, and you will be able to start creating a custom map style. Customize your style The style editor The Mapbox Studio style editor is a visual tool for creating custom map styles. Look at the layers on the left side of the style editor screen. Each layer can be customized in a variety of ways, including by changing its colors. You can also filter layers within the layer list and edit the properties of multiple layers at once. This is the easiest way to change the color of layers with similar properties. To learn more about the Mapbox Studio style editor, visit the Mapbox Studio Manual. In this section, you will change the color of the water, background, and building layers and alter the fonts for various labels to create a customized map. But first, change the name of your new style. Click into the name field in the upper left side of the screen and change the name to Mapbox Style. Style background and water layers When the style editor first opens with the Basic style template, the map is zoomed in at a high level. Zoom out to approximately zoom level 10 so that you can see a larger geographic region. In the search bar, type in San Francisco (or another region that gives you a good mix of water, land, and city features). You will start by altering the water and background layers so they match the colors from the Mapbox style guide. Style the water layer You will style the water layer with a bright blue color from the Mapbox style guide. Click on the water layer in the layer list. When the layer panel opens, click on the Color field if it is not highlighted already. Change the color to #314CCD. Style the background layer by zoom level Mapbox Studio lets you adjust styles based on specific data. In this case, you will use the style editor to change the color of the style's background based on the zoom level. Using zoom properties, the background color will become gradually lighter as the map zooms in. To style the background layer by zoom level: Click on the background layer in the layer list. When the layer panel opens, click the Color option if it's not already highlighted. You will see two zoom levels, each with a color. Click Edit next to each stop. The text field on the top right of the card is the zoom level and the text field on the bottom right is the color. When you're done adjusting the zoom level and the color for a specific stop, click Done. Edit the first stop so the zoom level is 6 and the color is #A9B6EF. Edit the second stop so the zoom level is 12 and the color is #EDF0FD. Now, when you zoom in, the background color changes gradually as the zoom level increases. Style the landuse and national park layers Now that you have changed the colors for the water and background layers, the green color that is used in the Basic style looks too bold. You will change the color of these layers to a light green from the style guide's secondary colors. Select the national_park layer. When the layer panel opens, select the Color field. Change the Color field to #E8F5EE. Select the landuse layer. Click on the Color field if it is not highlighted already. Click the ""class is park, pitch"" condition. Change the Color field to #E8F5EE. Update fonts Next, alter the fonts that are used as labels in your style. Click Filter layers at the top of the layers list. Choose Filter by value. Choose Fonts. Select Roboto Black. This will return the only layer in which this font is being used, state-label. Click on state-label, then click on Font. Change the font to Roboto Condensed Bold. Click on Filter layers again, and repeat this process for the font Roboto Regular, which you will change to Roboto Medium. You can select multiple layers at once by holding down command (Mac) or CTRL (Windows) while clicking to select layers Style labels After you have changed the fonts and set some general options, it's time to update the colors of the various label types used in your style. Click Filter layers at the top of the layers list and search for the word label. This search will return 9 layers with the word label in their names. Select country-label. When the layer panel opens, select the Color field and change it to #ffffff. Change the Halo color field to #314CCD. Change the following label layers to have the following attributes: place-neighborhood-suburb-label: color #EE4E8B, halo color #ffffff place-city-label: click Clear value and then specify the color #ffffff, halo color #273D56 Style buildings Next, change the color of the buildings in your style to a color from the Mapbox style guide: Click on the building layer in the layer list. When the layer panel opens, change the Color field to #aab7ef. Change the 1px stroke field to #aab7ef. To make sure that Mapbox template styles are performant, layers are not included at every zoom level. The building layer, for example, is visible only at zoom levels 15 and higher. You can use a zoom function to create a fade-in effect as you zoom past level 15 rather than buildings showing up abruptly once you hit zoom level 15: In the Opacity field of the building layer, select Style across zoom range. Click Edit to open and edit each stop: Edit the first stop so the zoom level is 15 and the opacity is 0. To change the opacity, move the opacity slider all the way to the left. Edit the second stop so the zoom level is 16 and the opacity is 1. Zoom in to see the buildings fade between zoom level 15 and 16. Your browser doesn't support embedded videos. This fade-in effect could also be applied to roads, parks, waterways, and any other layers you choose. Publish When you have finished editing your map style, publish your changes by clicking Publish in the upper right side of the screen. When you click the publish button, a window will display the difference between the previous and current version of this style. If you're happy with the changes, click Publish. Your style will now be available to share from a variety of tools and applications. Finished product You have created a map that reflects the Mapbox style guide, from a world view to the street level and at any location across the world. Explore your finished custom map style and take some time to view the style at various zoom levels. Next steps Mapbox Studio provides a wide variety of ways to use your new map style. You can use this map directly on your website or in a web or mobile application. Take a look at the Publish style section of the Mapbox Studio Manual to see all the ways you can use your style! Was this page helpful? Yes No",,Create a custom style,Create a new style,Customize your style,The style editor,Style background and water layers,Style the water layer,Style the background layer by zoom level,Style the landuse and national park layers,Update fonts,Style labels,Style buildings,Publish,Finished product,Next steps,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,map view,Map views were formerly used as a unit of measurement to track map usage on the web. Map views are now deprecated.,https://docs.mapbox.com/help/glossary/map-view/,glossary,,,"map view Map views are deprecated Map views are no longer used to track map usage for Mapbox products. For details on current pricing structures including map loads, see Pricing by product. Was this page helpful? Yes No",,map view,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Get features under the mouse pointer,Using queryRenderedFeatures to show properties of hovered-over map elements.,https://docs.mapbox.com/mapbox-gl-js/example/queryrenderedfeatures/,example,JavaScript,,Get features under the mouse pointer Using queryRenderedFeatures to show properties of hovered-over map elements. Was this example helpful? Yes No,,Get features under the mouse pointer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,layer,Layers are used in styles to add styling rules to specific subsets of data.,https://docs.mapbox.com/help/glossary/layer/,glossary,,,"layer Layers are used in styles to add styling rules to specific subsets of data. (For example, if you wanted all the rivers in your map to be pink, you would create a layer in your style for it.) Layers contain both a reference to the data for which they're defining a style as well as the styling rules to be applied. Read more about layers in the Mapbox Style Specification. Was this page helpful? Yes No",,layer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Custom voice controller,Use a custom voice controller.,https://docs.mapbox.com/ios/navigation/examples/custom-voice-controller/,example,Swift,,"Custom voice controller import Foundation import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections import AVFoundation class CustomVoiceControllerUI: UIViewController { var voiceController: CustomVoiceController? override func viewDidLoad() { super.viewDidLoad() let origin = CLLocationCoordinate2DMake(37.77440680146262, -122.43539772352648) let destination = CLLocationCoordinate2DMake(37.76556957793795, -122.42409811526268) let options = NavigationRouteOptions(coordinates: [origin, destination]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) self.voiceController = CustomVoiceController(navigationService: navigationService) let navigationOptions = NavigationOptions(navigationService: navigationService, voiceController: self.voiceController) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) self.present(navigationViewController, animated: true, completion: nil) } } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) voiceController = nil } } class CustomVoiceController: MapboxVoiceController { // You will need audio files for as many or few cases as you'd like to handle // This example just covers left, right and straight. let turnLeft = NSDataAsset(name: ""turnleft"")!.data let turnRight = NSDataAsset(name: ""turnright"")!.data let straight = NSDataAsset(name: ""continuestraight"")!.data override func didPassSpokenInstructionPoint(notification: NSNotification) { let routeProgress = notification.userInfo![RouteControllerNotificationUserInfoKey.routeProgressKey] as! RouteProgress let soundForInstruction = audio(for: routeProgress.currentLegProgress.currentStep) play(soundForInstruction) } func audio(for step: RouteStep) -> Data { switch step.maneuverDirection { case .left: return turnLeft case .right: return turnRight default: return straight } } } Copy Was this page helpful? Yes No",,Custom voice controller,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Create a timezone finder with Mapbox Tilequery API,Create a timezone finder app with Mapbox Tilequery API.,https://docs.mapbox.com/help/tutorials/create-a-timezone-finder-with-mapbox-tilequery-api/,tutorial,JavaScript,,"intermediate JavaScript Create a timezone finder with Mapbox Tilequery API Prerequisite Familiarity with front-end development concepts including JavaScript and API calls. The Mapbox Tilequery API enables users to get data from a tileset without necessarily needing to render a map. This tutorial shows you how to create an app that uses the Tilequery API and a custom tileset to determine which timezone a user is in. View fullscreen demo You will not be building a map in this tutorial. To see an example of how Mapbox Tilequery API can be used to interact with a rendered map, take a look at the Tilequery API Playground. Getting started There are a few resources you’ll need before getting started: An access token from your Mapbox account. You will use an access token to associate a map with your account. Your access token is on the Account page. Data. Your app will reference a tileset that contains timezone information. This data set was sourced from Evan Savage’s GitHub. For this tutorial, you don't have to download the data or upload it to Mapbox — we've done that for you already! Normally, you would need to upload this data to Mapbox using either Mapbox Studio or the Mapbox Uploads API. Mapbox Tilequery API. Our Tilequery API lets you query custom data without needing to render a map to the page. jQuery. jQuery is a JavaScript library you will use to add your API request to your application. Assembly. Assembly is an open source CSS framework that is maintained by Mapbox. A text editor. Use the text editor of your choice for writing HTML, CSS, and JavaScript. In this tutorial, you will create an interface using HTML and style it using Assembly, the CSS framework that Mapbox uses. Then you will add a call to the native HTML geolocation API, as well as a call to the Mapbox Tilequery API to query a custom tileset that contains timezone data. At the end of this tutorial, you will have created an app that, when a user clicks a button, determines their timezone. Structure the webpage Start by pasting the following code into your text editor. This code references a few items in the <head> of your file that you will take advantage of later in this tutorial: jQuery. Used to make the Tilequery API call and parse the response. Assembly. Using this framework will allow you to add styles to the HTML without having to write custom CSS. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title></title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <!-- import jQuery --> <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js'></script> <!-- import Assembly JavaScript --> <script async defer src='https://api.mapbox.com/mapbox-assembly/v0.21.2/assembly.js'></script> <!-- import Assembly CSS --> <link href='https://api.mapbox.com/mapbox-assembly/v0.21.2/assembly.min.css' rel='stylesheet'> </head> <body> <!-- the Assembly classes in the div below create a centered div with a top margin of 36px --> <!-- read the Assembly documentation for more info! --> <div class='mx-auto mt36 w600 prose'> <h2>Timezone finder</h2> <button id='tz-button' class='btn'>Find my timezone!</button> <!-- the textContainer div will display the success, error, and loading messages --> <div class='mt12 ml12' id='textContainer'> <!-- these Assembly classes will add an animation to the loading message! --> <p id='loading-message' class='inline-block round animation-pulse animation--infinite'></p> <p id='return-message'></p> </div> </div> </body> </html> Save this file and open it in your browser. The body of the code references a few different Assembly classes, so you do not need to add any additional styles (unless you want to!). This code doesn't do anything yet, so in the next few steps you will add more functionality to turn it into a fully realized timezone finder. Build the API request Next, you will build your request to the Mapbox Tilequery API and test it in your browser. After you have verified that it is returning the expected results, you will add the API call to your app! The format of a Tilequery API call is: https://api.mapbox.com/v4/ { tileset } /tilequery/ { longitude } , { latitude } .json?access_token= YOUR_MAPBOX_ACCESS_TOKEN In a Mapbox Tilequery API call, the tileset indicates the data that your API request will be querying. In this case, your app will query custom data that has been uploaded to Mapbox. You will reference this tileset id (examples.4ze9z6tv) in the API call. You can also tell the Tilequery API to ask questions of Mapbox’s default tilesets, such as Mapbox Streets or Mapbox Terrain. To visualize the results of a call to one of these tilesets, use the Tilequery API Playground. Parameters The only required parameters for a call to the Mapbox Tilequery API are the longitude and latitude of a desired location. To test the API, we will set this to -77.033835,38.89975, the coordinates of Mapbox’s Washington D.C. office. The Tilequery API also accepts several optional query parameters, including radius, that you will not need to use for this project. Read more about these optional parameters and how to use them in the Mapbox API Documentation’s Tilequery section. Access token The only required item left is your access token, which you will find on your Mapbox account page. The access token is required to track the requests you make from your account. Review the response When you put it all together, your request will look like: https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/-77.033835,38.89975.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Now that you have a request, take a look at what you get in return by pasting the full URL into a new browser window. Make sure that access_token= is set equal to your access token. When you make your request, a JSON object is returned that contains, along with other information, a TZID property. This property shows the timezone of our test coordinates, the America/New_York timezone. { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.033835, 38.89975 ] } , ""properties"": { ""TZID"": ""America/New_York"", ""tilequery"": { ""distance"": 0, ""geometry"": ""polygon"", ""layer"": ""tz_world-c5z4hv"" } } } ] } Now that you understand how Mapbox Tilequery API requests and responses both work, you can use this API request to build out your app’s functionality. Add the API request to the app All modern browsers support the HTML geolocation API, which allows a browser to determine a user’s location if the user provides permission for it to do so. The timezone finder app will use the HTML geolocation API to get the longitude and latitude that will be used in the Mapbox Tilequery API call. First, add the following code to your file above the closing </body> tag. This creates a place for you to add the JavaScript the app needs. The accessToken variable stores the access token that will be used in the query. Add your own access token between the quotation marks. <script> var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here </script> Next, you will write a call to the HTML geolocation API to get the user's longitude and latitude. Add the following code after the accessToken variable you created: navigator.geolocation.getCurrentPosition(function(position) { var lon = position.coords.longitude; var lat = position.coords.latitude; console.log('Your location: ' + lon + ',' + lat); } ); Save your work and open this page in your browser. The browser will ask your permission to know your location. The console.log line will print the variables lon and lat to your browser’s console so that you can see the data that the HTML geolocation service returns. Now it’s time to use this information to construct a Tilequery API call! Include Tilequery API To use the Tilequery API, you will write a function called getUserLocation that will make a call to the API. This code will replace the call to the HTML geolocation API that you wrote in the last step, so erase that and replace it with the following code. Now the code between your opening and closing script tags should be: var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here function getUserLocation() { function success(position) { // create variables that will hold the // user's latitude and longitude data var lon = position.coords.longitude; var lat = position.coords.latitude; // construct a query to Tilequery API using the // longitude and latitude variables as parameters var query = 'https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/' + lon + ',' + lat + '.json?access_token=' + accessToken; // make the call to Tilequery API and parse the results $.ajax( { method: 'GET', url: query, } ).done(function(data) { // get the timezone from the resulting GeoJSON FeatureCollection var userTimezone = data.features[0].properties.TZID; } ); } // pass the results of a successful Tilequery API call // to the HTML geolocation API navigator.geolocation.getCurrentPosition(success); } Add interactivity Now you’re ready to add interactivity to your app! Add an event listener that calls the getUserLocation function when the user clicks the button. To access the button, you can use its id tz-button. Create a new variable in your JavaScript right below the accessToken variable: var tzButton = document.getElementById('tz-button'); Now add an onclick event listener that will trigger the getUserLocation function when the button is clicked. Add the following line to your JavaScript below the tzButton variable declaration: tzButton.onclick = getUserLocation; The code between your opening and closing script tags should now be: var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here // create a variable that selects the button var tzButton = document.getElementById('tz-button'); // when the button is clicked, call the getUserLocation function tzButton.onclick = getUserLocation; function getUserLocation() { function success(position) { var lon = position.coords.longitude; var lat = position.coords.latitude; var query = 'https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/' + lon + ',' + lat + '.json?access_token=' + accessToken; $.ajax( { method: 'GET', url: query, } ).done(function(data) { var userTimezone = data.features[0].properties.TZID; } ); } navigator.geolocation.getCurrentPosition(success); } Display messages The only thing left to do is display the user’s timezone to the page! In the HTML section of your app, you already created a div that contains p tags with the ids loading-message and return-message. These will be used to display the success, error, and loading messages for your app. In the getUserLocation function, create variables for these elements: var loadingMessage = document.getElementById('loading-message'); var returnMessage = document.getElementById('return-message'); Now that you have selected these elements, you can start adding messages to them. Add a loading message at the beginning of the getUserLocation function that lets users know that the app is working on returning their information. document.getElementById('loading-message').textContent = 'loading'; The message will stand out since you already added an Assembly animation class to the p tag! Now that you have a loading message, you need to remove the loading message add a success message. Since a success message is there to tell users when things have gone correctly, your app will display a message that tells users which area code they are in. First, though, you will need to remove the loading message. Add these lines to your JavaScript right below the userTimezone variable: loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'You are in the ' + userTimezone + ' timezone.'; There’s always the possibility for something to go wrong, and if that happens you need to let the user know. Add an error message near the end of the getUserLocation function: function error() { loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'Sorry, unable to determine your current location.'; } The code between your script tags will look like this now: var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here var loadingMessage = document.getElementById('loading-message'); var returnMessage = document.getElementById('return-message'); var tzButton = document.getElementById('tz-button'); tzButton.onclick = getUserLocation; function getUserLocation() { // show a loading animation while we wait for the data document.getElementById('loading-message').textContent = 'loading'; function success(position) { var lon = position.coords.longitude; var lat = position.coords.latitude; var query = 'https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/' + lon + ',' + lat + '.json?access_token=' + accessToken; $.ajax( { method: 'GET', url: query, } ).done(function(data) { var userTimezone = data.features[0].properties.TZID; // on success, remove the loading message and display the user's timezone loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'You are in the ' + userTimezone + ' timezone.'; } ); } // if anything goes wrong, remove the loading message and display an error message function error() { loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'Sorry, unable to determine your current location.'; } navigator.geolocation.getCurrentPosition(success, error); } Finished product You used the Mapbox Tilequery API to build an app that queries a custom tileset to determine a user’s timezone, without ever having to reference a rendered map. Open your app in the browser and try it out. View fullscreen demo Next steps To learn how to use cURL to upload large custom data sets like the one used in this tutorial to your Mapbox account, read the Upload to Mapbox using cURL tutorial. Was this page helpful? Yes No",,Create a timezone finder with Mapbox Tilequery API,Structure the webpage,Build the API request,Parameters,Access token,Review the response,Add the API request to the app,Include Tilequery API,Add interactivity,Display messages,Finished product,Next steps,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Make a choropleth map with the Mapbox Visual for Power BI,Create a choropleth data map with the Mapbox Visual for Microsoft Power BI.,https://docs.mapbox.com/help/tutorials/power-bi-choropleth-map/,tutorial,No code,,"intermediate No code Make a choropleth map with the Mapbox Visual for Power BI Prerequisite Familiarity with Microsoft Power BI. In this tutorial, you will use the Mapbox Visual in Microsoft Power BI, data with information about US wildfires by state, and a custom tileset with information about US wildfires by county to create a choropleth visualization. This choropleth will display the number of acres burned at both the state and county levels, allowing you to drill into the data at the appropriate level. You will need a Mapbox account and a Microsoft Power BI account to complete this tutorial. Note This guide walks through using the Mapbox Visual in Power BI Online. The process in Power BI Desktop is similar, but the interface is different. Getting started Here are a few resources you'll need before you get started: Mapbox account. You need a Mapbox account and a Mapbox access token, which you can find on the Account page. Microsoft Power BI account. Sign into your Power BI account or create a new one. Mapbox Visual for Power BI. You can either add the Mapbox Visual using the Power BI Marketplace, or you can download the latest Mapbox Visual from the open-source GitHub repository. Both of these options are explained in detail in the tutorial. Geospatial data. You will upload this GeoJSON file, which contains county-level detail about wildfires in the United States, to Mapbox Studio as a tileset. Download GeoJSON Dataset for Power BI. You will upload this sample dataset, a CSV file that contains historical information about wildfires in the United States, to Power BI. Download CSV Upload your tileset to Mapbox Before you can reference the geospatial data from the downloaded GeoJSON file in a Power BI report, you need to upload it to Mapbox as a tileset. Note To upload geospatial data to Mapbox as a tileset, the data must be in one of the following formats: MBTile KML GPX GeoJSON Shapefile (zipped) CSV For information on upload file size limits for these formats, refer to the Uploads troubleshooting page. Navigate to the Tilesets page in Mapbox Studio. Click on the New tileset button. In the New tileset window, you can either click the Select a file button and choose the file, or you can drag and drop the file directly into the window. When you are prompted to do so, click Confirm. After the file uploads, you will see a confirmation success message. Click on the link in the confirmation message to open your new tileset’s information page. The tileset's information page includes the tileset ID, the layer's name, and the layer’s properties, all which you will need to reference in Power BI. You will use these pieces of information in the Add a custom tileset section of this tutorial. For now, though, you will open Power BI. Add data to Power BI You will start by adding the wildfire data you downloaded to a new Power BI workspace. In Power BI, click Get Data, which allows you to import data or connect to a data source. Under the Files option, click Get. Choose Local File and upload the wildfire data CSV file. Notes on using a custom dataset in Power BI Your dataset should be a CSV file with at least 2 columns. One column must be a unique identifier, which will be used to match a unique property from your tileset. The second column must be the value you want to connect to the unique identifier. (For the dataset in this example, the unique property is the `state_name`, which you will match to the pre-defined Power BI state tileset. The value you connect to the unique identifier will be the number of acres burned.) Create a new report Click on My Workspace and select the Datasets tab. Click the Create a report option (the bar graph icon) next to the new dataset. This will open the report window. Add the Mapbox Visual to the report You can use the Mapbox Visual for Microsoft Power BI with any dataset that contains geographic data values. To add the Mapbox Visual to your report: In the Visualizations pane, click the Import a custom visual option, represented by a three-dot icon. Select Import from marketplace. Enter ""Mapbox"" in the search menu and press enter. Click the Add button next to the Mapbox Visual option to add it to your Power BI report. After the Mapbox Visual is imported, it will appear as a blue Mapbox logo on the Visualizations pane. Alternative workflow: Manual upload Alternatively, you can download the latest Mapbox Visual for Power BI from Mapbox's open-source GitHub repository: Click the Import a custom visual icon (three dots) and select Import from file. Upload the latest Mapbox Visual. A new blue Mapbox logo will appear in the Visualizations pane. Build the choropleth visualization Include an access token Click on the Mapbox icon in the Visualizations pane to add a new visualization to your report. In the Fields tab, drag the state_name field from your data onto the Location shelf. You should see the Mapbox visualization container populate with instructions on how to create your first visualization. Connect your Mapbox account using your access token: Click the Click here to get a free Mapbox access token link in the visualization container. Accept the external link request if prompted. You will be forwarded to either the Mapbox sign up page or your Mapbox account page. Copy your Mapbox Access token from your account page. Back in Power BI, go to the Format tab and open the Viz Settings option. Paste your access token in the Access token field. Create the choropleth In the Viz Settings pane, change the Map Style option to Dark. Drag the ACRES field from the data options onto the Color shelf. Go back to the Format tab. Switch the Circle option off and turn the Choropleth option on. You will see a choropleth that visualizes the number of acres burned per state. Add a custom tileset To drill down more deeply into data about wildfires in the United States, you will reference the custom tileset with information about wildfires at the county level that you created in the first step of this tutorial. To add this data to Power BI, you will plug its identifying features into the appropriate fields in Power BI. The information that you'll need from the tileset are the tileset ID, the layer name, and the unique identifier property name. In the Format tab, click on Choropleth to open the choropleth layer settings. Use the Number of levels dropdown menu to change the number of levels to 2. (Having two levels will allow you to drill down from the state-level data in Level 1 into the county-level data that you are adding now.) In the Level dropdown, select Level 2. Click on the Data Level 2 dropdown. Select the Custom Tileset option. In the Vector Tile URL Level 2 field, paste the tileset ID. The tileset ID in this field must always be preceded by mapbox://. In the Source Layer Name Level 2 field, paste the layer's name. In the Vector Property Level 2 field, enter the unique identifier property name: id. Click on the Fields tab again. Drag the county_id field from the data options onto the Location shelf. Using a custom tileset in Power BI The boundaries in a custom tileset should contain one unique identifying property key that matches the dataset you are using in Power BI. Common examples are: FIPS code, zip code, ISO code, or any unique name string. Final product Use the buttons on the upper left side of the visualization to drill up to the state level or down to the county level. Hover over a state or county to see the number of acres burned in that specific boundary. You have created a choropleth visualization in Microsoft Power BI using the Mapbox Visual for Power BI. Next steps Explore ways to further customize the choropleth. For instance, you could use the Choropleth settings in the Format tab to change the color range of the visualization. For support and troubleshooting with the Mapbox Visual, open an issue in the open source repository or contact our support team. Want to do more with Mapbox and Power BI? Contact Mapbox sales to learn what else is possible, from adding custom shapes to visualize territories, adding detailed indoor maps, or visualizing billions of data points. Was this page helpful? Yes No",,Make a choropleth map with the Mapbox Visual for Power BI,Upload your tileset to Mapbox,Add data to Power BI,Create a new report,Add the Mapbox Visual to the report,Build the choropleth visualization,Include an access token,Create the choropleth,Add a custom tileset,Final product,Next steps,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Show a user's location on a map fragment,Use the LocationComponent to display a user's location on a map fragment.,https://docs.mapbox.com/android/maps/examples/show-a-users-location-on-a-fragment/,example,Java,,"Show a user's location on a map fragment Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:background=""@color/white_pressed"" tools:context="".examples.basics.SupportMapFragmentActivity""> <TextView android:id=""@+id/fragment_below_textview"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_marginTop=""8dp"" android:gravity=""center_horizontal"" android:text=""@string/location_component_fragment_text""/> <androidx.cardview.widget.CardView android:id=""@+id/location_frag_cardview"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_marginHorizontal=""40dp"" android:layout_marginVertical=""50dp"" android:layout_centerInParent=""true"" android:layout_gravity=""center_horizontal"" app:cardCornerRadius=""30dp"" app:cardElevation=""@dimen/cardview_default_elevation""> <FrameLayout android:id=""@+id/location_frag_container"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> </androidx.cardview.widget.CardView> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.location; import android.os.Bundle; import android.widget.Toast; import com.mapbox.android.core.permissions.PermissionsListener; import com.mapbox.android.core.permissions.PermissionsManager; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.LocationComponentActivationOptions; import com.mapbox.mapboxsdk.location.modes.CameraMode; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.MapboxMapOptions; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.maps.SupportMapFragment; import java.util.List; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.fragment.app.FragmentTransaction; public class LocationComponentFragmentActivity extends AppCompatActivity implements PermissionsListener { private MapboxMap mapboxMap; private PermissionsManager permissionsManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_location_map_frag); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // Create supportMapFragment SupportMapFragment mapFragment; if (savedInstanceState == null) { // Create fragment final FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Build a Mapbox map MapboxMapOptions options = MapboxMapOptions.createFromAttributes(this, null); options.camera(new CameraPosition.Builder() .target(new LatLng(38.899895, -77.03401)) .zoom(9) .build()); // Create map fragment mapFragment = SupportMapFragment.newInstance(options); // Add map fragment to parent container transaction.add(R.id.location_frag_container, mapFragment, ""com.mapbox.map""); transaction.commit(); } else { mapFragment = (SupportMapFragment) getSupportFragmentManager().findFragmentByTag(""com.mapbox.map""); } mapFragment.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { LocationComponentFragmentActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.OUTDOORS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { enableLocationComponent(style); } }); } }); } @SuppressWarnings( {""MissingPermission""}) private void enableLocationComponent(@NonNull Style loadedMapStyle) { // Check if permissions are enabled and if not request if (PermissionsManager.areLocationPermissionsGranted(this)) { // Get an instance of the LocationComponent. LocationComponent locationComponent = mapboxMap.getLocationComponent(); // Activate the LocationComponent locationComponent.activateLocationComponent( LocationComponentActivationOptions.builder(this, loadedMapStyle).build()); // Enable the LocationComponent so that it's actually visible on the map locationComponent.setLocationComponentEnabled(true); // Set the LocationComponent's camera mode locationComponent.setCameraMode(CameraMode.TRACKING); // Set the LocationComponent's render mode locationComponent.setRenderMode(RenderMode.NORMAL); } else { permissionsManager = new PermissionsManager(this); permissionsManager.requestLocationPermissions(this); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { permissionsManager.onRequestPermissionsResult(requestCode, permissions, grantResults); } @Override public void onExplanationNeeded(List<String> permissionsToExplain) { Toast.makeText(this, R.string.user_location_permission_explanation, Toast.LENGTH_LONG).show(); } @Override public void onPermissionResult(boolean granted) { if (granted) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { enableLocationComponent(style); } }); } else { Toast.makeText(this, R.string.user_location_permission_not_granted, Toast.LENGTH_LONG).show(); finish(); } } } Copy Was this page helpful? Yes No",,Show a user's location on a map fragment,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Troubleshooting SVG image errors in Mapbox Studio,Learn how to fix SVG upload errors in Mapbox Studio.,https://docs.mapbox.com/help/troubleshooting/studio-svg-upload-errors/,troubleshooting,,,"Troubleshooting SVG image errors in Mapbox Studio The Mapbox Studio style editor supports the SVG format for icons and patterns. Studio uses SVG because it's scalable and supports devices with a range of screen resolutions. Behind the scenes, the Mapbox Styles API uses the source SVGs to render sprites (collections of PNG) at a variety of resolutions, then delivers the proper sprite based on a user's device. For example, if a user views your map on a device with a high resolution screen, they will receive a 2x sprite. If a user views your map on a device with a low resolution screen, they receive a 1x sprite. Common issues Sometimes SVGs fail to upload or upload successfully, but do not appear as expected. Here are some common issues and suggestions for troubleshooting them. Black images with no color If you are able to add your SVG to Mapbox Studio, but appears black, it's likely because you are using <style> tags to assign style properties rather than using inline style attributes. Mapbox Studio does not support style properties added in <style> tags. If you are using Adobe Illustrator to create your SVG, make sure you have selected Presentation Attributes and unchecked Responsive checkbox. Sketch icons are not rendered correctly in Mapbox Studio The SVGs Sketch generates may include some SVG filters that can not be correctly rendered by Mapbox Studio. You can open the SVG in Adobe Illustrator and do Object > Expand Appearance. ""Icon upload failed"" error If your icon fails to upload, it's likely either because the SVG is too large or the file is not a valid SVG. (For the list of SVG elements and attributes that the Mapbox uploader supports, see the Mapnik SVG support page.) We recommend you make sure that: The images you're uploading are smaller than the sprite dimension limit: 1024px x 1024px. Learn more about how sprites work. There are no syntax errors in your SVG file. Size property causing icon to look blurry If you adjust an icon's size in the Mapbox Studio style editor or in code, you might notice that it seems fuzzy or dithered. To keep your icons crisp, set the size property to 1. And if you want to display a larger image on the map, upload a larger SVG. Change an icon from the Mapbox template styles You can get the original SVGs used in any Studio styles by clicking on the Download button of a style from the Mapbox Studio style list or use the Maki editor to create an entire set of custom designed icons. Create SVG icons in Adobe Illustrator We support a wide range of SVG features, but some features aren't available. To make sure that your vector graphics are accurately included in your maps, follow these steps: Make sure everything is in vector format. If you've applied some Illustrator effects, go to Object > Expand Appearance. Do not include symbols or raster images as part of your SVGs, whether embedded or linked. There are two ways to generate an .svg file from Illustrator: Export and Save As. Export To Export, go to File > Export. Click the Use Artboards and enter the artboard number within the Range box. Click the Export button. In the SVG Options window, under Advanced Options panel, select Presentation Attributes as the Styling option. Uncheck the Responsive checkbox, and make sure you have a Decimal value greater than 3. Your settings should look like this: Save as To Save As, go to File > Save As, and click Save As. In the SVG Options window, select SVG 1.1 for SVG profiles, select Presentation Attributes for CSS Properties, select a value greater than 3 for Decimal Places, and uncheck the Responsive checkbox. Your settings should look like this: Unsupported SVG elements and attributes The Mapbox uploader does not support all possible SVG elements and attributes. For a full list of supported and unsupported SVG elements and attributes, see the Mapnik SVG support page. Was this page helpful? Yes No",,Troubleshooting SVG image errors in Mapbox Studio,Black images with no color,Sketch icons are not rendered correctly in Mapbox Studio,"""Icon upload failed"" error",Size property causing icon to look blurry,Change an icon from the Mapbox template styles,Create SVG icons in Adobe Illustrator,Export,Save as,Unsupported SVG elements and attributes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for iOS,iOS,Examples,Code examples for the Mapbox Vision SDK for iOS.,https://docs.mapbox.com/ios/vision/examples/,,,,Getting started Set up an external camera source Use an external camera source instead of a device's built-in camera. AR Basic blue-line AR navigation Project a blue route line on the view of the road through your device. Safety Speeding alerts Display an alert when the vehicle is speeding.,,Getting started,Safety,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Change building color based on zoom level,Uses the interpolate expression to ease-in the building layer and smoothly fade from one color to the next.,https://docs.mapbox.com/mapbox-gl-js/example/change-building-color-based-on-zoom-level/,example,JavaScript,,Change building color based on zoom level Uses the interpolate expression to ease-in the building layer and smoothly fade from one color to the next. Was this example helpful? Yes No,,Change building color based on zoom level,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Toggle interactions,Enable or disable UI handlers on a map.,https://docs.mapbox.com/mapbox-gl-js/example/toggle-interaction-handlers/,example,JavaScript,,Toggle interactions Enable or disable UI handlers on a map. Was this example helpful? Yes No,,Toggle interactions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Display real-time traffic,Use the traffic plugin to display live car congestion data on top of a map.,https://docs.mapbox.com/android/plugins/examples/show-real-time-traffic-on-a-map/,example,Java,,"Display real-time traffic Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" android:layout_marginBottom=""0dp"" android:layout_marginLeft=""0dp"" android:layout_marginRight=""0dp"" android:layout_marginTop=""0dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintLeft_toLeftOf=""parent"" mapbox:layout_constraintRight_toRightOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""1.352506"" mapbox:mapbox_cameraTargetLng=""103.842874"" mapbox:mapbox_cameraZoom=""9.579712"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/traffic_toggle_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginBottom=""16dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" android:src=""@drawable/ic_directions_car_white_24dp"" mapbox:fabSize=""normal"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintRight_toRightOf=""parent""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.traffic.TrafficPlugin; /** * Toggle the Mapbox Traffic plugin to display real-time traffic data on top * of your map (not all regions supported at the moment). */ public class TrafficPluginActivity extends AppCompatActivity { private MapView mapView; private MapboxMap map; private TrafficPlugin trafficPlugin; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_traffic_plugin); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(final MapboxMap mapboxMap) { map = mapboxMap; mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { trafficPlugin = new TrafficPlugin(mapView, mapboxMap, style); // Enable the traffic view by default trafficPlugin.setVisibility(true); findViewById(R.id.traffic_toggle_fab).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (map != null) { trafficPlugin.setVisibility(!trafficPlugin.isVisible()); } } }); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Display real-time traffic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Global location search,"Add geocoding search functionality and UI for finding any region, country, place, or address in the world.",https://docs.mapbox.com/android/plugins/examples/global-location-search/,example,Java,,"Global location search Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLng=""-43.334931"" mapbox:mapbox_cameraZoom=""0.346515"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_location_search"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_margin=""16dp"" android:tint=""@android:color/white"" app:backgroundTint=""@color/colorPrimary"" app:srcCompat=""@android:drawable/ic_search_category_default"" /> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.app.Activity; import android.content.Intent; import android.graphics.BitmapFactory; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import com.google.gson.JsonObject; import com.mapbox.api.geocoding.v5.models.CarmenFeature; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.places.autocomplete.PlaceAutocomplete; import com.mapbox.mapboxsdk.plugins.places.autocomplete.model.PlaceOptions; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Use the places plugin to take advantage of Mapbox's location search (""geocoding"") capabilities. The plugin * automatically makes geocoding requests, has built-in saved locations, includes location picker functionality, * and adds beautiful UI into your Android project. */ public class PlacesPluginActivity extends AppCompatActivity implements OnMapReadyCallback { private static final int REQUEST_CODE_AUTOCOMPLETE = 1; private MapView mapView; private MapboxMap mapboxMap; private CarmenFeature home; private CarmenFeature work; private String geojsonSourceLayerId = ""geojsonSourceLayerId""; private String symbolIconId = ""symbolIconId""; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_places_plugin); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initSearchFab(); addUserLocations(); // Add the symbol layer icon to map for future use style.addImage(symbolIconId, BitmapFactory.decodeResource( PlacesPluginActivity.this.getResources(), R.drawable.blue_marker_view)); // Create an empty GeoJSON source using the empty feature collection setUpSource(style); // Set up a new symbol layer for displaying the searched location's feature coordinates setupLayer(style); } }); } private void initSearchFab() { findViewById(R.id.fab_location_search).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent = new PlaceAutocomplete.IntentBuilder() .accessToken(Mapbox.getAccessToken()) .placeOptions(PlaceOptions.builder() .backgroundColor(Color.parseColor(""#EEEEEE"")) .limit(10) .addInjectedFeature(home) .addInjectedFeature(work) .build(PlaceOptions.MODE_CARDS)) .build(PlacesPluginActivity.this); startActivityForResult(intent, REQUEST_CODE_AUTOCOMPLETE); } }); } private void addUserLocations() { home = CarmenFeature.builder().text(""Mapbox SF Office"") .geometry(Point.fromLngLat(-122.3964485, 37.7912561)) .placeName(""50 Beale St, San Francisco, CA"") .id(""mapbox-sf"") .properties(new JsonObject()) .build(); work = CarmenFeature.builder().text(""Mapbox DC Office"") .placeName(""740 15th Street NW, Washington DC"") .geometry(Point.fromLngLat(-77.0338348, 38.899750)) .id(""mapbox-dc"") .properties(new JsonObject()) .build(); } private void setUpSource(@NonNull Style loadedMapStyle) { loadedMapStyle.addSource(new GeoJsonSource(geojsonSourceLayerId)); } private void setupLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayer(new SymbolLayer(""SYMBOL_LAYER_ID"", geojsonSourceLayerId).withProperties( iconImage(symbolIconId), iconOffset(new Float[] {0f, -8f}) )); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == Activity.RESULT_OK && requestCode == REQUEST_CODE_AUTOCOMPLETE) { // Retrieve selected location's CarmenFeature CarmenFeature selectedCarmenFeature = PlaceAutocomplete.getPlace(data); // Create a new FeatureCollection and add a new Feature to it using selectedCarmenFeature above. // Then retrieve and update the source designated for showing a selected location's symbol layer icon if (mapboxMap != null) { Style style = mapboxMap.getStyle(); if (style != null) { GeoJsonSource source = style.getSourceAs(geojsonSourceLayerId); if (source != null) { source.setGeoJson(FeatureCollection.fromFeatures( new Feature[] {Feature.fromJson(selectedCarmenFeature.toJson())})); } // Move map camera to the selected location mapboxMap.animateCamera(CameraUpdateFactory.newCameraPosition( new CameraPosition.Builder() .target(new LatLng(((Point) selectedCarmenFeature.geometry()).latitude(), ((Point) selectedCarmenFeature.geometry()).longitude())) .zoom(14) .build()), 4000); } } } } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Global location search,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Migrating to v1.4,A guide to migrating your project from earlier versions of the Maps SDK for Unity to v1.4+.,https://docs.mapbox.com/unity/maps/overview/migrate-version/,guide,,,"Migrating to v1.4 CAUTION: Create a back up of your project to a new folder before migrating to the Maps SDK for Unity v1.4 or higher. You will need this backup project to make the migration process smoothly. Upgrade the Maps SDK for Unity If you did not change any source files from the previous version, you can skip ahead to the Map setup section of this guide. Import the latest version of the Maps SDK for Unity to a newly created project named NewSDK1.4. Next, delete all the old Mapbox folders from your existing project (let’s call it OldSDK1.3). Tip: compare your project folders with the NewSDK1.4 project to see which files and folders to delete. Finally, copy the new folders from the NewSDK1.4 project to your existing project. Do a diff of all the files that changed. Use a file comparison/diff tool like Sourcetree or TortoiseGit to make this process easier. Pay close attention to any files from the Maps SDK for Unity that you changed earlier. If you changed any files, carefully make a manual merge rather than relying on a version control tool to do an automatic merge for you. Map setup Once you have resolved any compiler errors in Unity, the next step is to resolve the missing script reference on the map game object. AbstractMap has a lot more functionality in v1.4.0 and later versions. You no longer need to add explicit Map types (Basic Map, MapAtSpecificLocation etc.). AbstractMap can be set up to function the same way as any of the v1.3 Maps. To do so, drag and drop the AbstractMap script to replace the missing script field. Refer to the table below to select the correct option for your map. v1.3 Map name v1.4 Abstract Map Placement Type v1.4 Abstract Map Scaling Type Basic Map At Tile Center Custom Quad Tree Basic Map At Location Center Custom Map At Specific Location At Location Center Custom Map At World Scale At Location Center World Scale Tile provider setup You are no longer required to add TileProviders explicitly, because in v1.4+ they are added to the map using the ExtentOptions. If you still want to add a custom TileProvider, you can do this by selecting the Custom option from the Extent Options menu. Refer the table below to select the correct setting for your TileProvider. v1.3 Tile Provider v1.4.0 Extent Option Remove v1.3 Component CameraBoundsTileProvider CameraBounds Yes QuadTreeTileProvider CameraBounds Yes RangeTileProvider RangeAroundCenter Yes RangeAroundTransformTileProvider RangeAroundTransform Yes Any Custom Tile Provider Custom No MapVisualizer setup Starting with v1.4.0, MapVisualizer will be set up automatically using the settings under the IMAGE, TERRAIN and VECTOR sections. To migrate v1.3 MapVisualizers to v1.4, follow the steps below. Open two separate instances of Unity. One instance will be your existing project, and the other will be the new project with the updated version of the Maps SDK for Unity. Next, open the Map Editor on your existing project by navigating to Mapbox > Map Editor from the top menu. Carefully go through every node of in your existing project and populate the fields on the AbstractMap script in the new project. You can find information on how the AbstractMap script can configured on the Introduction to the Maps SDK page. Map Image Factory → IMAGE. MapImageFactory in v1.3 can now be set up using the options available under IMAGE section of AbstractMap. Terrain Factory → TERRAIN. TerrainFactory in v1.3 can now be set up using the options available under TERRAIN section of AbstractMap. v1.3 Terrain Factory name v1.4 Elevation Layer Type FlatTerrainFactory FlatTerrain LowPolyTerrainFactory LowPolygonTerrain TerrainFactory TerrainWithElevation ( Add SideWalls option unchecked) TerrainWithSideWallsFactory TerrainWithElevation ( Add SideWalls option checked) FlatSphereTerrainFactory GlobeTerrain Vector Tile Factory → VECTOR. VectorTileFactory in v1.3 can now be set up using the options available under VECTOR section of AbstractMap. The new AbstractMap automatically applies default modifiers when choosing Point, Line, Polygon in the Primitive Type settings. See the table below for the conversions: Primitive Type Default Mesh Modifiers Default Game Object Modifiers Polygon PolygonMeshModifier, UVModifier, HeightModifier MaterialModifier Line LineMeshModifier, HeightModifier MaterialModifier SnapTerrainModifier in v1.3 is now configured by the Snap To Terrain checkbox. If you are using a MergedModifierStack in 1.3, you will need to use the Group Features checkbox. ColliderModifier in v1.3 is now set by the Collider Type menu which allows you to choose the type of collider you want to add to the extruded geometry. Select Custom for the Primitive Type if you don’t want any default modifiers to be attached. Compare your new project to your old project, going through every game object one by one. Make sure all the scripts have the same values and have been serialized properly. API changes If you are using Initialize() to load a new location after you have already initialized the map, replace it with the new UpdateMap() method which takes in the same arguments. The AbstractMap class has the Initialize(), UpdateMap() and ResetMap() methods. If you are using InitializeMapWithLocationProvider, make sure that the Initialize On Start checkbox on the AbstractMap script is unchecked. The new LocationProviderFactory script has a serialized Map Manager reference. Make sure you have serialized it with the corresponding AbstractMap reference. Was this page helpful? Yes No",,Migrating to v1.4,Map setup,Tile provider setup,MapVisualizer setup,API changes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add an image,Dark vector baselayer with radar weather image overlay.,https://docs.mapbox.com/mapbox-gl-js/example/image-on-a-map/,example,JavaScript,,Add an image Dark vector baselayer with radar weather image overlay. Was this example helpful? Yes No,,Add an image,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Draggable annotation views,Custom annotation views with that can be dragged.,https://docs.mapbox.com/ios/maps/examples/draggable-views/,example,Swift,,"Draggable annotation views This example uses two classes within a single file: DraggableAnnotationView is a subclass of MGLAnnotationView, a descendant of UIView. ViewController uses these annotation views with MGLMapView. Similar to the Annotation views example, this example demonstrates how native UIViews can be used to mark locations on a map. For more information about working with gesture recognizers, see our User interactions guide. To learn about more ways to add points to a map, see the Markers and annotations guide. Swift Objective C import Mapbox // Example view controller class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.styleURL = MGLStyle.lightStyleURL mapView.tintColor = .darkGray mapView.zoomLevel = 1 mapView.delegate = self view.addSubview(mapView) // Specify coordinates for our annotations. let coordinates = [ CLLocationCoordinate2D(latitude: 0, longitude: -70), CLLocationCoordinate2D(latitude: 0, longitude: -35), CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 0, longitude: 35), CLLocationCoordinate2D(latitude: 0, longitude: 70) ] // Fill an array with point annotations and add it to the map. var pointAnnotations = [MGLPointAnnotation]() for coordinate in coordinates { let point = MGLPointAnnotation() point.coordinate = coordinate point.title = ""To drag this annotation, first tap and hold."" pointAnnotations.append(point) } mapView.addAnnotations(pointAnnotations) } // MARK: - MGLMapViewDelegate methods // This delegate method is where you tell the map to load a view for a specific annotation. To load a static MGLAnnotationImage, you would use `-mapView:imageForAnnotation:`. func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? { // This example is only concerned with point annotations. guard annotation is MGLPointAnnotation else { return nil } // For better performance, always try to reuse existing annotations. To use multiple different annotation views, change the reuse identifier for each. if let annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: ""draggablePoint"") { return annotationView } else { return DraggableAnnotationView(reuseIdentifier: ""draggablePoint"", size: 50) } } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { return true } } // MGLAnnotationView subclass class DraggableAnnotationView: MGLAnnotationView { init(reuseIdentifier: String, size: CGFloat) { super.init(reuseIdentifier: reuseIdentifier) // `isDraggable` is a property of MGLAnnotationView, disabled by default. isDraggable = true // This property prevents the annotation from changing size when the map is tilted. scalesWithViewingDistance = false // Begin setting up the view. frame = CGRect(x: 0, y: 0, width: size, height: size) backgroundColor = .darkGray // Use CALayer’s corner radius to turn this view into a circle. layer.cornerRadius = size / 2 layer.borderWidth = 1 layer.borderColor = UIColor.white.cgColor layer.shadowColor = UIColor.black.cgColor layer.shadowOpacity = 0.1 } // These two initializers are forced upon us by Swift. override init(frame: CGRect) { super.init(frame: frame) } required init?(coder aDecoder: NSCoder) { fatalError(""init(coder:) has not been implemented"") } // Custom handler for changes in the annotation’s drag state. override func setDragState(_ dragState: MGLAnnotationViewDragState, animated: Bool) { super.setDragState(dragState, animated: animated) switch dragState { case .starting: print(""Starting"", terminator: """") startDragging() case .dragging: print(""."", terminator: """") case .ending, .canceling: print(""Ending"") endDragging() case .none: break @unknown default: fatalError(""Unknown drag state"") } } // When the user interacts with an annotation, animate opacity and scale changes. func startDragging() { UIView.animate(withDuration: 0.3, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0, options: [], animations: { self.layer.opacity = 0.8 self.transform = CGAffineTransform.identity.scaledBy(x: 1.5, y: 1.5) }, completion: nil) // Initialize haptic feedback generator and give the user a light thud. if #available(iOS 10.0, *) { let hapticFeedback = UIImpactFeedbackGenerator(style: .light) hapticFeedback.impactOccurred() } } func endDragging() { transform = CGAffineTransform.identity.scaledBy(x: 1.5, y: 1.5) UIView.animate(withDuration: 0.3, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0, options: [], animations: { self.layer.opacity = 1 self.transform = CGAffineTransform.identity.scaledBy(x: 1, y: 1) }, completion: nil) // Give the user more haptic feedback when they drop the annotation. if #available(iOS 10.0, *) { let hapticFeedback = UIImpactFeedbackGenerator(style: .light) hapticFeedback.impactOccurred() } } } Copy Was this page helpful? Yes No",,Draggable annotation views,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Build a store locator using Mapbox.js,Build a map application with Mapbox.js. This guide walks you through all the code that you need to build a store locator.,https://docs.mapbox.com/help/tutorials/building-a-store-locator-js/,tutorial,JavaScript,,"advanced JavaScript Build a store locator using Mapbox.js Prerequisite Familiarity with front-end development concepts. Some advanced JavaScript required. Note Mapbox.js is no longer in active development. To learn more about our newer mapping tools see Build a store locator with Mapbox GL JS. In this tutorial, you'll learn how to create a store locator map. Using your new map, you'll be able to browse through a list of locations from a sidebar and select a specific store to view more information. Selecting a marker on the map will highlight the selected store on the sidebar. View fullscreen demo For this tutorial, you're going to use Sweetgreen, a local salad shop, as an example. They have a healthy number of locations, plus their salads are delicious. This guide gets into a few more advanced JavaScript concepts with Mapbox.js. If you're new to Mapbox.js, we recommend you read our Extending with Mapbox.js guide first. Getting started Before writing any code, create a local folder called ""store-locator"" to house your project files. This folder is referred to as your project folder from here on out. There are a few resources you'll need to gather before we get started: A tileset ID. A tileset ID points to a unique map you have created with Mapbox. For the purposes of this guide, you'll use the tileset ID mapbox.k8xv42t9, but you can substitute your own custom tileset if you like! Your access token. The token is used to associate a map with your account: L.mapbox.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; Mapbox.js. The Mapbox JavaScript API for building maps. Data. We collected Sweetgreen's locations and marked up the data in GeoJSON for your convenience. Custom map marker. Your finished map will have some fancy custom images for its markers. Save the image to your project folder. A text editor. You'll be writing HTML, CSS, and JavaScript after all. Add structure In your project folder, create an index.html file. Set up the document by adding reference the Mapbox.js JavaScript library and its accompanying CSS: <script src='https://api.mapbox.com/mapbox.js/ v3.2.0 /mapbox.js'></script> <link href='https://api.mapbox.com/mapbox.js/ v3.2.0 /mapbox.css' rel='stylesheet' /> Next, markup the page to create a map container and sidebar listing: <div class='sidebar pad2'>Listing</div> <div id='map' class='map pad2'>Map</div> Apply a bit of CSS so you can visualize what the layout looks like: body { background: #404040; color: #f8f8f8; font: 500 20px/26px 'Helvetica Neue', Helvetica, Arial, Sans-serif; margin: 0; padding: 0; -webkit-font-smoothing: antialiased; } /** * The page is split between map and sidebar - the sidebar gets 1/3, map * gets 2/3 of the page. You can adjust this to your personal liking. */ .sidebar { width: 33.3333%; } .map { border-left: 1px solid #fff; position: absolute; left: 33.3333%; width: 66.6666%; top: 0; bottom: 0; } .pad2 { padding: 20px; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } View fullscreen demo Initialize map Now that you have set up the structure of the project, bring your map to life by initializing it with Mapbox.js. First, create an instance of L.mapbox.map and store it in a variable called map. You'll also use setView to focus the map to Washington DC where all the shops are located. Here, you'll need to update your tileset ID and access token. Add the script under your HTML: L.mapbox.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = L.mapbox.map('map') .setView([38.909671288923, -77.034084142948], 13) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); Load data Before you put any markers on your map, store all the GeoJSON data you downloaded above in a variable called geojson. Once the map is initialized, you can use featureLayer.setGeoJSON to load features on the map by referencing the geojson variable: L.mapbox.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var geojson = { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.034084142948, 38.909671288923 ] }, ""properties"": { ""phoneFormatted"": ""(202) 234-7336"", ""phone"": ""2022347336"", ""address"": ""1471 P St NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 15th St NW"", ""postalCode"": ""20005"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.049766, 38.900772 ] }, ""properties"": { ""phoneFormatted"": ""(202) 507-8357"", ""phone"": ""2025078357"", ""address"": ""2221 I St NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 22nd St NW"", ""postalCode"": ""20037"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.043929, 38.910525 ] }, ""properties"": { ""phoneFormatted"": ""(202) 387-9338"", ""phone"": ""2023879338"", ""address"": ""1512 Connecticut Ave NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at Dupont Circle"", ""postalCode"": ""20036"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.0672, 38.90516896 ] }, ""properties"": { ""phoneFormatted"": ""(202) 337-9338"", ""phone"": ""2023379338"", ""address"": ""3333 M St NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 34th St NW"", ""postalCode"": ""20007"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.002583742142, 38.887041080933 ] }, ""properties"": { ""phoneFormatted"": ""(202) 547-9338"", ""phone"": ""2025479338"", ""address"": ""221 Pennsylvania Ave SE"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""btwn 2nd & 3rd Sts. SE"", ""postalCode"": ""20003"", ""state"": ""D.C."" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -76.933492720127, 38.99225245786 ] }, ""properties"": { ""address"": ""8204 Baltimore Ave"", ""city"": ""College Park"", ""country"": ""United States"", ""postalCode"": ""20740"", ""state"": ""MD"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.097083330154, 38.980979 ] }, ""properties"": { ""phoneFormatted"": ""(301) 654-7336"", ""phone"": ""3016547336"", ""address"": ""4831 Bethesda Ave"", ""cc"": ""US"", ""city"": ""Bethesda"", ""country"": ""United States"", ""postalCode"": ""20814"", ""state"": ""MD"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.359425054188, 38.958058116661 ] }, ""properties"": { ""phoneFormatted"": ""(571) 203-0082"", ""phone"": ""5712030082"", ""address"": ""11935 Democracy Dr"", ""city"": ""Reston"", ""country"": ""United States"", ""crossStreet"": ""btw Explorer & Library"", ""postalCode"": ""20190"", ""state"": ""VA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.10853099823, 38.880100922392 ] }, ""properties"": { ""phoneFormatted"": ""(703) 522-2016"", ""phone"": ""7035222016"", ""address"": ""4075 Wilson Blvd"", ""city"": ""Arlington"", ""country"": ""United States"", ""crossStreet"": ""at N Randolph St."", ""postalCode"": ""22203"", ""state"": ""VA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -75.28784, 40.008008 ] }, ""properties"": { ""phoneFormatted"": ""(610) 642-9400"", ""phone"": ""6106429400"", ""address"": ""68 Coulter Ave"", ""city"": ""Ardmore"", ""country"": ""United States"", ""postalCode"": ""19003"", ""state"": ""PA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -75.20121216774, 39.954030175164 ] }, ""properties"": { ""phoneFormatted"": ""(215) 386-1365"", ""phone"": ""2153861365"", ""address"": ""3925 Walnut St"", ""city"": ""Philadelphia"", ""country"": ""United States"", ""postalCode"": ""19104"", ""state"": ""PA"" } }, { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.043959498405, 38.903883387232 ] }, ""properties"": { ""phoneFormatted"": ""(202) 331-3355"", ""phone"": ""2023313355"", ""address"": ""1901 L St. NW"", ""city"": ""Washington DC"", ""country"": ""United States"", ""crossStreet"": ""at 19th St"", ""postalCode"": ""20036"", ""state"": ""D.C."" } } ] } ; var map = L.mapbox.map('map') .setView([38.909671288923, -77.034084142948], 13) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')) .featureLayer.setGeoJSON(geojson); View fullscreen demo Alternatively, you can save the GeoJSON as a .geojson file and load the file on to the map. If you do this, you will need to run your application from a local web server (something like http://localhost/store-locator.html). If you try to open your index.html file directly in your browser, you will receive a Cross-origin Resource Sharing (CORS) error. Build listings and tooltips You have some markers on the map, but you still need to build the listings and tooltips. Rather than creating each manually, you can put JavaScript to work to read through the GeoJSON and dynamically build listings and set tooltips for us. This means that if you need to add a location then you only need to update the GeoJSON. L.mapbox.featureLayer allows you to iterate over data before it is added to the map using the eachLayer method. This means that JavaScript will run through each point, populate the custom tooltip, add each location listing to the sidebar, and listen for and respond to a user's click event to track when a marker or listing is selected: var locations = L.mapbox.featureLayer().addTo(map); locations.setGeoJSON(geojson); locations.eachLayer(function(locale) { // Iterate over each marker. } ); The variable locations references your new L.mapbox.featureLayer, then taps into eachLayer. The passed parameter locale is each marker object. At this point you can start populating content into each listing using information provided by each locale. Nice! But you still need to update the sidebar HTML to hold the listing information: <div class='sidebar'> <div class='heading'> <h1>Our locations</h1> </div> <div id='listings' class='listings'></div> </div> Next, update your CSS to accommodate your layout changes: body { color: #404040; font: 400 15px/22px 'Helvetica Neue', Sans-serif; margin: 0; padding: 0; -webkit-font-smoothing: antialiased; } * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } h1 { font-size: 22px; margin: 0; font-weight: 400; } a { color: #404040; text-decoration: none; } a:hover { color: #101010; } .sidebar { position: absolute; width: 33.3333%; height: 100%; top: 0; left: 0; overflow: hidden; border-right: 1px solid rgba(0, 0, 0, 0.25); } .pad2 { padding: 20px; } .quiet { color: #888; } .map { position: absolute; left: 33.3333%; width: 66.6666%; top: 0; bottom: 0; } .heading { background: #fff; border-bottom: 1px solid #eee; height: 60px; line-height: 60px; padding: 0 10px; } .listings { height: 100%; overflow: auto; padding-bottom: 60px; } .listings .item { display: block; border-bottom: 1px solid #eee; padding: 10px; text-decoration: none; } .listings .item:last-child { border-bottom: none; } .listings .item .title { display: block; color: #00853e; font-weight: 700; } .listings .item .title small { font-weight: 400; } .listings .item.active .title, .listings .item .title:hover { color: #8cc63f; } .listings .item.active { background-color: #f8f8f8; } ::-webkit-scrollbar { width: 3px; height: 3px; border-left: 0; background: rgba(0, 0, 0, 0.1); } ::-webkit-scrollbar-track { background: none; } ::-webkit-scrollbar-thumb { background: #00853e; border-radius: 0; } .clearfix { display: block; } .clearfix::after { content: '.'; display: block; height: 0; clear: both; visibility: hidden; } /* Marker tweaks */ .leaflet-popup-close-button { display: none; } .leaflet-popup-content { font: 400 15px/22px 'Source Sans Pro', 'Helvetica Neue', Sans-serif; padding: 0; width: 200px; } .leaflet-popup-content-wrapper { padding: 0; } .leaflet-popup-content h3 { background: #91c949; color: #fff; margin: 0; display: block; padding: 10px; border-radius: 3px 3px 0 0; font-weight: 700; margin-top: -15px; } .leaflet-popup-content div { padding: 10px; } .leaflet-container .leaflet-marker-icon { cursor: pointer; } Now you can put the finishing touches on your script. Outside of eachLayer, create a variable called listings that selects the listing container in the HTML. With this selected you can append each listing into the sidebar: var listings = document.getElementById('listings'); locations.eachLayer(function(locale) { // Shorten locale.feature.properties to `prop` so we're not // writing this long form over and over again. var prop = locale.feature.properties; var listing = listings.appendChild(document.createElement('div')); listing.className = 'item'; var link = listing.appendChild(document.createElement('a')); link.href = '#'; link.className = 'title'; link.innerHTML = prop.address; if (prop.crossStreet) { link.innerHTML += ' <br /><small>' + prop.crossStreet + '</small>'; } var details = listing.appendChild(document.createElement('div')); details.innerHTML = prop.city; if (prop.phone) { details.innerHTML += ' · ' + prop.phoneFormatted; } } ); The link variable should have the special behavior of panning to its associated marker on the map. By binding an onclick event, you can target the current locale object in context, pan the map to the object's coordinates, and trigger its tooltip to appear. link.onclick = function() { // 1. Toggle an active class for `listing`. View the source in the demo link for example. // 2. When a menu item is clicked, animate the map to center // its associated locale and open its popup. map.setView(locale.getLatLng(), 16); locale.openPopup(); } ; Each marker tooltip requires unique information. Use the bindPopup method to pass content to your popups. var popup = 'Sweetgreen'; locale.bindPopup(popup); Finally, make sure that when a user clicks a marker that it sets the associated listing in the sidebar as active by binding a click event handler to each locale. locale.on('click', function() { // 1. Toggle an active class for `listing`. View the source in the demo link for example. // 2. center the map on the selected marker. map.setView(locale.getLatLng(), 16); } ); At this point, your whole script should look like: var listings = document.getElementById('listings'); var locations = L.mapbox.featureLayer().addTo(map); locations.setGeoJSON(geojson); function setActive(el) { var siblings = listings.getElementsByTagName('div'); for (var i = 0; i < siblings.length; i++) { siblings[i].className = siblings[i].className .replace(/active/, '').replace(/\s\s*$/, ''); } el.className += ' active'; } locations.eachLayer(function(locale) { // Shorten locale.feature.properties to `prop` so you don't // have to write this long form over and over again. var prop = locale.feature.properties; // Each marker on the map. var popup = '<h3>Sweetgreen</h3><div>' + prop.address; var listing = listings.appendChild(document.createElement('div')); listing.className = 'item'; var link = listing.appendChild(document.createElement('a')); link.href = '#'; link.className = 'title'; link.innerHTML = prop.address; if (prop.crossStreet) { link.innerHTML += '<br /><small class=""quiet"">' + prop.crossStreet + '</small>'; popup += '<br /><small class=""quiet"">' + prop.crossStreet + '</small>'; } var details = listing.appendChild(document.createElement('div')); details.innerHTML = prop.city; if (prop.phone) { details.innerHTML += ' · ' + prop.phoneFormatted; } link.onclick = function() { setActive(listing); // When a menu item is clicked, animate the map to center // its associated locale and open its popup. map.setView(locale.getLatLng(), 16); locale.openPopup(); return false; } ; // Marker interaction locale.on('click', function(e) { // 1. center the map on the selected marker. map.panTo(locale.getLatLng()); // 2. Set active the markers associated listing. setActive(listing); } ); popup += '</div>'; locale.bindPopup(popup); } ); View fullscreen demo There's a lot of code inside the eachLayer function because it makes sure each event is bound to its respective elements. Add custom markers You could add style to our markers by adding property keys to each feature in the GeoJSON, but for this example you want to give your stores unique and fancy markers. To give your markers a custom icon, use the setIcon function inside the locations.eachLayer function you created earlier. In setIcon, pass L.icon with your own custom options by copying and pasting the following right after locale.bindPopup(popup);: locale.setIcon(L.icon( { iconUrl: 'marker.png', iconSize: [56, 56], iconAnchor: [28, 28], popupAnchor: [0, -34] } )); Freshen up your map's type with the Source Sans Pro font: <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700' rel='stylesheet'> You'll also need to update the font property in body style: font:400 15px/22px 'Source Sans Pro', 'Helvetica Neue', Sans-serif; Finished product You have completed the store locator! View fullscreen demo Download the completed project If you're interested in loading your GeoJSON from a file, here's the slightly modified code. Heads up! You'll need to serve these files to avoid a CORS error. Next steps Nice job! We hope you're set with the tools to create your own store locator. For bonus points, if a store's location data is added to Foursquare you could extend this example even further by pulling data directly from Foursquare's API. API requests return geolocated information and details about a place. This would allow for more dynamic data like user submitted images or the total number of check-ins a location has received. Was this page helpful? Yes No",,Build a store locator using Mapbox.js,Add structure,Initialize map,Load data,Build listings and tooltips,Add custom markers,Finished product,Next steps,,,,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a generated icon to the map,Add an icon to the map that was generated at runtime.,https://docs.mapbox.com/mapbox-gl-js/example/add-image-generated/,example,JavaScript,,Add a generated icon to the map Add an icon to the map that was generated at runtime. Was this example helpful? Yes No,,Add a generated icon to the map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Point-in-polygon query with Mapbox Boundaries,Query data in v2 of the Mapbox Boundaries tileset.,https://docs.mapbox.com/help/tutorials/point-in-polygon-query-with-mapbox-boundaries/,tutorial,JavaScript,,"intermediate JavaScript Point-in-polygon query with Mapbox Boundaries Prerequisite Familiarity with front-end development and access to Mapbox Boundaries. Access to Mapbox Boundaries Access to the Mapbox Boundaries tilesets are controlled by Mapbox account access token. If you do not have access on your account, contact a Mapbox sales representative to request access to Boundaries tilesets. Mapbox Enterprise users can add global administrative, postal, and statistical boundaries to their maps and data visualizations. This guide covers how to use Mapbox Boundaries with the Mapbox Tilequery API to query points in polygons. Getting started Mapbox Boundaries are available as a part of an Enterprise plan. If you do not have an Enterprise plan or if you do have an Enterprise plan and would like to add access to Mapbox Boundaries, contact a Mapbox sales representative to request access. Access to the Boundaries tilesets are controlled by your Mapbox account access token. About the Tilequery API The Mapbox Tilequery API allows you to get data from a tileset without necessarily rendering a map. You can use the Tilequery API to match points to polygons, in other words, you can provide the coordinates for a point and determine which (if any) polygons in a specified tileset exist at that point. Here's what a Tilequery API request using a Boundaries tileset would look like: https://api.mapbox.com/v4/mapbox.enterprise-boundaries-a0-v2/tilequery/ { longitude,latitude } .json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Note Be sure to use an access token from an account that has access to Mapbox Boundaries. If the specified point is within a polygon, the Tilequery API response will include a GeoJSON-format body with all features in the tileset. The id property value of the first feature returned is the ID of the Boundaries feature that contains the queried point. Since the feature lookup table contains all Mapbox Boundaries parent features, only one API request is required per point to find all matching parent boundaries. For example, you can query the admin-2 boundary of a point in Italy, and use the lookup table to find the parent features at admin-1 and admin-0. Query Mapbox Boundaries Below is an example API response from a sample query to admin-2 in Italy. The query URL is: https://api.mapbox.com/v4/mapbox.enterprise-boundaries-a2-v2/tilequery/12.87,43.100.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Note Be sure to use an access token from an account that has access to Mapbox Boundaries. The id returned is the identifier of the Boundaries feature containing the point at admin-2. { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ 12.87, 43.1 ] } , ""properties"": { ""id"": ""ITA2054"", ""worldview"": ""all"", ""tilequery"": { ""distance"": 0, ""geometry"": ""polygon"", ""layer"": ""boundaries_admin_2"" } } } ] } Query multiple tilesets You can query multiple admin levels in one API call using tile compositing. The query below will return the ids at a location for admin-1, admin-2, and admin-3: https://api.mapbox.com/v4/mapbox.enterprise-boundaries-a3-v2,mapbox.enterprise-boundaries-a2-v2,mapbox.enterprise-boundaries-a1-v2/tilequery/12.87,43.100.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Note Find the complete list of Boundaries tilesets in the reference documentation. This technique allows for aggregating and visualizing points at any admin level or multiple admin levels, down to individual points, as an API service. Next steps Learn more about the Tilequery API Build an application that determines which timezone you are in using the Mapbox Tilequery API and the native HTML geolocation API with our Create a timezone finder tutorial. Learn more about Mapbox Boundaries Learn more about how you can use Mapbox Boundaries. Data-joins with Mapbox Boundaries: The data-join technique involves inner joins between local data, such as the unemployment rate by US state, to vector tile features, such as admin boundaries in Mapbox Boundaries, using data-driven style notation. Extend Mapbox Boundaries: You can extend Mapbox Boundaries with any custom data you need for your application. This could mean adding school district, city, market, or property boundaries to your application — all with the same performance and API features of the native product. Advanced use cases You can also explore this end to end example, which uses the concepts outlined in both this point-in-polygon query tutorial and the data-join tutorial to create an application featuring an interactive choropleth map. Was this page helpful? Yes No",,Point-in-polygon query with Mapbox Boundaries,About the Tilequery API,Query Mapbox Boundaries,Query multiple tilesets,Next steps,Learn more about the Tilequery API,Learn more about Mapbox Boundaries,Advanced use cases,,,,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Button interaction styling,Change various properties of a map based on user interaction and other runtime situations.,https://docs.mapbox.com/android/maps/examples/runtime-styling/,example,Java,,"Button interaction styling Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.styles.RuntimeStylingActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""19.948045"" mapbox:mapbox_cameraTargetLng=""-84.654463"" mapbox:mapbox_cameraZoom=""3.371717"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/floatingActionButton"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" app:srcCompat=""@drawable/ic_swap_horiz_white_24dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" android:layout_marginBottom=""16dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.graphics.Color; import android.os.Bundle; import android.view.View; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.Layer; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; /** * Change various properties of a map based on user interaction and other runtime situations. */ public class RuntimeStylingActivity extends AppCompatActivity { private MapView mapView; private Layer waterLayer; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_styles_runtime_styling); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { waterLayer = style.getLayer(""water""); findViewById(R.id.floatingActionButton).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (waterLayer != null) { waterLayer.setProperties(PropertyFactory.fillColor(Color.parseColor(""#023689"")) ); } for (Layer singleMapLayer : style.getLayers()) { if (singleMapLayer.getId().contains(""water-"") && !singleMapLayer.getId().equals(""water-shadow"")) { singleMapLayer.setProperties( PropertyFactory.textHaloBlur(10f), PropertyFactory.textSize(25f), PropertyFactory.textColor(Color.parseColor(""#00FF08"")), PropertyFactory.textOpacity(1f) ); } } } }); } }); } }); } // Add the mapView's own lifecycle methods to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Button interaction styling,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Get started with Mapbox GL JS expressions,Learn how to write expressions in Mapbox GL JS.,https://docs.mapbox.com/help/tutorials/mapbox-gl-js-expressions/,tutorial,JavaScript,,"intermediate JavaScript Get started with Mapbox GL JS expressions Prerequisite Familiarity with front-end development concepts. In this guide you'll learn how to write expressions in Mapbox GL JS to style custom data based on a data property and by zoom level. Getting started A Mapbox account and access token. Sign up for an account at mapbox.com/signup. You can find your access tokens on your Account page. Mapbox GL JS. You'll be using, Mapbox GL JS, our JavaScript library. A style URL. You'll need a style URL to initialize your map. You'll walk through how to find your style URL in the Add a designer style to your account section of this guide. Data. In this tutorial, you'll be using a CSV file of HPC Landmarks from Open Minneapolis. Download the data What are expressions? In the Mapbox Style Specification, the value for any layout property, paint property, or filter may be specified as an expression. Expressions define how one or more feature property value and/or the current zoom level are combined using logical, mathematical, string, or color operations to produce the appropriate style property value or filter decision. A property expression is any expression defined using a reference to feature property data. Property expressions allow the appearance of a feature to change with its properties. They can be used to visually differentiate types of features within the same layer or create data visualizations. Property expressions vs. property functions If you have worked with Mapbox GL JS before, you may be familiar with property functions. Property expressions can help you achieve similar effects as property functions, with much more flexibility and functionality. Property expressions were introduced in Mapbox GL JS v0.41.0. While property functions are available, they will ultimately be deprecated and replaced by property expressions. Uses There are countless ways to apply property expressions to your application, including: Data-driven styling: Specify style rules based on one or more data attribute. Arithmetic: Do arithmetic on source data, for example performing calculations to convert units. Conditional logic: Use if-then logic, for example to decide exactly what text to display for a label based on which properties are available in the feature or even the length of the name. String manipulation: Take control over label text with things like uppercase, lowercase, and title case transforms without having to edit, re-prepare and re-upload your data. Syntax Mapbox GL JS expressions uses a Lisp-like syntax, represented using JSON arrays. Expressions follow this format: [expression_name, argument_0, argument_1, ...] The expression_name is the expression operator, for example, you would use '*' to multiply two arguments or 'case' to create conditional logic. For a complete list of all available expressions see the Mapbox Style Specification. The arguments are either literal (numbers, strings, or boolean values) or else themselves expressions. The number of arguments varies based on the expression. Here's one example using an expression to calculate an arithmetic expression (π * 32): ['*', ['pi'], ['^', 3, 2]] This example uses a '*' expression to multiply two arguments. The first argument is 'pi', which is an expression that returns the mathematical constant pi. The second arguement is another expression: a '^' expression with two arguments of its own. It will return 32, and the result will be multiplied by π. Set up a map Now that you've had an introduction to the uses and syntax for expressions, it's time to test it out yourself! Initialize a map with Mapbox GL JS and add the custom data as a circle layer. Add a designer style to your account The map in this guide uses one of our designer styles. To use a designer style you'll need to start by adding it to your account. Sign into your Mapbox account and visit the designer map page to add a new style to your account: Visit mapbox.com/designer-maps. Find the North Star style and click Add this style. The style will automatically be added to your Mapbox account. When the style is added to your account, it will appear on the Styles page in Mapbox Studio. From here, you can find the style URL for the style. You'll use the style URL to add this style to your map: Find the style on your Styles page. Click on the Menu next to the style name. Find the Style URL. You can use the clipboard icon to copy the style URL, which you'll use in the Initialize a map with data section. Upload data In this guide, you'll use a vector tileset to display data in your application. You can create a vector tileset by uploading the CSV you downloaded earlier to Mapbox Studio: Visit the Tilesets page in Mapbox Studio. Click New tileset. Select the CSV you downloaded at the beginning of this tutorial and click Confirm. A popover will appear in the bottom right showing the progress of your upload. Once the upload has Succeeded, the tileset will be ready to use! Click on the name of the tileset in the popover, which will open the tileset information page. Take note of the tileset ID on the right side of the tileset information page. You will use the ID to add this tileset to your map in the next step. Initialize a map with data In a text editor, create a new index.html file and use the following code to initialize your map. You will need to: Make sure mapboxgl.accessToken is set equal to one of your access tokens. Replace your-style-url-here with your style URL. Replace your-tileset-id-here with the tileset ID for the tileset you created. Replace your-source-layer-here with the name of the source layer in your tileset. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title></title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // container id style: 'your-style-url-here', // stylesheet location center: [-93.261, 44.971], // starting position [lng, lat] zoom: 10 // starting zoom } ); map.on('load', function() { map.addLayer( { id: 'historical-places', type: 'circle', source: { type: 'vector', url: 'mapbox://your-tileset-id-here' } , 'source-layer': 'your-source-layer-here', } ); } ); </script> </body> </html> Run your application in a browser, and you will see a light colored map centered on Minneapolis with black dots scattered across the city. Write a property expression Next, you'll write an expression to style the radius of each circle based on the age of each historic landmark. In this data file, provided by the City of Minneapolis's open data portal, the age of the historic landmark is not provided, but the year of construction is provided. You can use arithmetic to calculate the age based on the current year and style the circle-radius paint property based on the age. Calculate the age of each landmark Start by calculating the age of the landmark. Here's the expression you'll use: ['-', 2017, ['number', ['get', 'Constructi'], 2017]] Use a '-' expression with two arguments. The first argument is a number (the current year, 2017). The second argument is another expression (a 'number' expression) with two arguments. This expression will convert the first argument to a number. If the first argument doesn't have a value, then the second argument, the current year 2017, will be used. The first argument for the 'number' expression is yet another expression — this time a 'get' expression that retrieves the object property value of its only argument, 'Constructi'. ('Constructi' is the 'Construction_Date' from the original CSV file, but the name of the field was shortened in the upload process.) The value that is retrieved using 'get' is turned into a 'number'. Ultimately, this expression results in the age of the landmark, essentially 2017 - year of construction. Specify the circle radius Use this expression inside the existing addLayer function in your code: map.on('load', function() { map.addLayer( { id: 'historical-places', type: 'circle', source: { type: 'vector', url: 'mapbox://your-tileset-id-here' } , 'source-layer': 'your-source-layer-here', paint: { 'circle-radius': ['-', 2017, ['number', ['get', 'Constructi'], 2017]], 'circle-opacity': 0.8, 'circle-color': 'rgb(171, 72, 33)' } } ); } ); Refresh your browser and you'll see that the circle radius has changed dramatically. With the current expression, the radius of a circle representing a landmark that was built in 1950 would be 67 pixels. Next, you'll adjust the radius to be more appropriate in this context. Adjust the circle radius Wrap the expression in one other expression to make the size of the circles look better in this context. In this case, you'll divide the age of the landmark by 10. map.on('load', function() { map.addLayer( { id: 'historical-places', type: 'circle', source: { type: 'vector', url: 'mapbox://your-tileset-id-here' } , 'source-layer': 'your-source-layer-here', paint: { 'circle-radius': [ '/', ['-', 2017, ['number', ['get', 'Constructi'], 2017]], 10 ], 'circle-opacity': 0.8, 'circle-color': 'rgb(171, 72, 33)' } } ); } ); Refresh your browser and you'll see an updated map. Add a zoom expression The circles are still overlapping quite a bit at the starting zoom level, 10.5, but they look good at higher zoom levels. You can use a zoom expression to address this issue. A zoom expression is any expression defined using ['zoom']. Such expressions allow the appearance of a layer to change with the map’s zoom level. Zoom expressions can be used to create the illusion of depth and control data density. Use an 'interpolate' expression. An 'interpolate' expression produces continuous, smooth results by interpolating between pairs of input and output values (""stops""). In this case, use ['linear'] to interpolate linearly between a pair of stops slightly less than and slightly greater than the input. Then, specify that the radius should be the age of the landmark / 30 at zoom level 10 and age of the landmark / 10 at zoom level 13. map.on('load', function() { map.addLayer( { id: 'historical-places', type: 'circle', source: { type: 'vector', url: 'mapbox://your-tileset-id-here' } , 'source-layer': 'your-source-layer-here', paint: { 'circle-radius': [ 'interpolate', ['linear'], ['zoom'], 10, ['/', ['-', 2017, ['number', ['get', 'Constructi'], 2017]], 30], 13, ['/', ['-', 2017, ['number', ['get', 'Constructi'], 2017]], 10], ], 'circle-opacity': 0.8, 'circle-color': 'rgb(171, 72, 33)' } } ); } ); Note If you've worked with property functions before, notice that interpolate expressions allow you to achieve the same effect as stop functions. Refresh your browser and zoom into the map to see the resulting effect. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Minneapolis Landmarks</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // container id style: 'your-style-url-here', // stylesheet location center: [-93.261, 44.971], // starting position [lng, lat] zoom: 10.5 // starting zoom } ); map.on('load', function() { map.addLayer( { id: 'historical-places', type: 'circle', source: { type: 'vector', url: 'mapbox://your-tileset-id-here' } , 'source-layer': 'your-source-layer-here', paint: { 'circle-radius': [ 'interpolate', ['linear'], ['zoom'], 10, ['/', ['-', 2017, ['number', ['get', 'Constructi'], 2017]], 30], 13, ['/', ['-', 2017, ['number', ['get', 'Constructi'], 2017]], 10], ], 'circle-opacity': 0.8, 'circle-color': 'rgb(171, 72, 33)' } } ); } ); </script> </body> </html> Final product You've styled custom data using expressions in Mapbox GL JS! Next steps There are many other ways you can use expressions in Mapbox GL JS. For more information: Read about expressions in the Mapbox Style Specification. Explore other Mapbox GL JS examples that use expressions: Create and style clusters Create a hover effect Create a time slider Filter features within map view Update a choropleth layer by zoom level Was this page helpful? Yes No",,Get started with Mapbox GL JS expressions,What are expressions?,Uses,Syntax,Set up a map,Add a designer style to your account,Upload data,Initialize a map with data,Write a property expression,Calculate the age of each landmark,Specify the circle radius,Adjust the circle radius,Add a zoom expression,Final product,Next steps,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Introduction,Overview of Mapbox Android plugins.,https://docs.mapbox.com/android/plugins/overview/,guide,,,"Android Plugins Show annotations on the map Add in-app place searching Load GeoJSON files onto the map Display traffic and 3D buildings Change the map's language Offline mapping Support Chinese users Quickly add markers Visualize map scale Contribute on GitHub Mapbox Plugins build on top of the Maps SDK providing extra features in lightweight dependencies. Whether you're looking to include traffic on top of your map or show the user location as a layer, plugins offer customizable APIs with a few lines of code to get started. Separating features into different plugins also allows for a more aggressive updating timeline. What are Mapbox Plugins? Mapbox Plugins for Android are a collection of libraries that extend our Maps, Navigation, and Java SDKs for Android to help you integrate powerful mapping features into your applications. Use plugins to show a user's location, display traffic or building overlays, or search for places. With these plugins, you can pick the features that your app needs without losing the ability to customize; all bundled into lightweight dependencies. By using a plugin, you also include the Maps SDK for Android which means that you'll need to setup your project to use the Maps SDK if you haven't already. Head over to the Maps SDK Getting Started documentation to learn more. The example below shows how to install the Traffic Plugin, but the process is the same for other plugins. How plugins work Mapbox plugins cover many of our SDKs for Android. They can be used together or separately depending on your needs. A brief summary of each plugin and its purpose is provided below: Building: Add 3D buildings to your map style with as few as two lines of code. Take this further by allowing users to toggle the layer visibility. Traffic: Place realtime traffic data within your map style as a layer. Places: Add UI components such as a Place Picker or Autocomplete search built on top of the Mapbox Geocoding API. Each component includes an intentBuilder which starts an activity for results and returns a Carmen Feature. Offline: Download map tiles and view already-downloaded regions for offline mapping. Localization: Change the map's language based on the device's default language settings or other runtime variables. China: Provide accurate map tiles and data for Chinese users. Prerequisites Before using any of the Mapbox Plugins for Android, you will need: The latest version of Android Studio. JDK version 7.0 or higher. A recent version of the Android SDK. Android API Level 14 or higher (Android 4.0.3 and above). A Mapbox access token. Available documentation Guides. Each plugin has an associated guide which contains both technical descriptions about the plugin and its features, as well as, conceptual explanations of the different components and how they work together. Examples See the code in action inside of our demo app and use the source code as a good starting point for your project. Maps SDK compatibility The Mapbox Plugins for Android are heavily dependent on the major semantic versioning number of the Maps SDK. They either won't compile or hide runtime bugs when paired with a different major version of the Maps SDK. Each plugin's dependency name has a vX suffix which states the major version of the Maps SDK that the plugin is compatible with. This suffix makes the transition between versions easier and more educated without the need to jump into changelogs and compare repositories. Support and contributions If you are looking for support using this SDK, either reach out through Stack Overflow or through our contact page. If you find a bug and can provide steps to reliably reproduce it, open an issue in the /mapbox-plugins-android repository on GitHub and apply the bug label. If you have a feature request, open an issue in the /mapbox-plugins-android repository on GitHub, and apply the enhancement label. If you want to contribute, look over our contribution guidelines and open a pull request with your changes. Was this page helpful? Yes No",,Android Plugins,How plugins work,Prerequisites,Available documentation,Maps SDK compatibility,Support and contributions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Data-driven styling,Documentation for changing the look and feel of your Mapbox map in real time with the Mapbox Maps SDK for Android.,https://docs.mapbox.com/android/maps/overview/data-driven-styling/,guide,Java,,"Data-driven styling Style Spec Info guide View a full list of the features in runtime styling not specific to Android. Use the Maps SDK's data-driven styling capabilities to create and display many types of data. You can dynamically change the look and feel of your map in real time based on the information within a particular dataset. Data-driven styling is largely built on the idea of sources and layers. Annotation Plugin for Android Sources and layers provide nimble options for customizing the look of a Mapbox map and the data displayed on the map. The Mapbox Annotation Plugin for Android provides a simplified system for interacting with and customizing Mapbox map layers. Sources Sources hold the actual data and layers reference sources. That is how to show data on your Mapbox map. There are a handful of different source types supported and choosing the correct one to use depends on your data type. Adding a source won't instantly make data appear on the map because sources don't contain styling details like color or width. Layers refer to a source and give it a visual representation. Two parameters are required to use a source. A source requires a unique String ID and requires some sort of data. Vector VectorSource tiles must be in Mapbox Vector Tile format. All layers that use a vector source must specify a ""source-layer"" value. For vector tiles hosted by Mapbox, the URL value should be of the form mapbox://mapid. Java Kotlin // Adding a vector source layer VectorSource vectorSource = new VectorSource(""vector-source"", ""mapbox://mapbox.mapbox-terrain-v2""); mapboxMap.getStyle().addSource(vectorSource); Copy Raster RasterSource tiles can be added to your map if they are in TileJSON format. If hosted by Mapbox, the URL value should be of the form mapbox://mapid. Java Kotlin // Adding a raster source layer RasterSource rasterSource = new RasterSource(""raster-source"", ""mapbox://mapbox.u8yyzaor""); mapboxMap.getStyle().addSource(rasterSource); Copy GeoJson Add a GeoJSON source example Create a GeoJSON feature collection dynamically and then add it as a map source. Adding a GeoJsonSource can be done in a few different ways. You can provide a URL to the GeoJSON raw data hosted online, provide a link to a GeoJSON file hosted locally inside of the app's assets folder, or you can build your own GeoJSON FeatureCollection directly inside of the code. The snippets of code below show the different ways to add a GeoJSON source to your map. Add a GeoJSON source from a URL: Java Kotlin try { URL geoJsonUrl = new URL(""https://url-to-geojson-file.geojson""); GeoJsonSource geoJsonSource = new GeoJsonSource(""geojson-source"", geoJsonUrl); mapboxMap.getStyle().addSource(geoJsonSource); } catch (MalformedURLException exception) { Log.d(TAG, exception); } Copy Load a locally stored GeoJSON file. Either use the loadJsonFromAsset() method found below or use your own preferred way of loading in a JSON file: Java Kotlin private String loadJsonFromAsset(String nameOfLocalFile) throws IOException { InputStream is = getAssets().open(nameOfLocalFile); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } GeoJsonSource source = new GeoJsonSource(""geojson-source"", loadJsonFromAsset(""local_file.geojson"")); mapboxMap.addSource(source); Copy Create a GeoJSON FeatureCollection and add it to your map: Java Kotlin // Create a list to store our line coordinates. List routeCoordinates = new ArrayList<Point>(); routeCoordinates.add(Point.fromLngLat(-118.394391, 33.397676)); routeCoordinates.add(Point.fromLngLat(-118.370917, 33.391142)); // Create the LineString from the list of coordinates and then make a GeoJSON FeatureCollection so that you can add the line to our map as a layer. LineString lineString = LineString.fromLngLats(routeCoordinates); FeatureCollection featureCollection = FeatureCollection.fromFeatures( new Feature[]{Feature.fromGeometry(lineString)}); GeoJsonSource geoJsonSource = new GeoJsonSource(""geojson-source"", featureCollection); mapboxMap.getStyle().addSource(geoJsonSource); Copy Runtime intro tutorial Read an explanation and view the code for using runtime styling to change a map's water color. A benefit of having your data inside a GeoJSON source is that you can update, remove, or add additional Features inside the source at any time, providing a solution to animating data in your map through the Runtime Styling API. For example, an Android ValueAnimator can move a feature by updating its coordinates within the GeoJSON data. Image ImageSource allows for a georeferenced raster image to be shown on top of the map. The georeferenced image scales and rotates as the user zooms, tilts, and rotates the map. The geographic location of the raster image content, supplied with LatLngQuad, can be non-axis aligned. Java Kotlin // Set the latitude and longitude coordinates of the image's four corners LatLngQuad quad = new LatLngQuad( new LatLng(46.437, -80.425), new LatLng(46.437, -71.516), new LatLng(37.936, -71.516), new LatLng(37.936, -80.425)); mapboxMap.getStyle().addSource(new ImageSource(ID_IMAGE_SOURCE, quad, DRAWABLE_IMAGE_HERE)); // Add layer RasterLayer layer = new RasterLayer(ID_IMAGE_LAYER, IMAGE_SOURCE_ID); mapboxMap.getStyle().addLayer(layer); Copy The setImage() method is a convenient way to update the ImageSource's image by passing in a drawable. Java Kotlin ImageSource imageSource = (ImageSource) mapboxMap.getSource(ID_IMAGE_SOURCE); imageSource.setImage(DESIRED_IMAGE); Copy Custom geometry A CustomGeometrySource is helpful in situations when you have data which is dynamically generated or needs to be loaded on demand. A FeatureCollection with any type and number of GeoJSON geometries can be used in a CustomGeometrySource. Java Kotlin CustomGeometrySource source = new CustomGeometrySource(CUSTOM_SOURCE_ID, GeometryTileProvider); mapboxMap.getStyle().addSource(source); Copy One example of CustomGeometrySource usage is to create a black grid on top of the map. This example's code can be found in the GridSourceActivity of the Maps SDK for Android test application. Raster DEM RasterDemSource supports Mapbox Terrain RGB (mapbox://mapbox.terrain-rgb) and Mapzen Terrarium tile formats. The Mapbox terrain tileset is for adding hill terrain to any Mapbox map. Runtime styling can also be used to change the hillshade appearance. Java Kotlin RasterDemSource rasterDemSource = new RasterDemSource(""source-id"", ""mapbox://mapbox.terrain-rgb""); mapboxMap.getStyle().addSource(rasterDemSource); // Create hillshade layer source to map HillshadeLayer hillshadeLayer = new HillshadeLayer(""hillshade-layer-id"", ""source-id"").withProperties( hillshadeHighlightColor(Color.parseColor(HILLSHADE_HIGHLIGHT_COLOR)), hillshadeShadowColor(Color.BLACK) ); // Add hillshade layer to map mapboxMap.getStyle().addLayer(hillshadeLayer); Copy Layers While sources hold the data, layers are used to style and display the information. Several layer types are offered depending on your source geometry. Except for layers of the background type, each layer needs to refer to a source. You can optionally filter features and then define how those features are styled. Each layer offers a setProperties API which can be used to style the layer in many different ways. Note that instead of creating different layers depending on certain cases inside your source data, it's recommended to use data-driven styling to reduce the number of layers that the map needs to render. Background The background layer type is unique in that it doesn't require a source. Background layers can be a solid color or a pattern. Java Kotlin BackgroundLayer backgroundLayer = new BackgroundLayer(""background-layer""); backgroundLayer.setProperties( PropertyFactory.backgroundColor(Color.BLUE) ); Copy Fill Fill layers have an enclosed shape geometry that can be useful for marking areas on a map. Use a FillLayer with GeoJSON Polygon or MultiPolygon geometries. The geometry is like a line layer consisting of a series of coordinates in a particular order with the first and last points having the same coordinate. The geometry is ""enclosed"" when the coordinate list starts and ends with the same coordinates. If the geometry isn't enclosed, the FillLayer will render but some vertices and sides might be cut off by the tile boundaries. Java Kotlin FillLayer fillLayer = new FillLayer(""layer-id"", ""source-id""); fillLayer.setProperties( PropertyFactory.fillColor(Color.GREEN) ); Copy To alter the shape of the geometry once you have added it, the layer can stay with no changes needed, only the source it's using should be updated. The layer will always display the latest updates inside its source. Line Create and display line layer guide Build a GeoJSON FeatureCollection with the line geometry and then display it on the map using a line layer. A series of coordinates can be combined to create a line segment that shows on a map. Between each pair of coordinates, a line segment's created which gets drawn straight and connects the two points. Before beginning, you'll want to make sure that the Source your layer will be using has lineStrings as part of its geometry and you can find an example of this in the GeoJSON source section. Once the source has been created and added to the map, a lineLayer can be started, and properties can be set. Java Kotlin LineLayer lineLayer = new LineLayer(""line-layer"", ""line-source""); // The layer properties for our line. This is where you can make the line dotted, set the // color, etc. lineLayer.setProperties( PropertyFactory.lineDasharray(new Float[]{0.01f, 2f}), PropertyFactory.lineCap(Property.LINE_CAP_ROUND), PropertyFactory.lineJoin(Property.LINE_JOIN_ROUND), PropertyFactory.lineWidth(5f), PropertyFactory.lineColor(Color.parseColor(""#e55e5e"")) ); mapboxMap.getStyle().addLayer(lineLayer); Copy Symbol Symbol layers show a single location on the map with either an icon or text label. Like GL Markers and Marker Views, the symbol layer can represent the same data and offers the most power for in map displaying. To begin with, you will add a marker image to the map and then display it as a symbol layer. Java Kotlin Bitmap icon = BitmapFactory.decodeResource(getResources(), R.drawable.my_marker_icon); mapboxMap.getStyle().addImage(""my-marker-image"", icon); SymbolLayer symbolLayer = new SymbolLayer(""layer-id"", ""source-id""); symbolLayer.setProperties( PropertyFactory.iconImage(""my-marker-image"") ); mapboxMap.getStyle().addLayer(symbolLayer); Copy Not only can symbol layers mark locations on the map using an image, but they can also display text directly on the map. The SDK handles text symbol layers in a similar process to the image snippet given above, only the properties of the layer change. Note Use PropertyFactory.iconOffset if you're using a marker icon as a SymbolLayer icon. The middle of any SymbolLayer icon is placed at the coordinate, rather than the bottom of the marker icon. PropertyFactory.iconOffset will move the marker icon up a certain distance so that the bottom of the marker icon (the pin point) will be on the coordinate location. You'll need to find the correct float value to pass through PropertyFactory.iconOffset, because it will depend on the size of the SymbolLayer icon. Java Kotlin loadedMapStyle.addLayer(new SymbolLayer(""SYMBOL_LAYER_ID"", ""SYMBOL_LAYER_SOURCE_ID"").withProperties( iconImage(""SYMBOL_LAYER_ICON_ID""), iconOffset(new Float[] {0f, -8f}) )); Copy Raster Raster layers are typically a collection of images that display on top of the base map tiles. While vector tiles are preferred, satellite imagery or legacy map styles render as a raster layer. Java Kotlin RasterSource rasterSource = new RasterSource(""source-id"", ""mapbox://mapbox.u8yyzaor""); mapboxMap.getStyle().addSource(rasterSource); RasterLayer rasterLayer = new RasterLayer(""layer-id"", ""source-id""); mapboxMap.getStyle().addLayer(rasterLayer); Copy One common use case for a RasterLayer is adding a layer of satellite tiles to the map: Java Kotlin // Adding a raster source layer RasterSource satelliteRasterSource = new RasterSource(""satellite-raster-source"", ""mapbox://mapbox.satellite"",512); mapboxMap.getStyle().addSource(satelliteRasterSource); Copy Circle Circle layers have a single center coordinate which comes from the source data. It's a geographically accurate projection of a circle on the Earth's surface drawn on the map. A few default properties are provided but can be overridden when the layer's first created. Java Kotlin VectorSource vectorSource = new VectorSource(""source-id"", ""mapbox://mapbox.2opop9hr""); mapboxMap.getStyle().addSource(vectorSource); CircleLayer circleLayer = new CircleLayer(""layer-id"", ""source-id""); circleLayer.setSourceLayer(""museum-cusco""); circleLayer.setProperties( PropertyFactory.visibility(Property.VISIBLE), PropertyFactory.circleRadius(8f), PropertyFactory.circleColor(Color.argb(1, 55, 148, 179)) ); mapboxMap.getStyle().addLayer(circleLayer); Copy Removing sources and layers A source cannot be removed if it's still used by any layer. The removal will fail and log a console warning. Starting in the 7.0.0 release of the Maps SDK, the SDK changed remove methods to return a boolean which states whether the removal was successful. All layers using a particular source must be removed before that source can be removed. Removing a layer: Java Kotlin if (mapboxMap!= null && mapboxMap.getStyle() != null) { mapboxMap.getStyle().removeLayer(""layer-id""); } Copy Removing a source: Java Kotlin if (mapboxMap!= null && mapboxMap.getStyle() != null) { mapboxMap.getStyle().removeSource(""source-id""); } Copy Modify properties Sources and layers aren't immutable so they can be modified anytime during the map render. For example, to alter the fill color of a layer after it's been added to the map, you use the map's Style object to get the layer and set the property. Java Kotlin FillLayer fillLayer = (FillLayer) mapboxMap.getStyle().getLayer(""fill-layer-id""); if (fillLayer != null) { fillLayer.setProperties( PropertyFactory.fillColor(Color.GREEN) ); } Copy In a GeoJSON source, you are able to change, add, remove, or replace the FeatureCollection like so: Java Kotlin GeoJsonSource geoJsonSource = (GeoJsonSource) mapboxMap.getStyle().getSource(""geojson-source-id""); if (geoJsonSource != null) { geoJsonSource.setGeoJson(featureCollection); } Copy Capturing click events Layers are not clickable and don't expose any event listeners for you to handle user input. Instead, the map querying tools can help you detect when a user has interacted with the map. For example, when a FillLayer's Polygon has been tapped on. Alternatively, you can use the Mapbox Annotation Plugin, which provides onClick() and onLongClick() listening. Was this page helpful? Yes No",,Data-driven styling,Vector,Raster,GeoJson,Image,Custom geometry,Raster DEM,Layers,Background,Fill,Line,Symbol,Circle,Removing sources and layers,Modify properties,Capturing click events,,,,,,,,,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Dynamically style interactive points,"Add interactive, dynamically-styled points, derived from a web API call.",https://docs.mapbox.com/ios/maps/examples/runtime-multiple-annotations/,example,Swift,,"Dynamically style interactive points Related example: add multiple annotations. To learn about more ways to add points to a map, see the Markers and annotations guide. For more information on styling data at runtime, see our Information for style authors guide. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 37.090240, longitude: -95.712891), zoomLevel: 2, animated: false) mapView.delegate = self view.addSubview(mapView) // Add a single tap gesture recognizer. This gesture requires the built-in MGLMapView tap gestures (such as those for zoom and annotation selection) to fail. let singleTap = UITapGestureRecognizer(target: self, action: #selector(handleMapTap(sender:))) for recognizer in mapView.gestureRecognizers! where recognizer is UITapGestureRecognizer { singleTap.require(toFail: recognizer) } mapView.addGestureRecognizer(singleTap) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { fetchPoints() { [weak self] (features) in self?.addItemsToMap(features: features) } } func addItemsToMap(features: [MGLPointFeature]) { // MGLMapView.style is optional, so you must guard against it not being set. guard let style = mapView.style else { return } // You can add custom UIImages to the map style. // These can be referenced by an MGLSymbolStyleLayer’s iconImage property. style.setImage(UIImage(named: ""lighthouse"")!, forName: ""lighthouse"") // Add the features to the map as a shape source. let source = MGLShapeSource(identifier: ""us-lighthouses"", features: features, options: nil) style.addSource(source) let lighthouseColor = UIColor(red: 0.08, green: 0.44, blue: 0.96, alpha: 1.0) // Use MGLCircleStyleLayer to represent the points with simple circles. // In this case, we can use style functions to gradually change properties between zoom level 2 and 7: the circle opacity from 50% to 100% and the circle radius from 2pt to 3pt. let circles = MGLCircleStyleLayer(identifier: ""lighthouse-circles"", source: source) circles.circleColor = NSExpression(forConstantValue: lighthouseColor) // The circles should increase in opacity from 0.5 to 1 based on zoom level. circles.circleOpacity = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [2: 0.5, 7: 1]) circles.circleRadius = NSExpression(format: ""mgl_step:from:stops:($zoomLevel, 1, %@)"", [2: 2, 7: 3]) // Use MGLSymbolStyleLayer for more complex styling of points including custom icons and text rendering. let symbols = MGLSymbolStyleLayer(identifier: ""lighthouse-symbols"", source: source) symbols.iconImageName = NSExpression(forConstantValue: ""lighthouse"") symbols.iconColor = NSExpression(forConstantValue: lighthouseColor) symbols.iconScale = NSExpression(forConstantValue: 0.5) symbols.iconHaloColor = NSExpression(forConstantValue: UIColor.white.withAlphaComponent(0.5)) symbols.iconHaloWidth = NSExpression(forConstantValue: 1) symbols.iconOpacity = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [5.9: 0, 6: 1]) // ""name"" references the ""name"" key in an MGLPointFeature’s attributes dictionary. symbols.text = NSExpression(forKeyPath: ""name"") symbols.textColor = symbols.iconColor symbols.textFontSize = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [10: 10, 16: 16]) symbols.textTranslation = NSExpression(forConstantValue: NSValue(cgVector: CGVector(dx: 10, dy: 0))) symbols.textOpacity = symbols.iconOpacity symbols.textHaloColor = symbols.iconHaloColor symbols.textHaloWidth = symbols.iconHaloWidth symbols.textJustification = NSExpression(forConstantValue: NSValue(mglTextJustification: .left)) symbols.textAnchor = NSExpression(forConstantValue: NSValue(mglTextAnchor: .left)) style.addLayer(circles) style.addLayer(symbols) } // MARK: - Feature interaction @objc @IBAction func handleMapTap(sender: UITapGestureRecognizer) { if sender.state == .ended { // Limit feature selection to just the following layer identifiers. let layerIdentifiers: Set = [""lighthouse-symbols"", ""lighthouse-circles""] // Try matching the exact point first. let point = sender.location(in: sender.view!) for feature in mapView.visibleFeatures(at: point, styleLayerIdentifiers: layerIdentifiers) where feature is MGLPointFeature { guard let selectedFeature = feature as? MGLPointFeature else { fatalError(""Failed to cast selected feature as MGLPointFeature"") } showCallout(feature: selectedFeature) return } let touchCoordinate = mapView.convert(point, toCoordinateFrom: sender.view!) let touchLocation = CLLocation(latitude: touchCoordinate.latitude, longitude: touchCoordinate.longitude) // Otherwise, get all features within a rect the size of a touch (44x44). let touchRect = CGRect(origin: point, size: .zero).insetBy(dx: -22.0, dy: -22.0) let possibleFeatures = mapView.visibleFeatures(in: touchRect, styleLayerIdentifiers: Set(layerIdentifiers)).filter { $0 is MGLPointFeature } // Select the closest feature to the touch center. let closestFeatures = possibleFeatures.sorted(by: { return CLLocation(latitude: $0.coordinate.latitude, longitude: $0.coordinate.longitude).distance(from: touchLocation) < CLLocation(latitude: $1.coordinate.latitude, longitude: $1.coordinate.longitude).distance(from: touchLocation) }) if let feature = closestFeatures.first { guard let closestFeature = feature as? MGLPointFeature else { fatalError(""Failed to cast selected feature as MGLPointFeature"") } showCallout(feature: closestFeature) return } // If no features were found, deselect the selected annotation, if any. mapView.deselectAnnotation(mapView.selectedAnnotations.first, animated: true) } } func showCallout(feature: MGLPointFeature) { let point = MGLPointFeature() point.title = feature.attributes[""name""] as? String point.coordinate = feature.coordinate // Selecting an feature that doesn’t already exist on the map will add a new annotation view. // We’ll need to use the map’s delegate methods to add an empty annotation view and remove it when we’re done selecting it. mapView.selectAnnotation(point, animated: true, completionHandler: nil) } // MARK: - MGLMapViewDelegate func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { return true } func mapView(_ mapView: MGLMapView, didDeselect annotation: MGLAnnotation) { mapView.removeAnnotations([annotation]) } func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? { // Create an empty view annotation. Set a frame to offset the callout. return MGLAnnotationView(frame: CGRect(x: 0, y: 0, width: 20, height: 20)) } // MARK: - Data fetching and parsing func fetchPoints(withCompletion completion: @escaping (([MGLPointFeature]) -> Void)) { // Wikidata query for all lighthouses in the United States: http://tinyurl.com/zrl2jc4 let query = ""SELECT DISTINCT ?item "" + ""?itemLabel ?coor ?image "" + ""WHERE "" + ""{ "" + ""?item wdt:P31 wd:Q39715 . "" + ""?item wdt:P17 wd:Q30 . "" + ""?item wdt:P625 ?coor . "" + ""OPTIONAL { ?item wdt:P18 ?image } . "" + ""SERVICE wikibase:label { bd:serviceParam wikibase:language \""en\"" } "" + ""} "" + ""ORDER BY ?itemLabel"" let characterSet = NSMutableCharacterSet() characterSet.formUnion(with: CharacterSet.urlQueryAllowed) characterSet.removeCharacters(in: ""?"") characterSet.removeCharacters(in: ""&"") characterSet.removeCharacters(in: "":"") let encodedQuery = query.addingPercentEncoding(withAllowedCharacters: characterSet as CharacterSet)! let request = URLRequest(url: URL(string: ""https://query.wikidata.org/sparql?query=\(encodedQuery)&format=json"")!) URLSession.shared.dataTask(with: request, completionHandler: { (data, response, error) in guard error == nil else { preconditionFailure(""Failed to load GeoJSON data: \(error!)"") } guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: AnyObject], let results = json[""results""] as? [String: AnyObject], let items = results[""bindings""] as? [[String: AnyObject]] else { preconditionFailure(""Failed to parse GeoJSON data"") } DispatchQueue.main.async { completion(self.parseJSONItems(items: items)) } }).resume() } func parseJSONItems(items: [[String: AnyObject]]) -> [MGLPointFeature] { var features = [MGLPointFeature]() for item in items { guard let label = item[""itemLabel""] as? [String: AnyObject], let title = label[""value""] as? String else { continue } guard let coor = item[""coor""] as? [String: AnyObject], let point = coor[""value""] as? String else { continue } let parsedPoint = point.replacingOccurrences(of: ""Point("", with: """").replacingOccurrences(of: "")"", with: """") let pointComponents = parsedPoint.components(separatedBy: "" "") let coordinate = CLLocationCoordinate2D(latitude: Double(pointComponents[1])!, longitude: Double(pointComponents[0])!) let feature = MGLPointFeature() feature.coordinate = coordinate feature.title = title // A feature’s attributes can used by runtime styling for things like text labels. feature.attributes = [ ""name"": title ] features.append(feature) } return features } } Copy Was this page helpful? Yes No",,Dynamically style interactive points,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Vector tiles,Mapbox Streets v8,Reference documentation for the Mapbox Streets v8 tileset.,https://docs.mapbox.com/vector-tiles/reference/mapbox-streets-v8/,reference,,,"Mapbox Streets v8 Source id: mapbox.mapbox-streets-v8 This is an in-depth guide to the data inside the Mapbox Streets vector tile source to help with styling. For full examples of using Mapbox Streets vector tiles to create a map style, see the default styles in Mapbox Studio. Overview Data sources & updates Mapbox Streets vector tiles are largely based on data from OpenStreetMap, a free & global source of geographic data built by volunteers. An understanding of the OpenStreetMap data structure and tagging system is not necessary to make use of Mapbox Streets vector tiles, though it's helpful to understand some of the details. When you publicly use styles or software that use Mapbox Streets vector tiles, you must display proper attribution. The current supported version of the Mapbox Streets vector tiles receives regular data updates as new information becomes available and existing information is improved. Layer Source most layers OpenStreetMap replication feed admin custom Mapbox data water (ocean parts) OpenStreetMapData.com place_label, types country & state custom Mapbox data natural_label, types ocean & sea custom Mapbox data Multiple geometry types Mapnik vector tiles support multiple geometry types in the same layer. The Mapbox Streets source takes advantage of this for some layers. A geometry in the vector tile can be one of 3 types: Point Linestring / multilinestring Polygon / multipolygon In Mapbox Studio, you can select one or two or all the 3 types with the Geometry Type toggles in each layer's data selection tab. OpenStreetMap IDs OpenStreetMap IDs are not stored as object properties but as object IDs within the vector tile. This means they are not available for styling via Mapbox Studio, but can still be interacted with via Mapbox GL JS and other vector tile libraries. OpenStreetMap ID spaces are not unique across node, way, and relation object types. To make them unique for vector tiles, the IDs are transformed based on their OpenStreetMap object type. OpenStreetMap type OpenStreetMap ID transform node id × 10 eg. 123 → 1230 way (id × 10) + 1 eg. 123 → 1231 relation (id × 10) + 4 eg. 123 → 1234 Often, multiple objects from OpenStreetMap will be combined into a single object in our vector tiles. For example, water polygons are unioned to avoid seams and road lines are joined to save space and simplify better. In these cases the osm_id will either be 0, or one of the input IDs chosen at random. Data stability As we make ongoing data updates to reflect changes in the world, we may also add new layers, fields, and values Mapbox Streets v8 tiles. Our goal is to do this in a way that preserves compatibility with existing v8 styles as much as possible. Here's what you need to know about how Mapbox Streets v8 may change in the future: Layers Existing layers will not be renamed or removed New layers may be added Fields Existing fields will not be renamed or removed New fields may be added to any layer Field values The meanings of existing values will not change Values of specific features may change to correct errors or reflect real-world changes. New values may be added to any field unless otherwise noted in this documentation Fields that may contain null values are noted in this documentation, and null values will not be introduced to existing layers that do not already have them. You should design your styles to account for the possibility of new field values. Be explicit in your filters where possible, and make sure to include appropriate default styles when using expressions. Common fields name text & name_<lang-code> text Label names are available in many languages. The name_* value will be null if no translation data is available for a given feature; when styling label layers, you are responsible for determining an appropriate fallback approach. If the name field is null for a particular feature, then all the language-specific name_* fields will also be null. This means that name should always be the final fallback value if you want to include it in your set of label languages. Field Description name The name (or names) used locally for the place. name_ar Arabic name_en English name_es Spanish name_fr French name_de German name_pt Portuguese name_ru Russian name_zh-Hans Simplified Chinese name_zh-Hant Traditional Chinese (if available, but may contain some Simplified Chinese) name_ja Japanese name_ko Korean For languages that may have regional variations, the tileset gives no particular preference where place name spellings differ. name_script text Wherever there is a name field, there is also a name_script field that describes the primary script used in that text. This can be helpful for customizing fonts or language fallback conditions. Values include: Arabic Armenian Bengali Bopomofo Canadian_Aboriginal Common Cyrillic Devanagari Ethiopic Georgian Glagolitic Greek Gujarati Gurmukhi Han Hangul Hebrew Hiragana Kannada Katakana Khmer Lao Latin Malayalam Mongolian Myanmar Nko Sinhala Syriac Tamil Telugu Thaana Thai Tibetan Tifinagh Unknown The value will be null if name is also null. sizerank number The sizerank field is included in label layers where points or lines have been derived from polygons, such as poi_label, natural_label, airport_label. It lets you style & filter based on the size of a feature relative to the current zoom level. The tileset gives the largest objects sizerank=0, and gives points sizerank=16. A single feature will have a changing sizerank as you zoom in and the relative size of the feature increases. For example, a park might have a sizerank of 9 at z11, 6 at z12, and 2 at z13. The value will never be null and will always be within the range 0-16. filterrank number Filterrank is a value from 0-5 used to customize label density. It's intended to be used in style layer filters (in the 'Select data' tab in Mapbox Studio). The value is relative to the current zoom level. For example the same POI might have filterrank=5 at z10 while having filterrank=1 at z14, since zooming in changed the relative importance of the POI. You could set filterrank<=1 to only show the most prominent labels, filterrank<=3 to produce moderate density, and filterrank<=5 to see as many labels as possible. The value will never be null and will always be in the range of 0-5. maki text Some layers have a maki field designed to make it easier to assign icons using the Maki icon project, or with other icons that follow the same naming scheme. Each layer uses a different subset of the names, but the full list of values used in Mapbox Streets is compiled here so you can make sure your style has all the icons needed across different layers. Not all icons from the Maki project are used in Mapbox Streets, and different types of related features will sometimes have the same maki value (for example universities and colleges, or art supply shops and art galleries). Nameless POIs will have never have a Maki value of marker (the generic default). The possible values for the maki field for all layers are listed below. Icon names that were not part of any layer in v7 are marked with 🆕. No further values will be added in Mapbox Streets v8. airport_label: airport airfield heliport rocket natural_label: marker mountain volcano waterfall 🆕 poi_label: alcohol-shop american-football 🆕 amusement-park aquarium art-gallery attraction bakery bank bar basketball 🆕 beach 🆕 beer bicycle bowling-alley 🆕 bridge 🆕 cafe campsite car car-rental 🆕 car-repair 🆕 casino 🆕 castle cemetery charging-station 🆕 cinema clothing-store college communications-tower 🆕 confectionery 🆕 convenience 🆕 dentist doctor dog-park drinking-water embassy farm 🆕 fast-food fire-station fitness-centre 🆕 fuel furniture 🆕 garden globe 🆕 golf grocery harbor hardware 🆕 horse-riding 🆕 hospital ice-cream information jewelry-store 🆕 laundry library lodging marker mobile-phone 🆕 monument museum music optician 🆕 park parking 🆕 parking-garage 🆕 pharmacy picnic-site pitch 🆕 place-of-worship playground police post prison ranger-station 🆕 religious-buddhist 🆕 religious-christian religious-jewish religious-muslim restaurant restaurant-noodle 🆕 restaurant-pizza 🆕 restaurant-seafood 🆕 school shoe 🆕 shop skateboard 🆕 slipway 🆕 stadium suitcase 🆕 swimming table-tennis 🆕 tennis 🆕 theatre toilet town-hall veterinary viewpoint 🆕 volleyball 🆕 watch 🆕 watermill 🆕 windmill 🆕 zoo transit_stop_label: bicycle-share bus ferry rail rail-metro rail-light entrance Layer Reference The mapbox-streets-v8 tileset contains the following layers. For reference, the current minimum-available zoom level for each layer is mentioned, but please note that this is subject to change as we roll out updates and improvements. It also does not apply to all features within a layer - only the most prominent features are available at lower-numbered zoom levels, and more features are available as you zoom in. Labels for physically-large features also have a maximum zoom level based on their size. Layer Min. zoom level admin 0 aeroway 9 airport_label 8 building 13 housenum_label 16 landuse_overlay 5 landuse 5 motorway_junction 11 natural_label 0 place_label 0 poi_label 5 road 5 structure 13 transit_stop_label 11 water 0 waterway 7 admin buffer: 4 This layer contains boundary lines for national and subnational administrative units. The data source & shapes match polygons from the Mapbox Boundaries product. admin_level number The admin_level field separates different levels of boundaries. Value Description 0 Countries 1 First-level administrative divisions 2 Second-level administrative divisions worldview text Mapbox Streets v8 introduces the notion of worldviews to the administrative boundary layer. The vector tiles contain multiple versions of some boundaries, each with a worldview value indicating the intended audience. It is important to apply a worldview filter to all your admin style layers, otherwise your map will show conflicting & overlapping boundary lines. The filter should always include both all and one of the region-specific values. Value Description all Appropriate for all worldviews (most boundaries) CN Boundaries for a mainland Chinese audience/worldview, but not officially approved for use in the PRC. IN Boundaries conforming to cartographic requirements for use in India US Boundaries for an American audience, & which are generally appropriate outside of China & India. Lines do not necessarily reflect official US foreign policy. disputed text Boundary lines with a disputed value of true should have a dashed or otherwise distinct style applied in styles. No single map of the world will ever keep everybody happy, but acknowledging disputes where they exist is an important aspect of good cartography. The value will always be either true or false (never null). maritime text Mapbox Streets v8 includes a minimal set of maritime boundaries. These have a maritime value of true to use for distinct styling or filtering. The value will always be either true or false (never null). iso_3166_1 text The iso_3166_1 field contains the ISO 3166-1 alpha-2 code or codes that apply to a boundary. For subnational boundaries this will be a single code of the parent country. For international boundaries between two countries, the value will be the codes of both countries in alphabetical order, separated by a dash (-). aeroway buffer: 4 The aeroway layer includes both lines and polygons representing runways, helipads, etc. type text The type field separates different types of aeroways for styling. Value Description runway Where planes take off & land taxiway Where planes move between runways, gates, and hangars apron Where planes park, refuel, load helipad Where helicopters take off & land ref text The ref field contains runway and taxiway identifiers. The value may be null. airport_label buffer: 64 This layer contains point geometries that are one of: airport, airfield, heliport, and rocket. See names and name_script in for information about names and translations available for label text. See sizerank for information about that field. ref text The ref field contains short identifier codes for many airports. These are pulled from the OpenStreetMap tags iata, ref, icao, or faa (in order of preference). The value may be null. maki text The maki field lets you assign different icons to different types of airports. See the maki part of the Common Fields section for more details. Value Description airport Most commercial airports airfield Smaller airports & private airfields heliport For helicopters rocket Spaceflight facilities building buffer: 2 Large buildings appear at zoom level 13, and all buildings are included in zoom level 15 and up. underground text The underground field will be true for buildings that are underground (for example, some subway stations). This value will always be either true or false (never null). type text The type field lets you differentiate building parts from building outlines. Building part polygons intended primarily for 3D rendering have a value of building:part. Building outlines (covering the full footprint of a building) will have a value of building if tagged as building=yes on OpenStreetMap, otherwise the value will match the building tag from OpenStreetMap (see TagInfo for common values). height number The height field contains the height of a building or building part in meters (rounded to the nearest integer). Often this value is derived from the building:levels tag on OpenStreetMap - we estimate 3 meters per level if no exact height is specified. This value may be null where extrude is false. min_height number The min_height field contains the height in meters from the ground to the bottom of a building part, for cases where the bottom of the part is not on the ground. This allows for proper extrusion rendering of things such as sky bridges and cantilevered building parts. This value may be null where extrude is false. extrude text The extrude field indicates whether the object should be included in 3D-extrusion renderings. For example a complex building might have various building:part objects mapped with different heights and a building object representing the footprint of the entire building. Only the building:part objects are needed for 3D rendering, so the full footprint outline will have an extrude value of false. The extrude value will always be either true or false (never null). housenum_label buffer: 64 This layer contains points used to label the street number parts of specific addresses. house_num text The house_num field contains house and building numbers. These are commonly integers but may include letters or be only letters, for example ""1600"", ""31B"", ""D"". If an address has no number tag but has a house name or building name, the house_num field will be the name instead. landuse_overlay buffer: 8 This layer is for landuse / landcover polygons that your style should draw above the #water layer. class text The main field used for styling the landuse_overlay layer is class. Value Description national_park Relatively large area of land set aside by a government for human recreation and environmental protection wetland Wetlands that may include vegetation (marsh, swamp, bog) wetland_noveg Wetlands that probably dont contain vegetation (mud, tidal flat) type text The type field is pulled from the primary OpenStreetMap tags for that class. landuse buffer: 4 This layer includes polygons representing both land-use and land-cover. It's common for many different types of landuse/landcover to be overlapping, so the polygons in this layer are ordered by the area of their geometries to make sure smaller objects will not be obscured by larger ones. Pay attention to use of transparency when styling - the overlapping shapes can cause muddied or unexpected colors. class text The main field used for styling the landuse layer is class. Value Description aboriginal_lands The boundary of aboriginal lands. agriculture Various types of crop and farmland airport Airport grounds cemetery Cemeteries and graveyards glacier Glaciers or permanent ice/snow grass Grasslands, meadows, fields, lawns, etc hospital Hospital grounds park City parks, village greens, playgrounds, national parks, nature reserves, etc piste Area used for skiing, snowboading, and other snow/mountain sports pitch Sports fields & courts of all types rock Bare rock, scree, quarries sand Sand, beaches, dunes school Primary, secondary, post-secondary school grounds scrub Bushes, scrub, heaths wood Woods and forestry areas type text The type field is pulled from the primary OpenStreetMap tags for that class. motorway_junction buffer: 8 This layer contains point geometries for labeling motorway junctions (aka highway exits). Classes and types match the types in the road layer. ref text, reflen number, & name text The motorway junction layer has a ref field and a name field for styling labels. The reflen field tells you how long the ref value is in case you want to style this layer with shields. All these fields may be null. class text & type text The class and type fields tell you what kind of road the junction is on. See the #road layer for possible values. natural_label buffer: 64 The natural_label layer contains points and lines for styling natural features such as bodies of water, mountain peaks, valleys, deserts, and so on. See names and name_script in for information about names and translations available for label text. See sizerank and filterrank for information on using those fields to style text size and label density. class text & maki text The natural_label layer is organized into many different classes for styling & filtering. Within each class, several maki values are available for assigning icons to features - see the maki part of the Common Fields section for more details about that field. class maki values feature types bay marker inlet in a large body of water canal marker dock marker enclosed area of water for ships glacier marker glacier landform mountain , volcano , marker peaks, meadows, cave entrances, archipelago, island, islet, saddle, fell, desert, valley, etc. ocean marker oceans reservoir marker human water containment areas river marker sea marker seas and other large water features including some gulfs, straits, bays, etc. stream marker water_feature waterfall , marker waterfalls water marker lakes, ponds, etc. wetland marker wetland, marsh elevation_m number & elevation_ft number The elevation_m and elevation_ft fields hold the feature elevation in meters and feet, respectively. Values are rounded to the nearest whole number and do not include units. Use a text field such as { elevation_ft } feet or { elevation_m } m in Mapbox Studio to display the units. These fields may be null. place_label buffer: 128 This layer contains points for labeling places including countries, states, cities, towns, and neighborhoods. See names and name_script in for information about names and translations available for label text. See filterrank for information on using that field. type text The main field for styling labels for different kinds of places is type. Value Description country Sovereign or partially-recognized states sar Special Administrative Region territory Semi-autonomous or other subnational entities with ISO 3166-1 codes disputed_territory Disputed territories with ISO 3166-1 codes. state First-level administrative divisions or similar. Only a small subset of these are included to reduce clutter and put focus on cities, towns, etc. city Settlement of about 100,000 or more people. town Urban or rural settlement of about 10,000-100,000 people village Usually rural settlement of less than about 10,000 hamlet Rural settlement with a population of about 200 or fewer suburb A distinct section of an urban settlement such as an annexed town, historical district, or large & important neighborhood. quarter A large neighborhood or section of a larger city or town neighbourhood A smaller neighborhood or part of a larger settlement class text The class field provides a broad distinction between place types. The possible values are: Class Encompasses Types country country, territory, sar, disputed state state settlement city, town, village, hamlet settlement_subdivision suburb, quarter, neighbourhood symbolrank number The symbolrank value is intended to simplify styling of the label size and symbol prominence of place features. It ranges from 1 to 19 and is consistently assigned across zoom levels - for example a place with a symbolrank of 6 at z4 will have the same value as you zoom in to any other level. The value will never be null and will always be in the range of 1-19. iso_3166_1 text The iso_3166_1 field contains the ISO 3166-1 alpha-2 code of the country the place is in. The value may be null - either due to location match errors or for features that are in international waters. capital number The capital field allows distinct styling of labels or icons for the capitals of countries, regions, or states & provinces. The value of this field may be 2, 3, 4, 5, or 6. National capitals are 2, and 3 through 6 represent capitals of various sub-national administrative entities. These levels come from OpenStreetMap and have different meanings in different countries - see the OpenStreetMap wiki for specific details. The value will be null for any place that is not a capital. abbr text This abbr field is available for type=state and provides the local abbreviation of the state. text_anchor text The text_anchor field can be used as a hint for label placement. Possible values match the Mapbox Style Spec for text anchor. The value may be null. Value Meaning center The center of the text is placed closest to the anchor. left The left side of the text is placed closest to the anchor. right The right side of the text is placed closest to the anchor. top The top of the text is placed closest to the anchor. bottom The bottom of the text is placed closest to the anchor. top-left The top left corner of the text is placed closest to the anchor. top-right The top right corner of the text is placed closest to the anchor. bottom-left The bottom left corner of the text is placed closest to the anchor. bottom-right The bottom right corner of the text is placed closest to the anchor. poi_label buffer: 64 This layer is used to place icons and labels for various points of interest (POIs). See names and name_script in for information about names and translations available for label text. See sizerank and filterrank for information on using those fields to style text size and label density. See maki for more information about using this field for assigning icons. class text The class field groups points of interest into broad categories for styling purposes. The values are useful for designing icon color schemes, for example. arts_and_entertainment building commercial_services education food_and_drink food_and_drink_stores general historic industrial landmark lodging medical motorist park_like place_like public_facilities religion sport_and_leisure store_like visitor_amenities type text The type field contains a more specific classification intended for display - for example 'Cafe', 'Hotel', 'Laundry'. These values come from the original OpenStreetMap tags and are not a limited set. category_en text & category_zh-Hans text The category_en & category_zh-Hans fields contain translated category descriptions for POIs. These can be used as a fallback or as supplemental information where English or simplified Chinese translations may not exist. These values may be null. Language coverage may be expanded in a future v8 update. road buffer: 4 The roads layer contains lines, points, and polygons needed for drawing features such as roads, railways, paths and their labels. See names and name_script in for information about names and translations available for label text. class text The main field used for styling the road layers is class. Value Description motorway High-speed, grade-separated highways motorway_link Link roads/lanes/ramps connecting to motorways trunk Important roads that are not motorways. trunk_link Link roads/lanes/ramps connecting to trunk roads primary A major highway linking large towns. primary_link Link roads/lanes connecting to primary roads secondary A highway linking large towns. secondary_link Link roads/lanes connecting to secondary roads tertiary A road linking small settlements, or the local centres of a large town or city. tertiary_link Link roads/lanes connecting to tertiary roads street Standard unclassified, residential, road, and living_street road types street_limited Streets that may have limited or no access for motor vehicles. pedestrian Includes pedestrian streets, plazas, and public transportation platforms. construction Includes motor roads under construction (but not service roads, paths, etc). track Roads mostly for agricultural and forestry use etc. service Access roads, alleys, agricultural tracks, and other services roads. Also includes parking lot aisles, public & private driveways. ferry Those that serves automobiles and no or unspecified automobile service. path Foot paths, cycle paths, ski trails. major_rail Railways, including mainline, commuter rail, and rapid transit. minor_rail Includes light rail & tram lines. service_rail Yard and service railways. aerialway Ski lifts, gondolas, and other types of aerialway. golf The approximate centerline of a golf course hole roundabout Circular continuous-flow intersection mini_roundabout Smaller variation of a roundabout with no center island or obstacle turning_circle (point) Widened section at the end of a cull-de-sac for turning around a vehicle turning_loop (point) Similar to a turning circle but with an island or other obstruction at the centerpoint traffic_signals (point) Lights or other signal controlling traffic flow at an intersection oneway text The oneway field indicates whether the motor traffic on the road is one-way or not. If the road is one-way, traffic travels in the same direction as the linestring. The value will always be either true or false (never null). structure text The structure field describes whether the road segment is a bridge, tunnel, ford, or none of those. No further values will be added in Mapbox Streets v8. bike_lane text The bike_lane field indicates if there is a bike lane that is part of the road itself. This is different from separated cycle tracks, which are mapped as their own object in the roads layer, and receive class=path, type=cycleway. This value may be null where explicit bike lane details are unknown. Value Description yes Bike lane present, side of road not specified. left Bike lane present on the left side of the road. right Bike lane present on the right side of the road. both Bike lane present on both sides of the road. no Road is known to have no bike lane. iso_3166_1 text The iso_3166_1 field contains the ISO 3166-1 alpha-2 code of the country the road is in. The value may be null - either due to location match errors or for features that are in international waters. iso_3166_2 text The ISO 3166-2 code of the state/province/region the road is in. Not all areas are covered by this standard and the value may be null. ref text & reflen number Besides the standard name fields, there is also a ref field that holds any reference codes or route numbers a road may have. The reflen value indicates how many characters are in the corresponding ref to help choose an appropriate size of shield graphic. The valid range is 2-6 but more detailed ranges for specific shield designs are noted below. Note that ref values with a single character are assigned a reflen value of 2 to reduce the number of required shield graphics. From zoom levels 6 through 10, ref values are attached to separate points rather than lines to optimize symbol placement. Both ref & reflen may be null. shield text The shield values help to assign highway shield graphics. They should be combined with ref for the text on the shield and reflen to determine the width of shield image needed. The shield-text-color field can be used for styling the shield text. Routes that can be symbolized with shields of a common shape & color have generic shared shield values: Value reflen range Description default 2-6 No specific shield design suggested. rectangle-white 2-6 rectangle-red 2-6 rectangle-orange 2-6 rectangle-yellow 2-6 rectangle-green 2-6 rectangle-blue 2-6 circle-white 2-6 Other highways with more specific shield design requirements are captured individually: Value reflen range Description ae-national 3-4 United Arab Emirates national routes ae-d-route 3-4 UAE Dubai D-routes ae-f-route 3 UAE Fujairah F-routes ae-s-route 4 UAE Sharjah S-routes au-national-highway 2-3 Australia national highways au-national-route 2-6 Australia national routes au-state 2-6 Australia state roads au-tourist 2-3 Australia tourist routes br-federal 3 Brazil federal highways br-state 2-3 Brazil state highways ch-motorway 2-3 Switzerland motorways cn-nths-expy 3-5 China national expressway cn-provincial-expy 3-5 China provincial/regional expressway de-motorway 2-3 Germany motorways (Autobahnen) gr-motorway 2-4 Greece motorways hk-strategic-route 2 Hong Kong strategic routes hr-motorway 3-4 Croatia motorways hu-motorway 2-3 Hungary motorways hu-main 2-5 Hungary main roads in-national 2-4 India national highways & expressways in-state 2-3 India state highways kr-natl-expy 2-3 South Korea national expressways kr-natl-hwy 2 South Korea national highways kr-metro-expy 2-3 South Korea metropolitan expressways kr-metropolitan 2-6 South Korea metropolitan routes kr-local 2-6 South Korea local routes mx-federal 2-4 Mexico federal highways mx-state 2-4 Mexico state highways nz-state 2-3 New Zealand state highways pe-national 2-3 Peru national highways pe-regional 3-4 Peru departmental / regional highways ro-national 2-3 Romania national roads ro-county 3-4 Romania county roads ro-communal 2-4 Romania communal roads si-motorway 2 Slovenia motorways tw-national 2 Taiwan national routes tw-provincial-expy 2 Taiwan provincial expressways tw-provincial 2 Taiwan provincial routes tw-county-township 2-6 Taiwan county / township routes us-interstate 2-4 US Interstates us-interstate-duplex 4-5 US Interstates - segment shared by 2 route numbers us-interstate-business 2-3 US Interstates - business routes us-interstate-truck 2-3 US Interstates - truck routes us-highway 2-4 US highways us-highway-duplex 3-5 US highways - segment shared by 2 route numbers us-highway-alternate 2-3 US highways - alternate routes us-highway-business 2-3 US highways - business routes us-highway-bypass 2-3 US highways - bypasses us-highway-truck 2-3 US highways - truck routes us-bia 2-4 US BIA Indian routes za-national 2-3 South Africa national routes za-provincial 2 South Africa provincial routes The shield value will be null where ref is also null. No further shield values will be added in Mapbox Streets v8. shield_text_color text Used to style the text on the highway shield icon. Possible values: black blue white yellow orange type text The type field is the value of the road's ""primary"" OpenStreetMap tag. For most roads this is the highway tag, but for aerialways it will be the aerialway tag, and for golf holes it will be the golf tag. See TagInfo for a list of used tag values. Several classes pull in additional detail when it is available from OpenStreetMap. Possible construction class type values: construction:motorway construction:motorway_link construction:trunk construction:trunk_link construction:primary construction:primary_link construction:secondary construction:secondary_link construction:tertiary construction:tertiary_link construction:unclassifed construction:residential construction:road construction:living_street construction:pedestrian construction Possible track class type values: track:grade1 track:grade2 track:grade3 track:grade4 track:grade5 track Possible service class type values: service:alley service:emergency_access service:drive_through service:driveway service:parking service:parking_aisle service For the path class, the tileset made custom type assignments based on insight from various categorical, physical, and access tags from OpenStreetMap. Value Description steps aka stairs corridor An indoors passageway sidewalk aka pavement in many places outside North America crossing Usually connects sidewalk lines across a road piste Ski & snowboard trails, both downhill and cross-country mountain_bike Trails used primarily or exclusively for mountain biking hiking Hiking trails or othe",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,Mapbox Streets v8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Off-route detection,Learn how to use and customize off-route detection with the Mapbox Navigation SDK for Android for your Android app's navigation experience.,https://docs.mapbox.com/android/navigation/overview/off-route/,guide,Java,,"Off-route detection SDKs covered: Navigation SDK Navigation UI SDK The Navigation SDK provides information about whether a user's device is on the route that was generated. If a user is off-route, you can provide additional instruction to the user and generate a new route. Off-route detection is not enabled by default in the Navigation SDK, but when you add an OffRouteListener, off-route detection will be enabled using default criteria for determining when a user is considered off-route and what to do next. Off-route detection and the Navigation UI SDK This guide does not describe any specific options in the Navigation UI SDK. You need to enable off-route detection using the core Navigation SDK directly. RouteProgressState The user's on or off-route status is tracked using RouteProgressState. There are three possible states: RouteProgressState#INITIALIZED RouteProgressState#TRACKING RouteProgressState#OFFROUTE Initialized Upon loading a new route and if the DirectionsRoute JSON is valid, route-following will start in the RouteProgressState#INITIALIZED state. From there, route-following will try to gain confidence that the GPS locations being passed to the device are the user's location. To show this trust, at least a few location updates need to be delivered and they must be consecutively coherent in both time and space. While it is in the process of establishing this trust, the route-following logic will report that it's still in the RouteProgressState#INITIALIZED state. Tracking Once the user's location is considered to be on-route, the state will change to RouteProgressState#TRACKING. Off-route Once trust of the user's current stream of location updates has been established, route-following will try to measure the user's progress along the loaded route. If the user's location is found to be unreasonably far from the route, the state is flipped to the RouteProgressState#OFFROUTE state. Corralling If the user's current location is within a reasonable distance from the loaded route but not close enough to be considered on-route (RouteProgressState#TRACKING), the RouteProgressState#INITIALIZED state will be returned until user to makes their way to the route. This is called ""corralling"". Corralling allows a user, in the user's driveway or a store's parking lot for example, to load up a route and not get marked as RouteProgressState#OFFROUTE at once. If the user continually makes progress away from the route the user will eventually be marked OFFROUTE. OffRouteListener The OffRouteListener can be used to handle reroute events. Listen for when a user goes off route using the OffRouteListener, fetch a new DirectionsRoute, and use MapboxNavigation#startNavigation(DirectionsRoute) with the fresh route to restart navigation. Java Kotlin navigation.addOffRouteListener(new OffRouteListener() { @Override public void userOffRoute(Location location) { NavigationRoute.builder(this) .accessToken(Mapbox.getAccessToken()) .origin(newOrigin) .destination(destination) .build().getRoute(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { // Update MapboxNavigation here with new route // MapboxNavigation#startNavigation } @Override public void onFailure(Call<DirectionsResponse> call, Throwable t) { } }); } }); Copy Further customization If you would like to provide your own implementation for OffRoute detection, you can replace the default OffRouteDetector class. To do this, create your own class that extends from OffRoute and set this new class using MapboxNavigation#setOffRouteEngine(OffRoute): Java Kotlin OffRoute myOffRouteEngine = new OffRoute() { @Override public boolean isUserOffRoute(Location location, RouteProgress routeProgress, MapboxNavigationOptions options) { // User will never be off-route return false; } }; // MapboxNavigation navigation.setOffRouteEngine(myOffRouteEngine); Copy Was this page helpful? Yes No",,Off-route detection,Initialized,Tracking,Off-route,Corralling,OffRouteListener,Further customization,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Studio,"Mapbox Studio is a web application for managing your data, tilesets, styles, access tokens, and doing anything related to your account.",https://docs.mapbox.com/help/glossary/mapbox-studio/,glossary,,,"Mapbox Studio Mapbox Studio is a web application for creating custom maps. You can manage and create datasets, tilesets, and map styles. To get started with Mapbox Studio, explore the Mapbox Studio manual. Was this page helpful? Yes No",,Mapbox Studio,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Apply a style designed in Mapbox Studio Classic,Use legacy raster tiles on a map.,https://docs.mapbox.com/ios/maps/examples/raster-styles/,example,Swift,,"Apply a style designed in Mapbox Studio Classic Download mapbox-raster-v8.json, open it and replace mapbox.streets with your map ID, and add it to your project or upload the file to your server. For tiles hosted elsewhere, use raster-v8.json. This technique can load any custom style JSON that conforms to the Mapbox Style Specification. Swift Objective C import Mapbox class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let styleURL = URL(string: ""https://www.mapbox.com/ios-sdk/files/mapbox-raster-v8.json"") // Local paths are also acceptable. let mapView = MGLMapView(frame: view.bounds, styleURL: styleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] view.addSubview(mapView) } } Copy Was this page helpful? Yes No",,Apply a style designed in Mapbox Studio Classic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add hillshading,Adds raster hillshading to a map.,https://docs.mapbox.com/mapbox-gl-js/example/hillshade/,example,JavaScript,,Add hillshading Adds raster hillshading to a map. Was this example helpful? Yes No,,Add hillshading,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Turf.js,Turf.js is a JavaScript library for spatial analysis.,https://docs.mapbox.com/help/glossary/turf/,glossary,,,"Turf.js Turf.js is a JavaScript library for spatial analysis. It includes traditional spatial operations, helper functions for creating GeoJSON data, and data classification and statistics tools. Turf can be added to your website as a client-side plugin, or you can run Turf server-side with Node.js. You can find the source code on GitHub. Was this page helpful? Yes No",,Turf.js,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add live realtime data,Use realtime GeoJSON data streams to move a symbol on your map.,https://docs.mapbox.com/mapbox-gl-js/example/live-geojson/,example,JavaScript,,Add live realtime data Use realtime GeoJSON data streams to move a symbol on your map. Was this example helpful? Yes No,,Add live realtime data,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Add a WMS source,Adding an external Web Map Service layer to the map.,https://docs.mapbox.com/android/maps/examples/add-a-wms-source/,example,Java,,"Add a WMS source Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.6892"" mapbox:mapbox_cameraTargetLng=""-74.5447"" mapbox:mapbox_cameraZoom=""8""/> </LinearLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.RasterLayer; import com.mapbox.mapboxsdk.style.sources.RasterSource; import com.mapbox.mapboxsdk.style.sources.TileSet; /** * Adding an external Web Map Service layer to the map. */ public class AddWmsSourceActivity extends AppCompatActivity { MapView mapView; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_add_wms_source); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource(new RasterSource( ""web-map-source"", new TileSet(""tileset"", ""https://geodata.state.nj.us/imagerywms/Natural2015?bbox={"" + ""bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&"" + ""srs=EPSG:3857&width=256&height=256&layers=Natural2015""), 256)); // Add the web map source to the map. style.addLayerBelow( new RasterLayer(""web-map-layer"", ""web-map-source""), ""aeroway-taxiway""); } }); } }); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Add a WMS source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Ischrone time slider,Use an Android seekbar slider to retrieve info from the Isochrone API. Display the data and adjust the camera accordingly.,https://docs.mapbox.com/android/java/examples/isochrone-seekbar/,example,Java,,"Ischrone time slider Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.javaservices.IsochroneSeekbarActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" app:layout_constraintBottom_toTopOf=""@+id/guideline9"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintStart_toStartOf=""parent"" app:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""48.20355511"" mapbox:mapbox_cameraTargetLng=""16.374893"" mapbox:mapbox_cameraZoom=""8"" /> <androidx.constraintlayout.widget.Guideline android:id=""@+id/guideline9"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:orientation=""horizontal"" app:layout_constraintGuide_percent=""0.7"" /> <TextView android:id=""@+id/want_to_live_within_textview"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:gravity=""center"" android:text=""@string/live_within_textview"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintStart_toStartOf=""parent"" app:layout_constraintTop_toBottomOf=""@+id/mapView"" /> <TextView android:id=""@+id/minutes_textview"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginTop=""16dp"" android:text=""@string/minutes_textview"" android:textSize=""20sp"" android:textStyle=""bold"" app:layout_constraintEnd_toEndOf=""@+id/want_to_live_within_textview"" app:layout_constraintStart_toStartOf=""@+id/want_to_live_within_textview"" app:layout_constraintTop_toBottomOf=""@+id/want_to_live_within_textview"" tools:text=""10min"" /> <SeekBar android:id=""@+id/isochrone_minute_seekbar_slider"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_marginTop=""8dp"" app:layout_constraintEnd_toEndOf=""@+id/want_to_live_within_textview"" app:layout_constraintStart_toStartOf=""@+id/want_to_live_within_textview"" app:layout_constraintTop_toBottomOf=""@+id/minutes_textview"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.SeekBar; import android.widget.TextView; import com.mapbox.api.isochrone.IsochroneCriteria; import com.mapbox.api.isochrone.MapboxIsochrone; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import com.mapbox.turf.TurfMeta; import java.util.ArrayList; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.geometryType; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Use an Android system seekbar to set the minute range and use the Mapbox Isochrone API * (https://www.mapbox.com/api-documentation/#isochrone) to see how far one can * travel in a car. */ public class IsochroneSeekbarActivity extends AppCompatActivity { private static final String RESPONSE_FILL_LAYER_GEOJSON_SOURCE_ID = ""RESPONSE_FILL_LAYER_GEOJSON_SOURCE_ID""; private static final String ISOCHRONE_FILL_LAYER = ""ISOCHRONE_FILL_LAYER""; private static final String MAP_CENTER_DOWNTOWN_VIENNA_SOURCE_ID = ""MAP_CENTER_DOWNTOWN_VIENNA_SOURCE_ID""; private static final String MAP_CENTER_DOWNTOWN_VIENNA_ICON_ID = ""MAP_CENTER_DOWNTOWN_VIENNA_ICON_ID""; private static final String MAP_CENTER_DOWNTOWN_VIENNA_LAYER_ID = ""MAP_CENTER_DOWNTOWN_VIENNA_LAYER_ID""; private static final Point DOWNTOWN_VIENNA = Point.fromLngLat(16.374893, 48.20355511); private MapView mapView; private MapboxMap mapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_javaservices_isochrone_with_seekbar); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(new Style.Builder().fromUri(Style.LIGHT) .withImage(MAP_CENTER_DOWNTOWN_VIENNA_ICON_ID, BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.red_marker))) .withSource(new GeoJsonSource(MAP_CENTER_DOWNTOWN_VIENNA_SOURCE_ID, Feature.fromGeometry(DOWNTOWN_VIENNA))) .withSource(new GeoJsonSource(RESPONSE_FILL_LAYER_GEOJSON_SOURCE_ID)) .withLayer(new SymbolLayer(MAP_CENTER_DOWNTOWN_VIENNA_LAYER_ID, MAP_CENTER_DOWNTOWN_VIENNA_SOURCE_ID).withProperties( iconImage(MAP_CENTER_DOWNTOWN_VIENNA_ICON_ID), iconIgnorePlacement(true), iconAllowOverlap(true), iconOffset(new Float[]{0f, -4f}) )), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { IsochroneSeekbarActivity.this.mapboxMap = mapboxMap; // Initialize the Seekbar slider final SeekBar liveWithinMinutesSeekbar = findViewById(R.id.isochrone_minute_seekbar_slider); liveWithinMinutesSeekbar.setMax(60); liveWithinMinutesSeekbar.incrementProgressBy(5); liveWithinMinutesSeekbar.setProgress(30); // Initialize the TextView, which will update as the slider is moved // back and forth. final TextView liveWithinMinTextView = findViewById(R.id.minutes_textview); liveWithinMinTextView.setText(String.format(getString(R.string.minutes_textview), liveWithinMinutesSeekbar.getProgress())); makeIsochroneApiCall(new LatLng(DOWNTOWN_VIENNA.latitude(), DOWNTOWN_VIENNA.longitude()), liveWithinMinutesSeekbar.getProgress()); liveWithinMinutesSeekbar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { progress = progress / 5; progress = progress * 5; liveWithinMinTextView.setText(String.format(getString(R.string.minutes_textview), progress)); } @Override public void onStartTrackingTouch(SeekBar seekBar) { // Not needed in this example. } @Override public void onStopTrackingTouch(SeekBar seekBar) { makeIsochroneApiCall(new LatLng(DOWNTOWN_VIENNA.latitude(), DOWNTOWN_VIENNA.longitude()), seekBar.getProgress()); } }); initFillLayer(style); } }); } }); } /** * Make a request to the Mapbox Isochrone API * * @param mapClickPoint The center point of the isochrone. It is part of the API request. * @param contourMin The number of travel minutes to calculate Isochrone information for. */ private void makeIsochroneApiCall(@NonNull LatLng mapClickPoint, @NonNull Integer contourMin) { MapboxIsochrone mapboxIsochroneRequest = MapboxIsochrone.builder() .accessToken(getString(R.string.access_token)) .profile(IsochroneCriteria.PROFILE_DRIVING) .addContoursMinutes(contourMin) .polygons(true) .addContoursColors(""5a42f4"") .denoise(.4f) .generalize(10f) .coordinates(Point.fromLngLat(mapClickPoint.getLongitude(), mapClickPoint.getLatitude())) .build(); mapboxIsochroneRequest.enqueueCall(new Callback<FeatureCollection>() { @Override public void onResponse(Call<FeatureCollection> call, Response<FeatureCollection> response) { // Redraw Isochrone information based on response body if (response.body() != null) { FeatureCollection featureCollection = response.body(); mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { GeoJsonSource fillLayerSource = style.getSourceAs( RESPONSE_FILL_LAYER_GEOJSON_SOURCE_ID); if (fillLayerSource != null && featureCollection.features().size() > 0) { fillLayerSource.setGeoJson(featureCollection); // Move the camera from the map in case it's too zoomed in. // This is here so that the isochrone information can be seen if the camera // is too close to the map. LatLngBounds latLngBounds = new LatLngBounds.Builder() .includes(createLatLngsForCameraBounds(featureCollection.features())) .build(); mapboxMap.easeCamera(CameraUpdateFactory.newLatLngBounds( latLngBounds, 50), 2000); } } }); } } @Override public void onFailure(Call<FeatureCollection> call, Throwable throwable) { Timber.d(""Request failed: %s"", throwable.getMessage()); } }); } /** * Use the {@link TurfMeta#coordAll(Feature, boolean)} method and the Isochrone API * response to build a list of {@link LatLng}. The list will be used to create a * camera bounds so that the camera can adjust to the size of the visible Isochrone * API data. * * @param featureList list from the body of the Isochrone API response. * @return a list of {@link LatLng}. */ private List<LatLng> createLatLngsForCameraBounds(List<Feature> featureList) { List<LatLng> latLngList = new ArrayList(featureList.size()); for (Feature singleFeature : featureList) { for (Point singlePoint : TurfMeta.coordAll(singleFeature, false)) { latLngList.add(new LatLng((singlePoint.latitude()), singlePoint.longitude())); } } return latLngList; } /** * Add a FillLayer so that that polygon returned by the Isochrone API response can be displayed */ private void initFillLayer(@NonNull Style style) { // Create and style a FillLayer based on information in the Isochrone API response FillLayer isochroneFillLayer = new FillLayer(ISOCHRONE_FILL_LAYER, RESPONSE_FILL_LAYER_GEOJSON_SOURCE_ID); isochroneFillLayer.setProperties( fillColor(get(""color"")), fillOpacity(.7f)); // You could also pass in get(""opacity"")) instead of a hardcoded value isochroneFillLayer.setFilter(eq(geometryType(), literal(""Polygon""))); style.addLayerAbove(isochroneFillLayer, ""land""); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Ischrone time slider,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Location camera options,Use LocationComponent camera options to customize map camera behavior.,https://docs.mapbox.com/android/maps/examples/location-component-camera-options/,example,Java,,"Location camera options Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_marginBottom=""0dp"" mapbox:mapbox_cameraZoom=""10"" app:layout_constraintBottom_toTopOf=""@+id/linearLayout"" app:layout_constraintLeft_toLeftOf=""parent"" app:layout_constraintRight_toRightOf=""parent"" app:layout_constraintTop_toTopOf=""parent"" /> <LinearLayout android:id=""@+id/linearLayout"" style=""?android:attr/buttonBarStyle"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:background=""@color/colorPrimaryDark"" android:orientation=""horizontal"" android:weightSum=""4"" app:layout_constraintBottom_toBottomOf=""parent"" app:layout_constraintLeft_toLeftOf=""parent"" app:layout_constraintRight_toRightOf=""parent"" tools:layout_constraintBottom_creator=""1"" tools:layout_constraintLeft_creator=""1"" tools:layout_constraintRight_creator=""1""> <TextView android:id=""@+id/tv_mode"" android:layout_width=""0dp"" android:layout_height=""match_parent"" android:layout_weight="".75"" android:gravity=""center"" android:text=""Mode:"" android:textColor=""@color/mapboxWhite"" android:textSize=""18sp"" android:textStyle=""bold"" /> <Button android:id=""@+id/button_location_mode"" style=""?android:attr/buttonBarButtonStyle"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_weight=""1.25"" android:gravity=""center"" android:text=""Normal"" android:textColor=""@android:color/white"" /> <TextView android:id=""@+id/tv_tracking"" android:layout_width=""0dp"" android:layout_height=""match_parent"" android:layout_weight="".85"" android:gravity=""center"" android:text=""Tracking:"" android:textColor=""@color/mapboxWhite"" android:textSize=""18sp"" android:textStyle=""bold"" /> <Button android:id=""@+id/button_location_tracking"" style=""?android:attr/buttonBarButtonStyle"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_weight=""1.15"" android:gravity=""center"" android:text=""None"" android:textColor=""@android:color/white"" /> </LinearLayout> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.location; import android.annotation.SuppressLint; import android.location.Location; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.ListPopupWindow; import android.widget.ArrayAdapter; import android.widget.Button; import android.widget.Toast; import com.mapbox.android.core.location.LocationEngineRequest; import com.mapbox.android.core.permissions.PermissionsListener; import com.mapbox.android.core.permissions.PermissionsManager; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.LocationComponentActivationOptions; import com.mapbox.mapboxsdk.location.OnCameraTrackingChangedListener; import com.mapbox.mapboxsdk.location.OnLocationCameraTransitionListener; import com.mapbox.mapboxsdk.location.OnLocationClickListener; import com.mapbox.mapboxsdk.location.modes.CameraMode; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import java.util.ArrayList; import java.util.List; /** * Use LocationComponent camera options to customize the map camera's behavior. More information * can be found at https://docs.mapbox.com/android/maps/overview/location-component and in * {@link CameraMode}. */ public class LocationComponentCameraOptionsActivity extends AppCompatActivity implements OnMapReadyCallback, OnLocationClickListener, OnCameraTrackingChangedListener { private static final String SAVED_STATE_CAMERA = ""saved_state_camera""; private static final String SAVED_STATE_RENDER = ""saved_state_render""; private static final String SAVED_STATE_LOCATION = ""saved_state_location""; private MapView mapView; private Button locationModeBtn; private Button locationTrackingBtn; private PermissionsManager permissionsManager; private LocationComponent locationComponent; private MapboxMap mapboxMap; private Location lastLocation; @CameraMode.Mode private int cameraMode = CameraMode.TRACKING; @RenderMode.Mode private int renderMode = RenderMode.NORMAL; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_location_component_camera_options); mapView = findViewById(R.id.mapView); // Check and use saved instance state in case of device rotation if (savedInstanceState != null) { cameraMode = savedInstanceState.getInt(SAVED_STATE_CAMERA); renderMode = savedInstanceState.getInt(SAVED_STATE_RENDER); lastLocation = savedInstanceState.getParcelable(SAVED_STATE_LOCATION); } mapView.onCreate(savedInstanceState); // Check for (and request) the device location permission if (PermissionsManager.areLocationPermissionsGranted(this)) { mapView.getMapAsync(this); } else { permissionsManager = new PermissionsManager(new PermissionsListener() { @Override public void onExplanationNeeded(List<String> permissionsToExplain) { Toast.makeText(LocationComponentCameraOptionsActivity.this, R.string.user_location_permission_explanation, Toast.LENGTH_LONG).show(); } @Override public void onPermissionResult(boolean granted) { if (granted) { mapView.getMapAsync(LocationComponentCameraOptionsActivity.this); } else { finish(); } } }); permissionsManager.requestLocationPermissions(this); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); permissionsManager.onRequestPermissionsResult(requestCode, permissions, grantResults); } @SuppressLint(""MissingPermission"") @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, style -> { setModeButtonListeners(); // Retrieve and customize the Maps SDK's LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent( LocationComponentActivationOptions .builder(this, style) .useDefaultLocationEngine(true) .locationEngineRequest(new LocationEngineRequest.Builder(750) .setFastestInterval(750) .setPriority(LocationEngineRequest.PRIORITY_HIGH_ACCURACY) .build()) .build()); locationComponent.setLocationComponentEnabled(true); locationComponent.addOnLocationClickListener(this); locationComponent.addOnCameraTrackingChangedListener(this); locationComponent.setCameraMode(cameraMode); setRendererMode(renderMode); locationComponent.forceLocationUpdate(lastLocation); }); } @SuppressLint(""MissingPermission"") @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); // Save LocationComponent-related settings to use once device rotation is finished outState.putInt(SAVED_STATE_CAMERA, cameraMode); outState.putInt(SAVED_STATE_RENDER, renderMode); if (locationComponent != null) { outState.putParcelable(SAVED_STATE_LOCATION, locationComponent.getLastKnownLocation()); } } /** * Listen to and use a tap on the LocationComponent */ @Override public void onLocationComponentClick() { Toast.makeText(this, getString(R.string.clicked_on_location_component), Toast.LENGTH_LONG).show(); } /** * Adjust the LocationComponent's image to one of the preset options. * * @param mode desired normal (small blue circle laid on top of larger white dot), * compass (arrow point representing the phone's bearing), or * GPS (blue arrow within a white circle). */ private void setRendererMode(@RenderMode.Mode int mode) { renderMode = mode; locationComponent.setRenderMode(mode); if (mode == RenderMode.NORMAL) { locationModeBtn.setText(getString(R.string.normal)); } else if (mode == RenderMode.COMPASS) { locationModeBtn.setText(getString(R.string.compass)); } else if (mode == RenderMode.GPS) { locationModeBtn.setText(getString(R.string.gps)); } } private void showModeListDialog() { List<String> modes = new ArrayList<>(); modes.add(getString(R.string.normal)); modes.add(getString(R.string.compass)); modes.add(getString(R.string.gps)); ArrayAdapter<String> profileAdapter = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, modes); ListPopupWindow listPopup = new ListPopupWindow(this); listPopup.setAdapter(profileAdapter); listPopup.setAnchorView(locationModeBtn); listPopup.setOnItemClickListener((parent, itemView, position, id) -> { String selectedMode = modes.get(position); locationModeBtn.setText(selectedMode); if (selectedMode.contentEquals(getString(R.string.normal))) { setRendererMode(RenderMode.NORMAL); } else if (selectedMode.contentEquals(getString(R.string.compass))) { setRendererMode(RenderMode.COMPASS); } else if (selectedMode.contentEquals(getString(R.string.gps))) { setRendererMode(RenderMode.GPS); } listPopup.dismiss(); }); listPopup.show(); } /** * Instruct the map camera to disregard the LocationComponent or to * follow the device location in a certain way. * <p> * NONE = No camera tracking. * NONE_COMPASS = Camera does not track location, but does track compass bearing. * NONE_GPS = Camera does not track location, but does track GPS {@link Location} bearing. * TRACKING = Camera tracks the user location. * TRACKING_COMPASS = Camera tracks the user location, with bearing provided by a compass. * TRACKING_GPS = Camera tracks the user location, with bearing provided by a * normalized {@link Location#getBearing()}. * TRACKING_GPS_NORTH = Camera tracks the user location, with bearing always set to north (0). */ private void showTrackingListDialog() { List<String> trackingTypes = new ArrayList<>(); trackingTypes.add(getString(R.string.none)); trackingTypes.add(getString(R.string.none_compass)); trackingTypes.add(getString(R.string.none_gps)); trackingTypes.add(getString(R.string.tracking)); trackingTypes.add(getString(R.string.tracking_compass)); trackingTypes.add(getString(R.string.tracking_gps)); trackingTypes.add(getString(R.string.tracking_gps_north)); ArrayAdapter<String> profileAdapter = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, trackingTypes); ListPopupWindow listPopup = new ListPopupWindow(this); listPopup.setAdapter(profileAdapter); listPopup.setAnchorView(locationTrackingBtn); listPopup.setOnItemClickListener((parent, itemView, position, id) -> { String selectedTrackingType = trackingTypes.get(position); locationTrackingBtn.setText(selectedTrackingType); if (selectedTrackingType.contentEquals(getString(R.string.none))) { setCameraTrackingMode(CameraMode.NONE); } else if (selectedTrackingType.contentEquals(getString(R.string.none_compass))) { setCameraTrackingMode(CameraMode.NONE_COMPASS); } else if (selectedTrackingType.contentEquals(getString(R.string.none_gps))) { setCameraTrackingMode(CameraMode.NONE_GPS); } else if (selectedTrackingType.contentEquals(getString(R.string.tracking))) { setCameraTrackingMode(CameraMode.TRACKING); } else if (selectedTrackingType.contentEquals(getString(R.string.tracking_compass))) { setCameraTrackingMode(CameraMode.TRACKING_COMPASS); } else if (selectedTrackingType.contentEquals(getString(R.string.tracking_gps))) { setCameraTrackingMode(CameraMode.TRACKING_GPS); } else if (selectedTrackingType.contentEquals(getString(R.string.tracking_gps_north))) { setCameraTrackingMode(CameraMode.TRACKING_GPS_NORTH); } listPopup.dismiss(); }); listPopup.show(); } private void setCameraTrackingMode(@CameraMode.Mode int mode) { locationComponent.setCameraMode(mode, new OnLocationCameraTransitionListener() { @Override public void onLocationCameraTransitionFinished(@CameraMode.Mode int cameraMode) { if (mode != CameraMode.NONE) { locationComponent.zoomWhileTracking(15, 750, new MapboxMap.CancelableCallback() { @Override public void onCancel() { // No impl } @Override public void onFinish() { locationComponent.tiltWhileTracking(45); } }); } else { mapboxMap.easeCamera(CameraUpdateFactory.tiltTo(0)); } } @Override public void onLocationCameraTransitionCanceled(@CameraMode.Mode int cameraMode) { // No impl } }); } @Override public void onCameraTrackingDismissed() { locationTrackingBtn.setText(getString(R.string.none)); } @Override public void onCameraTrackingChanged(int currentMode) { this.cameraMode = currentMode; if (currentMode == CameraMode.NONE) { locationTrackingBtn.setText(getString(R.string.none)); } else if (currentMode == CameraMode.NONE_COMPASS) { locationTrackingBtn.setText(getString(R.string.none_compass)); } else if (currentMode == CameraMode.NONE_GPS) { locationTrackingBtn.setText(getString(R.string.none_gps)); } else if (currentMode == CameraMode.TRACKING) { locationTrackingBtn.setText(getString(R.string.tracking)); } else if (currentMode == CameraMode.TRACKING_COMPASS) { locationTrackingBtn.setText(getString(R.string.tracking_compass)); } else if (currentMode == CameraMode.TRACKING_GPS) { locationTrackingBtn.setText(getString(R.string.tracking_gps)); } else if (currentMode == CameraMode.TRACKING_GPS_NORTH) { locationTrackingBtn.setText(getString(R.string.tracking_gps_north)); } } private void setModeButtonListeners() { locationModeBtn = findViewById(R.id.button_location_mode); locationModeBtn.setOnClickListener(v -> { if (locationComponent == null) { return; } showModeListDialog(); }); locationTrackingBtn = findViewById(R.id.button_location_tracking); locationTrackingBtn.setOnClickListener(v -> { if (locationComponent == null) { return; } showTrackingListDialog(); }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } } Copy Was this page helpful? Yes No",,Location camera options,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,TIFF,"A TIFF, or sometimes TIF, is a file format for saving raster images.",https://docs.mapbox.com/help/glossary/tiff/,glossary,,,"TIFF A TIFF, or sometimes TIF, is a file format for saving raster images. With Mapbox, a TIFF is often a GeoTIFF, meaning the file is embedded with georeferencing information. You can upload TIFF files as tilesets in Mapbox Studio and use them in the Mapbox Studio style editor. You can also import TIFF files into Mapbox Studio Classic and upload to Mapbox as a tileset that way. When uploading a TIFF file, remember the current size limit for TIFF files. Download a sample TIFF file Was this page helpful? Yes No",,TIFF,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Blank or missing map tiles,Learn why you may be seeing blank or missing tiles.,https://docs.mapbox.com/help/troubleshooting/blank-tiles/,troubleshooting,,,"Blank or missing map tiles Maps can fail to load for a variety of reasons related to your Mapbox account, your code, the browser you are using, the network you are on, or your computer. This guide will walk you through how to troubleshoot some common reasons maps fail to load. Your style ID or tileset ID is invalid If you are using a Mapbox Studio style, check to make sure the style URL you are using contains a valid style ID. If you are using a Classic style, make sure the tileset ID is valid. Style ID You can test the style ID by finding the style URL you've added to your code, copying the string after the last /, and navigating to the following URL in your web browser (be sure to replace username with your own and use the string you copied from your style URL to replace the style_id): https://api.mapbox.com/styles/v1/ { username } / { style_id } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN If a JSON object is not returned, your style ID is invalid. You can find valid style URLs on your Styles page. You may also use any of the Mapbox styles. Tileset ID You can test the tileset ID for both tilesets and Classic styles by finding the tileset ID you've added to your code and navigating to the following URL in your web browser (be sure to replace the { tileset_id } with your own): https://api.mapbox.com/v4/ { tileset_id } /page.html?access_token= YOUR_MAPBOX_ACCESS_TOKEN If this page doesn't load, your tileset ID is invalid. You can find valid tileset IDs on your Tilesets page. If you have any Mapbox Studio Classic projects or styles, you can find their IDs on your Classic page. Your access token is invalid You can test your access token by navigating to the following URL in your web browser, making sure that you've replaced { access_token } with the access token used in your code: https://api.mapbox.com/v4/mapbox.satellite/page.html?access_token= YOUR_MAPBOX_ACCESS_TOKEN If this page doesn't load, your access token is faulty. Head to your Access tokens page, generate a new access token, and try again. Your invoice is unpaid If you exceed the API requests included in the free tier and do not have a valid payment method for your account, your account will be disabled and your maps will no longer be displayed. After the first failed payment, you will have a brief grace period to visit your Account settings page and add or update your payment information before your account is disabled. If your account is disabled, you can reactivate it following these steps: Log in to your Mapbox account at mapbox.com/account. After logging in, choose a plan from the prompt that is displayed. After choosing a plan, update the payment information on your Account settings page. Contact support so we can run your outstanding invoice. Your tiles will be restored shortly after you have reactivated your account. Your map is hidden If you're hiding your map initially with CSS rules like display:none, then showing it dynamically with JavaScript, it may have some problems appearing and sizing correctly. The map can't determine its own size when it's hidden from the page, since it doesn't have a size in the browser's calculation. To detect and resize your map with Mapbox GL JS, you can call map.resize(). If you're using Mapbox.js, you can call the map.invalidateSize() method. Mapbox GL JS When working with Mapbox GL JS, call map.resize() on the map object after its containing element is resized or shown: // your code that shows the map div $('#map-div').show(); // detect the map's new width and height and resize it map.resize(); Read more about resize in the documentation. Mapbox.js When working with Mapbox.js, call map.invalidateSize() after showing the map: // your code that shows the map div $('#map-div').show(); // invalidate the size of your map map.invalidateSize(); Read more about invalidateSize in the mapbox.js documentation. WebGL is not supported Mapbox GL JS maps (including the Mapbox Studio style editor and dataset editor) can fail to display because of issues with your browser, your network, your computer, or some combination of all three. WebGL compatibility can be tricky to troubleshoot and, but here are some general guidelines and resources: Is WebGL supported and enabled in your current browser? Mapbox GL JS and Mapbox Studio are compatible with most modern browsers, but require that WebGL is supported and enabled. Are you using a browser that supports the specific Mapbox product you are trying to use? Read more about browser support by product in our Browser support guide. Does the device you are using support WebGL? You will need to refer to the technical specifications for your specific device. Are you trying to access Mapbox products from behind a firewall? If you're interacting with the Mapbox REST APIs and having trouble getting a response, you can try white-listing the domain api.mapbox.com. Was this page helpful? Yes No",,Blank or missing map tiles,Style ID,Tileset ID,Your access token is invalid,Your invoice is unpaid,Your map is hidden,Mapbox GL JS,Mapbox.js,WebGL is not supported,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Gestures,Detecting gestures in the Mapbox Maps SDK for Android.,https://docs.mapbox.com/android/maps/overview/gestures/,guide,Java,,"Gestures The Mapbox Gestures for Android library is used inside of the Mapbox Maps SDK for Android for gesture detection based on user's input. This library wraps GestureDetectorCompat and ScaleGestureDetector as well as introduces implementation of rotate, move, shove, and tap gesture detectors. The library is implemented in both the Mapbox Maps SDK for Android and the library's test application. See the API documentation for more details on using the Gestures library. Installation Gradle Open Android Studio. Open up your application's build.gradle file. Make sure that your project's minSdkVersion is at API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-gestures-android version (see below). Click on Sync Project with Gradle Files near the toolbar in Android Studio. implementation 'com.mapbox.mapboxsdk:mapbox-android-gestures: 0.5.1 ' Note: ProGuard directives are included in the Android dependencies to preserve the required classes. The library's releases are published to Maven Central. If you'd like to test out the master branch build, use SNAPSHOTs which are available on Sonatype. // In the root build.gradle file repositories { mavenCentral() maven { url ""http://oss.sonatype.org/content/repositories/snapshots/"" } } // In the app build.gradle file dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-gestures: 0.6.0-SNAPSHOT ' } Standalone usage You have to instantiate AndroidGestureManager to start any gestures processing. Set any gesture listeners that you are interested in and pass all MotionEvent objects from your Activity/Fragment to AndroidGestureManager#onTouchEvent(). Mutually-exclusive gestures Mutually-exclusive gestures are possible thanks to the AndroidGestureManager class, which serves as a single entry point to all gesture detectors. This means that you can pass a list of GestureType sets. Whenever a gesture is detected, it will check whether there are any ProgressiveGestures started that are contained within the same set. If there aren't any, the listener for our detected gesture will not be notified. You can pass mutually exclusive gesture sets in a constructor of AndroidGestureManager or with AndroidGestureManager#setMutuallyExclusiveGestures(). For example: Java Kotlin Set<Integer> mutuallyExclusive1 = new HashSet<>(); mutuallyExclusive1.add(AndroidGesturesManager.GESTURE_TYPE_SHOVE); mutuallyExclusive1.add(AndroidGesturesManager.GESTURE_TYPE_SCROLL); Set<Integer> mutuallyExclusive2 = new HashSet<>(); mutuallyExclusive2.add(AndroidGesturesManager.GESTURE_TYPE_SHOVE); mutuallyExclusive2.add(AndroidGesturesManager.GESTURE_TYPE_SCALE); AndroidGesturesManager androidGesturesManager = new AndroidGesturesManager( context, mutuallyExclusive1, mutuallyExclusive2 ); Copy The first set makes it certain that when a shove gesture is detected, you will no longer be notified about the scroll gestures. The shove gesture will be able to execute because scroll is not a ProgressiveGesture. In the second set, when either a shove or scale is detected, you won't be notified about the other one until the first gesture finishes. Thresholds You can set thresholds for supported gestures, which means that a gesture detector won't fire until it meets the threshold (like minimum rotation angle). This allows you to personalize the gestures experience how you would like. Set thresholds using dimen values, rather than raw pixels, to accommodate for various screen sizes and pixel densities across Android devices. For example: Java Kotlin androidGesturesManager.getStandardScaleGestureDetector().setSpanSinceStartThresholdResource(R.dimen.scaleSpanSinceStartThreshold); Copy For thresholds that are not expressed in pixels: Java Kotlin androidGesturesManager.getRotateGestureDetector().setAngleThreshold(ROTATE_ANGLE_THRESHOLD); Copy Velocity Each progressive gesture with its respective #onEnd() callback will provide X velocity and Y velocity of the gesture at the moment when the pointer leaves the screen. Enable/disable and interrupt Every gesture detector can be enabled/disabled at any time using the #setEnabled() method. Additionally, every progressive gesture can be interrupted, which will force it to meet start conditions again to resume. A popular use case would be to increase the gesture's threshold when another gesture is detected: Java Kotlin @Override public boolean onScaleBegin(StandardScaleGestureDetector detector) { // forbid movement when scaling androidGesturesManager.getMoveGestureDetector().setEnabled(false); // this interrupts a gesture as well // increase rotate angle threshold when scale is detected, then interrupt to force re-check RotateGestureDetector rotateGestureDetector = androidGesturesManager.getRotateGestureDetector(); rotateGestureDetector.setAngleThreshold(ROTATION_THRESHOLD_WHEN_SCALING); rotateGestureDetector.interrupt(); return true; } @Override public boolean onScale(StandardScaleGestureDetector detector) { float scaleFactor = detector.getScaleFactor(); return true; } @Override public void onScaleEnd(StandardScaleGestureDetector detector) { // revert thresholds values RotateGestureDetector rotateGestureDetector = androidGesturesManager.getRotateGestureDetector(); rotateGestureDetector.setAngleThreshold(Constants.DEFAULT_ROTATE_ANGLE_THRESHOLD); } Copy Detectors With this library you will be able to recognize gestures using detectors provided by the Support Library and more. StandardGestureDetector Wraps GestureDetectorCompat exposed via the Support Library that recognizes gestures like tap, double tap or scroll. StandardScaleGestureDetector Wraps ScaleGestureDetector exposed via the Support Library that recognizes scale/pinch gesture. MultiFingerTapGestureDetector Gesture detector that tell listeners whenever a multi finger tap occurred and how many fingers where involved. RotateGestureDetector A detector that finds the angle difference between previous and current line made with two pointers (fingers). ShoveGestureDetector Detects a vertical movement of two pointers if they are placed within a certain horizontal angle. MoveGestureDetector Behaves similarly to #onScroll() contained in the StandardGestureDetector, but, it's a ProgressiveGesture that enables better filtering options, as well as thresholds. SidewaysShoveGesturesDetector A sibling of the ShoveGestureDetector, but, it recognizes the two-finger shove gesture executed in a horizontal, rather than vertical, line. Usage with the Maps SDK This library is shipped as a part of the Mapbox Maps SDK for Android and you don't have to declare any other dependencies. To get the AndroidGesturesManager object which holds references to all the gesture detectors, use: Java Kotlin AndroidGesturesManager gesturesManager = mapboxMap.getGesturesManager(); Copy To react to the user's input, you can register several different listeners that will be notified whenever a user interacts with a Mapbox map. OnMapClickListener: Java Kotlin mapboxMap.addOnMapClickListener(new MapboxMap.OnMapClickListener() { @Override public void onMapClick(@NonNull LatLng point) { // user clicked on the map } }); Copy OnMoveListener: Java Kotlin mapboxMap.addOnMoveListener(new MapboxMap.OnMoveListener() { @Override public void onMoveBegin(MoveGestureDetector detector) { // user started moving the map } @Override public void onMove(MoveGestureDetector detector) { // user is moving the map } @Override public void onMoveEnd(MoveGestureDetector detector) { // user stopped moving the map } }); Copy You can see a MoveGestureDetector object being passed in the callbacks above. This class is the underlying detector from the Mapbox Gestures for Android library. Other popular listener interfaces that you can implement are: OnMapLongClickListener fires when the map is touched and a single finger is held down on the map. OnRotateListener fires when the map is rotated. OnScaleListener fires when the map is zoomed in or out. OnShoveListener fires when map is tilted. Custom AndroidGesturesManager The Maps SDK offers a MapboxMap#setGesturesManager() method. If you create a custom AndroidGesturesManager object, you can use it as a parameter for that method and for the custom mapping experience that you want to create. Was this page helpful? Yes No",,Gestures,Gradle,Standalone usage,Mutually-exclusive gestures,Thresholds,Velocity,Enable/disable and interrupt,Detectors,StandardGestureDetector,StandardScaleGestureDetector,MultiFingerTapGestureDetector,RotateGestureDetector,ShoveGestureDetector,MoveGestureDetector,SidewaysShoveGesturesDetector,Usage with the Maps SDK,Custom AndroidGesturesManager,,,,,,,,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Animate a line,Animate a line by updating a GeoJSON source on each frame.,https://docs.mapbox.com/mapbox-gl-js/example/animate-a-line/,example,JavaScript,,Animate a line Animate a line by updating a GeoJSON source on each frame. Was this example helpful? Yes No,,Animate a line,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Events,"Documentation about map events within the Mapbox Maps SDK for Android. Read about map clicking, flinging, moving, and other Mapbox map events.",https://docs.mapbox.com/android/maps/overview/events/,guide,Java,,"Events The Maps SDK provides various ways to listen to map events. The majority of listeners that the SDK offers are listed below. But, you'll occasionally find other listeners specific to their corresponding API inside other overview documents. Map click & long click events Click (tap) events can be set up through the MapboxMap object and invoke a callback each time that the event occurs. In both cases, the callback provides a LatLng of where the user click occurred on the map. To add an onClick listener to your map, insert the following snippet inside your application's code: Java Kotlin mapboxMap.addOnMapClickListener(new MapboxMap.OnMapClickListener() { @Override public void onMapClick(@NonNull LatLng point) { String string = String.format(Locale.US, ""User clicked at: %s"", point.toString()) Toast.makeText(MainActivity.this, string, Toast.LENGTH_LONG).show(); } }); Copy Convert from screen pixel In occasions when you need to know the corresponding location on the screen where the user gesture occurred, you can convert the LatLng point to screen pixels. The MapboxMap object provides the Projection from the map which allows you to convert between LatLng coordinates to screen pixel using mapboxMap.getProjection().toScreenLocation(<LatLng>);. The reverse is available when you have a screen location in pixels and need to convert it to a corresponding LatLng object. A common use case for converting the values between LatLng and pixel coordinates is when you'd like to query a map layer or source to, for example, determine whether the users clicked on a POI. You can read more on how to do this in the Query map features documentation. Camera change events The map's camera is the view looking down on the maps flat plane. In almost all cases, you'll be interacting with the camera to adjust the map's starting zoom and target position. The user also can manipulate the camera by performing gestures on the map such as pinch-to-zoom, two-finger move to tilt, and single finger moves to adjust the position. The Map SDK provides a handful of camera change listeners which can tell you of any or specific camera movements. The SDK gives different camera listeners to determine if the camera movement was caused by a user gesture, built-in API animations, or a developer-controlled movement. The snippet below shows the various camera listeners available: Java Kotlin mapboxMap.addOnCameraMoveStartedListener(new MapboxMap.OnCameraMoveStartedListener() { private final String[] REASONS = {""REASON_API_GESTURE"", ""REASON_DEVELOPER_ANIMATION"", ""REASON_API_ANIMATION""}; @Override public void onCameraMoveStarted(int reason) { String string = String.format(Locale.US, ""OnCameraMoveStarted: %s"", REASONS[reason - 1]) Toast.makeText(MainActivity.this, string, Toast.LENGTH_LONG).show(); } }); mapboxMap.addOnCameraMoveListener(new MapboxMap.OnCameraMoveListener() { @Override public void onCameraMove() { Toast.makeText(MainActivity.this, ""onCameraMove"", Toast.LENGTH_LONG).show(); } }); mapboxMap.addOnCameraMoveCancelListener(new MapboxMap.OnCameraMoveCanceledListener() { @Override public void onCameraMoveCanceled() { Toast.makeText(MainActivity.this, ""onCameraMoveCanceled"", Toast.LENGTH_LONG).show(); } }); mapboxMap.addOnCameraIdleListener(new MapboxMap.OnCameraIdleListener() { @Override public void onCameraIdle() { Toast.makeText(MainActivity.this, ""onCameraIdle"", Toast.LENGTH_LONG).show(); } }); Copy On fling & on move events Besides the camera change listeners, the MapboxMap object allows you to listen into when the user moves or flings the map. A move event occurs when the user drags a single finger across the screen causing the camera position to change. A similar action from the user will cause the onFling callback to be invoked, but the user performs the gesture with more momentum. Only one of these events will be fired once when the user performs the particular gesture. Java Kotlin mapboxMap.addOnMoveListener(new MapboxMap.OnMoveListener() { @Override public void onMoveBegin(MoveGestureDetector detector) { // user started moving the map } @Override public void onMove(MoveGestureDetector detector) { // user is moving the map } @Override public void onMoveEnd(MoveGestureDetector detector) { // user stopped moving the map } }); mapboxMap.addOnFlingListener(new MapboxMap.OnFlingListener() { @Override public void onFling() { Toast.makeText(MainActivity.this, ""onFling"", Toast.LENGTH_LONG).show(); } }); Copy Marker and info window events The Maps SDK provides a handy listener for capturing when a user taps on a marker. By default, all markers come with an onMarkerClick event listener for displaying and hiding info windows. You can override this default event listener and set your own with the setOnMarkerClickListener method. To display a toast message with the clicked marker’s title, listen for a click event with setOnMarkerClickListener and finally call Toast.makeText(). To prevent displaying a toast message and an info window at the same time, return true at the end: Java Kotlin mapboxMap.setOnMarkerClickListener(new MapboxMap.OnMarkerClickListener() { @Override public boolean onMarkerClick(@NonNull Marker marker) { Toast.makeText(MainActivity.this, marker.getTitle(), Toast.LENGTH_LONG).show(); return true; } }); Copy In a similar case, the info window offers a handful of listeners for being notified when an info windows clicked, long clicked, or when a user closes the window. Java Kotlin mapboxMap.setOnInfoWindowLongClickListener(OnInfoWindowLongClickListener); mapboxMap.setOnInfoWindowCloseListener(new MapboxMap.OnInfoWindowCloseListener() { @Override public void onInfoWindowClose(@NonNull Marker marker) { } }); mapboxMap.setOnInfoWindowClickListener(new MapboxMap.OnInfoWindowClickListener() { @Override public boolean onInfoWindowClick(@NonNull Marker marker) { return false; } }); Copy Map change events The MapView goes through a series of lifecycle events while building and changing the map. The Maps SDK provides many different change listener interfaces to tell you when a specific map event has occurred. Instead of adding a listener to the MapboxMap object, each listener is added to a MapView object. For example OnDidFinishRenderingMapListener and addOnDidFinishLoadingMapListener. Java Kotlin mapView.addOnDidFinishRenderingMapListener(new MapView.OnDidFinishRenderingMapListener() { @Override public void onDidFinishRenderingMap(boolean fully) { // The map has finished rendering } }); Copy You can also implement the specific change event interface and override its method. The interface callback is then invoked when a new map change occurs. The listeners listed below are in the order in which the events occur during a MapView's life. Map change event listener Description OnCameraWillChangeListener This event is triggered whenever the displayed map region is about to change without an animation. OnCameraDidChangeListener This event is triggered whenever the displayed map region finished changing without an animation. OnWillStartLoadingMapListener This event is triggered when the map is about to start loading a new map style. OnWillStartRenderingMapListener This event is triggered when the map will start rendering the map. addOnWillStartRenderingFrameListener This event is triggered when the map will start rendering a frame. OnDidFinishRenderingFrameListener This event is triggered when the map finished rendering a frame. OnCameraWillChangeListener This event is triggered whenever the displayed map region is about to change without an animation. OnCameraDidChangeListener This event is triggered whenever the displayed map region finished changing without an animation. OnDidFinishLoadingStyleListener Triggered when a style has finished loading. OnDidFinishRenderingFrameListener This event is triggered when the map finished rendering a frame. OnSourceChangedListener Triggered when a source changes. addOnWillStartRenderingFrameListener This event is triggered when the map will start rendering a frame. OnDidFinishRenderingFrameListener This event is triggered when the map finished rendering a frame. OnDidFinishLoadingMapListener This is triggered when the map has successfully loaded a new map style. addOnWillStartRenderingFrameListener This event is triggered when the map will start rendering a frame. OnDidFinishRenderingMapListener This event is triggered when the map is fully rendered. Additional change events that are not part of the standard MapView lifecycle: Map change event listener Description OnCameraIsChangingListener This event is triggered whenever the displayed map region is changing. OnCameraDidChangeListener This event is triggered whenever the displayed map region finished changing with an animation. OnDidFailLoadingMapListener This event is triggered when the map has failed to load a new map style. Any of the map change event interfaces can be removed from the MapView object as well. addOnDidFinishLoadingStyleListener() is useful if you're using runtime styling to change the Mapbox map style in real time. Here's how you'd use the constant: Java Kotlin mapView.addOnDidFinishLoadingStyleListener(new MapView.OnDidFinishLoadingStyleListener() { @Override public void onDidFinishLoadingStyle() { // The map is now ready for other changes } }); Copy Was this page helpful? Yes No",,Events,Convert from screen pixel,Camera change events,On fling & on move events,Marker and info window events,Map change events,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Web applications,Learn how Mapbox’s JavaScript libraries work and how to integrate them into your web applications.,https://docs.mapbox.com/help/how-mapbox-works/web-apps/,guide,,,"Web applications Mapbox provides many tools to build maps into your website or web-based application. Mapbox GL JS and Mapbox.js are both open source JavaScript libraries you can use to display your Mapbox maps, add interactivity, and customize the map experience in your application. We also provide many plugins for extending your web map's functionality with drawing tools and interfaces to Mapbox web services APIs like the Mapbox Geocoding API or Mapbox Directions API. Building webpages or web applications with our JavaScript libraries will require writing code, but this guide is designed to provide you with the resources to get started. Web app using Mapbox GL JS Combine our JavaScript library with HTML, CSS, and JavaScript This web application uses a combination of HTML, CSS, JavaScript, and Mapbox GL JS, our GL-based JavaScript library. If you are interested in learning more about how to build an application like this one, read our step-by-step Build a store locator tutorial. How web apps work A web mapping library allows you to add a map to a webpage and define the data it contains, its appearance, and a variety of functionality. Think of it like a toolbox filled with many different map-making tools that can be used together to build beautiful and interactive custom experiences. Mapbox GL JS Mapbox GL JS is a JavaScript library for building web applications with our modern mapping technology. This guide walks through some of Mapbox GL JS's essential functions and common patterns, highlighting some of the core concepts that distinguish Mapbox GL JS from other map libraries. For those with experience using Leaflet, Mapbox.js, or OpenLayers, the next few sections will introduce some of the differences in Mapbox GL JS as well as features that should look familiar. Client-side rendering At the heart of Mapbox GL JS is client-side rendering. In web apps using Mapbox GL JS, maps are rendered dynamically by combining vector tiles with style rules using JavaScript and WebGL. Rendering maps in the browser rather than on a server makes it possible to change the map's style and the data it displays dynamically and in response to user interaction. The camera The camera is the map's field of view. While the viewpoint in systems like Leaflet or Mapbox.js is determined by the map's centerpoint and zoom level, Mapbox GL JS also includes parameters like pitch and bearing for adjusting the map's perspective. Center: in longitude, latitude order. Zoom: any number within the zoom range, including decimals. For example, 1.5 or 6.2 are valid zoom levels. Bearing: a value between 0 and 360 degrees that determines the map's bearing, or rotation. Pitch: a value between 0 and 60 degrees that determines the map's tilt, or pitch. Here's an example of combining bearing and zoom: Layers Traditional JavaScript map libraries often have two distinct categories of what are called ""layers"": baselayers, or image tiles that provide the foundation of the map, and overlays, which are often vector data like GeoJSON that are displayed on top of baselayers, sometimes obscuring details like labels. Mapbox GL JS has no distinction between baselayers and overlay layers. This means that map details like labels and icons and elements like streets and buildings can be modified with JavaScript, like overlays in earlier mapping libraries. Each layer provides rules about how the renderer should draw certain data in the browser, and the renderer uses these layers to draw the map on the screen. Mapbox GL JS and Mapbox GL Native Mapbox GL JS and Mapbox GL Native are two different projects for rendering maps build to the Mapbox Style Specification. They are similar, but are used for different purposes and do not have 100% feature parity. Mapbox GL JS is a JavaScript library for making maps for the web. It can read the Mapbox Style Specification and uses WebGL to render your maps in modern browsers. Mapbox GL Native is the backbone of the Mapbox Maps SDKs for iOS and Android. It supports the iOS and Android mobile platforms using OpenGL ES. Mapbox.js Note Mapbox.js is no longer in active development. To learn more about our newer mapping tools see the Mapbox GL JS documentation. Mapbox.js is a web mapping library that extends the popular Leaflet.js library. Mapbox.js boasts the power of Leaflet.js, but is also heavily integrated with the Mapbox stack. You can learn more about Mapbox.js in its API documentation. Creating a web app To create a web map, you'll need to have some familiarity with HTML, CSS, and JavaScript. If you are new to web maps, explore our tutorials to help you get started. Mapbox GL JS Before getting started coding up your Mapbox GL JS map, you'll need to include the relevant JavaScript and CSS files in your webpage. Mapbox provides hosted versions of each that you can include in the <head> of your HTML file: <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> The basis of every Mapbox GL JS project is the mapboxgl.Map class. The example code in this section demonstrates the minimum you need to add a map to your page. var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/streets-v 11 ', center: [-74.50, 40], zoom: 9 } ); Container: This is the HTML element where you would like to place your map. In the example above, it is an element with id=""map"". Style: The map loads a style via the URL mapbox://styles/mapbox/streets-v 11. This is a URL to a remote file that the map will download to determine the tilesets it includes and how they are styled for the end-user. Mapbox GL JS permits URLs instead of literal data in several places, including data sources. Consider using a style with style-optimized vector tiles for more performant maps. Center: Where Mapbox GL JS handles coordinates as arrays (here [-74.50, 40]), it assumes that the coordinates are in longitude, latitude order (versus latitude, longitude in Leaflet and Mapbox.js). This order corresponds to the order of coordinates in GeoJSON and every other geospatial format, as well as math's X, Y ordering. Zoom: The zoom level at which the map should be initialized. With Mapbox GL JS, can be a decimal value. Adding layers to the map You can add layers to the map using the addLayer() method. addLayer has only one required parameter: a Mapbox style layer object. It also accepts an optional before parameter, which is the ID of an existing layer to insert the new layer before. If you omit this argument, then the renderer will draw the layer on top of the map. The following sections describe the elements of a Mapbox style layer object. Asynchronous map.on('load', function() { map.addLayer( { id: 'terrain-data', type: 'line', source: { type: 'vector', url: 'mapbox://mapbox.mapbox-terrain-v2' } , 'source-layer': 'contour' } ); } ); Since these resources are remote, they are asynchronous. So code that connects to Mapbox GL JS often uses event binding to change the map at the right time. For instance: The above code uses the map.on('load', function() { code to call map.addLayer only after the map's resources, including the style, have been loaded. If it were to run the map.addLayer method immediately, it would trigger an error because the style to which you would like to add a layer would not yet exist. Specifying a source You will need to define a source when you add a new layer. A source accepts a type and a url (a GeoJSON source will not have a url). There are five types of sources, each with its own properties: vector tiles raster tiles GeoJSON image video Tilesets can include multiple subsets of data called source layers (the Mapbox Streets tileset contains source layers for roads, parks, etc). To make sure your layers are referencing the correct source layers, your layer object also needs to include a source-layer (often the name of the original file). See this example: addSource() You can also add sources using the Mapbox GL JS addSource() method. There is no difference in map performance when using this alternative method, but it is sometimes preferable to keep code more readable. Read more about this method in the Mapbox GL JS documentation. map.on('load', function() { map.addLayer( { id: 'rpd_parks', type: 'fill', source: { type: 'vector', url: 'mapbox://mapbox.3o7ubwm8' } , 'source-layer': 'RPD_Parks' } ); } ); For more information on each source type, explore the Sources section of the Mapbox Style Specification. Specifying layout and paint properties Layers feature two special properties that enable data styling: paint and layout. These are used to define how data will be rendered on the map. layout properties refer to placement and visibility, among other high-level preferences, and are applied early in the rendering process. paint properties are more fine-grained style attributes like opacity, color, and translation. They are less processing-intensive and are rendered later. The following code adds a layer to the map to style the parks data with a green fill. addLayer() If you added your source using the alternative addSource() method, you will need to include the source id as the source in addLayer(). Read more about this in the Mapbox GL JS API documentation. map.on('load', function() { map.addLayer( { id: 'rpd_parks', type: 'fill', source: { type: 'vector', url: 'mapbox://mapbox.3o7ubwm8' } , 'source-layer': 'RPD_Parks', layout: { visibility: 'visible' } , paint: { 'fill-color': 'rgba(61,153,80,0.55)' } } ); } ); The final product: a map zoomed to San Francisco with a parks layer with a green fill. The layer is based on a vector source of the city's park lands data. See the tutorials section for more Mapbox GL JS resources. Mapbox.js Note Mapbox.js is no longer in active development. To learn more about our newer mapping tools see the Mapbox GL JS documentation. Add a map to the page The core function of Mapbox.js is adding a map to your HTML page. Using one line of JavaScript, you can add a map to your webpage with a basemap that pans and zooms, set to a specific location and zoom level. See our example to add a map with Mapbox.js. Add and style custom data If you want to add your own data to your Mapbox.js map, you can! Mapbox.js supports a few different formats, including GeoJSON. You can then style your GeoJSON data by adding style properties to the GeoJSON in the simplestyle specification or by using the built-in setStyle method. See this example for how to add GeoJSON data to a map and style it using the simplestyle specification. Extend your web app with plugins Mapbox GL JS and Mapbox.js both support a rich ecosystem of plugins you can use to extend the functionality of your web map. There are plugins for adding interactive drawing tools, adding inset maps, integrating with the Mapbox Geocoding API and the Mapbox Directions API, and more! Explore the Mapbox GL JS plugins page and the Mapbox.js plugins page for more information. Use Mapbox GL JS with React Mapbox GL JS can be used with various JavaScript frameworks, including React. To learn more about using Mapbox GL JS with React, see our Mapbox react examples on GitHub. Was this page helpful? Yes No",,Web applications,Mapbox GL JS,Client-side rendering,The camera,Layers,Mapbox GL JS and Mapbox GL Native,Mapbox.js,Creating a web app,Adding layers to the map,Asynchronous,Specifying a source,Specifying layout and paint properties,Add a map to the page,Add and style custom data,Extend your web app with plugins,Use Mapbox GL JS with React,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Examples,Working code examples of Mapbox Plugins for Android,https://docs.mapbox.com/android/plugins/examples/,,,,"Getting started Change map text to device language Use the plugin to automatically change map label text to the language set on the device. Display buildings in 3D Use the building plugin to easily display 3D building height. Global location search Add geocoding search functionality and UI for finding any region, country, place, or address in the world. MarkerView Create a marker with an Android-system View. Place picker Use the place picker function of the Places Plugin to choose a specific location in the world. Scale bar Add a scale bar to determine distance based on zoom level. Display real-time traffic Use the traffic plugin to display live car congestion data on top of a map. Symbol listener Listen for SymbolLayer icon interaction using the Annotation plugin and its built-in listeners.",,Getting started,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Adjust a layer's opacity,Drag the seek bar to adjust the opacity of a raster layer on top of a map.,https://docs.mapbox.com/android/maps/examples/adjust-a-layers-opacity/,example,Java,,"Adjust a layer's opacity Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.AdjustLayerOpacityActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""41.8362"" mapbox:mapbox_cameraTargetLng=""-87.6321"" mapbox:mapbox_uiCompassMarginTop=""75dp"" mapbox:mapbox_cameraZoom=""9.5"" mapbox:mapbox_cameraZoomMax=""13"" mapbox:mapbox_cameraZoomMin=""7""/> <LinearLayout android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:orientation=""horizontal"" android:paddingBottom=""10dp"" android:paddingEnd=""24dp"" android:paddingLeft=""24dp"" android:paddingRight=""24dp"" android:paddingStart=""24dp"" android:paddingTop=""24dp""> <TextView android:id=""@+id/textview_opacity_value"" android:layout_width=""45dp"" android:layout_height=""wrap_content"" android:text=""100%""/> <SeekBar android:id=""@+id/seek_bar_layer_opacity"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:max=""100"" android:progress=""100""/> </LinearLayout> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.SeekBar; import android.widget.TextView; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.Layer; import com.mapbox.mapboxsdk.style.layers.RasterLayer; import com.mapbox.mapboxsdk.style.sources.RasterSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.rasterOpacity; /** * Use a seekbar to adjust the opacity of a raster layer on top of a map. */ public class AdjustLayerOpacityActivity extends AppCompatActivity { private MapView mapView; private MapboxMap map; private Layer chicago; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_adjust_layer_opacity); final SeekBar opacitySeekBar = findViewById(R.id.seek_bar_layer_opacity); final TextView percentTextView = findViewById(R.id.textview_opacity_value); opacitySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { if (chicago != null) { chicago.setProperties( rasterOpacity((float) progress / 100) ); } String progressPercentage = progress + ""%""; percentTextView.setText(progressPercentage); } @Override public void onStartTrackingTouch(SeekBar seekBar) { } @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { map = mapboxMap; mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource(new RasterSource(""chicago-source"", ""mapbox://mapbox.u8yyzaor"")); style.addLayer(new RasterLayer(""chicago"", ""chicago-source"")); chicago = map.getStyle().getLayer(""chicago""); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Adjust a layer's opacity,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Matrix API,The Mapbox Matrix API calculates travel times between many points in one API request.,https://docs.mapbox.com/help/glossary/matrix-api/,glossary,,,"Matrix API The Mapbox Matrix API calculates travel times between many points in one API request. The Matrix API returns travel times between many locations and is designed specifically for building a timetable or matrix. The number of sources and destinations are multiplied to create the matrix, or timetable, and calculate the number of elements needed to make the request. For example, given 3 locations — A, B, and C — the Matrix API will return a matrix of all travel times in seconds between all the locations: A B C A A → A A → B A → C B B → A B → B B → C C C → A C → B C → C The Matrix API works worldwide and is available for the mapbox/driving-traffic, driving, cycling, and walking routing profiles. A sample Matrix API request looks like: https://api.mapbox.com/directions-matrix/v1/mapbox/driving/-122.42,37.78;-122.45,37.91;-122.48,37.73?access_token= YOUR_MAPBOX_ACCESS_TOKEN The Matrix API has optional parameters that can be used to refine the results of a request. Related resources: Matrix API documentation How Directions works: Matrix API Was this page helpful? Yes No",,Matrix API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Datasets,Learn how to create and manage datasets in Mapbox Studio.,https://docs.mapbox.com/studio-manual/reference/datasets/,reference,,,"Datasets You can use the Mapbox Studio dataset editor to import, create, and edit point, line, and polygon features and their properties. A collection of these features in Mapbox is called a dataset. Datasets can either be downloaded as GeoJSON or exported to tilesets for use in Mapbox styles (see the Introduction section for more information). Mapbox Studio topics covered in this section: Upload Dataset Tileset Template style Custom style Add data to style Style data Publish What is a dataset? A dataset is an editable collection of GeoJSON features. Datasets are distinct from tilesets in that datasets can be edited on a feature-by-feature basis, but cannot be used directly in Mapbox Studio style. Any dataset you create can be exported to a tileset, which can be then added as a layer in the Mapbox Studio style editor. Downloading and exporting datasets Once you've created a dataset, you can export it to a tileset for use in a Mapbox map (see Style editor for more information), download it as a GeoJSON FeatureCollection, or use it with the Datasets API. Datasets can also be edited after export. To learn how to download and export datasets, see below. Manage datasets Your Datasets page in Mapbox Studio provides a list of your existing datasets as well as a link to create a new dataset. Search datasets Use the Search bar to filter or reorder your list of datasets. You can search for datasets by name or dataset ID and sort by name or date modified. Create a new dataset To create a new dataset, click the New dataset button at the top of the page. You can either start with a blank dataset or upload data as a starting point for your dataset. Data must be in one of the accepted data formats. Once your dataset is created, it opens in the dataset editor for editing. Dataset and dataset editor limits Multiple files can be uploaded to the same dataset without limit — they need to be loaded 5 MB at a time in the Mapbox Studio dataset editor. The size of a dataset is unlimited, but the Mapbox Studio dataset editor can only display datasets of 20 MB or smaller. Datasets that exceed 20 MB can still be downloaded from Mapbox Studio and accessed through the Mapbox Datasets API. Menu for each dataset Once a dataset is created, it will appear in the list on your Datasets page. There are several actions you can take with each dataset. View details Open the dataset information page for this data to see more details. Export to tileset Once exported, the tilesets can be added as a new custom layer to a Mapbox map in the Mapbox Studio style editor. You can also add a tileset directly to a web map by using Mapbox GL JS like in this example. Download Once created, you can download your data as a GeoJSON file to use with Mapbox GL JS or other web mapping applications. Delete Tileset deletion cannot be undone. Any tilesets that were derived from this dataset will stay intact, but you will no longer be able to update the data associated with those tilesets in the dataset editor. Dataset ID Each dataset has a unique ID. Use this ID when interacting with your dataset using the Mapbox Datasets API. Dataset editor In addition to managing datasets, Mapbox Studio provides an in-browser editor for creating and modifying dataset features. Export to tileset Manage features Map canvas Toolbar Export to tileset To add your data to a style in the Mapbox Studio style editor, you need to export your dataset to a tileset. Save. After you have finished editing your dataset, click Save to review the changes you have made. Export. Click Export to export your dataset to a vector tileset. A vector tileset is a collection of data broken up into a uniform grid of square tiles at up to 22 preset zoom levels. Your tilesets are stored on the Tilesets page in your Mapbox account, and tilesets created through dataset export have a reference back to the original dataset. See the Uploads section for more information on using tilesets. If you need to make further changes to your data, you can change a dataset after you have exported to a tileset and re-export to have those changes reflected in the tileset. If you update a connected tileset, any styles that reference that tileset will also be updated automatically. Manage features Features are individual points, lines, or polygons in your dataset. In the dataset editor you can add, change, and delete features in your dataset. Add new features: You can add new features to an existing dataset by either importing them from a data file or drawing them directly in the editor. Import. You can import data into your dataset from a GeoJSON or CSV file. If using a CSV, make sure that the data is already geocoded and represents point features. Draw tools. Use the draw tools to draw features directly on the map. You can change the geometry, placement, and properties of existing features with the dataset editor's draw tools: Draw a point Draw a line Draw a polygon Search places. You can search places in the toolbar. When you search for a country, region, postcode, place, locality, neighborhood, or address you will have the option to Save to dataset. This option is not available when searching POIs. Edit feature properties: You can add, edit, and delete feature properties using tools in the panel on the left side of the dataset editor. You can also view feature properties in GeoJSON form by clicking the GeoJSON tab. Map canvas You can interact directly with the features in your dataset on the map to draw, change or delete features. Geometry. Change the geometry by clicking on the feature, then clicking and dragging the points. Placement. Hover over the feature until you see , then click and drag to move the feature. Properties. To change the properties of a feature, click on the feature and edit properties in the panel on the left side of the editor. You can delete a feature by selecting the feature and clicking . You can select and delete multiple features at once using Shift + click + drag. Toolbar The toolbar in the upper right will help you navigate the dataset editor. Search places The Search places search bar allows you to search for locations on the map. You can find this button on the top right. Type in what you're looking for and select the result and search will take you to the exact location. This search is powered by the Mapbox Geocoding API. Search dataset You can use Search dataset to search your dataset by a property value. The search will return all features that contain that property value. Click on the thumbnail to jump to the feature on the map. Background style Use the Background button to switch between background styles. These include the default dataset editor style, Mapbox Satellite, Mapbox Satellite Streets, and an empty canvas. Reference tileset In addition to the pre-loaded background layers, you can display a custom raster tilesets (such as your own custom satellite imagery, for example) between the basemap and your data as a reference for drawing new GeoJSON features. Click Reference tileset and select the tileset you would like to add. Note that this must be a raster tileset uploaded to your account. You can remove the raster tileset by clicking Deselect or by clicking on the active tileset. History View your history by clicking the History button. The dataset keeps a history of all changes you made since the beginning of your current session. You can revert your changes in the current session, but your history will reset once you exit the dataset editor. Help The Help button includes the option to see a guided walkthrough of the dataset editor. As you scroll through this panel, you will see a list of keyboard shortcuts. At the top of the help panel, there are links to Mapbox Help and our contact page. Dataset information page For each dataset, there is a dataset information page where you can review the tilesets that are connected to that dataset and do the same tasks that you can in the menu on the Datasets page. Connected tilesets The center of the dataset information page contains a list of all connected tilesets, which can be added to your styles as new custom layers. Menu items The same items that exist in the menu for each dataset on the Datasets page are listed on the right side of the dataset information page. See the menu section for more details. Dataset characteristics In the lower right side of the dataset information page, there are several characteristics that are listed for each dataset. Size. Size of the dataset. Feature count. The number of features included in the dataset. Bounds. The coordinate bounds the dataset resides within, which are both listed and displayed on a satellite map. Edit dataset Click Edit to open the dataset editor and make changes to the dataset. Was this page helpful? Yes No",,Datasets,Downloading and exporting datasets,Manage datasets,Search datasets,Create a new dataset,Menu for each dataset,View details,Export to tileset,Download,Delete,Dataset ID,Dataset editor,Manage features,Map canvas,Toolbar,Search places,Search dataset,,Background style,Reference tileset,History,Help,Dataset information page,Connected tilesets,Menu items,Dataset characteristics,Edit dataset,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Restrict map panning to an area,Prevent a map from being panned to a different place by constraining the viewport.,https://docs.mapbox.com/ios/maps/examples/constraining-gestures/,example,Swift,,"Restrict map panning to an area Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { private var colorado: MGLCoordinateBounds! override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.delegate = self // Denver, Colorado let center = CLLocationCoordinate2D(latitude: 39.748947, longitude: -104.995882) // Starting point mapView.setCenter(center, zoomLevel: 10, direction: 0, animated: false) // Colorado’s bounds let northeast = CLLocationCoordinate2D(latitude: 40.989329, longitude: -102.062592) let southwest = CLLocationCoordinate2D(latitude: 36.986207, longitude: -109.049896) colorado = MGLCoordinateBounds(sw: southwest, ne: northeast) view.addSubview(mapView) } // This example uses Colorado’s boundaries to restrict the camera movement. func mapView(_ mapView: MGLMapView, shouldChangeFrom oldCamera: MGLMapCamera, to newCamera: MGLMapCamera) -> Bool { // Get the current camera to restore it after. let currentCamera = mapView.camera // From the new camera obtain the center to test if it’s inside the boundaries. let newCameraCenter = newCamera.centerCoordinate // Set the map’s visible bounds to newCamera. mapView.camera = newCamera let newVisibleCoordinates = mapView.visibleCoordinateBounds // Revert the camera. mapView.camera = currentCamera // Test if the newCameraCenter and newVisibleCoordinates are inside self.colorado. let inside = MGLCoordinateInCoordinateBounds(newCameraCenter, self.colorado) let intersects = MGLCoordinateInCoordinateBounds(newVisibleCoordinates.ne, self.colorado) && MGLCoordinateInCoordinateBounds(newVisibleCoordinates.sw, self.colorado) return inside && intersects } } Copy Was this page helpful? Yes No",,Restrict map panning to an area,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Disable scroll zoom,Prevents scroll from zooming a map.,https://docs.mapbox.com/mapbox-gl-js/example/disable-scroll-zoom/,example,JavaScript,,Disable scroll zoom Prevents scroll from zooming a map. Was this example helpful? Yes No,,Disable scroll zoom,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Statistics and usage,Learn how Mapbox tracks usage and how to interpret usage displayed on your Statistics page.,https://docs.mapbox.com/help/account/statistics/,guide,,,"Statistics and usage Your Statistics page displays analytics information about the Mapbox products used by your account. To access the Statistics page, log into your account and navigate to account.mapbox.com/statistics. Filter usage data There are two ways to filter the Mapbox usage data on your Statistics page: By date: Choose a standard period (such as week or month) or enter a custom date range. All dates are in UTC (Greenwich Mean Time). Usage data will be available on the Statistics page within 24 hours. By access token: See usage for all access tokens or one specific access token. Legacy SDKs for Mobile statistics are not available when filtering by access token. To see Legacy SDKs for Mobile statistics, filter by All tokens and connected apps. Browse by product Your account usage is organized by product on your Statistics page. For each product, you'll see the number of metered units for the token and time period selected. You will only see statistics for the products you’ve used within the specified time period and with the specified token. For more detailed explanations of how usage is metered for each product, see Pricing by products. Additional metrics For many products, you can load additional metrics about the Countries, Browsers, Domains, and Tileset IDs associated with your requests. These additional metrics are presented as percentages of the total number of metered units for the specified time period and token. Additional metrics are not available for products that are metered by user count (such as Maps SDK for Mobile). They are also not available for time periods exceeding 31 days. Not set and Other values When you see Not set as an additional metric value, it means that for some requests we are not able to find a value for that metric. With the additional metric Domains, for example, Not set means the request did not include a referrer from which we could parse a domain, which may because your requests are not coming from web browsers, or because you are using an outdated version of GL JS. Upgrading to the latest version of GL JS may reduce the number of Not set domains. When you see Other as an additional metric value, it means we are not able to convert the value to a legible display format. For example, for the additional metric Browsers, Other means we are not able to simplify the request's user agent to a display format. CSV Export We don't yet support an export feature on the Statistics page but would love to hear your feature requests around a CSV download option - contact us to share your use case. Troubleshooting If you see inconsistencies between usage on your Statistics page and charges on your monthly Invoice, see Analyze statistics and invoices. If the inconsistencies you are seeing are not explained in that guide, please contact support. Was this page helpful? Yes No",,Statistics and usage,Browse by product,Additional metrics,Not set and Other values,CSV Export,Troubleshooting,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Text anchor position,Adjust the anchor position of SymbolLayer text fields.,https://docs.mapbox.com/android/maps/examples/rotating-text-anchor-position/,example,Java,,"Text anchor position Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""32.562100"" mapbox:mapbox_cameraTargetLng=""-101.264445"" mapbox:mapbox_cameraZoom=""3.4"" mapbox:mapbox_cameraZoomMax=""5.38"" mapbox:mapbox_cameraZoomMin=""3.4"" /> <androidx.cardview.widget.CardView android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""top|center"" android:layout_marginTop=""24dp""> <TextView android:id=""@+id/anchor_position_textview"" android:layout_width=""wrap_content"" android:textColor=""@color/black_semi_transparent"" android:layout_height=""wrap_content"" android:padding=""8dp"" /> </androidx.cardview.widget.CardView> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/switch_anchor_position_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom|end"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" android:layout_marginBottom=""16dp"" app:layout_constraintBottom_toBottomOf=""parent"" app:layout_constraintEnd_toEndOf=""parent"" app:srcCompat=""@drawable/ic_cycle_through"" mapbox:fabSize=""normal"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.TextView; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.Layer; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_BOTTOM; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_BOTTOM_LEFT; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_BOTTOM_RIGHT; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_CENTER; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_LEFT; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_RIGHT; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_TOP; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_TOP_LEFT; import static com.mapbox.mapboxsdk.style.layers.Property.TEXT_ANCHOR_TOP_RIGHT; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textAnchor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textIgnorePlacement; /** * Use runtime-styling to adjust the state label SymbolLayer's textField anchor position. */ public class RotatingTextAnchorPositionActivity extends AppCompatActivity { private MapView mapView; private Layer stateLabelSymbolLayer; private int index = 0; private TextView anchorPositionTextView; private static final String[] anchorOptions = new String[] { TEXT_ANCHOR_CENTER, // The center of the text is placed closest to the anchor. TEXT_ANCHOR_LEFT, // The left side of the text is placed closest to the anchor. TEXT_ANCHOR_RIGHT, // The right side of the text is placed closest to the anchor. TEXT_ANCHOR_TOP, // The top of the text is placed closest to the anchor. TEXT_ANCHOR_BOTTOM, // The bottom of the text is placed closest to the anchor. TEXT_ANCHOR_TOP_LEFT, // The top left corner of the text is placed closest to the anchor. TEXT_ANCHOR_TOP_RIGHT, // The top right corner of the text is placed closest to the anchor. TEXT_ANCHOR_BOTTOM_LEFT, // The bottom left corner of the text is placed closest to the anchor. TEXT_ANCHOR_BOTTOM_RIGHT, // The bottom right corner of the text is placed closest to the anchor. }; private static final String[] anchorDescriptions = new String[] { ""The center of the text is placed closest to the anchor."", ""The left side of the text is placed closest to the anchor."", ""The right side of the text is placed closest to the anchor."", ""The top of the text is placed closest to the anchor."", ""The bottom of the text is placed closest to the anchor."", ""The top left corner of the text is placed closest to the anchor."", ""The top right corner of the text is placed closest to the anchor."", ""The bottom left corner of the text is placed closest to the anchor."", ""The bottom right corner of the text is placed closest to the anchor."" }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_style_rotating_text_anchor); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { stateLabelSymbolLayer = style.getLayer(""state-label""); if (stateLabelSymbolLayer != null) { // Use runtime-styling to ignore collision and allow overlap, so that adjusted text in this example, // is more easily visible. stateLabelSymbolLayer.setProperties( textIgnorePlacement(true), textAllowOverlap(true) ); anchorPositionTextView = findViewById(R.id.anchor_position_textview); setTextView(anchorOptions[index], anchorDescriptions[index]); findViewById(R.id.switch_anchor_position_fab).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { index++; if (index == anchorOptions.length - 1) { index = 0; } // Use runtime styling to adjust the SymbolLayer's textAnchor position stateLabelSymbolLayer.setProperties(textAnchor(anchorOptions[index])); setTextView(anchorOptions[index], anchorDescriptions[index]); } }); } } }); } }); } private void setTextView(String anchorOption, String anchorDescription) { anchorPositionTextView.setText(String.format(getString(R.string.position_textview), anchorOption, anchorDescription)); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Text anchor position,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Use an image source,Use an image source to easily display images on the map.,https://docs.mapbox.com/android/maps/examples/use-an-image-source/,example,Java,,"Use an image source Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""25.7845"" mapbox:mapbox_cameraTargetLng=""-80.1263"" mapbox:mapbox_cameraZoom=""12"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngQuad; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.RasterLayer; import com.mapbox.mapboxsdk.style.sources.ImageSource; /** * Use an ImageSource to add an image to the map. */ public class ImageSourceActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private static final String ID_IMAGE_SOURCE = ""animated_image_source""; private static final String ID_IMAGE_LAYER = ""animated_image_layer""; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_image_source); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Set the latitude and longitude values for the image's four corners LatLngQuad quad = new LatLngQuad( new LatLng(25.7836, -80.11725), new LatLng(25.783548, -80.1397431334), new LatLng(25.7680, -80.13964), new LatLng(25.76795, -80.11725) ); // Add an ImageSource to the map style.addSource(new ImageSource(ID_IMAGE_SOURCE, quad, R.drawable.miami_beach)); // Create a raster layer and use the imageSource's ID as the layer's data. Then add a RasterLayer to the map. style.addLayer(new RasterLayer(ID_IMAGE_LAYER, ID_IMAGE_SOURCE)); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Use an image source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Mobile applications,Learn how the Mapbox mobile SDKs work and how to add Mapbox maps to a mobile application.,https://docs.mapbox.com/help/how-mapbox-works/mobile-apps/,guide,,,"Mobile applications The Mapbox Maps SDK for iOS and the Mapbox Maps SDK for Android are open-source tools for adding Mapbox maps to mobile applications. These SDKs leverage Mapbox's open source OpenGL-based renderer, Mapbox GL Native, and support a full suite of dynamic styling features and interactivity. You can add your custom Mapbox style, search for locations using the Mapbox Geocoding API, or get directions, all without leaving your app. Where possible, the Mapbox Maps SDKs for iOS and Android provide straightforward drop-in replacements for common platform-specific maps SDKs. This guide outlines how the Mapbox mobile SDKs work and how Mapbox services can be added to a mobile application. How the Mapbox mobile SDKs work The Mapbox Maps SDKs for iOS and Android allow you to add interactive maps to your mobile applications, define custom and dynamic style rules, manipulate custom data, and interface with Mapbox web APIs. Client-side rendering At the heart of the Mapbox mobile SDKs is Mapbox GL: a powerful rendering engine that reads raw data and style rules and outputs complete, rendered maps on the device. While traditional server-side rendering works for creating static map tiles, the resulting tiles cannot be styled once they reach the client. With Mapbox GL, tiles can be rendered directly on the client. This enables you to create dynamic visualizations, add and remove layers dynamically, and adjust your style's properties based on data or the user's unique needs. Layers and runtime styling Many popular map libraries conform to the ""basemap-overlay"" paradigm in which a map is composed of two distinct types of layers: the basemap (a complete map that provides the foundation and context for the map) and the overlay (often interactive data that is added on top of the basemap, usually at runtime). Layers While the basemap-overlay strategy has worked well for a long time, there are many drawbacks. Overlays often obscure basemap labels below and large overlay datasets quickly become cumbersome. Mapbox maps do away with the basemap-overlay strategy and treat everything on the map as a layer that you can style independently and move up and down the rendering stack. In this approach to displaying maps, a layer is a styled representation of vector or raster data that is rendered using rules about how Mapbox should draw certain data on the map. This strategy allows data to be added without obscuring contextual features like labels. Runtime styling Because everything in the map is rendered from vector or raster tiles on the device in real time, Mapbox maps have no distinction between baselayers and overlay layers. This means that every element of the map can be added, removed, and styled dynamically at runtime, like overlays in other mapping libraries. Data-driven styling Data-driven styling enables you to change a map style based on data properties. For example, you can change the radius of a circle at an intersection based on the number of pedestrians crossing the intersection, or change the color of a state boundary fill-layer based on the population of each state. Feature querying and interactivity One benefit of rendering maps on the device at runtime is that it enables the map user to query any feature in the map, including what would have once been considered the ""basemap."" Using feature querying, you can add interactivity to any layer in your map style. For example, you can use feature querying to build an app that allows your users to tap on a park polygon to open a popup that contains information about the park. The Mapbox mobile SDKs include methods for querying features that have been rendered on the map or features that have not been rendered, but are present in the tiles loaded in the map view. Explore the Select a feature using feature querying example to see feature querying in action. The camera The camera is the map’s field of view. The viewpoint of the camera in many popular mapping libraries is determined by the map’s centerpoint and zoom level. The mobile SDKs also include parameters for adjusting the map’s perspective. Centerpoint: in decimal degrees and longitude, latitude order. Zoom level: any number between 0 and 22. This can be a fractional number like 1.5 or 6.2. Bearing: a map rotation value in degrees. The map will be rotated and details like text labels will react by rotating right-side-up. Tilt: also in degrees, a value by which the map will be tilted in perspective. Offline maps Applications built with our mobile SDKs can download maps of selected regions for use when the device lacks network connectivity. Offline maps are useful for apps whose users expect to travel through areas with limited data connectivity or who want to save on cellular roaming charges while traveling abroad. To estimate the number of tiles needed to download a region offline, use our offline tile count estimator. Please note that this only generates an estimate of the number of tiles needed to load a defined region offline. The size of the download will vary according to the location being downloaded and the style being used in your application. Offline tile count estimator Our mobile SDKs also automatically cache tiles and other resources that are requested during normal use of the app. These resources are stored in the same database as offline resources, but unlike offline resources, they are limited to 50 MB of space. When this limit is reached, the least-recently used resources that aren't shared by an offline region will be evicted to make room for newer resources. Learn more about how to use offline maps for iOS and Android in the respective documentation. For more background on offline maps, read our Offline maps troubleshooting guide. Telemetry By default, whenever your application causes the user's location to be gathered it sends anonymized location and usage data to Mapbox. But your users should be in charge of their own location data and when it is shared. If you're developing a native app with one of the Mapbox mobile SDKs, our terms of service require that you provide a telemetry opt-out option within your app for all end users. The default attribution control includes an opt out button. If you hide the attribution control, you must provide an alternative opt out method your users can use. You are responsible for allowing your users to opt out of Mapbox Telemetry. Adding Mapbox to your mobile app Mapbox provides a variety of tools to help you integrate Mapbox maps and our other web services, like directions, geocoding, and static maps, into your mobile application. Maps To get started, visit the mobile SDK overview pages, which include installation instructions, API documentation, and sample code: Mapbox Maps SDK for Android Mapbox Maps SDK for iOS If you would like a more guided introduction to building your first mobile app with one of our Maps SDKs, explore our first steps guides: First steps with the Mapbox Maps SDK for iOS First steps with the Mapbox Maps SDK for Android Mapbox web services To keep the Mapbox Maps SDKs for iOS and Android small, we provide separate libraries for interfacing with Mapbox web services like the Mapbox Directions API, Geocoding API, and Static Images API. On Android, the Mapbox Java SDK provides convenient interfaces to many Mapbox web services APIs as well as a handful of useful utilities for performing common geospatial tasks. On iOS, MapboxGeocoder.swift, MapboxDirections.swift, and MapboxStatic.swift provide interfaces to the Mapbox Geocoding API, Directions API, and Static Images API. For installation instructions, API documentation, and code examples, please visit each platform's respective documentation pages: Mapbox Java SDK Mapbox API libraries for iOS Mapbox Navigation SDKs Built on top of the Mapbox Directions API, the Mapbox Navigation SDKs provide all the logic necessary to implement a navigation experience in your app. The Mapbox Navigation SDKs include critical features like: Drop-in turn-by-turn navigation UI. Automotive, cycling, and walking directions. Traffic avoidance. Maneuver announcements. Text instructions. Text to speech support. Automatic rerouting. Snap to route. To include the Mapbox Navigation SDKs in your application, please visit the respective documentation pages for installation instructions, API reference, and sample code: Mapbox Navigation SDK for iOS Mapbox Navigation SDK for Android Hybrid frameworks Third parties have created plugins and integrations that allow to you use Mapbox SDKs with a variety of alternative development platforms. See our hybrid pricing guide for more information on how usage of your app will be billed. Hybrid frameworks using Mapbox JavaScript APIs Creating hybrid apps with Mapbox GL JS or Mapbox.js is also possible. Potential problems Contact the maintainers of these integrations directly if you have issues or implementation questions, as we are not able to provide official support for hybrid frameworks. Development of the Mapbox Maps SDKs for iOS and Android move quickly, and new features are released on a regular basis. Third-party plugins that rely on these native SDKs may break with new versions, lag behind the official releases, and not support all available features. Our native SDKs work best when you use them directly. Get started now with our first steps guides for Android and iOS. Was this page helpful? Yes No",,Mobile applications,Client-side rendering,Layers and runtime styling,Layers,Runtime styling,Data-driven styling,Feature querying and interactivity,The camera,Offline maps,Telemetry,Adding Mapbox to your mobile app,Maps,Mapbox web services,Mapbox Navigation SDKs,Hybrid frameworks,Hybrid frameworks using Mapbox JavaScript APIs,Potential problems,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Help,"Tutorials, troubleshooting guides and more to help you get started with the Mapbox Maps SDK for Android.",https://docs.mapbox.com/android/maps/help/,,,,"Our Help page contains tutorials, troubleshooting guides, and other resources to help you get started. Tutorials First steps with the Mapbox Maps SDK for Android Walk through installing the Mapbox Maps SDK for Android, getting a map on the screen, and changing the map style Runtime styling for Android Change various properties of a map based on user interaction and other ""runtime"" situations. Data-driven styling for Android Create a map for Android that styles a circle based on a data attribute. Build a store locator for Android Build a store locator to integrate into a an Android application. Troubleshooting Understanding Android APK size Learn how to measure and optimize your Android app’s size. Change your map’s label language Learn about available languages and how to change your map’s language. Offline maps Learn about how offline maps work. Interactive tools Mapbox offline tile count estimator Estimate the number of tiles required to download an offline region using the Mapbox Maps SDK for Android and iOS. Marker playground Add a marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, React Native, or web application.",,Tutorials,Interactive tools,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Data explorer,An overview of the data explorer example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/data-explorer/,example,No code,,"Data explorer Explore Mapbox’s location data. Each map vector tile includes high levels of detail about a particular location or building that you can leverage for procedurally generating experiences or styling. The data layers include building data, points of interest (POIs), roads, and real-time traffic data. You can filter these data layers on and off as needed in the Map Editor (access through the Mapbox menu). This article explains how to use vector tiles to generate 3D features and use metadata in your application or game. Data layers The data explorer example scene uses a combination of the Mapbox 3D Buildings and Mapbox Streets v7 tilesets to visualize a large array of features. As shown in the screenshot below, you can specify multiple data sources by selecting Custom as the Data Source, then adding multiple comma-separated tileset IDs in the Map Ids field. This allows you to use multiple custom tilesets, or add your custom tileset as well as the default Mapbox Streets tileset. For more information on how to use custom data with the Maps SDK for Unity, refer to the custom data documentation. The scene has a comprehensive list of Map Features as shown in the screenshot below. This article will cover the features rendered using the Buildings, Roads, and POI layers specifically. Buildings To see how the buildings are configured in this scene, navigate to Map Features > Features and click on the Feature named Buildings. In this example the there are customizations to the Modeling and Texturing settings as described below. For more information on possible configurations, see the map features documentation for buildings. Data Layer: The layer name in the tileset that contains building footprints. In the tileset, this is called building. Filters: The are no filters configured for this example. See the traffic and directions example for more information on how you can set up filters. Modeling: In the modeling section, you can make changes to the settings to fine tune your meshes. Primitive Type: Vector data is made up of lines, polygons, points, or custom data. The primitive type defines the type of vector feature you are trying to access. In the case of buildings this will be “polygon” since building footprints are essentially polygons extruded by a height value. Extrusion Type: The extrusion type setting provides a way to specify max, min, or fixed heights for buildings. The available options are below. You will see different settings in the inspector depending on these dropdown selections. For this example Max Height is specified. Geometry Type: Settings to extrude roofs, sidewalls, or both. Property Name: The name of the property on the building layer of the tileset that is used for extrusion. By default it is set to height. For more information see the Mapbox Streets v7 tileset layer reference. Scale Factor: The height scale factor by which you would like to extrude the buildings. For example, if this is set to 2, the building extrusions will be done at twice the original scale. Snap to Terrain: This makes sure buildings snap properly to the terrain when using a terrain with elevation. When this is not checked, the buildings might spawn above or below the terrain. Combine Meshes: Check this option if you want to combine all the building meshes on a tile into a single game object. While this helps improve runtime performance, it may not offer you flexibility to make changes on individual buildings (for example, changing the color or texture of a particular building). It may also make it impossible to use a raycast to find the address of a building. Collider Type: This option is used to add a collider to the extruded buildings. The available types of colliders that you can apply to your buildings are Box Collider, Mesh Collider, or Sphere Collider. Note that if you have Combine Meshes selected, this option will add a collider to the entire tile instead of to individual buildings. Texturing: Texturing settings are where you can configure material options for the building geometry. Style Type: The Simple type is specified. The Simple style combines stylized vector designs with scriptable palettes to create a procedurally colored style. Palette Type: City is specified. For more information on possible Palette Type settings, see the map texturing documentation. Behavior Modifiers: Behavior modifiers are ScriptableObjects that work with meshes and game objects to further allow you to decorate, enhance, or make modifications to your game objects. There are no modifiers added to this feature. For an example of a feature that uses a modifier, see the POI feature of this example. Roads To see how the buildings are configured in this scene, navigate to Map Features > Features and click on the Feature named Roads. In this example the there are customizations to the Modeling and Texturing settings as described below: Data Layer: The layer name in the tileset that contains road data. In the tileset, this is called road. Filters: The are no filters configured for this example. See the traffic and directions example for more information on how you can set up filters. Modeling: In the modeling section, you can make changes to the settings to fine tune your meshes. Primitive Type: The primitive type defines the type of vector feature you are trying to access. For roads, this will be set to Line. Line Width: This is the setting for the width of the road line feature. For this example it is set to 3. Extrusion Type: The extrusion type setting provides a way to specify max, min, or fixed heights for the feature. For roads, this is usually set to Absolute height to give a fixed height value. Geometry Type: Settings to extrude the top part of the roads, and, if necessary, to render their side walls. This will give the roads a width. Scale Factor: The height scale factor by which you would like to visualize the roads. For example, if set to 2, the road's width and line height will be twice the original scale. Snap to Terrain: This makes sure roads snap properly to the terrain while using a terrain with elevation. When this is not checked, the roads might spawn above or below the terrain. Combine Meshes: Check this option if you want to combine all the road meshes on a tile into a single game object. While this helps improve runtime performance, it may not offer you flexibility to make changes to individual roads (for example, changing the color or texture of a particular road). It may also make it impossible to use a raycast to find the address of a road. Collider Type: This option is used to add a collider to a road. The available types of colliders that you can apply to your roads are Box Collider, Mesh Collider, or Sphere Collider. Note that if you have the Combine Meshes selected, this option will add a collider to the entire tile instead of to individual roads. Texturing: Texturing settings are where you can configure material options for the building geometry. Style Type: A Custom type is specified. When Custom is selected, materials must be assigned. Texturing Type: Tiled is specified for this example. Top Material: This is the material selected for the top of the road features. Side Material: This is the material selected for the sides of the road features. Behavior Modifiers: Behavior modifiers are ScriptableObjects that work with meshes and game objects to further allow you to decorate, enhance, or make modifications to your game objects. There are no modifiers added to this feature. For an example of a feature that uses a modifier, see the POI feature of this example. POIs To see how the buildings are configured in this scene, navigate to Map Features > Features and click on the Feature named PoiLabels. In this example the there are customizations to the Filters, Modeling, and Behavior Modifiers settings as described below. Data Layer: The layer name in the tileset that contains POI data. In the tileset, this is called poi_label. Filters: Using filters you can make settings to conditionally render vector features contained in the poi_label layer. Using filters in this way allows for controlling the POI label density in the scene. Key: localrank is specified. This value comes from the poi_label layer in the tileset. Operator: Is Equal is selected. Other options are Contains, Is Greater, Is Less, and Is in Range are other possible options. Num Value: 1 is specified. This means that only the most important place in each cell will be rendered. Modeling: In the modeling section, you can make changes to the settings to fine tune your meshes. Primitive Type: The primitive type defines the type of vector feature you are trying to access. For POIs, this will be set to Point. Snap to Terrain: This makes sure points snap properly to the terrain while using a terrain with elevation. When this is not checked, the points might spawn above or below the terrain. Combine Meshes: Check this option if you want to combine all the points on a tile into a single game object. While this helps improve runtime performance, it may not offer you flexibility to make changes to, or interact with individual points. Behavior Modifiers: Feature Position: This setting is for selecting where in the tile the feature will be placed. Mesh Modifiers: No modifiers are configured for this scene. For an example of how Mesh Modifiers can be used, see the astronaut game example. Game Object Modifiers: This scene makes use of a PrefabModifier which allows you to specify a prefab game object to be spawned at each point. Click on the modifier to inspect the settings and/or edit the prefab. Clicking Add New will open a dialogue that has all the available modifiers so that they can be added to the feature and configured. Was this page helpful? Yes No",,Data explorer,Buildings,Roads,POIs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,expression,"An expression defines a formula for computing the value of any layout property, paint property, or filter within a map style.",https://docs.mapbox.com/help/glossary/expression/,glossary,,,"expression An expression defines a formula for computing the value of any layout property, paint property, or filter within a map style. Expressions allow you to style data with multiple feature properties at once, apply conditional logic, and manipulate data with mathematical, logical, and string operators. This allows for sophisticated runtime styling. Take a look at the Mapbox Style Specification or the Mapbox iOS SDK expressions reference for more information on using expressions in your map styles. Was this page helpful? Yes No",,expression,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Build indoor floorplans with Mapbox,Upload a floorplan to create an indoor map.,https://docs.mapbox.com/help/tutorials/indoor-floorplans/,tutorial,Varies,,"advanced Varies Build indoor floorplans with Mapbox Prerequisite Familiarity with GIS. You can use Mapbox to put a floor plan or non-geographic data on our maps. There are a couple of routes you can take. The key is to give your data some geographic reference for it to work in a mapping application. You can do this in a couple of ways, depending on your data's format: If you want to overlay an image of your plan, you need to georeference it. If you want to use a tool like Mapbox.js to display your data as a tiled image, read this guide to learn about processing non-map images as maps. If you know the bounding coordinates of your image, you can use the imageOverlay constructor in Leaflet shown in this example. If you have data in a geographic vector format, such as GeoJSON, KML, or Shapefile, you can upload it to Mapbox Studio as a tileset, add it to a style, and embed it in your website using Mapbox GL JS. If you are using Mapbox GL JS, you can also create 3D floorplans like in this example using fill-extrusions. Was this page helpful? Yes No",,Build indoor floorplans with Mapbox,,,,,,,,,,,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Measure distances,Click points on a map to create lines that measure distanced using turf.lineDistance.,https://docs.mapbox.com/mapbox-gl-js/example/measure/,example,JavaScript,,Measure distances Click points on a map to create lines that measure distanced using turf.lineDistance. Was this example helpful? Yes No,,Measure distances,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,overzoom,Overzoom is the result of a tileset being zoomed in beyond its given zoom extent.,https://docs.mapbox.com/help/glossary/overzoom/,glossary,,,"overzoom Overzoom is the result of a tileset being zoomed in beyond its given zoom extent. Raster tilesets will appear to lose clarity if overzoom occurs. For example, if you are displaying a raster tileset with a zoom extent between z0 and z6, if you zoom to a higher zoom level past z6, the imagery will become blurry and difficult to see. The effects of overzoom are not as noticeable with vector tilesets since vector data is not stored in a pixel-based format, but rather encoded and calculated from a series of points, lines, and polygons. Because of this, vector data can be overzoomed and visualized to zoom 22. Was this page helpful? Yes No",,overzoom,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display map navigation controls,Zoom and rotation controls to make map navigation more obvious.,https://docs.mapbox.com/mapbox-gl-js/example/navigation/,example,JavaScript,,Display map navigation controls Zoom and rotation controls to make map navigation more obvious. Was this example helpful? Yes No,,Display map navigation controls,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Documentation,Documentation,"Examples, tutorials, and API references to help you start building with Mapbox",https://docs.mapbox.com/,,,,"Documentation Examples, tutorials, and API references to help you start building with Mapbox Maps Embed highly customized maps in your applications. Mapbox GL JS Mapbox GL JS is a JavaScript library that uses WebGL to render interactive maps from vector tiles and Mapbox styles. Read documentation Read documentation Maps SDKs The Mapbox Maps SDKs are open-source libraries for embedding highly customized maps in web and mobile applications. Choose a platform iOSAndroidUnity Choose a platform iOSAndroidUnity Maps APIs The Mapbox web services APIs allow for programmatic access to Mapbox map-related tools and services. Choose an API Vector TilesRaster TilesMapsStylesStatic ImagesTilequeryUploadsTilesetsDatasets Choose an API Vector TilesRaster TilesMapsStylesStatic ImagesTilequeryUploadsTilesetsDatasets Navigation Add turn-by-turn navigation inside mobile applications, create optimized routes, and more. Navigation SDKs The Mapbox Navigation SDKs allow developers to add turn-by-turn navigation into iOS or Android apps in minutes. Choose a platform iOSAndroid Choose a platform iOSAndroid Directions APIs With the Mapbox directions-related APIs, you can add routing with turn-by-turn directions to your map. Choose an API DirectionsOptimizationMatrixMap MatchingIsochrone Choose an API DirectionsOptimizationMatrixMap MatchingIsochrone Search Turn coordinates into addresses or addresses into coordinates. Geocoding API The Mapbox Geocoding API provides worldwide forward and reverse geocoding. Read documentation Read documentation Studio Learn how Mapbox Studio works, get guidance on best practices, and browse a comprehensive application reference. Read documentation Other Documentation Vector tiles Vector tiles are vector data for maps. Learn more about how vector tiles make your maps fast while offering full design flexibility. Read documentation Read documentation Plugins Build on top of the Mapbox Maps SDKs with extra features in lightweight dependencies. Choose a platform AndroidiOS Choose a platform AndroidiOS Open source tools Browse open source tools including Turf.js, Tippecanoe, Rasterio, Mapbox.js, and more. Visit GitHub Visit GitHub Web service interfaces Access and integrate with Mapbox web services APIs using these SDKs and libraries. Choose a language JavaJavaScriptSee all Choose a language JavaJavaScriptSee all Atlas Run Mapbox global maps on your own infrastructure, including behind a firewall or completely offline. Read documentation Read documentation Android Core library Easily handle device location, permissions, and connectivity for any app. Read documentation Read documentation Didn't find what you need? Mapbox documentation is full of useful guides and tutorials to help get you started in no time. Sign up for feature updates Sign up to get a monthly summary of Mapbox feature updates and new products delivered straight to your inbox. Sign up",,Documentation,Navigation,Search,Studio,Other Documentation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,https://docs.mapbox.com/mapbox.js/api/,,,,"if not redirected, click here.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Examples,Code examples for Mapbox GL JS.,https://docs.mapbox.com/mapbox-gl-js/examples/,,,,Examples Getting started Display a map Initialize a map in an HTML element with Mapbox GL JS. Styles Add an animated icon to the map Add a generated icon to the map Generate and add a missing icon to the map Add an icon to the map Display a map with a custom style Display a satellite map Change a map's style Display a map Layers Display buildings in 3D Extrude polygons for 3D indoor mapping Add a 3D model Add an animated icon to the map Add a generated icon to the map Generate and add a missing icon to the map Add an icon to the map Adjust a layer's opacity Animate a line Animate a series of images Animate a point Change building color based on zoom level Change the case of labels Display HTML clusters with custom properties Create and style clusters Change a layer's color with buttons Add a custom style layer Style circles with a data-driven property Style lines with a data-driven property Display and style rich text labels Add a pattern to a polygon Add a new layer below labels Add a GeoJSON line Draw GeoJSON points Add a GeoJSON polygon Create a heatmap layer Add an image Create a gradient line using an expression Add multiple geometries from one GeoJSON source Style ocean depth data Show and hide layers Change worldview of administrative boundaries Update a choropleth layer by zoom level Variable label placement Add a video Visualize population density Add hillshading Sources Animate a line Animate a series of images Animate a point Join local JSON data with vector tile geometries Add an image Add live realtime data Update a feature in realtime Add a raster tile source Add a third party vector tile source Create a time slider Add a vector tile source Add a video Add a WMS source Add hillshading User interaction Adjust a layer's opacity Center the map on a clicked symbol Change a layer's color with buttons Animate 3D buildings based on ambient sounds Disable map rotation Create a draggable Marker Create a draggable point Filter features within map view Filter symbols by text input Filter symbols by toggling a list Display a non-interactive map Change a map's language Measure distances Get coordinates of the mouse pointer Highlight features containing similar data Select features around a clicked point Get features under the mouse pointer Restrict map panning to an area Change a map's style Toggle interactions Create a time slider Change worldview of administrative boundaries Update a choropleth layer by zoom level Highlight features within a bounding box Fit to the bounds of a LineString Create a hover effect Camera Animate map camera around a point Animate a point along a route Center the map on a clicked symbol Fit a map to a bounding box Slowly fly to a location Fly to a location Navigate the map with game-like controls Jump to a series of locations Play map locations as a slideshow Fly to a location based on scroll position Set pitch and bearing Controls and overlays Animate a marker Change the default position for attribution Add custom icons with Markers Disable scroll zoom View a fullscreen map Locate the user Swipe between maps Display driving directions Show drawn polygon area Add a geocoder Add a marker using a place name Display map navigation controls Show polygon information on click Display a popup on click Display a popup on hover Display a popup Attach a popup to a marker instance Geocoder Supplement forward geocoding search results from another data source Use a custom render function with a geocoder Accept coordinates as input to a geocoder Limit geocoder results to a named region Place the geocoder input outside the map Use a custom camera animation with a geocoder Localize the geocoder to a given language Add a geocoder Set a point after Geocoder result Browser support Check for browser support Internationalization support Use locally generated ideographs Add support for right-to-left scripts,,Examples,Styles,Layers,Sources,User interaction,Camera,Controls and overlays,Geocoder,Browser support,Internationalization support,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,"Add points to a web map, part 3: add interactivity",Add popups when markers are clicked using Mapbox GL JS.,https://docs.mapbox.com/help/tutorials/add-points-pt-3/,tutorial,JavaScript,,"beginner JavaScript Add points to a web map, part 3: add interactivity This is the third and final part in a tutorial series that teaches you how to add points to a map using the Mapbox Studio dataset editor, the Mapbox Studio style editor, and Mapbox GL JS. Part 3 focuses on using Mapbox GL JS, a JavaScript library, and will require you to write code. In this tutorial, you will learn how to: Add a custom style to a Mapbox GL JS map Add popups when a marker is clicked Getting started There are a few resources you will need to follow along with this guide: The ""Chicago Parks"" custom style. You will need a style containing markers for 10 Chicago parks. You can learn how to create this style in Add points to a web map, part 1: create a dataset and Add points to a web map, part 2: create a style. Development environment. This guide requires writing code. See Get ready to write code below for tips on how to get started. Get ready to write code To create an interactive map with popups you will need to use Mapbox GL JS. This will require writing code. First, you will need to get setup with a development environment to write HTML, CSS, and JavaScript. If you are new to writing code, you may want to explore a resource like Codecademy to learn more about how front-end development works before using Mapbox GL JS. Here's what you'll need to do: Download a text editor (for example, Sublime Text or Atom). Familiarize yourself with JavaScript and front-end development concepts. Create an HTML file Create a new HTML file in your text editor to initialize a Mapbox GL JS map. Initialize your map Open your text editor. Copy and paste the code below into your text editor to initialize your Mapbox GL JS map. Make sure mapboxgl.accessToken is set equal to your access token. You can find your access token on your Access tokens page when you sign into your Mapbox Account. Replace your-style-URL-here with your own style URL. Need help finding your style URL? Save your file as ""index.html."" Open the file in a browser. You should see a map displaying your data in the browser window. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Points on a map</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // replace this with your access token var map = new mapboxgl.Map( { container: 'map', style: 'your-style-URL-here', // replace this with your style URL center: [-87.661557, 41.893748], zoom: 10.7 } ); // code from the next step will go here </script> </body> </html> Add popups After you have successfully displayed your map, you will need to add a little more code to allow the user to interact with your markers. This code will include: queryRenderedFeatures: This Mapbox GL JS method will generate a list of all the points on your map and the feature properties associated with each. mapboxgl.Popup: This method is used to create popups that show certain feature properties. The Popup component has several different instance members that you can use to customize the popup elements. In this example, you will use: Popup.setLngLat(): Sets the geographical location of the popup's anchor. Popup.setHTML(): Sets the popup's content to the HTML provided as a string. The specified properties must match the name of the properties you would like to display in your popups. In the code below, the properties that will display are the title and description properties for each feature. Popup.addTo(map): Adds the popup to a map. An event listener: This event listener will make sure that popups are only shown when the user clicks a marker. Add more code Copy and paste the code below into your HTML file after the code that initializes your map, but before the </script> tag. In the variable features, make sure you replace layer-name-here with the name of your layer as seen in the style editor. This is probably chicago-parks if you have been following the earlier tutorials in this series. Refresh your browser page. You will be able to click on the markers and see titles and descriptions displayed in the popups. map.on('click', function(e) { var features = map.queryRenderedFeatures(e.point, { layers: ['layer-name-here'] // replace this with the name of the layer } ); if (!features.length) { return; } var feature = features[0]; var popup = new mapboxgl.Popup( { offset: [0, -15] } ) .setLngLat(feature.geometry.coordinates) .setHTML('<h3>' + feature.properties.title + '</h3><p>' + feature.properties.description + '</p>') .addTo(map); } ); Final product You've made a map using the Mapbox Studio dataset editor, Mapbox Studio style editor, and Mapbox GL JS that incorporates custom data and styles and allows for user interaction. Next steps To learn about more things you can do with Mapbox Studio, explore the Mapbox Studio manual. For more information on Mapbox GL JS and how it works, read our guide on how Mapbox web applications work. Was this page helpful? Yes No",,"Add points to a web map, part 3: add interactivity",Get ready to write code,Create an HTML file,Initialize your map,Add popups,Add more code,Final product,Next steps,,,,,,,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Examples,Code examples for the Mapbox Maps SDK for iOS.,https://docs.mapbox.com/ios/maps/examples/,,,,"Getting started Camera animation Animate camera movement. Apply a style designed in Mapbox Studio Use a style created in Mapbox Studio with the Mapbox Maps SDK for iOS. Mark a place on the map with an annotation Add a default marker with a callout and title using the Mapbox Maps SDK for iOS. Simple map view Show a map in a view controller with the Mapbox Maps SDK for iOS. Markers and callouts Annotation models Subclass annotation classes and implement the MGLAnnotation protocol. Add annotation views and images Add multiple annotations containing views and images. Annotation views Custom annotation views with animated selection. Display custom views as callouts Create and display a custom callout view with the Mapbox Maps SDK for iOS. Default callout usage Use default appearance and interactivity of annotation callout views. Mark a place on the map with an image Add a point annotation with a custom image. Dynamically style interactive points Add interactive, dynamically-styled points, derived from a web API call. Customize the user location annotation Override the default user location annotation. Dynamic styling Use images to cluster point data Color & display clustered point data using images and interval-based property styling. Cluster point data Color & display data point clusters using interval-based property styling. Data-driven circles Dynamically style a circle layer with data-driven styling. Create a heatmap layer Visualize earthquake data using a heatmap layer. Add an image Add an image to a map using an image source and raster style layer. Add live data Add and update a source that uses real-time data. Add multiple shapes from a single shape source Create style layers from a shape collection feature. Add raster imagery Dynamically add a raster source. User interaction Restrict map panning to an area Prevent a map from being panned to a different place by constraining the viewport. Draggable annotation views Custom annotation views with that can be dragged. Point conversion Convert between screen location and geographic coordinates. Show and hide a layer Add a source and a toggleable layer. Select a feature within a layer Allow a user to select a feature within a style layer. Switch between user tracking modes Toggle between user tracking modes using a custom UIButton. Map styles Default styles Use a variety of professionally designed styles with the Mapbox Maps SDK for iOS. Apply a style designed in Mapbox Studio Classic Use legacy raster tiles on a map. Satellite styles Use the satellite base layer on your map. Use third-party vector tiles Load a third-party vector source using a custom style. Switch between map styles Switch between map styles using a UISegmentedControl. 3D Display 3D buildings Create fill extrusions using building height. Adjust lighting of 3D buildings Adjust the lighting properties for fill extrusions with a slider. Lines and polygons Add a pattern to a polygon Create a polygon with a custom fill pattern. Add a line annotation from GeoJSON Draw a polyline by parsing a GeoJSON file. Add a polygon annotation Draw a vector polygon on a map with the Mapbox Maps SDK for iOS. Add a line style layer from GeoJSON Add a polyline from a GeoJSON source and style it dynamically. Animate a line Add an animated polyline from a GeoJSON source. Offline Create a static map snapshot Create a map snapshot object. Download an offline map Download an offline pack and track its progress.",,Getting started,Dynamic styling,User interaction,Map styles,3D,Lines and polygons,Offline,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,"Add points to a web map, Part 1: create a dataset",Create a new dataset containing points.,https://docs.mapbox.com/help/tutorials/add-points-pt-1/,tutorial,No code,,"beginner No code Add points to a web map, Part 1: create a dataset This tutorial is the first in a series of tutorials that will teach you how to add points to a map using the Mapbox Studio dataset editor, the Mapbox Studio style editor, and Mapbox GL JS. Part 1 of the series focuses on the Mapbox Studio dataset editor. In this tutorial, you will learn how to: Upload geospatial data as a dataset Draw additional data in the dataset editor Save and export your dataset as a tileset Getting started There are a few resources you will need to follow along with this guide: Mapbox account. Sign up for a free account on Mapbox. Data. Download this GeoJSON file, which includes the coordinates and feature properties for nine different Chicago Parks. Download GeoJSON Upload a new dataset You can store an editable version of your data in your Mapbox account by uploading it to Mapbox Studio as a dataset. Having an editable version of your data means that you can add, remove, and edit features (points, lines, and polygons) and properties for each feature. Note If you don't need to edit or draw data from scratch, you can upload data to Mapbox as a tileset instead of a dataset. For more information on the difference between tilesets and datasets, see the Uploads section of the Mapbox Studio Manual. Create a dataset Log into Mapbox Studio and navigate to the Datasets page. Click the New dataset button. Select the Upload option in the upper right corner of the New Dataset modal. Select the GeoJSON file you downloaded. Click Confirm, then click Create. Once your file has completed uploading, click Start editing. The dataset editor automatically opens, and the data is displayed on a dark base map to help visualize the features. About datasets You can edit both dataset features and properties in the dataset editor: Features are the points, lines, and polygons on your map. You can add new features using the draw tools, edit the placement or shape of features using by clicking and dragging features on the map, or remove features all together by clicking on them and hitting the delete key. You can also click on each feature in the dataset editor to view its properties. Properties can be strings, numbers, or boolean. In the sample dataset you uploaded, there are title and description properties for each point with a unique text string. You can edit properties, add new properties, or delete properties in the dataset editor. Make sure any content that you want to display in popups in your final product is included as a property while you are working in the dataset editor. Draw data You can use the draw tools in the dataset editor to add a new point to your dataset. You can also change the geometry, placement, and properties of existing features with the dataset editor’s draw tools. Read more about draw tools in the Mapbox Studio manual. Draw a new feature Click inside the Search places field in the upper right side of the editor and search for Garfield Park Chicago. Use the draw tool to create a new point on the map at that location. Next, click the Add Property button. Use the properties list on the left side of the screen to add the following field name and description: Add the field name title and give it the value Garfield Park. Click Confirm. Add the field name description and give it the value Home of the Garfield Park Conservatory. Click Confirm. Export the dataset as a tileset Next, you will save and export the dataset as a tileset so that you can add it to a Mapbox style. Create a tileset Click the Save button in the upper right corner of the editor to save your changes. Click the Export button, then select Export to a new tileset. Name your tileset chicago-parks and click Export. After your tileset has successfully uploaded, click the tileset's name in the Notifications pane to open it. About tilesets Web maps are comprised of map tiles. A collection of tiles is called a tileset. Mapbox cuts up data into tiles that are then added to a web map and displayed at various zoom levels. To make Mapbox maps more performant, a dataset's features are simplified when it is converted into a tileset. Next steps Next, start part 2 of this tutorial series to learn how to add your tileset to a map style in the Mapbox Studio style editor. Was this page helpful? Yes No",,"Add points to a web map, Part 1: create a dataset",Upload a new dataset,Create a dataset,About datasets,Draw data,Draw a new feature,Export the dataset as a tileset,Create a tileset,About tilesets,Next steps,,,,,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Upgrade Atlas,Upgrade Atlas.,https://docs.mapbox.com/atlas/overview/upgrade/,guide,,,"Upgrade Atlas Note This guide assumes you are using at least v1.3.0 of the Atlas Installer To upgrade to the latest version of Mapbox Atlas, you will need access to the internet to pull in new data. To upgrade when a new Atlas version is released, you will need to download new Docker images. This guide also applies for upgrading your map data. We recommend upgrading using the install command to upgrade Atlas. Back up your settings As a precaution before upgrading, make sure your config is saved as a JSON to use as a backup in case your settings are overwritten during an upgrade: { ""AtlasServerPassword"": ""newpassword"", ""AtlasServerPort"": 2999, ""AtlasServerHostName"": ""localhost"" } Save this file and keep it somewhere safe. If you need to update your settings from a backup after upgrading, follow the guide to change your configuration post setup. Clean out old data Run the following commands before downloading any new data: # Stop all docker containers, remove mounted volumes, networks, and purge all images $ ./atlas-installer remove atlas-server/ # Remove existing docker tarballs $ rm -rf atlas-server/docker/ $ rm -rf atlas-server-files/docker Upgrade using the Installer Wizard First, make sure you followed the guide to clean out old data. To upgrade, run: $ ./atlas-installer install The install command will guide you through the upgrade process. If you want to upgrade to a new version of Atlas without downloading new map data, make sure you deselect everything except Docker Images when the installer prompts you about downloading data. To ensure your settings aren't touched, make sure you answer yes to Are you upgrading an existing Atlas installation?. If you are planning to update your tilesets without upgrading to a new version of Atlas, you can use the install command and deselect Docker images and then select the tilesets you want to download for the What data would you like to download? prompt Manual upgrade If you prefer to run the download and setup commands manually rather than the install command, follow these instructions. Make sure you followed the instructions to clean out old data and you have backed up your settings. To upgrade to a new version of Atlas # Download new images $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --no-tilesets --no-geocoding --enterprise-boundaries none # Set up Atlas with new images $ ./atlas-installer setup atlas-server-files/ atlas-server/ --config <config.json> Upgrade Atlas images and tilesets If you are upgrading a testing or beta Atlas installation that was using development tilesets, you may want to download the full-zoom production tilesets instead. Run the following commands to upgrade your Atlas images and tilesets: # Stop all docker containers, remove mounted volumes, networks, purge all images, and remove Mapbox tilesets $ ./atlas-installer remove atlas-server --mapbox-mbtiles # Download new images and data $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> # Set up Atlas with new images and tilesets $ ./atlas-installer setup atlas-server-files/ atlas-server/ --config <config.json> Upgrade from development to production tilesets If you initially installed Atlas with low-res development tilesets, at some point you may want to upgrade to full-zoom production tilesets. To do this, you will re-run the download command with the --tilesets flag. Run the following commands to upgrade from development tilesets to production tilesets: # Download production tilesets $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --no-docker --no-geocoding --enterprise-boundaries none --tilesets all # Overwrite the dev tilesets with the downloaded production tilesets $ ./atlas-installer setup atlas-server-files/ atlas-server/ --config <config.json> If you want to only update your Mapbox Streets tileset, you can specify --tilesets streets to only download the latest Mapbox Streets tileset. Upgrade from development to production geocoding data Like upgrading from development to production tilesets, to fully experience Atlas Search, you should use production search data. To do this, you will re-run the download command with the --geocoding flag. Run the following commands to upgrade from development geocoding data to production geocoding data: # Download production geocoding data $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --no-docker --no-tilesets --enterprise-boundaries none --geocoding # Overwrite the dev geocoding data with the downloaded production geocoding data $ ./atlas-installer setup atlas-server-files/ atlas-server/ --config <config.json> Upgrade to a specific version of Atlas If you want to upgrade to a specific version of Atlas, provide the version number when downloading the files. $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --no-tilesets --no-geocoding --enterprise-boundaries none --version <your-version> # Set up Atlas with new images and tilesets $ ./atlas-installer setup atlas-server-files/ atlas-server/ --config <config.json> Was this page helpful? Yes No",,Upgrade Atlas,Clean out old data,Upgrade using the Installer Wizard,Manual upgrade,To upgrade to a new version of Atlas,Upgrade Atlas images and tilesets,Upgrade from development to production tilesets,Upgrade from development to production geocoding data,Upgrade to a specific version of Atlas,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,map ID,Map IDs are used to identify vector and raster tilesets.,https://docs.mapbox.com/help/glossary/map-id/,glossary,,,"map ID Map ID is a deprecated term for the unique identifier used to identify a tileset. This identifier is now referred to as a tileset ID. To learn more, visit the tileset ID glossary page. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,map ID,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Settings and account management,Learn how to manage your Mapbox account settings.,https://docs.mapbox.com/help/account/settings/,guide,,,"Settings and account management Your Settings page is where you can manage profile and billing information, passwords and security, and apps connected to your Mapbox account. To access the Settings page, log into your account and navigate to account.mapbox.com/settings. Profile Change your email address Log in and navigate to your Account settings page. Enter your new email address and click Save changes. Change your username It's not possible to change your username. Doing so would break links to your maps and could cause unanticipated problems. Instead, you can create a new account, transfer your assets, and update your web and mobile applications to reference the new account and maps. Once this transition is complete, you can delete the old account without breaking any links to your maps. For more information, see Transfer styles between accounts. Delete your account You can delete your account by scrolling to the bottom of your Account settings and clicking the Delete account button. When you delete an account, the change is effective immediately and all maps and data are removed: Projects and data associated with your account will no longer be available. You will not be able to use the account to log in to Mapbox. We won't automatically prorate for unused services. Deleting your account is permanent. We will not be able to recover your account if you change your mind. You will not be able to create an account with the same username again. Password Change your password Log in and navigate to your Account settings. Enter your current password and new password in the appropriate fields. If you have two-factor authentication enabled, enter your two-factor authentication code. Click Save new password. Reset your password If you're having trouble logging in, try resetting your password by providing the email address that's associated with your Mapbox account. We'll send you an email with further instructions. The link you'll receive in your password reset email is only valid for 24 hours. If you receive an Invalid token error message or have waited more than 24 hours, you'll need to request another password reset email. If you don't remember your email address or you're having other access problems, contact our support team and we'll look into it. Sometimes, password reset emails are undeliverable especially for inactive email addresses. If you are not receiving the password reset email, let us know. Security Two-factor authentication Two-factor authentication (2FA), also known as multi-factor authentication (MFA) or two-step authentication, provides an optional, but recommended, layer of security to your account. Once enabled, you'll be prompted to enter your password as well as a security code generated on your mobile device whenever you log in. Enable two-factor authentication When you're logged in to your account, you can enable two-factor authentication from your Security page. Your Security page will include a barcode which you'll be prompted to scan with your mobile device. Scan the generated barcode using an authenticator app on your mobile device. We recommend using Google Authenticator - it's free and available for iOS and Android. For a Windows phone, use the Authenticator app. Your mobile device will display a 6-digit code. Type this code into the field below the barcode to complete the process. Use a recovery code to access your account without your two-factor device After you've set up two-factor authentication on your account, you will be redirected to a page with a recovery code. A recovery code is a single-use code that lets you sign in without your two-factor device. Write down this code and keep it in a safe place. Treat your recovery code like a password to your account. If you lose your mobile device, you will need this code to log in to your account. If you have already set up two-factor authentication on your account and do not have a recovery code, go to your Security page to generate and retrieve your recovery code. To use the code, you'll need your username or email and your password. To use your recovery code: Navigate to the Sign in page. Enter your username and password and click Sign in. Click the Lost your mobile device? link below the Sign in button. A new field will appear. Enter your recovery code in the new field and click Sign in. Using your recovery code will temporarily disable two-factor authentication and give you a chance to configure a new two-factor authentication device. Regain access after losing your recovery code If you do not have your recovery code, you must have a payment method on file so we can verify your account and remove two-factor authentication. Contact our support team to get started. GDPR compliance Mapbox Services are fully compliant with GDPR. For more information, read our DPA and subprocessors pages. Mapbox is also Privacy Shield certified and can be found on privacyshield.org. If you have any questions after reviewing those documents, let us know. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Settings and account management,Change your username,Delete your account,Password,Change your password,Reset your password,Security,Two-factor authentication,Enable two-factor authentication,Use a recovery code to access your account without your two-factor device,Regain access after losing your recovery code,GDPR compliance,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Convert units,Use a formula to convert elevation values from meters to feet.,https://docs.mapbox.com/studio-manual/examples/convert-units/,example,No code,,"Convert units About this style Contour data: The contour data used in this example comes from the mapbox-terrain-v2 tileset. The contour source layer contains the geometry for each contour line and two properties: index and ele. The ele property is the elevation in meters. Read more about the Mapbox Terrain tileset in the vector tile reference documentation. Two-layer approach: This example uses two different layers from the same data source: a line layer called contour and a symbol layer called contour-label. The line layer, contour, was added by adding a new layer and specifying the contour source layer from the Mapbox Terrain tileset as the source and creating a line layer. The contour layer uses the default styling for line layers. The symbol layer, contour-label, was added by duplicating the contour line layer and changing the type of layer from line to symbol. Using formulas: The Text field for the contour-label layer uses a formula to calculate and display elevation in both meters and feet from the ele data property. Open the contour-label layer to see how the formula works. Related resources Looking for more guidance? Read our tutorials. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Convert units,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Map camera,Fine grain control over the map camera during your Android app navigation experience with the Mapbox Navigation SDK for Android. Click to learn how.,https://docs.mapbox.com/android/navigation/overview/camera/,guide,Java,Kotlin,"Map camera SDKs covered: Navigation SDK Navigation UI SDK The Navigation SDK provides control over the map camera throughout the navigation app experience. This guide provides instructions on how to set the map camera using NavigationView and MapboxNavigation. You can find more details on how the map camera works in the Maps SDK for Android documentation. Navigation UI SDK Using the Navigation UI SDK, you can specify the initial camera position and update the camera position as the user progresses along the route or when the user interacts with the UI. Set the initial camera position You can initialize the NavigationView with a CameraPosition of your choice. This way, the MapView does not need to zoom in to the initial Location of the device from the world view. Java Kotlin CameraPosition initialPosition = new CameraPosition.Builder() .target(new LatLng(ORIGIN.latitude(), ORIGIN.longitude())) .zoom(INITIAL_ZOOM) .build(); navigationView.initialize(this, initialPosition); Copy Update the camera position Driven by DynamicCamera engine, the NavigationCamera holds all the logic needed to drive a MapboxMap camera that reacts and adjusts to the current progress along a DirectionsRoute. To create an instance of NavigationCamera, you need a MapboxMap, MapboxNavigation, and LocationComponent object: Java Kotlin NavigationCamera camera = new NavigationCamera(mapboxMap, mapboxNavigation, locationComponent); } Copy Calling NavigationCamera#start(DirectionsRoute route) will begin an animation to the start of the DirectionsRoute you provided: Java Kotlin camera.start(directionsRoute); } Copy The NavigationCamera has two tracking modes: NAVIGATION_TRACKING_MODE_GPS and NAVIGATION_TRACKING_MODE_NORTH. They offer two different behaviors. MODE_GPS follows the Location updates from the device based on the values provided by DynamicCamera. MODE_NORTH does the same, but with a bearing that is always zero, so the camera will always be pointed north. To adjust these, use: Java Kotlin camera.updateCameraTrackingMode(NavigationCamera.NAVIGATION_TRACKING_MODE_NORTH); } Copy NavigationCamera#showRouteOverview(int[] padding) will also adjust the camera to the bounds of the DirectionsRoute being traveled along with the given padding which is passed. NavigationCamera#resetCameraPositonWith(NAVIGATION_TRACKING_MODE_GPS) will reset the camera to the last known position update and will resume tracking of future updates with the mode you pass - in this case, tracking will resume with GPS tracking. Custom camera engine The Navigation SDK provides a SimpleCamera by default. You're also able to create your own CameraEngine and give it to the Navigation SDK like so: MapboxNavigation#setCameraEngine(CameraEngine cameraEngine). Example The DynamicCamera provided by the libandroid-navigation-ui library (described above) is an example of a custom CameraEngine. In DynamicCamera, calculations are being made based on the user's location along the given route. MapboxNavigation creates a SimpleCamera by default that you can access with the MapboxNavigation#getCameraEngine() method. SimpleCamera extends from Camera and is required to provide values for bearing, tilt, zoom, and a target Point given a RouteInformation. A RouteInformation object can be created from a DirectionsRoute, Location, or RouteProgress. Depending on which objects are provided, SimpleCamera will return a value for each camera method: Java Kotlin RouteInformation.create(route, location, routeProgress); Copy For example, if RouteInformation has a DirectionsRoute, the SimpleCamera will return the List of Points based on the route geometry for Camera#overview(RouteInformation routeInformation): Java Kotlin public List<Point> overview(RouteInformation routeInformation) { ... if (invalidCoordinates) { buildRouteCoordinatesFromRouteData(routeInformation); } return routeCoordinates; } Copy You can then use the returned List to update the MapboxMap camera. In this case, you can use the list to build a LatLngBounds that the camera will move to include: Java Kotlin Camera cameraEngine = navigation.getCameraEngine(); List<Point> routePoints = cameraEngine.overview(routeInformation); LatLngBounds routeBounds = ... CameraUpdateFactory.newLatLngBounds(routeBounds, padding[0], padding[1], padding[2], padding[3]); mapboxMap.easeCamera(CameraUpdateFactory.newCameraPosition(position)); Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Map camera,Update the camera position,Custom camera engine,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a third party vector tile source,Render vector data provided by Mapillary.,https://docs.mapbox.com/mapbox-gl-js/example/third-party/,example,JavaScript,,Add a third party vector tile source Render vector data provided by Mapillary. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Add a third party vector tile source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Annotation,Mapbox Android Annotation Plugin.,https://docs.mapbox.com/android/plugins/overview/annotation/,guide,Java,Kotlin,"Annotation The Mapbox Annotation Plugin simplifies the way to set and adjust the visual properties of annotations on a Mapbox map. The Mapbox Maps SDK for Android provides developers with fine-grain control over the appearance and location of map annotations. In this context, ""annotations"" means circles, polygons, lines, text, and icons. Using runtime and data-driven styling to create annotations can require a deep understanding of the Maps SDK. This plugin obfuscates much of the required boilerplate code. Note: A SymbolLayer is the layer that is responsible for both map text and icons. Install the Annotation Plugin To start developing an application using the Annotation Plugin, you'll need to add the appropriate dependencies inside of your build.gradle. The Annotation Plugin dependency includes the Mapbox Maps SDK for Android. You can find all dependencies given below on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-annotation- v8. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-annotation- v8 : 0.7.0 ' } Initialize the plugin The plugin includes manager classes for the various map layers available in the Mapbox Maps SDK for Android. The manager classes are explained below and their constructors only require a MapboxMap object. You should initialize a manager class within the onMapReady() method to be sure that the annotations are added to a MapboxMap that's completely ready. Java Kotlin @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Use a layer manager here } }); } Copy Manager The circle, line, fill, and symbol map layers have accompanying manager classes. Each manager class has methods for setting layer properties that are less related to the visual styling. For example, SymbolManager adjusts the position of the SymbolLayer's icon or text with methods such as iconAllowOverlap() or iconTranslate(). You can also set onClick and onLongClick listeners to the type of annotations that you're adding to the map. Layer type Manager class Circle CircleManager Line LineManager Fill FillManager Symbol SymbolManager For example, here's how a `SymbolManager` would be used: Java Kotlin // create symbol manager object SymbolManager symbolManager = new SymbolManager(mapView, mapboxMap); // add click listeners if desired symbolManager.addClickListener(symbol -> ); symbolManager.addLongClickListener(symbol -> { }); // set non-data-driven properties, such as: symbolManager.setIconAllowOverlap(true); symbolManager.setIconTranslate(new Float[]{-4f,5f}); symbolManager.setIconRotationAlignment(ICON_ROTATION_ALIGNMENT_VIEWPORT); Copy Manager class usage example See more usage of various manager classes Options The circle, line, fill, and symbol map layers also have accompanying options classes. The options classes follow the builder pattern, which allows you to set various layer properties that are more related to visual styling. For example, FillOptions adjusts the look of a FillLayer polygon with methods such as withFillColor(), withFillOpacity(), and withFillPattern(). Layer type Option class Circle CircleOptions Line LineOptions Fill FillOptions Symbol SymbolOptions Java Kotlin // create a fixed fill List<LatLng> innerLatLngs = new ArrayList<>(); innerLatLngs.add(new LatLng(-10.733102, -3.363937)); innerLatLngs.add(new LatLng(-19.716317, 1.754703)); innerLatLngs.add(new LatLng(-21.085074, -15.747196)); List<List<LatLng>> latLngs = new ArrayList<>(); latLngs.add(innerLatLngs); FillOptions fillOptions = new FillOptions() .withLatLngs(latLngs) .withFillColor(PropertyFactory.colorToRgbaString(Color.RED)); fillManager.create(fillOptions); // random add fills across the globe List<FillOptions> fillOptionsList = new ArrayList<>(); for (int i = 0; i < 20; i++) { int color = Color.argb(255, random.nextInt(256), random.nextInt(256), random.nextInt(256)); fillOptionsList.add(new FillOptions() .withLatLngs(createRandomLatLngs()) .withFillColor(PropertyFactory.colorToRgbaString(color)) ); } fillManager.create(fillOptionsList); Copy Manager class usage example See more usage of various option classes As you saw above, the FillManager#create() method takes in a single FillOptions object as a parameter. A List<> of FillOptions is also a valid parameter for the create() method. This is the same for all the manager classes. LineManager will require a LineOptions class and so on. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Annotation,Initialize the plugin,Manager,Options,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Directions to selected location,Show a dotted directions route to a location that's based on map movement.,https://docs.mapbox.com/android/java/examples/dashed-directions-line/,example,Java,,"Directions to selected location Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""60.1698556"" mapbox:mapbox_cameraTargetLng=""24.9383791"" mapbox:mapbox_cameraZoom=""12"" mapbox:mapbox_cameraZoomMin=""11"" /> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.Gravity; import android.view.ViewGroup; import android.widget.FrameLayout; import android.widget.ImageView; import android.widget.Toast; import com.mapbox.api.directions.v5.DirectionsCriteria; import com.mapbox.api.directions.v5.MapboxDirections; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.core.constants.Constants.PRECISION_6; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineDasharray; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineTranslate; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Drag the map to automatically draw a directions route to wherever the map is centered. */ public class DashedLineDirectionsPickerActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnCameraIdleListener { private MapView mapView; private MapboxMap mapboxMap; private FeatureCollection dashedLineDirectionsFeatureCollection; private Point directionsOriginPoint = Point.fromLngLat(24.9383791, 60.1698556); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_place_picker_dashed_directions_route); // Initialize the mapboxMap view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @SuppressWarnings( {""MissingPermission""}) @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { DashedLineDirectionsPickerActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Add a marker on the map's center/""target"" for the place picker UI ImageView hoveringMarker = new ImageView(DashedLineDirectionsPickerActivity.this); hoveringMarker.setImageResource(R.drawable.red_marker); FrameLayout.LayoutParams params = new FrameLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.CENTER); hoveringMarker.setLayoutParams(params); mapView.addView(hoveringMarker); // Add the layer for the dashed directions route line initDottedLineSourceAndLayer(style); // Add the camera idle listener mapboxMap.addOnCameraIdleListener(DashedLineDirectionsPickerActivity.this); Toast.makeText( DashedLineDirectionsPickerActivity.this, getString(R.string.move_map_around_instruction), Toast.LENGTH_LONG ).show(); } }); } @Override public void onCameraIdle() { if (mapboxMap != null) { Point destinationPoint = Point.fromLngLat( mapboxMap.getCameraPosition().target.getLongitude(), mapboxMap.getCameraPosition().target.getLatitude()); getRoute(destinationPoint); } } /** * Set up a GeoJsonSource and LineLayer in order to show the directions route from the device location * to the place picker location */ private void initDottedLineSourceAndLayer(@NonNull Style loadedMapStyle) { dashedLineDirectionsFeatureCollection = FeatureCollection.fromFeatures(new Feature[] {}); loadedMapStyle.addSource(new GeoJsonSource(""SOURCE_ID"", dashedLineDirectionsFeatureCollection)); loadedMapStyle.addLayerBelow( new LineLayer( ""DIRECTIONS_LAYER_ID"", ""SOURCE_ID"").withProperties( lineWidth(4.5f), lineColor(Color.BLACK), lineTranslate(new Float[] {0f, 4f}), lineDasharray(new Float[] {1.2f, 1.2f}) ), ""road-label-small""); } /** * Make a call to the Mapbox Directions API to get the route from the device location to the * place picker location * * @param destination the location chosen by moving the map to the desired destination location */ @SuppressWarnings( {""MissingPermission""}) private void getRoute(Point destination) { MapboxDirections client = MapboxDirections.builder() .origin(directionsOriginPoint) .destination(destination) .overview(DirectionsCriteria.OVERVIEW_FULL) .profile(DirectionsCriteria.PROFILE_WALKING) .accessToken(getString(R.string.access_token)) .build(); client.enqueueCall(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { if (response.body() == null) { Timber.d( ""No routes found, make sure you set the right user and access token.""); return; } else if (response.body().routes().size() < 1) { Timber.d( ""No routes found""); return; } drawNavigationPolylineRoute(response.body().routes().get(0)); } @Override public void onFailure(Call<DirectionsResponse> call, Throwable throwable) { Timber.d(""Error: %s"", throwable.getMessage()); if (!throwable.getMessage().equals(""Coordinate is invalid: 0,0"")) { Toast.makeText(DashedLineDirectionsPickerActivity.this, ""Error: "" + throwable.getMessage(), Toast.LENGTH_SHORT).show(); } } }); } /** * Update the GeoJson data that's part of the LineLayer. * * @param route The route to be drawn in the map's LineLayer that was set up above. */ private void drawNavigationPolylineRoute(final DirectionsRoute route) { if (mapboxMap != null) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { List<Feature> directionsRouteFeatureList = new ArrayList<>(); LineString lineString = LineString.fromPolyline(route.geometry(), PRECISION_6); List<Point> coordinates = lineString.coordinates(); for (int i = 0; i < coordinates.size(); i++) { directionsRouteFeatureList.add(Feature.fromGeometry(LineString.fromLngLats(coordinates))); } dashedLineDirectionsFeatureCollection = FeatureCollection.fromFeatures(directionsRouteFeatureList); GeoJsonSource source = style.getSourceAs(""SOURCE_ID""); if (source != null) { source.setGeoJson(dashedLineDirectionsFeatureCollection); } } }); } } @Override @SuppressWarnings( {""MissingPermission""}) protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Directions to selected location,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,zoom extent,The zoom extent is the range of zoom levels at which a tileset is visible.,https://docs.mapbox.com/help/glossary/zoom-extent/,glossary,,,"zoom extent The zoom extent is the range of zoom levels at which a tileset is visible. You can see the zoom extent of a tileset by selecting a tileset from the Tilesets page. When a tileset is created in Mapbox Studio, a zoom extent is assigned to limit its visibility and make sure map data renders efficiently. By only rendering tilesets at certain zoom levels, lower-resolution data won't appear at higher zoom levels, and detailed data won't clutter the map at lower zoom levels. If you wish to change the zoom extent of a tileset, you can do so with other Mapbox tools. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,zoom extent,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Show drawn polygon area,Use mapbox-gl-draw to draw a polygon and Turf.js to calculate its area in square meters.,https://docs.mapbox.com/mapbox-gl-js/example/mapbox-gl-draw/,example,JavaScript,,Show drawn polygon area Use mapbox-gl-draw to draw a polygon and Turf.js to calculate its area in square meters. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Show drawn polygon area,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Fit camera in bounding box,Position the camera so that all the given markers are in view.,https://docs.mapbox.com/android/maps/examples/fit-camera-in-bounding-box/,example,Java,,"Fit camera in bounding box Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.camera.BoundingBoxCameraActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.431"" mapbox:mapbox_cameraTargetLng=""-120.981"" mapbox:mapbox_cameraZoom=""4""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.camera; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Fit a map to a bounding box */ public class BoundingBoxCameraActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private MapView mapView; private MapboxMap mapboxMap; private static final LatLng locationOne = new LatLng(36.532128, -93.489121); private static final LatLng locationTwo = new LatLng(25.837058, -106.646234); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_camera_bounding_box); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { BoundingBoxCameraActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { addMarkerIconsToMap(style); // Toast instructing user to tap on the map to start animation and set bounds Toast.makeText( BoundingBoxCameraActivity.this, getString(R.string.tap_on_map_instruction), Toast.LENGTH_LONG ).show(); mapboxMap.addOnMapClickListener(BoundingBoxCameraActivity.this); } }); } private void addMarkerIconsToMap(@NonNull Style loadedMapStyle) { loadedMapStyle.addImage(""icon-id"", BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.red_marker))); loadedMapStyle.addSource(new GeoJsonSource(""source-id"", FeatureCollection.fromFeatures(new Feature[] { Feature.fromGeometry(Point.fromLngLat(locationOne.getLongitude(), locationOne.getLatitude())), Feature.fromGeometry(Point.fromLngLat(locationTwo.getLongitude(), locationTwo.getLatitude())), }))); loadedMapStyle.addLayer(new SymbolLayer(""layer-id"", ""source-id"").withProperties( iconImage(""icon-id""), iconOffset(new Float[]{0f,-8f}) )); } @Override public boolean onMapClick(@NonNull LatLng point) { LatLngBounds latLngBounds = new LatLngBounds.Builder() .include(locationOne) // Northeast .include(locationTwo) // Southwest .build(); mapboxMap.easeCamera(CameraUpdateFactory.newLatLngBounds(latLngBounds, 50), 5000); return true; } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Fit camera in bounding box,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Show changes over time with Mapbox GL JS,Build a map application with Mapbox GL JS to visualize changes in data over time.,https://docs.mapbox.com/help/tutorials/show-changes-over-time/,tutorial,JavaScript,,"advanced JavaScript Show changes over time with Mapbox GL JS Prerequisite Familiarity with front-end development concepts. Some advanced JavaScript required. Property functions vs. property expressions This tutorial uses property expressions. This new feature was introduced in Mapbox GL JS v0.41.0. Property expressions can help you achieve similar effects as property functions, but with much more flexibility and functionality. While property functions are available, they will ultimately be deprecated and replaced by property expressions. Read more about property expressions in the Mapbox Style Specification and in the Get started with Mapbox GL JS expressions guide. This tutorial will show how to build a map that shows data change over time using Mapbox GL JS. The source data you'll be working with in this guide is from NYC OpenData and contains more than 15,000 motor vehicle collisions in New York City that occurred in January 2016. If you're new to Mapbox GL JS you might want to read Mapbox GL JS fundamentals first. Get started There are a few resources you'll need before getting started: An access token from your Mapbox account. The access token is used to associate a map with your account and you can find it on your Account page. Data. This GeoJSON file contains 15,273 geocoded motor vehicle collision incidents from January 2016, pulled from NYC OpenData. Download data A text editor for writing HTML, CSS, and JavaScript. Add a map Before you start adding your NYC collision data, you need to create a map to put it on. Start by creating an HTML file and then initialize the map object on the page. This guide will require several files, so we recommend creating a project folder on your computer to keep them together. Create an HTML file In your project folder, create an index.html file. Set up the document by adding Mapbox GL JS and CSS to your head. <meta charset='utf-8' /> <title>NYC motor vehicle collisions</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> Next, create a map container and a container for your legend and data interactivity elements in body. <div id='map'></div> <div id='console'> <h1>Motor vehicle collisions</h1> <p>Data: <a href='https://data.cityofnewyork.us/Public-Safety/NYPD-Motor-Vehicle-Collisions/h9gi-nx95'>Motor vehicle collision injuries and deaths</a> in NYC, Jan 2016</p> </div> Apply some CSS to create the page layout. Create a pair of style tags at the end of your head, then add: body { margin: 0; padding: 0; font-family: 'Helvetica Neue', Helvetica, Arial, Sans-serif; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } h1 { font-size: 20px; line-height: 30px; } h2 { font-size: 14px; line-height: 20px; margin-bottom: 10px; } a { text-decoration: none; color: #2dc4b2; } #console { position: absolute; width: 240px; margin: 10px; padding: 10px 20px; background-color: white; } Initialize the map Once you have the structure done, you can initialize the map with Mapbox GL JS. Insert a pair of script tags at the end of body — you will write all the following code (JavaScript) between these tags. Start by creating a new map object using new mapboxgl.Map() and store it in a variable called map. mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // container element id style: 'mapbox://styles/mapbox/light-v 10 ', center: [-74.0059, 40.7128], // initial map center in [lon, lat] zoom: 12 } ); If you load the page, it should look like this: Load your data Once you get the page structure and map done and onto the page, it's time to load in your data, get it styled, and add a legend. Fortunately, Mapbox GL JS has some handy functions that can help! First, make sure that the collisions1601.geojson file you downloaded is in your project folder. Add a layer To add data to your map using Mapbox GL JS, you will need to add a layer that includes a source. In this example, you will use the GeoJSON file you downloaded above as your source. Note Be sure to save and store the GeoJSON file in the same domain as your project. You will also need to run this application from a local web server, otherwise you will receive a Cross-origin Resource Sharing (CORS) error. Python's SimpleHTTPServer is included on many computers and is a good choice if this is your first time running a local server. In this example, you'll use expressions to set the style of the points based on a property in the data. This kind of data-driven styling allows you to add an extra dimension to you map visualization, helping convey a particular insight or message to your readers. In this case, you can make the map more informative by applying styles based on the Casualty property in the data, which is the total number of people injured or killed in the collision. The code below changes both the size and color of the points based on the Casualty field. Both of the expressions used below are 'interpolate' expressions. This kind of expression interpolates continuously between pairs of input and output values. In this instance, 'linear' interpolation can be used for circle-radius and circle-color to make sure that interpolation occurs smoothly and linearly between the pairs of stops. Also, note the map.on('load', function() { } ) code below — this tells your browser to wait until the map is finished loading before trying to add new things to it. Any code that adds layers should be inside of this callback function. map.on('load', function() { map.addLayer( { id: 'collisions', type: 'circle', source: { type: 'geojson', data: './collisions1601.geojson' // replace this with the url of your own geojson } , paint: { 'circle-radius': [ 'interpolate', ['linear'], ['number', ['get', 'Casualty']], 0, 4, 5, 24 ], 'circle-color': [ 'interpolate', ['linear'], ['number', ['get', 'Casualty']], 0, '#2DC4B2', 1, '#3BB3C3', 2, '#669EC4', 3, '#8B88B6', 4, '#A2719B', 5, '#AA5E79' ], 'circle-opacity': 0.8 } } ); } ); Create a legend To describe the data you added, create a legend to communicate what each color and size means. Begin by creating a new div with class session inside the console div you added earlier. <div class='session'> <h2>Casualty</h2> <div class='row colors'> </div> <div class='row labels'> <div class='label'>0</div> <div class='label'>1</div> <div class='label'>2</div> <div class='label'>3</div> <div class='label'>4</div> <div class='label'>5+</div> </div> </div> Next, apply some CSS to define how the new session class should be styled. Create a color gradient using the same colors as the stops of the circle-color values you defined in your layer. This should go inside the style tags you added earlier. .session { margin-bottom: 20px; } .row { height: 12px; width: 100%; } .colors { background: linear-gradient(to right, #2dc4b2, #3bb3c3, #669ec4, #8b88b6, #a2719b, #aa5e79); margin-bottom: 5px; } .label { width: 15%; display: inline-block; text-align: center; } After adding the CSS and refreshing your browser, you should see the following: Add a time slider With the data symbolized by casualty, your map is already telling a compelling story. To make it more compelling, you can add a time slider to allow your readers to filter the collision data by time of day. Add a map filter Besides providing the value of a paint or layout property, you can use expressions as filters. By adding a == expression as a filter with the structure ""filter"": ['==', ['type',['get', 'key']],'value'], you can single out all features where the 'key' is equal to the 'value' of the specified type. Add the following code to the end of the addLayer() options you wrote earlier: filter: ['==', ['number', ['get', 'Hour']], 12] Refresh the map. You should see a lot fewer collisions! Create a slider bar You don't only want to show collisions that happened at noon, though — you want the user to be able to control what hour of the day the map shows. To do this, you can add a time slider in the console div by adding a new session div after legend. There are 24 hours in a day labeled by the integers 0-23 in the dataset, so you'll set the input's min and max attributes to 0 and 23, respectively, and the initial value to 12, or 12PM. Add the following code below the other session div you added in a previous step: <div class='session' id='sliderbar'> <h2>Hour: <label id='active-hour'>12PM</label></h2> <input id='slider' class='row' type='range' min='0' max='23' step='1' value='12' /> </div> Add interactivity Now, add some code to connect the slider with the map. Begin by adding an event listener to the slider called onInput, which listens for any change in the slider's value. Next, use Mapbox GL JS's setFilter(layer, filter) method to change your layer's filter property whenever the input event fires. Finally, add a bit of math to add PM or AM to the time displayed next to your slider. Add this right after addLayer() in your script: document.getElementById('slider').addEventListener('input', function(e) { var hour = parseInt(e.target.value); // update the map map.setFilter('collisions', ['==', ['number', ['get', 'Hour']], hour]); // converting 0-23 hour to AMPM format var ampm = hour >= 12 ? 'PM' : 'AM'; var hour12 = hour % 12 ? hour % 12 : 12; // update text in the UI document.getElementById('active-hour').innerText = hour12 + ampm; } ); Here's what it will look like: Filter by day of the week Another useful metric for gathering insights about collisions in NYC is the day of the week when accidents occur. With the following code, you can add radio buttons that filter on days of the week. Create a radio button group First, add the following radio button group in your HTML inside the console div. <div class='session'> <h2>Day of the week</h2> <div class='row' id='filters'> <input id='all' type='radio' name='toggle' value='all' checked='checked'> <label for='all'>All</label> <input id='weekday' type='radio' name='toggle' value='weekday'> <label for='weekday'>Weekday</label> <input id='weekend' type='radio' name='toggle' value='weekend'> <label for='weekend'>Weekend</label> </div> </div> Add interactivity Create a new change event listener in your code, like you did for the slider, then place it after the slider event. To show collisions on all days, use a != expression that filters for the 'placeholder' value. This filter is added so that filterDay never evaluates to null. It will become clearer why this is necessary by the end of the tutorial. To filter for weekday and weekend values, use a match expression. Match expressions allow you to specify input and output values. The pattern that the expression below follows is: ['match', ['get', property], inputValue, outputValue if match, outputValue if not a match] Add the following code after the slider event you added in the previous step: document.getElementById('filters').addEventListener('change', function(e) { var day = e.target.value; // update the map filter if (day === 'all') { filterDay = ['!=', ['string', ['get', 'Day']], 'placeholder']; } else if (day === 'weekday') { filterDay = ['match', ['get', 'Day'], ['Sat', 'Sun'], false, true]; } else if (day === 'weekend') { filterDay = ['match', ['get', 'Day'], ['Sat', 'Sun'], true, false]; } else { console.log('error'); } map.setFilter('collisions', ['all', filterDay]); } ); Refresh your page and try the week of the day buttons. Combine the filters As you may have discovered, toggling between weekday and weekend will automatically override the hour filter. You can fix this by using a combining filter (documentation). Combining filters To combine multiple filters, you will append them to a new 'all' expression. Using this 'all' expression makes sure that both filters result in true. Add two variables at the beginning of the map load event handler to store the 'hour' and 'day of the week' filters and apply them independently. This way when you want to update one part of the filter, you can update that variable, then apply setFilter(my layer, ['all', filterHour, filterDay]) to reset the filter. First, add two variables at the beginning of the map load event handler you created earlier. This is where the placeholder filter becomes necessary since you cannot have null in a combining filter. var filterHour = ['==', ['number', ['get', 'Hour']], 12]; var filterDay = ['!=', ['string', ['get', 'Day']], 'placeholder']; Then, in addLayer, replace the value of filter with: ['all', filterHour, filterDay]. Next, in the slider onInput event, replace map.setFilter('collisions', ['==', ['number', ['get', 'Hour']], hour]); with this code: filterHour = ['==', ['number', ['get', 'Hour']], hour]; map.setFilter('collisions', ['all', filterHour, filterDay]); Lastly, polish the week of the day onChange event by replacing it with this code: document.getElementById('filters').addEventListener('change', function(e) { var day = e.target.value; if (day === 'all') { // `null` would not work for combining filters filterDay = ['!=', ['string', ['get', 'Day']], 'placeholder']; } /* the rest of the if statement */ map.setFilter('collisions', ['all', filterHour, filterDay]); } ); Finished product You created a map showing NYC collision data from January 2016, complete with data-driven styles, a legend, a time slider, and a day of the week filter. Next steps With this guide, you have the tools to create your own interactive time series data visualizations with Mapbox GL JS. Explore more Mapbox GL JS resources on our Help page and see the full Mapbox GL JS documentation and examples for more inspiration and guidance. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Show changes over time with Mapbox GL JS,Create an HTML file,Initialize the map,Load your data,Add a layer,Create a legend,Add a time slider,Add a map filter,Create a slider bar,Add interactivity,Filter by day of the week,Create a radio button group,Combine the filters,Combining filters,Finished product,Next steps,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,annotation,An annotation is a defined location on a map in the Mapbox Maps SDK for iOS.,https://docs.mapbox.com/help/glossary/annotation/,glossary,,,"annotation Within the Mapbox Maps SDK for iOS, an annotation is a defined location on a map, represented by a custom UIView or UIImage. You can use annotations to represent point data, such as restaurants in a city, bus stops along a route, or earthquake locations. There are multiple ways you can add an annotation to your maps. For more information about adding annotations, see the Adding points to a map guide in the Mapbox Maps SDK for iOS documentation. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,annotation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display a map,Initialize a map in an HTML element with Mapbox GL JS.,https://docs.mapbox.com/mapbox-gl-js/example/simple-map/,example,JavaScript,,Display a map Initialize a map in an HTML element with Mapbox GL JS. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Display a map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Prototype apps with Mapbox in Framer X,Learn how to use the Mapbox component to add a map to a prototype in Framer X.,https://docs.mapbox.com/help/tutorials/mapbox-framer-x/,tutorial,No code,,"beginner No code Prototype apps with Mapbox in Framer X Prerequisite Familiarity with Framer X. The Mapbox component for Framer X allows designers to prototype location-aware products and apps, without needing to write any code. In this tutorial, you will learn how to use the Mapbox component to add a functional, data-rich map to a prototype in Framer X. This prototype will consist of three different frames, each using a different mapping function. The prototype will simulate an app that allows users to search, uses animations to display the search result, and then displays a list of local landmarks. Get started There are a few resources you’ll need before you get started: A Mapbox account and access token. Sign up for a Mapbox account at mapbox.com/signup. Your access tokens are on your Account page. A Framer account. You need to have Framer X installed on your computer. You should also have some familiarity with how to use Framer X. Install the Mapbox component This section assumes that you have a working knowledge of how to navigate and use Framer X. If you need help with Framer X, visit the Framer documentation site. In Framer X, click on the Store icon. Search for Mapbox in the search bar. Select the Mapbox component, then click Install. Use the Mapbox component For the first frame, you will use the Mapbox component to create a map with a functional search bar. Once the Mapbox component has installed, click on the Tools icon. Click the Frame button (or press the F key) to add a new frame to your project. The example in this tutorial uses the Apple iPhone 8 preset size. You can choose any preset frame size you like from the dropdown menus on the right side of the screen, or you can click and drag to create a freestyle frame. Click on the Components icon. There are several component options: Mapbox, SequentialLocationMap, and MarkerMap. Click on the Mapbox component and drag it onto the frame. A new Mapbox map will populate inside the frame. You can resize and position the map within the frame. Add your Mapbox access token The Mapbox component shows a functional map by default, but it also contains a text watermark in the upper left side of the map that says ""Get your access token."" When you add your access token, the text watermark will disappear. Navigate to your Mapbox account page. Click on the clipboard icon next to copy your default public token to copy it. In Framer X, paste this access token in the Access Token field. Press the Enter key on your keyboard to integrate it into the current frame. Next, you will change the map style to a Mapbox designer style. Change the map style The Mapbox component gives you access to several Mapbox core styles by default (Mapbox Light, Mapbox Dark, Mapbox Streets, Mapbox Satellite, and Mapbox Satellite Streets), and you can use these styles even if you do not add your access token. But to access any Mapbox designer styles, or a custom map style of your own creation, you will need to use your Mapbox access token, as described in the last section. To change the map design: In Framer X, click on the Map Style dropdown menu. Click on the LeShine style. The map in the Mapbox component will update to use the LeShine Mapbox designer style. Update the map location The Mapbox component comes with a list of default locations for you to use in your prototypes. You can also add a custom location if you choose. Click the City dropdown menu. Click on ""Washington DC, USA"". The location shown in the map will change to Washington DC. Add the search bar Next, you will add the functional Mapbox search bar to this frame. Click on the Show button next to the Search option. Use the Position dropdown menu to move the bar to the top left side of the map. Use the Offset field to move the search bar down 15 pixels. The Drop Pin option is True by default. In this case, leave the setting as True since you want search results in your prototype to be marked with a pin. To preview this frame, click on the Preview icon on the top right side of the Framer X screen. In the Preview screen, you can type a location into the search bar and select a result. The map will fly to the selected location. Use the SequentialLocationMap component Next, you will create a new frame using the SequentialLocationMap component. In this frame, you will prototype a search results screen that shows changes in pitch, bearing, and zoom. Click the Frame button (or press the F key) to add another iPhone 8 frame to your project. Click on the Components icon and drag the SequentialLocationMap component onto the new frame. Paste your access token in the Access Token field. Press the Enter key on your keyboard to integrate it into the current frame. Click on the Map Style dropdown menu and choose the LeShine style. Set the map location Click on the Code tab to expand it. Click on the dropdown menu next to File and select New File. (If prompted to do so, download Visual Studio Code.) Framer X will open a .tsx file in Visual Studio Code. Delete the contents of this file and paste in the following code: import { Override } from ""framer""; // To control what locations the map looks at, provide an // array of location values. All properties for the locations are optional, // with any unspecified values reverting to the current map's values. // Valid properties are: // latitude, longitude, zoom, bearing, pitch export const CameraMoveSequence: Override = () => { return { locations: [ // set the location to Sydney, Australia { bearing: 0, pitch: 0, zoom: 11, latitude: -33.86729979946806, longitude: 151.209683984967 } , // zoom in to the location { zoom: 13 } , // change the pitch of the map { pitch: 60 } , // change the bearing of the map { bearing: 90 } ] } ; } ; Save the file. If you choose, you can rename the file using Save As, but the file must retain the .tsx extension. In Framer X, click on the dropdown menu next to File and select your new file. Click on the dropdown menu next to Override and select CameraMoveSequence. Set the value of the Autoplay field to True. This will start the animation automatically in Preview mode. To preview this frame, click on the Preview icon on the top right side of the Framer X screen. The preview will show Sydney and will move through the animations that you set up in the .tsx file. Use the MarkerMap component Next, you will create a new frame using the MarkerMap component. In this frame, you will prototype a map that displays several marker locations. Click the Frame button (or press the F key) to add another iPhone 8 frame to your project. Click on the Components icon and drag the MarkerMap component onto the new frame. Paste your access token in the Access Token field. Press the Enter key on your keyboard to integrate it into the current frame. Click on the Map Style dropdown menu and choose the LeShine style. Set the marker locations The MarkerMap component requires a file with valid GeoJSON formatting to set the marker locations. Open Visual Studio Code or the text editor of your choice. Create a new file and name it sydney_attractions.json. Paste the following code into the new file: [ { ""name"": ""Sydney Opera House"", ""location"": { ""longitude"": 151.21507755097377, ""latitude"": -33.85725554523418 } , ""focusLocation"": { ""zoom"": 9 } , ""category"": ""cultural attraction"", ""details"": ""World-famous opera house designed by Jørn Utzon. Opened in 1973."" } , { ""name"": ""Bondi Beach"", ""location"": { ""longitude"": 151.27362005956923, ""latitude"": -33.89084702828488 } , ""focusLocation"": { } , ""category"": ""beach"", ""details"": ""A popular beach located in a Sydney suburb of the same name."" } , { ""name"": ""Darling Harbour"", ""location"": { ""longitude"": 151.20180875882124, ""latitude"": -33.87151653767559 } , ""focusLocation"": { } , ""category"": ""cultural attraction"", ""details"": ""A large recreational and pedestrian precinct situated on the west side of the Sydney central business district."" } , { ""name"": ""Sydney Harbour Bridge"", ""location"": { ""longitude"": 151.21064244901527, ""latitude"": -33.8522736348907 } , ""focusLocation"": { } , ""category"": ""cultural attraction"", ""details"": ""Distinctive bridge between the Sydney central business district and the North Shore. Opened in 1932. "" } , { ""name"": ""Royal Botanical Gardens"", ""location"": { ""longitude"": 151.21602755096444, ""latitude"": -33.86416527202888 } , ""focusLocation"": { } , ""category"": ""cultural attraction"", ""details"": ""The oldest botanical garden in Australia. Opened in 1816."" } ] In Framer X, click the Choose File button next to the Location option. Choose the sydney_attractions.json file. Paste the longitude 151.2356 into the Longitude field. Paste the latitude -33.8682 into the Latitude field. Change the value of Zoom to 11. Click on the Show button next to the Search option. Use the Position dropdown menu to move the bar to the top left side of the map. Use the Offset field to move the search bar down 15 pixels. To preview this frame, click on the Preview icon on the top right side of the Framer X screen. The preview will show Sydney and the markers set at each landmark described in sydney_attractions.json. If you click on a marker in Preview mode, it will display a card for the marker with information from the .json file's name, category, and details properties. Connect the frames Finally, you will connect these three frames together so that they create one prototype. Click the first frame. You will see a purple outline around the frame that shows that it is selected. Click the purple circle on the right side of the frame and drag it so that it connects the first frame to the second. To connect the second and third frames, you will create a button on the second frame. Click the Frame button (or press the F key) to add a new frame on top of the second frame. If you choose, you can adjust the location, size, color, and opacity of the new button using the controls on the right side of the screen. You can also add text to the button, such as ""Show me places to visit!"" Select the button and type the L key to create a link. Drag the link and connect it to the third frame. Finished product You have created a prototype using the Mapbox component for Framer X. When you click the Preview button, you can see your new search app prototype. Type ""Sydney"" into the search bar and select the option ""Sydney, New South Wales, Australia"". The prototype will fly to Sydney and move through the animations you set in the SequentialLocationMap component. Then click on the button, which will pull up the markers that show the map locations you set in the MarkerMap component. Next steps For more tips on how to use Mapbox with Framer X, watch our tutorial videos on the Mapbox component, the SequentialLocationMap component, and the MarkerMap component. For information on how to create your own custom map styles that you can use in Framer X, read the Mapbox Studio Manual. You can also browse the Mapbox style gallery to get inspiration! Want to stay in the loop about what’s coming next in the Mapbox component for Framer X? Sign up on our Framer X component page. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Prototype apps with Mapbox in Framer X,Use the Mapbox component,Add your Mapbox access token,Change the map style,Update the map location,Add the search bar,Use the SequentialLocationMap component,Set the map location,Use the MarkerMap component,Set the marker locations,Connect the frames,Finished product,Next steps,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Adjust light location and color,Change the location and color of the light shined on extrusions.,https://docs.mapbox.com/android/maps/examples/adjust-light-location-and-color/,example,Java,,"Adjust light location and color Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.7135"" mapbox:mapbox_cameraTargetLng=""-74.0066"" mapbox:mapbox_cameraTilt=""45"" mapbox:mapbox_cameraZoom=""16"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/fabLightPosition"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_marginBottom=""82dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" android:src=""@drawable/ic_my_location"" mapbox:backgroundTint=""@color/mapboxPink"" mapbox:layout_anchorGravity=""top""/> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/fabLightColor"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_margin=""16dp"" android:src=""@drawable/ic_paint"" mapbox:backgroundTint=""@color/mapboxBlue""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.extrusions; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.Menu; import android.view.MenuItem; import android.view.View; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillExtrusionLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.light.Light; import com.mapbox.mapboxsdk.style.light.Position; import com.mapbox.mapboxsdk.utils.ColorUtils; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionBase; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionHeight; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionOpacity; /** * Change the location and color of the light that's shined on extrusions */ public class AdjustExtrusionLightActivity extends AppCompatActivity { private MapView mapView; private Light light; private boolean isMapAnchorLight; private boolean isLowIntensityLight; private boolean isRedColor; private boolean isInitPosition; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_extrusion_light); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap map) { map.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { setupBuildings(style); setupLight(style); } }); } }); } private void setupBuildings(@NonNull Style loadedMapStyle) { FillExtrusionLayer fillExtrusionLayer = new FillExtrusionLayer(""3d-buildings"", ""composite""); fillExtrusionLayer.setSourceLayer(""building""); fillExtrusionLayer.setFilter(eq(get(""extrude""), ""true"")); fillExtrusionLayer.setMinZoom(15); fillExtrusionLayer.setProperties( fillExtrusionColor(Color.LTGRAY), fillExtrusionHeight( interpolate( exponential(1f), zoom(), stop(15, literal(0)), stop(16, get(""height"")) ) ), fillExtrusionBase(get(""min_height"")), fillExtrusionOpacity(0.9f) ); loadedMapStyle.addLayer(fillExtrusionLayer); } private void setupLight(@NonNull Style loadedMapStyle) { light = loadedMapStyle.getLight(); findViewById(R.id.fabLightPosition).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { isInitPosition = !isInitPosition; if (isInitPosition) { light.setPosition(new Position(1.5f, 90, 80)); } else { light.setPosition(new Position(1.15f, 210, 30)); } } }); findViewById(R.id.fabLightColor).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { isRedColor = !isRedColor; light.setColor(ColorUtils.colorToRgbaString(isRedColor ? Color.RED : Color.BLUE)); } }); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_building, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { if (light != null) { int id = item.getItemId(); if (id == R.id.menu_action_anchor) { isMapAnchorLight = !isMapAnchorLight; light.setAnchor(isMapAnchorLight ? Property.ANCHOR_MAP : Property.ANCHOR_VIEWPORT); } else if (id == R.id.menu_action_intensity) { isLowIntensityLight = !isLowIntensityLight; light.setIntensity(isLowIntensityLight ? 0.35f : 1.0f); } else if (id == android.R.id.home) { finish(); return true; } } return super.onOptionsItemSelected(item); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Adjust light location and color,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Use images to cluster point data,Color & display clustered point data using images and interval-based property styling.,https://docs.mapbox.com/ios/maps/examples/clustering-with-images/,example,Swift,Objective-C,"Use images to cluster point data Download the point GeoJSON and icon asset catalog and add it to your project. For more information on styling data at runtime, see our Information for style authors guide. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() // Initialize the Map mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.lightStyleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.delegate = self view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { // Define an initial icon to help set source attributes let icon = UIImage(named: ""squircle"")! // Retrieve data and set as source. This associates the data with the map, but style layers are still required to make data visible. let url = URL(fileURLWithPath: Bundle.main.path(forResource: ""ports"", ofType: ""geojson"")!) let source = MGLShapeSource(identifier: ""clusteredPorts"", url: url, options: [.clustered: true, .clusterRadius: icon.size.width]) style.addSource(source) // Show unclustered features as icons. The `cluster` attribute is built into clustering-enabled source features. // This example requires two style layers to work properly: one for clustered points and one for unclustered points let markerLayer = MGLSymbolStyleLayer(identifier: ""ports"", source: source) markerLayer.iconImageName = NSExpression(forConstantValue: ""marker"") markerLayer.predicate = NSPredicate(format: ""cluster != YES"") style.addLayer(markerLayer) style.setImage(UIImage(named: ""marker"")!, forName: ""marker"") // Create style layer to cluster features as images with labels let clusterLayer = MGLSymbolStyleLayer(identifier: ""clusteredPortsNumbers"", source: source) clusterLayer.textColor = NSExpression(forConstantValue: UIColor.white) clusterLayer.textFontSize = NSExpression(forConstantValue: NSNumber(value: Double(icon.size.width) / 2)) clusterLayer.iconAllowsOverlap = NSExpression(forConstantValue: true) // Style image clusters style.setImage(UIImage(named: ""squircle"")!, forName: ""squircle"") style.setImage(UIImage(named: ""circle"")!, forName: ""circle"") style.setImage(UIImage(named: ""rectangle"")!, forName: ""rectangle"") style.setImage(UIImage(named: ""star"")!, forName: ""star"") style.setImage(UIImage(named: ""oval"")!, forName: ""oval"") let stops = [ 10: NSExpression(forConstantValue: ""circle""), 25: NSExpression(forConstantValue: ""rectangle""), 75: NSExpression(forConstantValue: ""star""), 150: NSExpression(forConstantValue: ""oval"") ] // Use expressions to set each cluster's image based on defined stops and display the point count over the corresponding image let defaultShape = NSExpression(forConstantValue: ""squircle"") clusterLayer.iconImageName = NSExpression(format: ""mgl_step:from:stops:(point_count, %@, %@)"", defaultShape, stops) clusterLayer.text = NSExpression(format: ""CAST(point_count, 'NSString')"") style.addLayer(clusterLayer) } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Use images to cluster point data,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Interacting with the map,An overview of individual gestures in the Mapbox Maps SDK for iOS.,https://docs.mapbox.com/ios/maps/overview/interacting-with-the-map/,guide,,,"Interacting with the map Gesture Description Related property Pinch Zooms in or out on the map's anchor point zoomEnabled Rotation Changes the MGLMapView direction based on the user rotating two fingers in a circular motion rotateEnabled Single tap Selects/deselects the annotation that you tap. Double tap Zooms in on the map's anchor point zoomEnabled Two-finger tap Zooms out with the map's anchor point centered zoomEnabled Pan Scrolls across mapView (note: if MGLUserTrackingModeFollow is being used, it will be disabled once the user pans) scrollEnabled Two-finger drag Adjusts the pitch of the MGLMapView pitchEnabled One-finger zoom Tap twice; on second tap, hold your finger on the map and pan up to zoom in, or down to zoom out zoomEnabled Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Interacting with the map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Interactive tools,Experiment with Mapbox tools.,https://docs.mapbox.com/help/interactive-tools/,,,,"Interactive tools Experiment with Mapbox tools. Data Tilequery API playground Retrieve features from vector tiles with the Mapbox Tilequery API. Mobile apps Marker playground Add a marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, React Native, or web application. Mapbox offline tile count estimator Estimate the number of tiles required to download an offline region using the Mapbox Maps SDK for Android and iOS. Print Mapbox Static Images API playground Generate an image of a map using the Mapbox Static Images API. Specify the map style, coordinates, zoom level, image size, and more. Web apps Mapbox GL JS usage playground Interact with a Mapbox GL JS map to understand the relationship between billing units including map loads, map views, and tile requests. Marker playground Add a marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, React Native, or web application.",,5c6adb81d3b68758d0c5c15a,Data,Web apps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Geographic Analytics,Data flow and Visualization details,How the extension works under the hood.,https://docs.mapbox.com/geographic-analytics/overview/visualization/,guide,,,"Data flow and Visualization details The Geographic Analytics Extension provides many visualizations. Each visualization style listed below is one of the drop-down options found in the Configure Map Appearance menu. This section will explain how the extension processes data and uses that data to create visualizations. Data flow The Geographic Analytics Extension works by tapping into the data that powers your Tableau worksheets. This data is temporarily cached for downstream processing, but is overwritten on a new selection or a visualization update. Once connected, it utilizes a library called Turf to calculate the bounding box of the selected data. This is recalculated on every worksheet interaction, which is how it produces the zoom-to-selection function. Visualization Types Clustering Clustering is the default visualization. This works by passing the data into Mapbox GL and requesting a style-type of cluster. This cluster is powered by a library called Supercluster that figures out how close points are to each other within a certain radius and then creates a single point (the cluster) out of those points. The more points, the larger the cluster. This is computed for all points as you move around the map. As you zoom in, the clusters disassemble into their constituent points. You can read more about Supercluster on the Mapbox blog and on the Supercluster GitHub repository. Grids Grids are calculated using a Turf method called hexGrid and squareGrid. This takes the bounding box of the data (collected when the Geographic Analytics Extension connects to the Worksheet) and a distance setting (in miles or kilometers), and outputs a grid covering that area. The extension then uses a secondary method called collection. This takes the grids that it generates and compares it to the points from the worksheet. Once the extension has collected the points that are within each cell, it then computes the Measures and assigns them to each cell. Grids can also be extruded, which takes the value that is assigned to the color and moves the grid into 3D. This is where the Extrusion Height is used, as you can adjust the minimum height so that your data is visible and variance between cells can be observed. To trigger extrusion, click the Awesome button. To reset, click the Reset button. Voronoi Voronoi are calculated like Grids - they take in data and pass it through a Turf method called voronoi. Since each Voronoi cell contains one data point - there is no collection, color is the selected measure assigned to that point. Data elevation Data elevation, in GIS terms, is an isoband. Isobands are traditionally used to show changes in data, typically elevation, in two dimensions. They are computed from a grid that expresses how data changes over space which then generates rings that show a specific value and rate of change. The closer the rings, the faster the rate of change; the further, the slower. This is an intensive calculation that may cause the extension to hang or become unresponsive, depending on your settings. Creating an isoband is a two step process. First, the extension will take the data from the worksheet and process it using a Turf method called interpolate. This takes the points from the worksheet and snaps them to a grid of width X, which is the width you established in the configuration screen. This process will interpolate the change in your selected measure via a process called inverse distance weighting. Remember: Before creating a data elevation, consider the fact that all computations are happening within a browser. The tighter the grid, the longer it will take to process. The method has to do the interpolation and then snap points to the grid, which can be intensive if the grid is too tight over too large a geographic area. Second, the grid must be processed into bands representing areas of change and when breaks are exceeded. This is performed by a Turf method called isobands. It takes the grid from the first step and then finds the breaks in the data where changes occur. These steps are controlled by your Classification method and the number of breaks you select. For example: if your data range is 0-100, and you have four equidistant breaks, you will see three lines that show where you cross 25, 50, and 75 (calculated from the interpolated grid). Before choosing Data Elevation, you may want to switch to a Square or Hex grid to see how tightly packed your grid might be. Once you have found a grid that works, experiment with your breaks. Once you have completed both of those steps, switch to Data Elevation and it should do well. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Data flow and Visualization details,Clustering,Grids,Voronoi,Data elevation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Examples,Examples for Mapbox Studio.,https://docs.mapbox.com/studio-manual/examples/,,,,Map design Add 3D buildings Use a fill extrusion layer to add 3D buildings to a map in Mapbox Studio. Apply conditional labels Check if a data property exists and if it does not display a different label. Add a custom icon Upload an SVG and add it to the map as a custom icon. Add a hillshade layer Add a raster-dem source as a hillshade layer for detailed slope and shading. Data visualization Create a choropleth map Add a fill layer and use expressions to style a choropleth map. Convert units Use a formula to convert elevation values from meters to feet. Style a heatmap layer Add and style a heatmap layer.,,5c6adb81d3b68758d0c5c15a,Map design,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Variable label placement,Use text-variable-anchor to allow high priority labels to shift position to stay on the map.,https://docs.mapbox.com/mapbox-gl-js/example/variable-label-placement/,example,JavaScript,,Variable label placement Use text-variable-anchor to allow high priority labels to shift position to stay on the map. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Variable label placement,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Location-based game,An overview of the location-based game example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/location-based-game/,example,No code,,"Location-based game The location-based game example shows how to position and orient a Player GameObject on a map using a GPS device or using the editor directly. The scene set a pin on a 2D map that includes building outline data and other procedurally generated geo features from Mapbox’s data that you can toggle and style as needed. This example uses a custom map style from Mapbox Studio, but it can be swapped with any other map style. Add a Player The Player GameObject is a 3D model representing the player’s location on the map. Player moves and rotates along with LocationProvider, a GameObject that captures real or simulated location. Any GameObject can represent the player in this scene. To use a different 3D model: Remove the original Player object, add the new model into the scene, and position it at 0,0,0. Add the Immediate Position With Location Provider and Rotate With Location Provider components to this GameObject. Attach the Map object to the Map field in Immediate Position With Location Provider. The custom Player will show up on the map and move accordingly. Understand the LocationProvider script The LocationProvider GameObject holds a collection of scripts to determine a player’s location, either in the real world (with GPS, on a device) or simulated in Unity (with manually added coordinates). Without these scripts, the location would be hard-coded in the AbstractMap script. There are several different Location Provider scripts: DeviceLocationProvider: Uses GPS data on a device. The Player GameObject follows the location on the map reported by the GPS device update. EditorLocationProvider: Similar to DeviceLocationProvider, but for testing inside Unity. LocationArrayEditorLocationProvider: Allows the Player GameObject to be moved across a set of points entered as latitude, longitude coordinates in an array. TransformLocationProvider: Makes the Player GameObject follow the position and rotation of another GameObject. DeviceLocationProviderAndroidNative: Uses GPS data optimized for Android devices. Benefits and limitations With the Location Based Game example, you can create a zoomable, pannable map that a Player can move around. Use it to look at real world map data from a top-down view, like a paper map. But, it is not ideal for building 3D scenes with a more flexible camera view. This is like the Zoomable Map example, which acts similarly to Location Based Game, but does not have a Player GameObject. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Location-based game,Benefits and limitations,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Introduction,"Introduction to Mapbox GL JS, a JavaScript library that uses WebGL to render interactive maps from vector tiles and Mapbox styles.",https://docs.mapbox.com/mapbox-gl-js/overview/,API,,,"Mapbox GL JS Current version: v 1.2.1 View changelog Custom map styles Fast vector maps Compatible with other Mapbox tools Install Contribute on GitHub Mapbox GL JS is a JavaScript library that uses WebGL to render interactive maps from vector tiles and Mapbox styles. It is part of the Mapbox GL ecosystem, which includes Mapbox Mobile, a compatible renderer written in C++ with bindings for desktop and mobile platforms. Quickstart To get started, you need an access token and a style URL. You can choose from one of our professionally designed styles or create your own using Mapbox Studio. Mapbox CDN Module bundler Include the JavaScript and CSS files in the <head> of your HTML file. <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl.css' rel='stylesheet' /> Copy Include the following code in the <body> of your HTML file. <div id='map' style='width: 400px; height: 300px;'></div> <script> mapboxgl.accessToken = 'undefined'; var map = new mapboxgl.Map({ container: 'map', style: 'mapbox://styles/mapbox/streets-v9' }); </script> Copy CSP Directives As a mitigation for Cross-Site Scripting and other types of web security vulnerabilities, you may use a Content Security Policy (CSP) to specify security policies for your website. If you do, Mapbox GL JS requires the following CSP directives: worker-src blob: ; child-src blob: ; img-src data: blob: ; Requesting styles from Mapbox or other services will require additional directives. For Mapbox, you can use this connect-src directive: connect-src https://*.tiles.mapbox.com https://api.mapbox.com https://events.mapbox.com For strict CSP environments without worker-src blob: ; child-src blob: enabled, there's a separate Mapbox GL JS bundle (mapbox-gl-csp.js and mapbox-gl-csp-worker.js) which requires setting the path to the worker manually: <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl-csp.js'></script> <script> mapboxgl.workerUrl = ""https://api.tiles.mapbox.com/mapbox-gl-js/v1.2.1/mapbox-gl-csp-worker.js""; ... </script> Copy Mapbox CSS The CSS referenced in the Quickstart is used to style DOM elements created by Mapbox code. Without the CSS, elements like Popups and Markers won't work. Including it with a <link> in the head of the document via the Mapbox CDN is the simplest and easiest way to provide the CSS, but it is also bundled in the Mapbox module, meaning that if you have a bundler that can handle CSS, you can import the CSS from mapbox-gl/dist/mapbox-gl.css. Note too that if the CSS isn't available by the first render, as soon as the CSS is provided, the DOM elements that depend on this CSS should recover. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Mapbox GL JS,Mapbox CSS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Traffic Data,Data format,Learn how data from Mapbox Traffic Data is formatted.,https://docs.mapbox.com/traffic-data/overview/data/,guide,,,"Data format Mapbox Traffic Data consists of two different types of files: Typical: The Typical traffic data file contains speeds that show normal traffic conditions throughout the week. The Typical traffic data set is an estimate for traffic speeds at a specific location, at a specific time, based on historical observations. This data shows traffic expectations during a normal week. Live: The Live traffic data file contains speeds that have been directly observed in the 15 minutes prior to data generation. The Live traffic data set is most useful in the event of unexpected traffic — for instance, during severe weather events or accidents. Speeds are associated with either pairs of adjacent OpenStreetMap node IDs or OpenLR strings, depending on customer preference. Each pair of OpenStreetMap IDs marks the start and end of the road segment. OpenLR strings are base64-encoded binary representations of the OpenLR location reference for the road segment, which usually only includes the location reference points at the start and end of the way. Intermediate location reference points are included for roads longer than 15km. All speeds are given in kilometers per hour. Quadkeys Data is stored in files specific to a Zoom 7 quadkey, as described in the OpenStreetMap zoom levels specification. Each Zoom 7 tile is large enough to capture a major metropolitan area, small US state, or small European country. You can view tiles using the What the Tile interactive tool. Data updates Mapbox Traffic Data files are updated on a regular cadence: Typical traffic is updated weekly. Each week, you should overwrite the results of the previous week with the new data. Live traffic is updated every five minutes, based on data that is less than 15 minutes old. Typical data file Typical predictions are stored for every five-minute period of a typical week. For every road segment, there will be 2,016 typical speed predictions (7 days × 24 hours × 12 five-minute periods). Typical file S3 naming schema Typical speed data is stored as gzipped CSV files, divided into separate files by Z7 quadkey and time zone using the following naming schema: s3://<bucket_name>/typical-speeds/<Z7_quadkey>/<time_zone>/<Z7_quadkey>-<time_zone>.csv.gz For example, if your company username was ABC, and you were using Typical traffic data for the New York area, the filename would be: s3://mapbox-traffic-data-abc-shared/typical-speeds/0320101/America-New_York/0320101-America-New_York.csv.gz The time_zone for each file is defined by the IANA time zone database. Note that the slashes (/) used by IANA are replaced with dashes (-) in Traffic Data filenames. In the example filename above, the IANA timezone America/New_York becomes America-New_York. Typical file contents In their uncompressed form, each CSV file contains one line per road segment:segment_identifier,speed_1,speed_2,…,speed_2016 segment_identifier: Either a comma-separated pair of OpenStreetMap node IDs or an OpenLR string. speed_1,speed_2,…,speed_2016: 2,016 comma-separated integer speeds in kilometers per hour, starting at 0:00 Sunday in the file’s time zone. Each value shows the usual speed during a five-minute period of a typical week within that road segment. The following example uses OpenStreetMap node IDs as segment identifiers: osm_start_node osm_end_node speed_1 speed_2 ... speed_2016 113054533 113096757 54 54 ... 57 170190194 170190194 93 93 ... 98 172637811 172637810 70 64 ... 66 Alternatively, the files with OpenLR segment identifiers will have a single column for the OpenLR string instead of the osm_start_node and osm_end_node columns. The headers in this example are for demonstration purposes. The Typical files that you download will not have headers. Find a specific time in the Typical file To find a speed for a specific five-minute increment, you must count the segment identifier columns and the number of five-minute increments between Sunday at 00:00 and the time for which you are looking. For example, if you were looking for the typical speed for a segment between 9:00 and 9:05 AM on Monday in a file with OpenStreetMap nodes, you would add the two columns for the nodes and the 396 five-minute intervals between Sunday at 0:00 AM and Monday at 9:00 AM, leading you to took at the 399th column for this data. Data considerations for the Typical file Not all segments in a tile have an estimated speed. Segments without enough data for an accurate prediction are omitted. Segments that overlap a time zone boundary or Z7 tile boundary may appear in two files. Speed estimates correspond only to the traffic that matches the ordering of the segment identifier. Node pairs that carry bidirectional traffic will have up to two different rows in each file, each row corresponding to the ordering of the node pair. For example, if you have a two-way road with a segment between nodes ""123"" and ""456"", the estimates may be different when traveling from ""123"" to ""456"" than they are when traveling from ""456"" to ""123"". Typical file size The compressed file size varies depending on the density of the area covered by the tile. A dense urban tile can be approximately 2 GB. Most tiles are much smaller than this. Live data file Live traffic speeds are generated in real time based on speeds that have been directly observed in the 15 minutes prior to data generation. The Live traffic data file is updated every five minutes. Since Live data is not available for all roads, we recommend falling back to Typical speeds when Live data is not available. Offline routing, planning, and simulation should only use Typical speeds. Live file S3 naming schema Live traffic data files are delivered to a shared S3 as one file per Z7 quadkey. s3://<bucket_name>/live-speeds/latest/<Z7_quadkey>.csv Live file contents We deliver our most recent Live traffic estimates for a Z7 quadkey as an uncompressed CSV file. The Live CSV file contains one line per road segment, each with two or three columns. Each line contains:segment_identifier,speed segment_identifier: Either a comma-separated pair of OpenStreetMap node IDs or an OpenLR string. speed: The estimated road segment speed, in kilometers per hour. The following example uses OpenStreetMap node IDs as segment identifiers: osm_start_node osm_end_node speed 113054533 113096757 54 170190194 4525170049 93 172637810 172637809 70 Alternatively, the files with OpenLR segment identifiers will have a single column for the OpenLR string instead of the osm_start_node and osm_end_node columns. The headers in this example are for demonstration purposes. The Live file that you download will not have headers. Data considerations for the Live file The Live file only provides speeds for segments for which the volume and quality of data allow a high confidence estimate. Segments that overlap a time zone boundary or Z7 tile boundary may appear in two files. Speed estimates correspond only to the traffic that matches the ordering of the segment identifier. Node pairs that carry bidirectional traffic will have up to two different rows in each file, each row corresponding to the ordering of the node pair. For example, if you have a two-way road with a segment between nodes ""123"" and ""456"", the estimates may be different when traveling from ""123"" to ""456"" than they are when traveling from ""456"" to ""123"". Live file size The CSV file size for Live data is 5 MB per tile on average, which covers only roads with live traffic estimates. The file size will vary based on how populous a tile is, as well as the time of day. For example, the file for New York City's tile during rush hour could be 12 to 15 MB. An empty file indicates that Mapbox telemetry volumes are too low to estimate a speed for any road segment in the region at the current time. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Data format,Typical data file,Typical file S3 naming schema,Typical file contents,Find a specific time in the Typical file,Data considerations for the Typical file,Typical file size,Live data file,Live file S3 naming schema,Live file contents,Data considerations for the Live file,Live file size,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,API,Accounts service,Overview of the Mapbox Accounts service APIs.,https://docs.mapbox.com/api/accounts/,API,,,"Accounts service The Mapbox Accounts service is composed of the following APIs: Tokens An access token provides access to Mapbox resources on behalf of a user. The Mapbox Tokens API provides you with a programmatic way to create, update, delete, and retrieve tokens, as well as list a user's tokens and token scopes. All user accounts have a default public token. Additional tokens can be created to grant additional, or more limited, privileges. The actions allowed by a token are based on scopes. A scope is a string that often is a resource type and action separated by a colon. For example, the styles:read scope allows read access to styles. Tokens will have access to different scopes depending on their account level and other features of their account. To create additional tokens using the Mapbox Tokens API, you need to have an authorizing token that has the tokens:write scope, as well as all the scopes you want to add to the newly created token. To create the authorization token, visit your Account Dashboard, and click Create a token. Token format Mapbox uses JSON Web Tokens (JWT) as the token format. Each token is a string delimited by dots into three parts: header, payload, and signature. Header. A literal value of either pk (public token), sk (secret token), or tk (temporary token). Payload. A base64-encoded JSON object containing the identity and authorities of the token. pk and sk tokens contain a reference to metadata that holds the rights granted for the token. tk tokens contain the contents of the metadata directly in the payload. Signature. Signed by Mapbox and used to verify the token has not been tampered with. Token metadata object Every token has a metadata object that contains information about the capabilities of the token. The token metadata object contains the following properties: Property Description id The token's unique identifier. usage The type of token. One of: pk (public), sk (secret), or tk (temporary). client The client for the token. This is always api. default Indicates whether the token is a default token. scopes An array that contains the scopes granted to the token. note A human-readable description of the token. created The date and time the token was created. modified The date and time the token was last modified. allowedUrls An array that contains the URLs that the token is restricted to. token The token itself. Example token metadata object { ""id"": ""cijucimbe000brbkt48d0dhcx"", ""usage"": ""pk"", ""client"": ""api"", ""default"": false, ""note"": ""My website"", ""scopes"": [""styles:read"", ""fonts:read""], ""created"": ""2018-01-25T19:07:07.621Z"", ""modified"": ""2018-01-26T00:39:57.941Z"", ""allowedUrls"": [""https://docs.mapbox.com""], ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" } Support for allowed URLs The allowed URLs feature is compatible with many Mapbox tools, with some limitations. For web applications using Mapbox GL JS, it requires version 0.53.1+. It is not compatible with Mapbox native SDKs. Adding a URL restriction to a token makes it unusable by a mobile application. A separate token should be maintained for mobile applications. See the Adding URL restrictions to access tokens guide to learn more about this feature for web requests. List tokens get /tokens/v2/{username} tokens:read token scope List all the tokens that belong to an account. This endpoint supports pagination. Required parameter Description username The username of the account for which to list tokens. You can further refine the results from this endpoint with the following optional parameters: Optional parameters Description default If this parameter is set to true, the response will only include the account's default token. If this parameter is set to false, the response will include all of the account's tokens except for the default token. limit The maximum number of tokens to return. sortby Sort the tokens in the response by their created or modified timestamps. start The token after which to start the listing. The token key is found in the Link header of a response. See the pagination section for details. usage Use this parameter to return either only public tokens (pk) or secret tokens (sk). By default, this endpoint returns both types of token. Example request: List tokens $ curl ""https://api.mapbox.com/tokens/ v2 / {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:read scope. "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: List tokens The response body will contain all the tokens that belong to the username specified in the query, each containing the properties described in the token metadata object section. If a listed token's usage property is sk, the token property will not be included in the response. Example response: List tokens [ { ""client"": ""api"", ""note"": ""a public token"", ""usage"": ""pk"", ""id"": ""cijucimbe000brbkt48d0dhcx"", ""default"": false, ""scopes"": [""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com"", ""https://account.mapbox.com""], ""created"": ""2016-01-25T19:07:07.621Z"", ""modified"":""2016-01-26T00:39:57.941Z"", ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" }, { ""client"": ""api"", ""note"": ""a secret token"", ""usage"": ""sk"", ""id"": ""juorumy001cutm5r4fl2y1b"", ""default"": false, ""scopes"": [""styles:list""], ""created"": ""2016-01-26T00:50:13.701Z"", ""modified"": ""2016-01-26T00:50:13.701Z"" } ] Create a token post /tokens/v2/{username} tokens:write token scope Creates a new token. Every requested scope must be present in the access token used to allow the request. It is not possible to create a token with access to more scopes than the token that created it. Note that while it is possible to create a token with no scopes, you will not be able to update this token later to include any scopes. Required parameter Description username The username of the account for which to list scopes. The request body must be a JSON object that contains the following properties: Parameter Description note Create a description for the token. scopes Specify the scopes that the new token will have. The authorizing token needs to have the same scopes as, or more scopes than, the new token you are creating. allowedUrls URLs that this token is allowed to work with. Available token scopes The scopes included in the token decide whether the token is public or secret. A public token may only contains public scopes, while a secret token can contain both public and secret scopes. Public tokens: styles:tiles, styles:read, fonts:read, datasets:read Secret tokens: scopes:list, map:read, map:write, user:read, user:write, uploads:read, uploads:list, uploads:write, styles:write, styles:list, tokens:read, tokens:write, datasets:list, datasets:write, tilesets:list, tilesets:read, tilesets:write, analytics:read (if user has a Commercial or Enterprise account) Example request: Create a token # Create a public token with ""styles:read"" and ""fonts:read"" scopes and a ""https://docs.mapbox.com"" allowed URL $ curl -H ""Content-Type: application/json"" -X POST -d '{""note"": ""My top secret project"",""scopes"": [""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com""]}' 'https://api.mapbox.com/tokens/ v2 / {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. ' Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Create a token The response body for a successful request will be a new public or secret token. Example response: Create a token { ""client"": ""api"", ""note"": ""My top secret project"", ""usage"": ""pk"", ""id"": ""cijucimbe000brbkt48d0dhcx"", ""default"": false, ""scopes"": [""styles:read"", ""fonts:read""], ""created"": ""2016-01-25T19:07:07.621Z"", ""modified"":""2016-01-25T19:07:07.621Z"", ""allowedUrls"": [""https://docs.mapbox.com""], ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" } Create a temporary token post /tokens/v2/{username} tokens:write token scope Creates a new temporary token that automatically expires at a set time. You can create a temporary token using a secret token that has the tokens:write scope. You can also create a temporary token using another temporary token as long as the authorizing token has tokens:write scope. Temporary tokens can't be updated or revoked after they are created. Required parameter Description username The username of the account for which to create a temporary token. The request body must be a JSON object that contains the following properties: Request body properties Description expires Specify when the temporary token will expire. Cannot be a time in the past or more than one hour in the future. If the authorizing token is temporary, the expires time for the new temporary token cannot be later than that of the authorizing temporary token. scopes Specify the scopes that the new temporary token will have. The authorizing token needs to have the same scopes as, or more scopes than, the new temporary token you are creating. Example request: Create a temporary token # Request a temporary token with ""styles:read"" and ""font:read"" scopes $ curl -H ""Content-Type: application/json"" -X POST -d '{""expires"": "" 2019-08-21T01:28:50.447Z "",""scopes"": [""styles:read"", ""fonts:read""]}' 'https://api.mapbox.com/tokens/ v2 / {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. ' Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Example request body: Create a temporary token { ""expires"": ""2016-09-15T19:27:53.000Z"", ""scopes"": [""styles:read"", ""fonts:read""] } Response: Create a temporary token The response body for a successful request will be a new temporary token. Unlike public and secret tokens, a temporary token contains its metadata inside the payload of the token instead of referencing a metadata object that persists on the server. Example response: Create a temporary token { ""token"": ""tk.eyJ1IjoibWFwYm94IiwiZXhwIjoxNDczOTY3NjczLCJpYXQiOjE0NzM5Njc2NDMsInNjb3BlcyI6WyJzdHlsZXM6cmVhZCIsImZvbnRzOnJlYWQiXSwiY2xpZW50IjoiYXBpIn0.ZepsWvpjTMlpePE4IQBs0g"" } Update a token patch /tokens/v2/{username}/{token_id} tokens:write token scope Update the note, the scopes, the allowedUrls, or all three in a token's metadata. When updating scopes for an existing token, the token sent along with the request must also have the scopes you're requesting. It is not possible to create a token with access to more scopes than the token that updated it. Required parameter Description token_id The ID of the token that you want to update. The request body must be a JSON object that contains one or both of the following properties: Request body properties Description note Update the token's description. scopes Update the token's scopes. The authorizing token needs to have the same scopes as, or more scopes than, the token you are updating. A public token may only be updated to include other public scopes. A secret token may be updated to contain public and secret scopes. allowedUrls Update the restricted token's allowed URLs. Example request: Update a token # Update a token to have ""fonts:read"" scope and a ""https://docs.mapbox.com"" allowed URL $ curl -H 'Content-Type: application/json' -X PATCH -d '{""scopes"": [""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com""]}' 'https://api.mapbox.com/tokens/ v2 / {username} /{token_id}?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. ' Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Update a token The response body for a successful request will be a new temporary token. Example response: Update a token { ""client"": ""api"", ""note"": ""My top secret project"", ""usage"": ""pk"", ""id"": ""cijucimbe000brbkt48d0dhcx"", ""default"": false, ""scopes"": [""styles:tiles"", ""styles:read"", ""fonts:read""], ""allowedUrls"": [""https://docs.mapbox.com""], ""created"": ""2016-01-25T19:07:07.621Z"", ""modified"":""2016-01-25T19:07:07.621Z"", ""token"": ""pk.eyJ1Ijoic2NvdGhpcyIsImEiOiJjaWp1Y2ltYmUwMDBicmJrdDQ4ZDBkaGN4In0.sbihZCZJ56-fsFNKHXF8YQ"" } Delete a token delete /tokens/v2/{username}/{token_id} tokens:write token scope Delete an access token. This will revoke its authorization and remove its access to Mapbox APIs. Applications using the revoked token will need to get a new access token before they can access Mapbox APIs. Note that cached resources may continue to be accessible for a little while after a token is deleted. No new or updated resources will be accessible with the deleted token. Required parameter Description token_id The ID of the token that you want to delete. Example request: Delete a token $ curl -X DELETE ""https://api.mapbox.com/tokens/ v2 / {username} / { token_id } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with tokens:write scope. "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Delete a token HTTP 204 Retrieve a token get /tokens/v2?access_token={access_token} Retrieve an access token and check whether it is valid. If the token is invalid, an explanation is returned as the code property in the response body. Required parameter Description access_token The access token to retrieve. Example request: Retrieve a token $ curl ""https://api.mapbox.com/tokens/ v2 ?access_token= YOUR_MAPBOX_ACCESS_TOKEN "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Retrieve a token The body of the token is parsed and included as the token property in object form. The returned object contains the following properties: Property Description code Indicates whether the token is valid. If the token is invalid, describes the reason. One of: Code Description TokenValid The token is valid and active. TokenMalformed The token cannot be parsed. TokenInvalid The signature for the token does not validate. TokenExpired The token was temporary and has expired. TokenRevoked The token's authorization has been deleted. token The token object. Contains the following properties: token.usage The token type. One of pk, sk, or tk. token.user The user to whom the token belongs. token.authorization The token's unique identifier. token.expires tk tokens only. The expiration time of the token. token.created tk tokens only. The creation time of the token. token.scopes tk tokens only. The token's assigned scopes. token.client tk tokens only. Always ""api"". Example response: Retrieve a token For a public token: { ""code"": ""TokenValid"", ""token"": { ""usage"": ""pk"", ""user"": ""mapbox"", ""authorization"": ""cijucimbe000brbkt48d0dhcx"" } } For a temporary token: { ""code"": ""TokenExpired"", ""token"": { ""usage"": ""tk"", ""user"": ""mapbox"", ""expires"": ""2016-09-15T19:27:53.000Z"", ""created"": ""2016-09-15T19:27:23.000Z"", ""scopes"": [""styles:read"", ""fonts:read""], ""client"": ""api"" } } List scopes get /scopes/v1/{username}?access_token={access_token} scopes:list token scope List scopes for a user. All potential scopes a user has access to are listed. Public tokens may only contain scopes with the public property set to true. Secret tokens may contain any scope. Required parameter Description username The username of the account for which to list scopes. Example request: List scopes $ curl ""https://api.mapbox.com/scopes/v1/ {username} ?access_token= YOUR_MAPBOX_ACCESS_TOKEN This endpoint requires a token with scopes:list scope. "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDK supports this endpoint: Mapbox JavaScript SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: List scopes The response body will contain an object for each scope the user has access to, each with the following properties: Property Description id The identifier of the scope. description A description of permissions granted by the scope. public true if the scope is available for public tokens. Example response (truncated): List scopes [ { ""id"": ""scopes:list"", ""description"": ""List all available scopes."" }, { ""id"": ""styles:read"", ""public"": true, ""description"": ""Read styles."" } ] Tokens API errors Response body code or message HTTP status code Description TokenInvalid, TokenMalformed 200 Check the access token used in the query when retrieving a token. TokenExpired 200 The temporary token has expired and needs to be regenerated when retrieving a token. TokenRevoked 200 The token has been revoked and needs to be regenerated when retrieving a token. Unauthorized 401 The token used in the query was not valid, or no token was used in the query. If a temporary token was used, it may be expired. Not found 404 The access token used in the query needs the tokens:read (to list) or tokens:write scope (to create, update, or delete). This error may also indicate that a token is not associated with a user plan. No such user 404 Check the username used in the query. access token is required 422 No access token was used in the query. usage must be pk or sk 422 The usage parameter must be one of pk (public token) or sk (secret token). expires is in the past 422 You can't create a temporary token with an expires parameter that occurs in the past. expires is more than one hour in the future 422 When creating a temporary token, the expiration must be no more than one hour in the future. expires may not be greater than the expiration of the authorizing token 422 When creating a temporary token using another temporary token, the expiration of the created token cannot be greater than that of the creating token. scopes are invalid 422 You cannot create a new token with scopes that exceed those of the token you are using to create it. resources are invalid 422 When creating or updating a token, the resources in the body are malformed, empty, or require higher permissions that those of the creating token. Internal Server Error 500 This error can occur if the start value is not valid. Tokens API restrictions and limits Requests must be over HTTPS. HTTP is not supported. The Tokens API is limited to 100 requests per minute per account. Each token is limited to 100 allowed URLs. Temporary tokens cannot have allowed URLs, but public tokens and secret tokens can. Was this section on Tokens helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Accounts service,Token metadata object,Example token metadata object,List tokens,Example request: List tokens,Response: List tokens,Example response: List tokens,Create a token,Available token scopes,Example request: Create a token,Response: Create a token,Example response: Create a token,Create a temporary token,Example request: Create a temporary token,Example request body: Create a temporary token,Response: Create a temporary token,,Example response: Create a temporary token,Update a token,Example request: Update a token,Response: Update a token,Example response: Update a token,Delete a token,Example request: Delete a token,Response: Delete a token,Retrieve a token,Example request: Retrieve a token,Response: Retrieve a token,Example response: Retrieve a token,List scopes,Example request: List scopes,Response: List scopes,Example response (truncated): List scopes,Tokens API errors,Tokens API restrictions and limits,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Map Matching,Match raw GPS points to the map so they aligns with the roads/pathways.,https://docs.mapbox.com/android/java/examples/use-map-matching/,example,Java,,"Map Matching Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical"" tools:context="".examples.javaservices.MapMatchingActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""34.01591350351023"" mapbox:mapbox_cameraTargetLng=""-118.4945560781314"" mapbox:mapbox_cameraZoom=""14.5""/> </LinearLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.graphics.Color; import android.os.AsyncTask; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.api.matching.v5.MapboxMapMatching; import com.mapbox.api.matching.v5.models.MapMatchingMatching; import com.mapbox.api.matching.v5.models.MapMatchingResponse; import com.mapbox.core.exceptions.ServicesException; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.ColorUtils; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.List; import java.util.Objects; import java.util.Scanner; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.api.directions.v5.DirectionsCriteria.PROFILE_DRIVING; import static com.mapbox.core.constants.Constants.PRECISION_6; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Match raw GPS points to the map so they align with roads and pathways. */ public class MapMatchingActivity extends AppCompatActivity { private static final String TAG = ""MapMatchingActivity""; private MapView mapView; private MapboxMap map; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_javaservices_map_matching); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { map = mapboxMap; map.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { new LoadGeoJson(MapMatchingActivity.this).execute(); } }); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private static class LoadGeoJson extends AsyncTask<Void, Void, FeatureCollection> { private WeakReference<MapMatchingActivity> weakReference; LoadGeoJson(MapMatchingActivity activity) { this.weakReference = new WeakReference<>(activity); } @Override protected FeatureCollection doInBackground(Void... voids) { try { MapMatchingActivity activity = weakReference.get(); if (activity != null) { InputStream inputStream = activity.getAssets().open(""trace.geojson""); return FeatureCollection.fromJson(convertStreamToString(inputStream)); } } catch (Exception exception) { Timber.e(""Exception Loading GeoJSON: %s"", exception.toString()); } return null; } static String convertStreamToString(InputStream is) { Scanner scanner = new Scanner(is).useDelimiter(""\\A""); return scanner.hasNext() ? scanner.next() : """"; } @Override protected void onPostExecute(@Nullable FeatureCollection featureCollection) { super.onPostExecute(featureCollection); MapMatchingActivity activity = weakReference.get(); if (activity != null && featureCollection != null) { activity.drawLines(featureCollection); } } } private void drawLines(@NonNull FeatureCollection featureCollection) { List<Feature> features = featureCollection.features(); if (features != null && features.size() > 0) { Feature feature = features.get(0); drawBeforeMapMatching(feature); requestMapMatched(feature); } } private void drawBeforeMapMatching(Feature feature) { map.getStyle(style -> { style.addSource(new GeoJsonSource(""pre-matched-source-id"", feature)); style.addLayer(new LineLayer(""pre-matched-layer-id"", ""pre-matched-source-id"").withProperties( lineColor(ColorUtils.colorToRgbaString(Color.parseColor(""#c14a00""))), lineWidth(6f), lineOpacity(1f) )); }); } private void requestMapMatched(Feature feature) { List<Point> points = ((LineString) Objects.requireNonNull(feature.geometry())).coordinates(); try { // Setup the request using a client. MapboxMapMatching client = MapboxMapMatching.builder() .accessToken(Objects.requireNonNull(Mapbox.getAccessToken())) .profile(PROFILE_DRIVING) .coordinates(points) .build(); // Execute the API call and handle the response. client.enqueueCall(new Callback<MapMatchingResponse>() { @Override public void onResponse(@NonNull Call<MapMatchingResponse> call, @NonNull Response<MapMatchingResponse> response) { if (response.code() == 200) { drawMapMatched(Objects.requireNonNull(response.body()).matchings()); } else { // If the response code does not response ""OK"" an error has occurred. Timber.e(""MapboxMapMatching failed with %s"", response.code()); } } @Override public void onFailure(Call<MapMatchingResponse> call, Throwable throwable) { Timber.e(throwable, ""MapboxMapMatching error""); } }); } catch (ServicesException servicesException) { Timber.e(servicesException, ""MapboxMapMatching error""); } } private void drawMapMatched(@NonNull List<MapMatchingMatching> matchings) { Style style = map.getStyle(); if (style != null && !matchings.isEmpty()) { style.addSource(new GeoJsonSource(""matched-source-id"", Feature.fromGeometry(LineString.fromPolyline( Objects.requireNonNull(matchings.get(0).geometry()), PRECISION_6))) ); style.addLayer(new LineLayer(""matched-layer-id"", ""matched-source-id"") .withProperties( lineColor(ColorUtils.colorToRgbaString(Color.parseColor(""#3bb2d0""))), lineWidth(6f)) ); } } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Map Matching,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Map features,An overview of rendering vector features in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/overview/map-features/,guide,,,"Map features Map layers The Map Layers section of the AbstractMap script is where you can control how vector features are rendered on your map. Data Source: This setting is where you can specify the tileset to use for your map layer. Buildings With Building Ids: This tileset combines Mapbox-Streets-v7 vector data with our experimental 3D buildings data, which assigns unique IDs to building features to avoid visual artifacts for buildings at tile borders. Mapbox Streets: This is the Mapbox-Streets-v7 tileset. This tileset will be the most appropriate choice for common use cases. Custom: Use this setting for bringing your custom tileset into Unity. You can create a composite data source for your layer by adding multiple comma-separated tileset IDs in the Map Ids field. This allows you to use multiple custom tilesets, or add your custom tileset as well as the default Mapbox Streets tileset. For more information on how to use custom data with the Maps SDK for Unity, refer to the custom data documentation. Features Map features is where you can specify how to render specific layers from the tilesets assigned as a Data Source. With a Data Source selected, click on FEATURES and then on Add Features. A selection dialogue will appear with the following: Buildings, Roads, Landuse, Points, and Custom. These settings refer to the layers contained in the selected Data Source. Select a layer for the required feature. Buildings Add 3D buildings to your map with the following steps: Select Buildings for the map feature. Preset settings for the feature type selected will be populated. Click on the Name to rename the feature. Enter Play mode. The 3D buildings from the building layer on the Mapbox-Streets-v7 tileset will be rendered on your map. See the sections below for details on the default settings, and how to further customize the 3D buildings in your scene. Filters Using filters you can make settings to conditionally render vector features contained in the building layer. Modeling In this section you can make settings to fine tune your meshes. Primitive Type: Vector data is made up of lines, polygons, points, or custom data. The primitive type defines the type of vector feature you are trying to access. In the case of buildings this will be “polygon” since building footprints are essentially polygons extruded by a height value. Extrusion Type: The extrusion type setting provides a way to specify max, min, or fixed heights for buildings. The available options are below. You will see different settings in the inspector depending on these dropdown selections. None: No extrusion. Property Height: Extrudes features using the property value. Min Height: Extrudes features using the property value. If height is not uniform, this sets the height based on property's minimum height value. This results in flat rooftops. Max Height: Extrudes features using the property value. If height is not uniform, this sets the height based on property's maximum height. This results in flat rooftops. Range Height: Extrudes features using the property value. Values are clamped to the min and max values if they are lower or greater than the min and max values respectively. Absolute Height: Extrudes all features using a fixed value. Geometry Type: Settings to extrude roofs, sidewalls, or both. Property Name: The name of the property on the building layer of the tileset that is used for extrusion. By default it is set to height. For more information see the Mapbox Streets v7 tileset layer reference. Scale Factor: The height scale factor by which you would like to extrude the buildings. For example, if this is set to 2, the building extrusions will be done at twice the original scale. Snap to Terrain: This makes sure buildings snap properly to the terrain when using a terrain with elevation. When this is not checked, the buildings might spawn above or below the terrain. Combine Meshes: Check this option if you want to combine all the building meshes on a tile into a single game object. While this helps improve runtime performance, it may not offer you flexibility to make changes on individual buildings (for example, changing the color or texture of a particular building). It may also make it impossible to use a raycast to find the address of a building. Collider Type: This option is used to add a collider to the extruded buildings. The available types of colliders that you can apply to your buildings are Box Collider, Mesh Collider, or Sphere Collider. Note that if you have Combine Meshes selected, this option will add a collider to the entire tile instead of to individual buildings. Texturing Use the Texturing settings to configure material options for the building geometry. Custom: Choose this setting to specify custom materials and texturing type. Simple: The Simple style combines stylized vector designs with scriptable palettes to create a procedurally colored style. Light: The Light style uses colored materials to create a light, greyscale shading for your map. Dark: The Dark style uses colored materials to create a dark, greyscale shading for your map. Realistic: This is the default texturing for buildings. This combines modern and urban designs with physically based rendering materials to create a contemporary cityscape. Fantasy: The Fantasy style combines old world medieval designs with physically based rendering materials to create a fantasy-style city visualization. Satellite: The Satellite style uses high-resolution satellite imagery as a texture set. The comprehensive set of road, label, and POI information brings clarity and context to the crisp detail in our high-resolution satellite imagery. Color: The Color style is for user-defined color and opacity. Use this setting to specify a custom color. Behavior modifiers Behavior modifiers are ScriptableObjects that work with meshes and game objects to further allow you to decorate, enhance, or make modifications to your game objects. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Map features,Buildings,Filters,Modeling,Texturing,Behavior modifiers,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Analyze data with Turf.js and Mapbox.js,"Using Turf.js, you can add some spatial analysis to your map to solve problems. This guide walks through an example of Turf.js and Mapbox.js in a real-world context.",https://docs.mapbox.com/help/tutorials/analysis-with-turf-mapbox-js/,tutorial,JavaScript,,"intermediate JavaScript Analyze data with Turf.js and Mapbox.js Prerequisite Familiarity with front-end development concepts. Note Mapbox.js is no longer in active development. To learn more about our newer mapping tools see Analyze data with Turf.js and Mapbox GL JS. This guide walks you through how to use Turf.js, a JavaScript library for spatial analysis and statistics. Let's say you are part of a team that manages health and safety for the libraries in Lexington, KY. One important part of your preparedness mandate is to know which hospital is closest to each library in case there's an emergency at one of your facilities. This example will walk you through making a map of libraries and hospitals; when a user clicks on a library, the map will show which hospital is nearest. View fullscreen demo Getting started There are a few resources you'll need to get started: A tileset ID. An ID points to a unique map you have created on Mapbox. An access token. The token is used to associate a map with your account: L.mapbox.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; Mapbox.js. The Mapbox JavaScript API for building maps. Turf.js. Turf is the JavaScript library you'll be using today to add analysis to your map. Data. This example uses two data files: hospitals in Lexington, KY and libraries in Lexington, KY. A text editor. You'll be writing HTML, CSS, and JavaScript. Add structure For this guide, you will include the latest versions of Mapbox.js and Turf.js. Create a new HTML file in your text editor, and add these libraries to the head by copying the snippet below: <link href='https://api.mapbox.com/mapbox.js/ v3.2.0 /mapbox.css' rel='stylesheet' /> <script src='https://api.mapbox.com/mapbox.js/ v3.2.0 /mapbox.js'></script> <script src='https://api.mapbox.com/mapbox.js/plugins/turf/ v3.0.11 /turf.min.js'></script> Now, add your map element. First, in the body, create an empty div for your map: <div id='map'></div> Next, add some CSS to a style element in the head so your map takes up the width of the page: body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } Initialize a map Now that your page has some nice structure to it, go ahead and get a map on the page using Mapbox.js. You'll create a L.mapbox.map object called map and use setView to center the map on Lexington, KY. This is where you'll need to use your access token and tileset ID. Add the following script inside the <body> after the HTML: L.mapbox.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = L.mapbox.map('map') .setView([38.05, -84.5], 12) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); map.scrollWheelZoom.disable(); View fullscreen demo Sweet! Now your page has a map centered on Lexington, KY. Note There is an additional line in the code above that turns off scroll zoom on the map. This is optional. Load data As mentioned above, this example uses two data files: libraries and hospitals in Lexington, KY, each of them is a GeoJSON FeatureCollection. In the next step, you'll add them to the map as L.mapbox.featureLayer objects and add a little code to make sure they're styled differently from each other. Also, you'll make sure that your map view contains all the points by fitting the map bounds to your features: L.mapbox.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // store GeoJSON objects in these variables var hospitals = { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""properties"": { ""Name"": ""VA Medical Center -- Leestown Division"", ""Address"": ""2250 Leestown Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.539487, 38.072916 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""St. Joseph East"", ""Address"": ""150 N Eagle Creek Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.440434, 37.998757 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Central Baptist Hospital"", ""Address"": ""1740 Nicholasville Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.512283, 38.018918 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""VA Medical Center -- Cooper Dr Division"", ""Address"": ""1101 Veterans Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.506483, 38.02972 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Shriners Hospital for Children"", ""Address"": ""1900 Richmond Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.472941, 38.022564 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Eastern State Hospital"", ""Address"": ""627 W Fourth St"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.498816, 38.060791 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Cardinal Hill Rehabilitation Hospital"", ""Address"": ""2050 Versailles Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.54212, 38.046568 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""St. Joseph Hospital"", ""ADDRESS"": ""1 St Joseph Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.523636, 38.032475 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""UK Healthcare Good Samaritan Hospital"", ""Address"": ""310 S Limestone"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.501222, 38.042123 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""UK Medical Center"", ""Address"": ""800 Rose St"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.508205, 38.031254 ] } } ] } ; var libraries = { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""properties"": { ""Name"": ""Village Branch"", ""Address"": ""2185 Versailles Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.548369, 38.047876 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Northside Branch"", ""ADDRESS"": ""1733 Russell Cave Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.47135, 38.079734 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Central Library"", ""ADDRESS"": ""140 E Main St"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.496894, 38.045459 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Beaumont Branch"", ""Address"": ""3080 Fieldstone Way"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.557948, 38.012502 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Tates Creek Branch"", ""Address"": ""3628 Walden Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.498679, 37.979598 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Eagle Creek Branch"", ""Address"": ""101 N Eagle Creek Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.442219, 37.999437 ] } } ] } ; // Add marker color, symbol, and size to hospital GeoJSON for (var i = 0; i < hospitals.features.length; i++) { hospitals.features[i].properties['marker-color'] = '#DC143C'; hospitals.features[i].properties['marker-symbol'] = 'hospital'; hospitals.features[i].properties['marker-size'] = 'small'; } // Add marker color, symbol, and size to library GeoJSON for (var j = 0; j < libraries.features.length; j++) { libraries.features[j].properties['marker-color'] = '#4169E1'; libraries.features[j].properties['marker-symbol'] = 'library'; libraries.features[j].properties['marker-size'] = 'small'; } var map = L.mapbox.map('map') .setView([38.05, -84.5], 12) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); map.scrollWheelZoom.disable(); var hospitalLayer = L.mapbox.featureLayer(hospitals) .addTo(map); var libraryLayer = L.mapbox.featureLayer(libraries) .addTo(map); // When map loads, zoom to libraryLayer features map.fitBounds(libraryLayer.getBounds()); Note that hospitalLayer and libraryLayer are defined after you create your map object; you must define them in this order to make sure they can be added to the map. View fullscreen demo Alternatively, you can save the GeoJSON as one or two .geojson files and load the files on to the map. If you do this, you will need to run this application from a local web server otherwise, you will receive a Cross-origin Resource Sharing (CORS) error. Add interactivity Your map users will want to know the names of the libraries and hospitals displayed on the map, so next you'll add some popups. For this map, add some popups to these features that appear when the user hovers over the markers. Insert this into your script after you've created hospitalLayer and libraryLayer: // Bind a popup to each feature in hospitalLayer and libraryLayer hospitalLayer.eachLayer(function(layer) { layer.bindPopup('<strong>' + layer.feature.properties.Name + '</strong>', { closeButton: false } ); } ).addTo(map); libraryLayer.eachLayer(function(layer) { layer.bindPopup(layer.feature.properties.Name, { closeButton: false } ); } ).addTo(map); // Open popups on hover libraryLayer.on('mouseover', function(e) { e.layer.openPopup(); } ); hospitalLayer.on('mouseover', function(e) { e.layer.openPopup(); } ); View fullscreen demo Next, you'll make your map of the libraries and hospitals in Lexington even more useful by adding some analysis. Use Turf Turf is a JavaScript library for adding spatial and statistical analysis to your web maps. It contains many commonly-used GIS tools (like buffer, union, and merge) as well as statistical analysis functions (like sum, median, and average). Fortunately, Turf has some functions that will help you out here! You're going to update your map so that clicking on a library will show users which hospital is closest to that library. As a first step, make an ""event handler"" for when someone clicks on a library marker. When an event occurs, like a click on a marker, the event handler tells the map what to do in response. Before, you created event handlers for hovering over hospital and library markers; now you're going to make one for clicks. libraryLayer.on('click', function(e) { } ); This is the structure of an event handler; anything you want to happen on click goes inside of the braces { }. In this case, you want to use Turf to identify the nearest hospital to the clicked library and make that marker larger to identify it. libraryLayer.on('click', function(e) { // Get the GeoJSON from libraryFeatures and hospitalFeatures var libraryFeatures = libraryLayer.getGeoJSON(); var hospitalFeatures = hospitalLayer.getGeoJSON(); // Using Turf, find the nearest hospital to library clicked var nearestHospital = turf.nearest(e.layer.feature, hospitalFeatures); // Change the nearest hospital to a large marker nearestHospital.properties['marker-size'] = 'large'; // Add the new GeoJSON to hospitalLayer hospitalLayer.setGeoJSON(hospitalFeatures); } ); View fullscreen demo Excellent! This is almost ready to go. Add finishing touches When a user clicks on a library, the nearest hospital gets larger. But when the user click on a different library, or on the map, the previously-nearest hospital doesn't go back to a small marker again. To address this, add some code to make the popup for the nearest hospital open up when it gets larger. Add the following function before the click event handler. // reset marker size to small function reset() { var hospitalFeatures = hospitalLayer.getGeoJSON(); for (var i = 0; i < hospitalFeatures.features.length; i++) { hospitalFeatures.features[i].properties['marker-size'] = 'small'; } hospitalLayer.setGeoJSON(hospitalFeatures); } Then, inside of the click handler, add a function call to reset() and some code for making sure the nearest hospital opens a popup when it gets larger. libraryLayer.on('click', function(e) { // Reset any and all marker sizes to small reset(); // Get the GeoJSON from libraryFeatures and hospitalFeatures var libraryFeatures = libraryLayer.getGeoJSON(); var hospitalFeatures = hospitalLayer.getGeoJSON(); // Using Turf, find the nearest hospital to library clicked var nearestHospital = turf.nearest(e.layer.feature, hospitalFeatures); // Change the nearest hospital to a large marker nearestHospital.properties['marker-size'] = 'large'; // Add the new GeoJSON to hospitalLayer hospitalLayer.setGeoJSON(hospitalFeatures); // Bind popups to new hospitalLayer and open popup // for nearest hospital hospitalLayer.eachLayer(function(layer) { layer.bindPopup('<strong>' + layer.feature.properties.Name + '</strong>', { closeButton: false } ); if (layer.feature.properties['marker-size'] === 'large') { layer.openPopup(); } } ); } ); Lastly, add a little bit of code at the end to reset all the markers to small when anywhere on the map is clicked (besides on a library). map.on('click', function(e) { reset(); } ); View fullscreen demo Finished product Nicely done! You have successfully created a map that calculates which hospital is closest to each library dynamically. Your finished HTML file should look like this: <html> <head> <meta charset=utf-8 /> <title>Turf.js Map</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.mapbox.com/mapbox.js/ v3.2.0 /mapbox.js'></script> <link href='https://api.mapbox.com/mapbox.js/ v3.2.0 /mapbox.css' rel='stylesheet' /> <script src='https://api.mapbox.com/mapbox.js/plugins/turf/ v3.0.11 /turf.min.js'></script> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> L.mapbox.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var hospitals = { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""properties"": { ""Name"": ""VA Medical Center -- Leestown Division"", ""Address"": ""2250 Leestown Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.539487, 38.072916 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""St. Joseph East"", ""Address"": ""150 N Eagle Creek Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.440434, 37.998757 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Central Baptist Hospital"", ""Address"": ""1740 Nicholasville Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.512283, 38.018918 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""VA Medical Center -- Cooper Dr Division"", ""Address"": ""1101 Veterans Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.506483, 38.02972 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Shriners Hospital for Children"", ""Address"": ""1900 Richmond Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.472941, 38.022564 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Eastern State Hospital"", ""Address"": ""627 W Fourth St"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.498816, 38.060791 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Cardinal Hill Rehabilitation Hospital"", ""Address"": ""2050 Versailles Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.54212, 38.046568 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""St. Joseph Hospital"", ""ADDRESS"": ""1 St Joseph Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.523636, 38.032475 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""UK Healthcare Good Samaritan Hospital"", ""Address"": ""310 S Limestone"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.501222, 38.042123 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""UK Medical Center"", ""Address"": ""800 Rose St"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.508205, 38.031254 ] } } ] } ; var libraries = { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""properties"": { ""Name"": ""Village Branch"", ""Address"": ""2185 Versailles Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.548369, 38.047876 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Northside Branch"", ""ADDRESS"": ""1733 Russell Cave Rd"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.47135, 38.079734 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Central Library"", ""ADDRESS"": ""140 E Main St"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.496894, 38.045459 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Beaumont Branch"", ""Address"": ""3080 Fieldstone Way"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.557948, 38.012502 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Tates Creek Branch"", ""Address"": ""3628 Walden Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.498679, 37.979598 ] } }, { ""type"": ""Feature"", ""properties"": { ""Name"": ""Eagle Creek Branch"", ""Address"": ""101 N Eagle Creek Dr"" }, ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -84.442219, 37.999437 ] } } ] } ; // Add marker color, symbol, and size to hospital GeoJSON for (var i = 0; i < hospitals.features.length; i++) { hospitals.features[i].properties['marker-color'] = '#DC143C'; hospitals.features[i].properties['marker-symbol'] = 'hospital'; hospitals.features[i].properties['marker-size'] = 'small'; } // Add marker color, symbol, and size to library GeoJSON for (var j = 0; j < libraries.features.length; j++) { libraries.features[j].properties['marker-color'] = '#4169E1'; libraries.features[j].properties['marker-symbol'] = 'library'; libraries.features[j].properties['marker-size'] = 'small'; } var map = L.mapbox.map('map') .setView([38.05, -84.5], 12) .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10')); map.scrollWheelZoom.disable(); var hospitalLayer = L.mapbox.featureLayer(hospitals) .addTo(map); var libraryLayer = L.mapbox.featureLayer(libraries) .addTo(map); map.fitBounds(libraryLayer.getBounds()); // Bind a popup to each feature in hospitalLayer and libraryLayer hospitalLayer.eachLayer(function(layer) { layer.bindPopup('<strong>' + layer.feature.properties.Name + '</strong>', { closeButton: false } ); } ).addTo(map); libraryLayer.eachLayer(function(layer) { layer.bindPopup(layer.feature.properties.Name, { closeButton: false } ); } ).addTo(map); // Open popups on hover libraryLayer.on('mouseover', function(e) { e.layer.openPopup(); } ); hospitalLayer.on('mouseover', function(e) { e.layer.openPopup(); } ); // Reset marker size to small function reset() { var hospitalFeatures = hospitalLayer.getGeoJSON(); for (var k = 0; k < hospitalFeatures.features.length; k++) { hospitalFeatures.features[k].properties['marker-size'] = 'small'; } hospitalLayer.setGeoJSON(hospitalFeatures); } // When a library is clicked, do the following libraryLayer.on('click', function(e) { // Reset any and all marker sizes to small reset(); // Get the GeoJSON from libraryFeatures and hospitalFeatures var libraryFeatures = libraryLayer.getGeoJSON(); var hospitalFeatures = hospitalLayer.getGeoJSON(); // Using Turf, find the nearest hospital to library clicked var nearestHospital = turf.nearest(e.layer.feature, hospitalFeatures); // Change the nearest hospital to a large marker nearestHospital.properties['marker-size'] = 'large'; // Add the new GeoJSON to hospitalLayer hospitalLayer.setGeoJSON(hospitalFeatures); // Bind popups to new hospitalLayer and open popup // for nearest hospital hospitalLayer.eachLayer(function(layer) { layer.bindPopup('<strong>' + layer.feature.properties.Name + '</strong>', { closeButton: false } ); if (layer.feature.properties['marker-size'] === 'large') { layer.openPopup(); } } ); } ); // When the map is clicked on anywhere, reset all // hospital markers to small map.on('click', function(e) { reset(); } ); </script> </body> </html> Next steps Turf has dozens of tools that would help extend this map even further. For example, you could also use turf.distance to determine not only which hospital is closest, but exactly how far away it is. The possibilities are virtually endless with Turf.js! Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Analyze data with Turf.js and Mapbox.js,Initialize a map,Load data,Add interactivity,Use Turf,Add finishing touches,Finished product,Next steps,,,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Create a static map snapshot,Create a map snapshot object.,https://docs.mapbox.com/ios/maps/examples/map-snapshotter/,example,Swift,Objective-C,"Create a static map snapshot Swift Objective C import Mapbox class StaticSnapshotExample: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! var button: UIButton! var imageView: UIImageView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: CGRect(x: 0, y: 0, width: view.bounds.width, height: view.bounds.height / 2), styleURL: MGLStyle.satelliteStreetsStyleURL) mapView.autoresizingMask = [.flexibleHeight, .flexibleWidth] // Center map on the Giza Pyramid Complex in Egypt. let center = CLLocationCoordinate2D(latitude: 29.9773, longitude: 31.1325) mapView.setCenter(center, zoomLevel: 14, animated: false) view.addSubview(mapView) // Create a button to take a map snapshot. button = UIButton(frame: CGRect(x: mapView.bounds.width / 2 - 40, y: mapView.bounds.height - 40, width: 80, height: 30)) button.layer.cornerRadius = 15 button.backgroundColor = UIColor(red: 0.96, green: 0.65, blue: 0.14, alpha: 1.0) button.setImage(UIImage(named: ""camera""), for: .normal) button.addTarget(self, action: #selector(createSnapshot), for: .touchUpInside) view.addSubview(button) // Create a UIImageView that will store the map snapshot. imageView = UIImageView(frame: CGRect(x: 0, y: view.bounds.height / 2, width: view.bounds.width, height: view.bounds.height / 2)) imageView.backgroundColor = .black imageView.autoresizingMask = [.flexibleWidth, .flexibleHeight] self.view.addSubview(imageView) } @objc func createSnapshot() { // Use the map's style, camera, size, and zoom level to set the snapshot's options. let options = MGLMapSnapshotOptions(styleURL: mapView.styleURL, camera: mapView.camera, size: mapView.bounds.size) options.zoomLevel = mapView.zoomLevel // Add an activity indicator to show that the snapshot is loading. let indicator = UIActivityIndicatorView(frame: CGRect(x: self.imageView.center.x - 30, y: self.imageView.center.y - 30, width: 60, height: 60)) view.addSubview(indicator) indicator.startAnimating() // Create the map snapshot. var snapshotter: MGLMapSnapshotter? = MGLMapSnapshotter(options: options) snapshotter?.start { (snapshot, error) in if error != nil { print(""Unable to create a map snapshot."") } else if let snapshot = snapshot { // Add the map snapshot's image to the image view. indicator.stopAnimating() self.imageView.image = snapshot.image } snapshotter = nil } } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Create a static map snapshot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display buildings in 3D,Use extrusions to display buildings' height in 3D.,https://docs.mapbox.com/mapbox-gl-js/example/3d-buildings/,example,JavaScript,,Display buildings in 3D Use extrusions to display buildings' height in 3D. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Display buildings in 3D,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Reroute,Test the reroute feature inside the Navigation SDK for Android.,https://docs.mapbox.com/android/navigation/examples/reroute/,example,Java,,"Reroute Activity View on GitHub package com.mapbox.services.android.navigation.testapp.activity; import android.annotation.SuppressLint; import android.graphics.Color; import android.location.Location; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.design.widget.Snackbar; import android.view.View; import android.widget.Toast; import com.mapbox.android.core.location.LocationEngineCallback; import com.mapbox.android.core.location.LocationEngineResult; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.core.constants.Constants; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.annotations.MarkerOptions; import com.mapbox.mapboxsdk.annotations.Polyline; import com.mapbox.mapboxsdk.annotations.PolylineOptions; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.services.android.navigation.testapp.R; import com.mapbox.services.android.navigation.ui.v5.instruction.InstructionView; import com.mapbox.services.android.navigation.v5.location.replay.ReplayRouteLocationEngine; import com.mapbox.services.android.navigation.v5.milestone.Milestone; import com.mapbox.services.android.navigation.v5.milestone.MilestoneEventListener; import com.mapbox.services.android.navigation.v5.milestone.VoiceInstructionMilestone; import com.mapbox.services.android.navigation.v5.navigation.MapboxNavigation; import com.mapbox.services.android.navigation.v5.navigation.MapboxNavigationOptions; import com.mapbox.services.android.navigation.v5.navigation.NavigationEventListener; import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute; import com.mapbox.services.android.navigation.v5.offroute.OffRouteListener; import com.mapbox.services.android.navigation.v5.routeprogress.ProgressChangeListener; import com.mapbox.services.android.navigation.v5.routeprogress.RouteProgress; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; import butterknife.BindView; import butterknife.ButterKnife; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; public class RerouteActivity extends HistoryActivity implements OnMapReadyCallback, Callback<DirectionsResponse>, MapboxMap.OnMapClickListener, NavigationEventListener, OffRouteListener, ProgressChangeListener, MilestoneEventListener { @BindView(R.id.mapView) MapView mapView; @BindView(android.R.id.content) View contentLayout; @BindView(R.id.instructionView) InstructionView instructionView; private Point origin = Point.fromLngLat(-0.358764, 39.494876); private Point destination = Point.fromLngLat(-0.383524, 39.497825); private Polyline polyline; private final RerouteActivityLocationCallback callback = new RerouteActivityLocationCallback(this); private Location lastLocation; private ReplayRouteLocationEngine mockLocationEngine; private MapboxNavigation navigation; private MapboxMap mapboxMap; private boolean running; private boolean tracking; private boolean wasInTunnel = false; @Override protected void onCreate(Bundle savedInstanceState) { setTheme(R.style.NavigationViewLight); super.onCreate(savedInstanceState); setContentView(R.layout.activity_reroute); ButterKnife.bind(this); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); MapboxNavigationOptions options = MapboxNavigationOptions.builder().isDebugLoggingEnabled(true).build(); navigation = new MapboxNavigation(getApplicationContext(), Mapbox.getAccessToken(), options); navigation.addNavigationEventListener(this); navigation.addMilestoneEventListener(this); addNavigationForHistory(navigation); instructionView.retrieveSoundButton().show(); instructionView.retrieveSoundButton().addOnClickListener( v -> Toast.makeText(RerouteActivity.this, ""Sound button clicked!"", Toast.LENGTH_SHORT).show() ); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); shutdownLocationEngine(); shutdownNavigation(); } @SuppressLint(""MissingPermission"") @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; this.mapboxMap.addOnMapClickListener(this); mapboxMap.setStyle(Style.DARK, style -> { LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent(this, style); locationComponent.setLocationComponentEnabled(true); locationComponent.setRenderMode(RenderMode.GPS); mockLocationEngine = new ReplayRouteLocationEngine(); getRoute(origin, destination); }); } @Override public boolean onMapClick(@NonNull LatLng point) { if (!running || mapboxMap == null || lastLocation == null) { return false; } mapboxMap.addMarker(new MarkerOptions().position(point)); mapboxMap.removeOnMapClickListener(this); destination = Point.fromLngLat(point.getLongitude(), point.getLatitude()); resetLocationEngine(destination); tracking = false; return false; } @Override public void onRunning(boolean running) { this.running = running; if (running) { navigation.addOffRouteListener(this); navigation.addProgressChangeListener(this); } } @Override public void userOffRoute(Location location) { origin = Point.fromLngLat(lastLocation.getLongitude(), lastLocation.getLatitude()); getRoute(origin, destination); Snackbar.make(contentLayout, ""User Off Route"", Snackbar.LENGTH_SHORT).show(); mapboxMap.addMarker(new MarkerOptions().position(new LatLng(location.getLatitude(), location.getLongitude()))); } @Override public void onProgressChange(Location location, RouteProgress routeProgress) { boolean isInTunnel = routeProgress.inTunnel(); lastLocation = location; if (!wasInTunnel && isInTunnel) { wasInTunnel = true; Snackbar.make(contentLayout, ""Enter tunnel!"", Snackbar.LENGTH_SHORT).show(); } if (wasInTunnel && !isInTunnel) { wasInTunnel = false; Snackbar.make(contentLayout, ""Exit tunnel!"", Snackbar.LENGTH_SHORT).show(); } if (tracking) { mapboxMap.getLocationComponent().forceLocationUpdate(location); CameraPosition cameraPosition = new CameraPosition.Builder() .zoom(15) .target(new LatLng(location.getLatitude(), location.getLongitude())) .bearing(location.getBearing()) .build(); mapboxMap.animateCamera(CameraUpdateFactory.newCameraPosition(cameraPosition), 2000); } instructionView.updateDistanceWith(routeProgress); } @Override public void onMilestoneEvent(RouteProgress routeProgress, String instruction, Milestone milestone) { if (milestone instanceof VoiceInstructionMilestone) { Snackbar.make(contentLayout, instruction, Snackbar.LENGTH_SHORT).show(); } instructionView.updateBannerInstructionsWith(milestone); Timber.d(""onMilestoneEvent - Current Instruction: %s"", instruction); } @Override public void onResponse(@NonNull Call<DirectionsResponse> call, @NonNull Response<DirectionsResponse> response) { Timber.d(call.request().url().toString()); if (response.body() != null) { if (!response.body().routes().isEmpty()) { DirectionsRoute route = response.body().routes().get(0); drawRoute(route); resetLocationEngine(route); navigation.startNavigation(route); mapboxMap.addOnMapClickListener(this); tracking = true; } } } @Override public void onFailure(@NonNull Call<DirectionsResponse> call, @NonNull Throwable throwable) { Timber.e(throwable); } void updateLocation(Location location) { if (!tracking) { mapboxMap.getLocationComponent().forceLocationUpdate(location); } } private void getRoute(Point origin, Point destination) { NavigationRoute.builder(this) .origin(origin) .destination(destination) .accessToken(Mapbox.getAccessToken()) .build().getRoute(this); } private void drawRoute(DirectionsRoute route) { List<LatLng> points = new ArrayList<>(); List<Point> coords = LineString.fromPolyline(route.geometry(), Constants.PRECISION_6).coordinates(); for (Point point : coords) { points.add(new LatLng(point.latitude(), point.longitude())); } if (!points.isEmpty()) { if (polyline != null) { mapboxMap.removePolyline(polyline); } polyline = mapboxMap.addPolyline(new PolylineOptions() .addAll(points) .color(Color.parseColor(getString(R.string.blue))) .width(5)); } } private void resetLocationEngine(Point point) { mockLocationEngine.moveTo(point); navigation.setLocationEngine(mockLocationEngine); } private void resetLocationEngine(DirectionsRoute directionsRoute) { mockLocationEngine.assign(directionsRoute); navigation.setLocationEngine(mockLocationEngine); } private void shutdownLocationEngine() { if (mockLocationEngine != null) { mockLocationEngine.removeLocationUpdates(callback); } } private void shutdownNavigation() { navigation.removeNavigationEventListener(this); navigation.removeProgressChangeListener(this); navigation.onDestroy(); } private static class RerouteActivityLocationCallback implements LocationEngineCallback<LocationEngineResult> { private final WeakReference<RerouteActivity> activityWeakReference; RerouteActivityLocationCallback(RerouteActivity activity) { this.activityWeakReference = new WeakReference<>(activity); } @Override public void onSuccess(LocationEngineResult result) { RerouteActivity activity = activityWeakReference.get(); if (activity != null) { Location location = result.getLastLocation(); if (location == null) { return; } activity.updateLocation(location); } } @Override public void onFailure(@NonNull Exception exception) { Timber.e(exception); } } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Reroute,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,Platform Support | Mapbox SDK for Unity,,https://docs.mapbox.com/mapbox-unity-sdk/docs/02-known-issues.html,,,,"Toggle navigation Show / Hide Table of Contents Please Note: Current support is limited to Unity 2017.1+ Platform Support Minimum iOS version supported is 8 Minimum Android version supported is 15 For UWP, please read these special notes. Hololens builds are currently not working as expected General If you experience issues with tiles not refreshing as expected, please remember to clear the disk cache You can do this from the Mapbox menu or with MapboxAccess.Instance.ClearCache(); Vector Tile Vector tile overzooming buffer hardcoded (to zero) Buildings are split along tile borders (features duplicated across boundaries) Building parts are not associated with specific buildings (other than spatially) Global Elevation Data Some tiles are missing elevation data (mapbox.terrain-rgb)—these tiles will be treated as flat terrain by the TerrainFactory Directions Cannot cancel direction queries Traffic Traffic visualizer is not offsetting data for both sides of the street Tile Error Callbacks When a client sends a Cancel() / Recycle() request to a UnityTile instance, the OnTileError event handler method is unsubscribed from the OnTileError event. Followed by that, a ""request aborted"" exception is sent as a part of the response to the requested Tile. But, the UnityTile instance cannot listen to this exception since, it has already unsubscribed from the OnTileError event Improve this Doc Back to top © 2017 Mapbox",,5c6adb81d3b68758d0c5c15a,Platform Support,Global Elevation Data,Directions,Traffic,Tile Error Callbacks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Maps SDK for Unity,"The Mapbox Maps SDK for Unity is an open source toolset for building location based augmented and virtual reality applications with Unity, using real map data.",https://docs.mapbox.com/help/glossary/mapbox-maps-sdk-for-unity/,glossary,,,"Mapbox Maps SDK for Unity The Mapbox Maps SDK for Unity is a set of tools to build Unity applications from real map data. It consists of a robust API for interfacing with Mapbox web services and converting map resources into game objects as well as a robust graphical user interface built on top of the Unity platform. To include the Mapbox Maps SDK for Unity in your application, please visit the documentation pages for installation instructions, API reference, and tutorials: Mapbox Maps SDK for Unity overview API documentation Tutorials Pricing for Unity apps Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Mapbox Maps SDK for Unity,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Download an offline map,Download an offline pack and track its progress.,https://docs.mapbox.com/ios/maps/examples/offline-pack/,example,Swift,Objective-C,"Download an offline map See our mobile offline help page for more information about uses and limitations. For a more comprehensive example that manages offline packs, see MBXOfflinePacksTableViewController. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! var progressView: UIProgressView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.darkStyleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .gray mapView.delegate = self view.addSubview(mapView) mapView.setCenter(CLLocationCoordinate2D(latitude: 22.27933, longitude: 114.16281), zoomLevel: 13, animated: false) // Setup offline pack notification handlers. NotificationCenter.default.addObserver(self, selector: #selector(offlinePackProgressDidChange), name: NSNotification.Name.MGLOfflinePackProgressChanged, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(offlinePackDidReceiveError), name: NSNotification.Name.MGLOfflinePackError, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(offlinePackDidReceiveMaximumAllowedMapboxTiles), name: NSNotification.Name.MGLOfflinePackMaximumMapboxTilesReached, object: nil) } func mapViewDidFinishLoadingMap(_ mapView: MGLMapView) { // Start downloading tiles and resources for z13-16. startOfflinePackDownload() } deinit { // Remove offline pack observers. NotificationCenter.default.removeObserver(self) } func startOfflinePackDownload() { // Create a region that includes the current viewport and any tiles needed to view it when zoomed further in. // Because tile count grows exponentially with the maximum zoom level, you should be conservative with your `toZoomLevel` setting. let region = MGLTilePyramidOfflineRegion(styleURL: mapView.styleURL, bounds: mapView.visibleCoordinateBounds, fromZoomLevel: mapView.zoomLevel, toZoomLevel: 16) // Store some data for identification purposes alongside the downloaded resources. let userInfo = [""name"": ""My Offline Pack""] let context = NSKeyedArchiver.archivedData(withRootObject: userInfo) // Create and register an offline pack with the shared offline storage object. MGLOfflineStorage.shared.addPack(for: region, withContext: context) { (pack, error) in guard error == nil else { // The pack couldn’t be created for some reason. print(""Error: \(error?.localizedDescription ?? ""unknown error"")"") return } // Start downloading. pack!.resume() } } // MARK: - MGLOfflinePack notification handlers @objc func offlinePackProgressDidChange(notification: NSNotification) { // Get the offline pack this notification is regarding, // and the associated user info for the pack; in this case, `name = My Offline Pack` if let pack = notification.object as? MGLOfflinePack, let userInfo = NSKeyedUnarchiver.unarchiveObject(with: pack.context) as? [String: String] { let progress = pack.progress // or notification.userInfo![MGLOfflinePackProgressUserInfoKey]!.MGLOfflinePackProgressValue let completedResources = progress.countOfResourcesCompleted let expectedResources = progress.countOfResourcesExpected // Calculate current progress percentage. let progressPercentage = Float(completedResources) / Float(expectedResources) // Setup the progress bar. if progressView == nil { progressView = UIProgressView(progressViewStyle: .default) let frame = view.bounds.size progressView.frame = CGRect(x: frame.width / 4, y: frame.height * 0.75, width: frame.width / 2, height: 10) view.addSubview(progressView) } progressView.progress = progressPercentage // If this pack has finished, print its size and resource count. if completedResources == expectedResources { let byteCount = ByteCountFormatter.string(fromByteCount: Int64(pack.progress.countOfBytesCompleted), countStyle: ByteCountFormatter.CountStyle.memory) print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” completed: \(byteCount), \(completedResources) resources"") } else { // Otherwise, print download/verification progress. print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” has \(completedResources) of \(expectedResources) resources — \(progressPercentage * 100)%."") } } } @objc func offlinePackDidReceiveError(notification: NSNotification) { if let pack = notification.object as? MGLOfflinePack, let userInfo = NSKeyedUnarchiver.unarchiveObject(with: pack.context) as? [String: String], let error = notification.userInfo?[MGLOfflinePackUserInfoKey.error] as? NSError { print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” received error: \(error.localizedFailureReason ?? ""unknown error"")"") } } @objc func offlinePackDidReceiveMaximumAllowedMapboxTiles(notification: NSNotification) { if let pack = notification.object as? MGLOfflinePack, let userInfo = NSKeyedUnarchiver.unarchiveObject(with: pack.context) as? [String: String], let maximumCount = (notification.userInfo?[MGLOfflinePackUserInfoKey.maximumCount] as AnyObject).uint64Value { print(""Offline pack “\(userInfo[""name""] ?? ""unknown"")” reached limit of \(maximumCount) tiles."") } } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Download an offline map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Astronaut game,An enhanced version of the location-based game example provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/astronaut-game/,example,No code,,"Astronaut game This is an enhanced version of the location-based game example. It features custom styling, procedural vehicle movement based on road data, and dynamic lighting. Click on the road in the editor to navigate the astronaut character to a point using our Directions API. When run on a device, this example uses GPS location information to move and rotate the character appropriately with the device. Locate the player The LocationProvider GameObject holds a collection of scripts to determine a player’s location, either in the real world (with GPS, on a device) or simulated in Unity (with manually added coordinates). Without these scripts, the location would be derived from the AbstractMap script. There are several different Location Provider scripts: DeviceLocationProvider: Uses GPS data on a device. The MapboxAstronaut GameObject follows the location on the map reported by the GPS device update. EditorLocationProvider: Similar to DeviceLocationProvider, but you can provide coordinates for debugging in the editor rather than GPS. LocationArrayEditorLocationProvider: Allows the GameObject to be moved across a set of points entered as latitude, longitude coordinates in an array. TransformLocationProvider: Makes the GameObject follow the position and rotation of another GameObject. DeviceLocationProviderAndroidNative: Uses GPS data optimized for Android devices. Directions This example shows how Mapbox Navigation can be used inside of Unity with the DirectionsFactory.cs script. The player in the scene is the MapboxAstronaut GameObject. In the hierarchy, click on MapboxAstronaut and you'll see that it contains a click-to-move controller, a custom DirectionsFactory script called AstronautDirections. When a point on the map is clicked, the route between the astronaut and the point on the map will be returned via a query to the Directions API, and the astronaut will move to the point clicked following that route. For more information on navigation inside of Unity, see the Traffic and Directions documentation. Traffic In this scene, traffic is visualized by leveraging the road data from the Mapbox Streets v7 tileset. The tileset is specified on the AbstractMap inside the Map Layers settings as a Custom Data Source as shown in the screenshot below. You can specify multiple tilesets as data sources by separating them with a comma. For more information refer to the documentation on using custom data in Unity. Map Features are used to render the road data and car animations. Navigate to Map Layers > Features > Map Features, and click on the Traffic layer to see how the visualizers are configured. Open the Advanced > Filters section to see how you can filter the Mapbox Streets v7 tileset data to display exactly what is needed for your use case. The road layer of the tileset contains the class key, which has the values major, street, tertiary, and primary specified. Set Combiner Type to Any to show all roads that have the specified Str Value. Filters are a robust way to show as much or as little data as you need for your scene. To see how the streets are styled with moving cars, open the Behavior Modifiers section. A custom LoftModifier is specified for the Mesh Modifiers. This provides depth for the cars moving on the street. Additionally, the Game Object Modifiers section holds a custom version of a MaterialModifier, which has the materials used to style the top and sides of the roads. The animation effect is handled by the TrafficAnimator object, which also contains the same RoadMaterial. This example scene is a good starting point for a location-based game with directions and polished styling. See the documentation for a location-based game example. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Astronaut game,Traffic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Introduction,"The official overview documentation for the Mapbox Maps SDK for Android. Learn how to customize your Android app's maps, visualize data, and much more.",https://docs.mapbox.com/android/maps/overview/,guide,Java,Kotlin,"Maps SDK for Android Current version: v 8.2.1 View changelog Map styles Run-time styling Data clusters Camera manipulation Querying the map Gestures Map images Install Contribute on GitHub The Mapbox Maps SDK for Android is an open source toolset for displaying maps inside of your Android application. Mapbox's demo app on the Google Play Store includes many examples of how to use the Mapbox Maps SDK for Android. The demo app and examples page will illustrate the power of the Mapbox Maps SDK for Android. Upgrade to the most recent version For information about migrating from older versions of the Mapbox Maps SDK for Android to newer ones, see: v7.x.x to v8.x.x: This version change improved the method for counting monthly active users. No migration guide is required, but you can read more about these changes in the changelog and the Pricing by products guide. v6.x.x to v7.x.x v5.x.x to v6.x.x v4.x.x to v5.x.x Install the Maps SDK Begin installation guide A step-by-step walkthrough to help you get started with Maps SDK for Android. Before starting to develop your application with the Maps SDK, you'll need to add the SDK as a dependency. You can find the following dependency given below in the MavenCentral repository. Although this document shows you how to insert the stable version of the Maps SDK inside of your project, you can also use the nightly build (i.e. SNAPSHOT) or the beta version, if one is available. Find more information about how to do this inside the project’s GitHub repository. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. You can also shrink the file APK file size by making use of APK splitting. 1. Add the dependency Start Android Studio. Open up your application's build.gradle file. Make sure that your project's minSdkVersion is at API 14 or higher. Under dependencies, add a new implementation dependency line for the latest mapbox-android-sdk. Find the File in the toolbar and then click on Sync Project with Gradle Files. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-sdk: 8.2.1 ' } Note: You might have mismatching Gradle dependencies once you add the Mapbox Maps SDK for Android. Don't forget that you can use exclude group like below, to remove certain dependencies: implementation ('com.mapbox.mapboxsdk:mapbox-android-sdk: 8.2.1 ') { exclude group: 'group_name', module: 'module_name' } Additionally, running gradle app_module_name_here:dependencies in your command line will print a list of dependencies. ./gradlew app:dependencies works if you have a Gradle wrapper. They are helpful for troubleshooting nimble Gradle configurations when various libraries are included in a single project. You can see the dependencies that specific libraries are bringing and where conflicts might be happening. 2. Get an access token If you don't have a Mapbox account, sign up, and then navigate to your Account page. Copy your default public token to your clipboard. After you've added the Maps SDK as a dependency inside of your Android project, open the R.strings.xml file, create a new String resource, and paste the access token. <string name=""mapbox_access_token"">MAPBOX_ACCESS_TOKEN</string> Then to pass this into the Maps SDK, you'll want to place the access token inside of your application's onCreate() method. Java Kotlin public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); // Mapbox Access token Mapbox.getInstance(getApplicationContext(), YOUR_MAPBOX_ACCESS_TOKEN); } } Copy The Maps SDK also provides a setToken() method in case you want to switch the Mapbox access token at runtime. Certain Mapbox APIs require special Mapbox tokens, such as maps in China. Setting a new token enables use of multiple Mapbox tools in conjunction with one another. This method allows you to set a token before a specific Mapbox tool is used instead of setting the token initially and being required to use the same token for all Mapbox-related requests. Java Kotlin Mapbox.setAccessToken(YOUR_MAPBOX_ACCESS_TOKEN); Copy 3. Setup permissions Starting with the 5.0 version of the Maps SDK, you can use the Manifest merge feature to reduce the need to include any Maps SDK required things inside of your application's manifest file. You'll need to add either the Fine or Coarse location permission if you plan to display a user's location on the map or get the user's location information. The user location permission should also be checked during runtime using the PermissionsManager. <uses-permission android:name=""android.permission.ACCESS_FINE_LOCATION"" /> 4. Add a map Open the Java file of the activity where you'd like to include the map in and add the code below to the file. Java Kotlin private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, YOUR_MAPBOX_ACCESS_TOKEN); setContentView(R.layout.activity_main); mapView = (MapView) findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Map is set up and the style has loaded. Now you can add data or make other map adjustments } }); } }); Copy Open the activity's XML layout file and add the mapView within your layout. <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> 5. Lifecycle methods The MapView contains its own lifecycle methods for managing Android's OpenGL lifecycle, which must be called directly from the containing Activity. In order for your app to correctly call the MapView's lifecycle methods, you must override the following lifecycle methods in the Activity that contains the MapView and call the respective MapView method. For example, your onStart() method should look like this: Java Kotlin @Override protected void onStart() { super.onStart(); mapView.onStart(); } Copy Like the onStart() override above, the following lifecycle methods also need to be overridden and include the matching MapView method: Java Kotlin onCreate(); onStart(); onResume(); onPause(); onStop(); onSaveInstanceState(); onLowMemory(); onDestroy(); Copy If you're using a fragment, call mapview.onDestroy() inside the fragment's onDestroyView() method rather than inside onDestroy(): Java Kotlin @Override public void onDestroyView() { super.onDestroyView(); mapView.onDestroy(); } Copy Attribution You must include the Mapbox wordmark and attribution notice on any map that uses the Mapbox Maps SDK for Android. The SDK provides an attribution layout that includes all required information and can be customized either in xml or using the UiSettings object. You may adjust the position of the Mapbox wordmark and attribution notice, but they must stay visible on the map. You may also change the background and text color of the attribution notice to match your design aesthetics, but all information must be legible. You may not otherwise alter the Mapbox wordmark or text attribution notice. If you wish to move or to remove the Mapbox wordmark, please contact our sales team to discuss options available under our Enterprise plans. Telemetry opt out Mapbox Telemetry is a powerful location analytics platform included in this SDK. By default, the SDK sends anonymized location and usage data to Mapbox whenever the host app causes it to be gathered. The Mapbox Terms of Service require your app to provide users with a way to individually opt out of Mapbox Telemetry, which is provided automatically as part of the attribution control. If you hide the attribution control, you must provide an alternative opt out for your users to use. MapView XML attributes XML attributes can be added inside of the XML MapView to further customize map behavior, such as setting the starting camera position, enabling tilt, or adjusting the compass' location on the screen. All MapView XML attributes start with mapbox_ for identification and for removing any potential conflicts with other libraries. Due to the current implementation of Android Studio, you can't autogenerate MapView attributes by typing. View the full list of MapView attributes here. Some examples of MapView attributes are: <com.mapbox.mapboxsdk.maps.MapView mapbox:mapbox_cameraTargetLat=""-36.84"" mapbox:mapbox_cameraTargetLng=""174.76"" mapbox:mapbox_cameraZoom=""10"" mapbox:mapbox_cameraBearing=""34.33"" mapbox:mapbox_cameraTilt=""50.25"" mapbox:mapbox_cameraZoomMax=""12.41"" mapbox:mapbox_cameraZoomMin=""6"" mapbox:mapbox_uiRotateGestures=""false""/> Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Maps SDK for Android,2. Get an access token,3. Setup permissions,4. Add a map,5. Lifecycle methods,Attribution,Telemetry opt out,MapView XML attributes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for Android,Android,Safety alerts,Introduction to Mapbox Vision Safety for Android.,https://docs.mapbox.com/android/vision/overview/safety/,guide,,,"Safety alerts Developers can create features to notify and alert drivers about road conditions and potential hazards with Mapbox Vision Safety, an add-on module that uses segmentation, detection, and classification information passed from the Vision SDK. Monitor speed limits Developers can monitor speed limits and other critical signage using sign classification and track the most recently observed speed limit. When the detected speed of the vehicle is more than the last observed speed limit, you can set programmable alerts. There are two pieces to displaying speeding alerts: detecting speed limit signs and determining current vehicle speed. Sign detection Vision Safety uses the Mapbox Vision SDK's Detection class to detect trafficSigns in view and filters for SignTypes equal to any of the speedLimit* types (including special speed limit signs like maximum speeds for trucks and minimum speed). Vision Safety's SpeedLimitRange class contains two numbers: a min and a max speed limit. Vehicle speed Use the VisionSafetyListener to watch for speed limit signs and determine the max speed at the user's current location. The approach used below to determine max speed will look for speed limit signs, update the maxAllowedSpeed variable, and continue to use that value as the max speed until another speed limit sign is detected. Java Kotlin @Override public void onRoadRestrictionsUpdated(@NotNull RoadRestrictions roadRestrictions) { maxAllowedSpeed = roadRestrictions.getSpeedLimits().getCar().getMax(); } Copy Then, you can use the Vision SDK's VehicleLocation class's speed property to determine the speed at which the device is currently traveling. Then, introduce some logic to determine if the user's speed (mySpeed) is currently above the speed limit (maxAllowedSpeed), and display an alert if the user is speeding. Java Kotlin // current speed of the car Float mySpeed = vehicleState.getSpeed(); // display toast with overspeed warning if the car's // speed is greater than maximum allowed speed if (mySpeed > maxAllowedSpeed && maxAllowedSpeed > 0) { Toast.makeText( MainActivity.this, ""Overspeeding! Current speed : "" + mySpeed + "", allowed speed : "" + maxAllowedSpeed, Toast.LENGTH_LONG ).show(); } Copy See the full example code in the Speeding alerts example. Alert drivers of pedestrians and cyclists Vision Safety CollisionObject class detects objects in the vehicle's path and provides an estimated time to impact and a CollisionDangerLevel between 0 and 2. Collision detection can warn drivers when pedestrians or cyclists are in the vehicle’s path or a driver is closing too quickly on a lead vehicle. Related resources Speeding alerts code example Vision Safety for Android reference documentation Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Safety alerts,Vehicle speed,Alert drivers of pedestrians and cyclists,Related resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Map texturing,An overview of styling buildings in the Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/overview/styling/,guide,,,"Map texturing Mapbox’s Maps SDK allows developers to create custom styling for buildings in their Unity projects. Custom styles Mapbox’s Maps SDK allows developers to create custom styling for buildings in their Unity projects. Custom styles can include user-defined architectural feature proportions, textures, and colors. Custom styles are comprised of three different building blocks: AtlasInfo files MapboxStyles materials Scriptable Palettes AtlasInfo Create an AtlasInfo file AtlasInfo files contain user-defined data that tells the Maps SDK how to organize, partition and assign sections of a texture atlas to procedurally generated buildings. They inherit from Unity’s scriptable object class, which means they can be saved in a Unity project and used in multiple scenes. The AtlasInfo class inherits from Unity’s scriptable object class. Users can use the default Atlas Info file, or create their own by doing the following: Right click or go to the Assets menu and navigate to Create > Mapbox > AtlasInfo to create an Atlasinfo file. Click Textures. Change the Size to 1. Click Element 0 to view the parameters. Repeat steps 1-4 for Roofs. Textures: Contains a public list of texture sections for building facades. Roofs: Contains a public list of texture sections for building roofs. Note that textures and roofs can have sections that overlap in UV space. This is useful, as facade and roof textures can be packed either in one Atlas texture or multiple, as roof and facade geometry can use different materials. Texture Rect: Position and size of texture section in UV space X: Position of the bottom left corner of the texture section in UV space. Y: Position of the bottom left corner of the texture section in UV space. W: Width of the texture section in UV space. H: Height of the texture section in UV space. Mid floor count: Number of mid floors to define in texture space. Mid floors will repeat as required to fill a given building’s height. If you set the mid floor count to 1, a single floor will be redrawn repeatedly. Mid floor counts of greater than 1 will result in a series of floors being redrawn in a repeated sequence. Column count: Number of columns to define in texture space. Columns will be repeated as necessary. Top Section ratio: Height ratio of the top floor in the section. So if a section has 8 floors (including ground and top floors) and they are all equal height, this should be 1/8. Bottom Section ratio: Height ratio of the ground floor in the section. So if the section has 8 floor (including ground and top floors) and they are all equal height, this should be 1/8. Preferred Edge Section Length: Ideal wall length. The mesh generation setting will cut down long wall segments to smaller chunks of this length and chosen texture section will be applied to each separately. This setting doesn’t effect uv mapping directly. Floor Height: Single mid floor height. Even if the texture has a big mid segment that consists of multiple floors, this value is a single one of them. This is a mesh generation setting, and doesn’t effect uv mapping directly. First Floor Height: Ground floor height. This is a mesh generation setting, and doesn’t effect uv mapping directly. Top Floor Height: This is a mesh generation setting, and doesn’t effect uv mapping directly. Export an AtlasInfo file as a savable template texture Data defined in an AtlasInfo file can be exported as a savable template texture. This texture can then be opened in an image editing program such as Adobe Photoshop or Illustrator, and used as a reference layer for constructing a texture atlas that conforms to the structure defined in the AtlasInfo. From the top menu, go to Mapbox > Atlas Template Generator. In the Mapbox Atlas Template Generator window, drag an AtlasInfo file into the Atlas info field, shown below. Select what AtlasInfo data to render to the texture by checking Create Facades and/or Create Roofs Specify a Texture resolution. The default is 2048 x 2048. Unity sets colors programmatically and are for template reference only. Change the colors by clicking in their respective Color fields. Click Generate Template. The tools will draw the key subsections of each texture section, such as ground/mid/top floors, columns, etc. The tools will also draw black lines to show subsection centers. Click Save to File to save the generated texture out to a PNG, which can then be used in an image editing software of your choice. MapboxStyles materials Any type of material can be used to render buildings. To take full advantage of the Maps SDK styling features, use of the MapboxStyles materials, which provide support for three colorization layers. To specify the materials used for building visualization, go to the gameObject that contains the AbstractMap component. Next, navigate to the VECTOR settings. Under Vector Layer Visualizers, click on a visualizer. ExtrudedBuildings is selected in this example. Next, add a material for Roof Material and Wall Material. To add a new visualizer instead of using an existing one, click Add Visualizer. Roofs and facades can use the same material or separate ones. These layers are defined by assigning transparent mask textures to the Detail_1 and Detail_2 texture slots. Coloring these layers can be done in one of two ways, depending on the material type used: MapboxStyles - allow you to set colors for feature layers directly in the material inspector, which works for when you want all buildings to have the same base, detail_1, and detail_2 colors. Change the colors by selecting the material and using the color picker. Specify the textures by clicking Select and adding a texture of your choice. The materials can be found by in the Mapbox > Resources > MapboxStyles > Materials directory. MapboxStylesPerRenderer - you cannot set colors for feature layers in the inspector. Instead, Unity sets them programmatically using colors defined in a scriptable palette file. This shader uses Unity’s [PerRendererData] tag on color properties to allow for different renderers to modify those properties at runtime without creating material instances and incurring additional draw calls. To use this material, you must define a ScriptablePalette in the Material Options section of the Vector Layer Visualizer. Use it if you want buildings to have their base, detail_1, and detail_2 colors randomly assigned from a palette. Scriptable Palettes Scriptable Palettes are containers that can generate and hold a palette of colors. They inherit from Unity’s scriptable object class, which means they can be saved in a Unity project and used in multiple scenes. Scriptable Palettes require the use of MapboxStylesPerRenderer materials. Assign/Change the scriptable palette in use Select the gameObject containing the AbstractMap component, and navigate to the VECTOR settings. Navigate to Vector Layer Visualizers > ExtrudedBuildings > Material Options > Atlas Info. Create a new Scriptable Palette Right click or go to the Assets menu and navigate to Create > Mapbox > ScriptablePalette to create an ScriptablePalette file. Generate a palette of colors Define a Key Color. This will be used as a ‘seed’, from which other colors will be procedurally derived. Set a Palette Size. Choose how many colors will be in the palette. Define Hue, Saturation and Value ranges. Hue Range. Hue Range is used to define how far colors in the palette can deviate from the key color's hue. Saturation Range. Saturation Range is used to define how far colors in the palette can deviate from the key color's saturation. Value Range. Value Range is used to define how far colors in the palette can deviate from the key color's value. Click Generate Palette. To make any changes to your palette, repeat steps 1-4 until you are satisfied with it. You can edit the final colors in the inspector. If desired, set Color Overrides. This provides a method for directly setting colors for feature layers. For instance, you can enable Override Detail 2 to directly assign a chosen color to all windows. In this case, Override Detail 2 sets all windows to black to give buildings a night aesthetic. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Map texturing,MapboxStyles materials,Scriptable Palettes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Understanding iOS framework size,Learn how to measure and optimize your iOS app’s size.,https://docs.mapbox.com/help/troubleshooting/ios-framework-size/,troubleshooting,,,"Understanding iOS framework size The Mapbox Maps SDK for iOS provides much functionality and countless customization options at high performance, requiring somewhat more storage space than a less complex framework would. Nonetheless, the SDK contributes only 3–4 megabytes to the ultimate size of your application, thanks to various optimization steps that occur during the compilation and App Store submission processes. App thinning Apple packages optimized, device-specific versions of your app via app thinning. What your users download only includes code and resources required by their specific device. You can generate an app size report using Xcode or look at the “App Store File Sizes” report in iTunes Connect to see what the actual initial download size of your app will be. Note that these figures represent the maximum amount that your users will download — see the application updates section of this page for more information on how updates are optimized. CPU architectures Our framework includes a “fat” (multi-architecture) binary that contains slices for armv7, arm64, i386, and x86_64 CPU architectures. ARM slices are used by physical iOS devices, while i386 and x86_64 are used by Simulator and are stripped from your app during the build and archive process. When a user downloads your app from the App Store, they receive only the architecture that their device requires. Bitcode Bitcode is included for ARM architectures but does not affect the final size of your application. Bitcode is an unoptimized intermediate code representation that is used by Apple for potential recompilation and re-optimization of your app binary, after App Store submission. As metadata solely intended for build optimization, bitcode is never downloaded by your users. If you have disabled bitcode in your project, it is not necessary for you to remove bitcode from frameworks that contain it. Regardless of whether your app takes advantage of bitcode, the version of your app that the App Store delivers to your users never contains bitcode. Application updates When you update your application, your users download only the files that have changed in that update. These partial updates are commonly known as “delta updates”. If resources and binaries in your app have not changed, they will not be downloaded again. See Apple’s Reducing Download Size for iOS App Updates guide for more information on how to take advantage of delta updates. Debug symbols The Mapbox Maps SDK for iOS framework download includes dSYM and BCSymbolMap files. These are used for crash symbolication and are not included in the app that your users download. Dynamic versus static frameworks Following Apple’s platform guidelines, Mapbox recommends using the dynamic-linked version of our SDK in your app. If you have installed our SDK via CocoaPods or Carthage, you are already using our dynamic framework. See Apple’s Overview of Dynamic Libraries for information on how dynamic libraries work and a discussion of their benefits. Mapbox does additionally build and publish a statically-linked version of our SDK, but we do not recommend it for general use. Reducing the size of your app We recommend that you read Apple’s Reducing the size of my App guide to learn about ways to accurately measure and reduce the size of your app. The Mapbox team is constantly optimizing the size of our framework, making sure that your users only get the bits they need to enjoy your maps. If you have any questions or concerns, reach out to our support team. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Understanding iOS framework size,Bitcode,Application updates,Debug symbols,Dynamic versus static frameworks,Reducing the size of your app,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Geographic Analytics,Getting started,Getting Started with the Extension.,https://docs.mapbox.com/geographic-analytics/overview/start/,guide,,,"Getting started Open Tableau Desktop Once you have downloaded the TREX file, open Tableau Desktop and build a visualization. Once you have created your initial dashboard, drag the Geographic Analytics Extension into your dashboard. Grant permissions You will be prompted with a request that grants the extension full data permissions. This is what allows the extension to query the data contained in your workbook. There is no communication between your Tableau environment and Mapbox, except to render map tiles. Mapbox has no knowledge of the data being queried or your interactions with Tableau. Create your first visualization Once you click Allow the map should initialize instantly, and you will be presented with a cluster visualization.         The Geographic Analytics Extension automatically binds to the first sheet on the dashboard and searches for the Latitude and Longitude columns present in that worksheet's data connection. For the extension to function, your columns must be named Latitude and Longitude within Tableau Desktop. As with all Tableau extensions, the Geographic Analytics Extension is limited to the first 10,000 rows, so there is a chance you may see a Too much data error. Don't be alarmed, this is the extension working as intended. You visualization will still render, however each interaction will throw the Too much data error. To resolve, select a smaller subset of your data OR filter it upstream via your data source. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Getting started,Create your first visualization,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Maps SDK for iOS,The Mapbox Maps SDK for iOS is an open source toolset for building mapping applications for iPhone and iPad devices.,https://docs.mapbox.com/help/glossary/mapbox-ios-sdk/,glossary,,,Mapbox Maps SDK for iOS The Mapbox Maps SDK for iOS is an open source toolset for building mapping applications for iPhone and iPad devices with flexibility for visual styling and customizability. Maps SDK for iOS documentation Maps SDK for iOS on GitHub Guides to getting started with the Maps SDK for iOS Was this page helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Mapbox Maps SDK for iOS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,baselayer,A baselayer provides geographic context and serves as a starting point for your map.,https://docs.mapbox.com/help/glossary/baselayer/,glossary,,,"baselayer Note Mapbox Studio Classic, which uses baselayers, is no longer in active development. To learn more about our newer mapping tools see Mapbox Studio. A baselayer often refers to the map style that you designed in Mapbox Studio Classic. The baselayer provides geographic context and serves as a starting point for your map. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,baselayer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Core library,Android,Introduction,"Overview of the Mapbox Core Libraries for Android. Easily handle device location, permissions, and connectivity for any app.",https://docs.mapbox.com/android/core/overview/,guide,,,"Android Core library Current version: v 1.3.0 View changelog Real-time device location Checking and requesting permissions Connectivity Contribute on GitHub The Mapbox Core Libraries for Android are a set of utilities that help you with permissions, device location, and connectivity within your Android project. With these libraries, you can: Check for, request, and respond to any number of Android system permissions such as device location or camera. Check for and respond to a change in the device's internet connectivity status. Retrieve a device's real-time location. This core module has no dependencies on any of the other Mapbox Java modules and only depends on having the Android API plugin inside your project. Installation Gradle Open Android Studio. Open up your application's build.gradle file. Make sure that your project's minSdkVersion is at API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-core version (see below). Click on Sync Project with Gradle Files near the toolbar in Android Studio. implementation 'com.mapbox.mapboxsdk:mapbox-android-core: 1.3.0 ' Note: ProGuard directives are included in the Android dependencies to preserve the required classes. ConnectivityReceiver ConnectivityReceiver is a BroadcastReceiver that helps you keep track of the device's connectivity status. When used statically by calling getSystemConnectivity(), the ConnectivityReceiver will always return the connectivity status as reported by the Android system. You have the option to set a connectedFlag when instantiating ConnectivityReceiver. You can override the connectivity value reported by the system by setting this flag to true or false. If left in its default value (null), ConnectivityReceiver will report the system value. ConnectivityReceiver also lets you subscribe to connectivity changes using a ConnectivityListener interface. ConnectivityListener ConnectivityListener is a callback that is used with the ConnectivityReceiver. You can implement the ConnectivityListener interface where you'd like and then will need to override its onConnectivityChanged() method. This method returns a boolean, which is whether the device's new connectivity state is connected or not. PermissionsManager If you build your Android project targeting API level 23 or higher, then your application will need to request permission during runtime. Handling this directly in your activity produces boilerplate code and can often be hard to manage. That's where the PermissionsManager class comes into play. With the PermissionsManager class, you can check whether the user has granted location permission and request permissions if the user hasn't granted them yet. You can use PermissionsManager permissionsManager = new PermissionsManager(this); if you're implementing PermissionsListener. Once you have set up your permissions manager, you will still need to override onRequestPermissionsResult() and call the permissionsManager's same method. Note: The PermissionsManager can be used for requesting other permissions in addition to location. Java Kotlin PermissionsManager permissionsManager = new PermissionsManager(this); if (PermissionsManager.areLocationPermissionsGranted(this)) { // Permission sensitive logic called here, such as activating the Maps SDK's LocationComponent to show the device's location } else { permissionsManager = new PermissionsManager(this); permissionsManager.requestLocationPermissions(this); } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { permissionsManager.onRequestPermissionsResult(requestCode, permissions, grantResults); } Copy PermissionsListener The PermissionsListener is an interface that needs to be set up and passed into the PermissionsManager's constructor. You can use permissionsManager = new PermissionsManager(this); if you're implementing PermissionsListener. You'll notice that PermissionsListener overrides the onExplanationNeeded() and onPermissionResult() methods. An explanation isn't required but strongly encouraged to allow the user to understand why you are requesting this permission. The permission result is invoked once the user decides whether to allow or deny the permission. A boolean value is given, which you can then use to write an if statement. Both cases should be handled correctly. Continue with your permission-sensitive logic if the user approves. Otherwise, if the user denies, display a message that tells the user that the permission is required for your application to work. Java Kotlin PermissionsListener permissionsListener = new PermissionsListener() { @Override public void onExplanationNeeded(List<String> permissionsToExplain) { } @Override public void onPermissionResult(boolean granted) { if (granted) { // Permission sensitive logic called here, such as activating the Maps SDK's LocationComponent to show the device's location } else { // User denied the permission } } }; Copy LocationEngine If your application needs location information, the LocationEngine class can help you get this information while also simplifying the process and being flexible enough to use different services. The LocationEngine found in the core module now supports the following location providers: Google's Fused Location Providers Android GPS and Network Providers If you are using the Mapbox Maps SDK for Android, create a LocationEngine object using: Java Kotlin LocationEngine locationEngine = LocationEngineProvider.getBestLocationEngine(this); Copy This will obtain the best location engine that is available and eliminate the need to create a new LocationEngine from scratch. Requesting location updates You'll need a class that implements LocationEngineCallback<LocationEngineResult>. Make sure the class requires Android system Activity as a constructor parameter. This class will serve as a ""callback"" and it's needed because a LocationEngine memory leak is possible if the activity/fragment directly implements the LocationEngineCallback<LocationEngineResult>. The WeakReference setup avoids the leak. When implementing the LocationEngineCallback interface, you are also required to override the onSuccess() and onFailure() methods. OnSuccess() runs whenever the Mapbox Core Libraries identifies a change in the device's location. result.getLastLocation() gives you a Location object that contains the latitude and longitude values. Now you can display the values in your app's UI, save it in memory, send it to your backend server, or use the device location information how you'd like. Java Kotlin private static class LocationListeningCallback implements LocationEngineCallback<LocationEngineResult> { private final WeakReference<MainActivity> activityWeakReference; LocationListeningCallback(MainActivity activity) { this.activityWeakReference = new WeakReference<>(activity); } @Override public void onSuccess(LocationEngineResult result) { // The LocationEngineCallback interface's method which fires when the device's location has changed. Location lastLocation = result.getLastLocation(); } @Override public void onFailure(@NonNull Exception exception) { // The LocationEngineCallback interface's method which fires when the device's location can not be captured } } Copy Globally declare an instance of the class you created above: Java Kotlin private LocationListeningCallback callback = new LocationListeningCallback(this); Copy Request location updates once you know location permissions have been granted: Java Kotlin long DEFAULT_INTERVAL_IN_MILLISECONDS = 1000L; long DEFAULT_MAX_WAIT_TIME = DEFAULT_INTERVAL_IN_MILLISECONDS * 5; LocationEngine locationEngine = LocationEngineProvider.getBestLocationEngine(this); LocationEngineRequest request = new LocationEngineRequest.Builder(DEFAULT_INTERVAL_IN_MILLISECONDS) .setPriority(LocationEngineRequest.PRIORITY_NO_POWER) .setMaxWaitTime(DEFAULT_MAX_WAIT_TIME) .build(); locationEngine.requestLocationUpdates(request, callback, getMainLooper()); locationEngine.getLastLocation(callback); Copy To prevent your application from having a memory leak, it is a good idea to stop requesting location updates inside of your activity's onStop() method. Java Kotlin @Override protected void onStop() { super.onStop(); if (locationEngine != null) { locationEngine.removeLocationUpdates(callback); } mapView.onStop(); } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Android Core library,ConnectivityReceiver,ConnectivityListener,PermissionsManager,PermissionsListener,LocationEngine,Requesting location updates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,attribution,"Attribution is the combination of two visual elements that are placed on all Mapbox maps, stating that a map was created with Mapbox tools and data.",https://docs.mapbox.com/help/glossary/attribution/,glossary,,,"attribution Attribution is the combination of two visual elements that are placed on all Mapbox maps, stating that a map was created with Mapbox tools and data. Mapbox requires all maps to include the Mapbox wordmark and text attribution. The Mapbox wordmark is a small image containing the stylized word ""Mapbox"" and the Mapbox logo. The text attribution contains at least three links: © Mapbox, © OpenStreetMap and Improve this map. This attribution is strictly required when using the Mapbox Streets tileset due to OpenStreetMap's data source ODbL license. Some other Mapbox-provided tilesets require additional attribution which is stored in the TileJSON of the tileset. For more information about how and when attribution is required, see our attribution guide. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,attribution,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Troubleshooting App Store submission with the Mapbox Maps SDK for iOS,Learn how to troubleshoot frequently seen issues when submitting applications built with the Mapbox Maps SDK for iOS to the App Store.,https://docs.mapbox.com/help/troubleshooting/ios-sdk-submission/,troubleshooting,,,"Troubleshooting App Store submission with the Mapbox Maps SDK for iOS Framework errors If you have installed the Mapbox Maps SDK for iOS manually, you may see an App Store bug that results in the following error when submitting your application to the App Store: ERROR ITMS-90087: Unsupported Architectures. The executable for YourApp.app/Frameworks/Mapbox.framework contains unsupported architectures '[x86_64, i386]' To avoid this, you'll need to add the following script in the Build Phases tab of your project. This script will remove architectures for simulators, which is not necessary for App Store submission. ""$ { BUILT_PRODUCTS_DIR } /$ { FRAMEWORKS_FOLDER_PATH } /Mapbox.framework/strip-frameworks.sh"" If you have installed the Mapbox framework with CocoaPods or Carthage, adding this script is not necessary. If you're still running into issues working with the Mapbox Maps SDK for iOS, reach out to our support team, providing as much detail as possible so we can help better understand your issue. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Troubleshooting App Store submission with the Mapbox Maps SDK for iOS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Map and app styling,Customize the map style and the style of UI elements in your application.,https://docs.mapbox.com/ios/navigation/overview/app-styling/,guide,,,"Map and app styling When using NavigationMapViewController, it's possible to apply custom fonts and colors to various parts of the UI. Customize the style of UI elements The easiest way to find elements and their class name to style is to use the Debug View Hierarchy feature in Xcode. While running your app, select the Debug View Hierarchy button. Select the view you wish to style. On the right side of your screen, note the class name. Apply your styling: DistanceLabel.appearance(whenContainedInInstancesOf: [InstructionsBannerView.self]).unitTextColor = .red It is also helpful to view the default styling applied by the DayStyle. Customize the map style Create a new Style class Subclass DayStyle, and make the necessary changes: class CustomDayStyle: DayStyle { required init() { super.init() // Use a custom map style. mapStyleURL = MGLStyle.satelliteStreetsStyleURL! previewMapStyleURL = MGLStyle.satelliteStreetsStyleURL! // Specify that the style should be used during the day. styleType = .day } override func apply() { super.apply() // Begin styling the UI BottomBannerView.appearance().backgroundColor = .orange } } You can provide a custom night style that will be used at night and while the user is in tunnels. class CustomNightStyle: NightStyle { required init() { super.init() // Specify that the style should be used at night. styleType = .night } override func apply() { super.apply() // Begin styling the UI BottomBannerView.appearance().backgroundColor = .purple } } Then, initialize NavigationMapViewController with these styles. let options = NavigationOptions(styles: [CustomDayStyle(), CustomNightStyle()]) let navigation = NavigationViewController(for: route, options: options Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Map and app styling,Create a new Style class,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a video,Satellite raster baselayer with video on top. Click on the map to play and pause.,https://docs.mapbox.com/mapbox-gl-js/example/video-on-a-map/,example,JavaScript,,Add a video Satellite raster baselayer with video on top. Click on the map to play and pause. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Add a video,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a custom style layer,Use a custom style layer to render custom WebGL content.,https://docs.mapbox.com/mapbox-gl-js/example/custom-style-layer/,example,JavaScript,,Add a custom style layer Use a custom style layer to render custom WebGL content. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Add a custom style layer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for iOS,iOS,Introduction,Introduction to the Mapbox Vision SDK for iOS.,https://docs.mapbox.com/ios/vision/overview/,guide,,,"Vision SDK for iOS Beta This feature is in public beta and is subject to potential changes. Current version: v 0.7.1 View changelog AI and AR features for drivers that run on today’s mobile and embedded applications Build augmented reality navigation with turn-by-turn directions and custom objects Create custom alerts for speeding, lane departures, tailgating, and more Neural networks run on-device: real time performance without taxing your data plan Install The Mapbox Vision SDK for iOS is a library for interpreting road scenes in real-time directly on iOS devices using the device’s built-in camera. Features include: Classification and display of regulatory and warning signs Object detection for vehicles, pedestrians, road signs, and traffic lights Semantic segmentation of the roadway into 14 different classes Augmented reality navigation with global coverage Support for external cameras: WiFi or wired connection SDK structure The Vision SDK for iOS is composed of three libraries you can interact with directly: Vision, Vision AR, and Vision Safety. All three depend on the VisionCore module. Available libraries Vision (Vision) is the primary library, needed for any application of Mapbox Vision. Its components enable camera configuration, display of classification, detection, and segmentation layers, lane feature extraction, and other interfaces. Vision accesses real-time inference running in Vision Core. Vision AR (VisionAR) is an add-on module for Vision used to create customizable augmented reality experiences. It allows configuration of the user’s route visualization: lane material (shaders, textures), lane geometry, occlusion, custom objects, and more. Read more in the AR navigation guide. Vision Safety (VisionSafety) is an add-on module for Vision used to create customizable alerts for speeding, nearby vehicles, cyclists, pedestrians, lane departures, and more. Read more in the Safety alerts guide. Core logic Vision Core is the core logic of the system, including all machine learning models. Importing any of the Vision-related modules listed above into your project automatically brings VisionCore along. Requirements The Vision SDK for iOS is written in Swift 4.2 and can be used with iOS 11.2 and higher on iPhone 6s or newer. Use of the Vision SDK requires that the device is pointed with a view of the road. We strongly recommend using a dashboard or windshield mount to keep your phone oriented correctly while you drive. We have tested a few options and have seen positive results with two mounts (option 1 and option 2). Getting started To set up the Vision SDK you will need to download the SDK, install the frameworks relevant to your project, and complete a few configuration steps. Download and install the SDK Download from vision.mapbox.com/install You must download the relevant frameworks from vision.mapbox.com/install before continuing. You can download the framework directly or import it into your project with CocoaPods or Carthage. This will require that you are logged into your Mapbox account. SDK configuration After downloading or importing the SDK into your project, configure the following in your Xcode project. Set your Mapbox access token Mapbox APIs require a Mapbox account and access token. Get an access token from the Mapbox account page. In the project editor, select the application target, then go to the Info tab. Under the “Custom iOS Target Properties” section, set MGLMapboxAccessToken to your access token. Configure permissions In order for the SDK to track the user’s location, set NSLocationWhenInUseUsageDescription and NSLocationAlwaysAndWhenInUseUsageDescription to a description of location usage. Set NSCameraUsageDescription to a description of camera usage. Set up the ViewController Required: Import relevant modules, MapboxVision being required. import MapboxVision // OPTIONAL: include Vision AR functionality import MapboxVisionAR // OPTIONAL: include Vision Safety functionality import MapboxVisionSafety Required: Initialize video source and create instance of VisionManager with it. let videoSource = CameraVideoSource() let visionManager = VisionManager.create(videoSource: videoSource) Optional: If you want to subscribe to AR events, create VisionARManager. // Create AR module // `self` should implement `VisionARManagerDelegate` protocol let visionARMAnager = VisionARManager.create(visionManager: visionManager, delegate: self) Optional: If you want to subscribe to Safety events, create VisionSafetyManager. // Create Safety module // `self` should implement `VisionSafetyManagerDelegate` protocol let visionSafetyManager = VisionSafetyManager.create(visionManager: visionManager, delegate: self) Required: Control events sending with an instance of VisionManager. videoSource.start() // `self` should implement `VisionManagerDelegate` protocol visionManager.start(delegate: self) visionManager.stop() Required: Clean up the resources when you don’t need them anymore. videoSource.stop() visionManager.stop() // AR and/or Safety should be destroyed first visionARManager.destroy() visionSafetyManager.destroy() // Finally destroy instance of `VisionManager` visionManager.destroy() Device setup After installing the framework, you will need to set up the device in the vehicle. Some things to consider when choosing and setting up a mount: Generally, shorter length mounts will vibrate less. Mounting to your windshield or to the dashboard itself are both options. Place the phone near or behind your rearview mirror. Note that your local jurisdiction may have limits on where mounts may be placed. Make sure the phone’s camera view is unobstructed (you will be able to tell with any of the video screens open). Testing and development Read more about setting up your development environment for testing the capabilities of the Vision SDK in the Testing and development guide. Conditions Pricing: For details on pricing, read the Vision FAQ. Attribution: While the Vision SDK is using the camera you must display the Mapbox watermark on screen. Read more about attribution requirements in our terms of service. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Vision SDK for iOSBetaThis feature is in public beta and is subject to potential changes.,Core logic,Requirements,Getting started,Download and install the SDK,SDK configuration,Set your Mapbox access token,Configure permissions,Set up the ViewController,Device setup,Testing and development,Conditions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,GPX,GPX (GPS eXchange format) is a data format commonly created from GPS receivers.,https://docs.mapbox.com/help/glossary/gpx/,glossary,,,"GPX GPX, or GPS eXchange format, is a data format commonly created from GPS receivers. You can upload GPX files to your Mapbox account to use in a custom map style. See the Mapbox Studio manual uploads page for details. Below is a sample GPX file for reference. Please note that Mapbox does not support values along lines (for example, elevation and time at various points along a jogging route). A GPX file with values along a line can be uploaded, but Mapbox will ignore any data along the line. Download a sample GPX file Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,GPX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Vector Tiles API,The Mapbox Vector Tiles API allows you to request a single tile from a Mapbox-hosted vector tileset.,https://docs.mapbox.com/help/glossary/vector-tiles-api/,glossary,,,"Vector Tiles API The Mapbox Vector Tiles API serves vector tiles. Each API request results in a single tile from a vector tileset. Vector Tiles API requests are typically made as a series of requests used to render a map using a Mapbox GL map library. A sample Vector Tiles API request looks like: https://api.mapbox.com/v4/mapbox.mapbox-streets-v8/12/1171/1566.mvt?access_token= YOUR_MAPBOX_ACCESS_TOKEN The Vector Tiles API has optional parameters that can be used to refine the results of a request. Vector Tiles API requests and map loads Web maps using any version of Mapbox GL JS before v1.0.0 are billed by Vector Tiles API requests and Raster Tiles API requests rather than map loads. To be billed by map loads instead of tile requests, you must update to Mapbox GL JS v1.0.0 or higher. Related resources: Vector Tiles API documentation Pricing by product Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Vector Tiles API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Make a geocode request,Use the Geocoding API to receive information about specific coordinates.,https://docs.mapbox.com/android/java/examples/geocoding/,example,Java,,"Make a geocode request Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.javaservices.GeocodingActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""-12.0463"" mapbox:mapbox_cameraTargetLng=""-77.0427"" mapbox:mapbox_cameraZoom=""11"" /> <androidx.cardview.widget.CardView android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:layout_marginRight=""8dp""> <LinearLayout android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:background=""#fff"" android:orientation=""vertical""> <androidx.constraintlayout.widget.ConstraintLayout android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:paddingBottom=""8dp""> <Button android:id=""@+id/choose_city_spinner_button"" android:layout_width=""0dp"" android:layout_height=""44dp"" android:layout_weight=""1.25"" android:background=""@color/mapboxBlue"" android:gravity=""center"" android:padding=""8dp"" android:text=""@string/choose_city_spinner"" android:textAllCaps=""false"" android:textColor=""@android:color/white"" mapbox:layout_constraintBottom_toBottomOf=""@+id/start_geocode_button"" mapbox:layout_constraintStart_toEndOf=""@+id/start_geocode_button"" mapbox:layout_constraintTop_toBottomOf=""@+id/geocode_latitude_editText"" /> <EditText android:id=""@+id/geocode_latitude_editText"" android:layout_width=""100dp"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:hint=""@string/latitude"" android:inputType=""numberDecimal|numberSigned"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" /> <EditText android:id=""@+id/geocode_longitude_editText"" android:layout_width=""100dp"" android:layout_height=""45dp"" android:hint=""@string/longitude"" android:inputType=""numberDecimal|numberSigned"" mapbox:layout_constraintLeft_toRightOf=""@id/geocode_latitude_editText"" mapbox:layout_constraintTop_toTopOf=""@+id/geocode_latitude_editText"" tools:layout_editor_absoluteX=""116dp"" /> <Button android:id=""@+id/start_geocode_button"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:backgroundTint=""#37b426"" android:text=""@string/geocode"" android:textAllCaps=""false"" android:textColor=""#FFFFFF"" mapbox:layout_constraintStart_toStartOf=""@+id/geocode_latitude_editText"" mapbox:layout_constraintTop_toBottomOf=""@+id/geocode_latitude_editText"" /> <Button android:id=""@+id/map_center_button"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:backgroundTint=""@color/mapboxRedDark"" android:text=""@string/map_center"" android:textAllCaps=""false"" android:textColor=""#FFFFFF"" mapbox:layout_constraintStart_toStartOf=""@+id/start_geocode_button"" mapbox:layout_constraintTop_toBottomOf=""@+id/start_geocode_button"" /> <TextView android:id=""@+id/textView4"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:text=""@string/geocoding_results"" android:textStyle=""bold"" mapbox:layout_constraintStart_toEndOf=""@+id/geocode_longitude_editText"" mapbox:layout_constraintTop_toTopOf=""@+id/geocode_longitude_editText"" /> <ScrollView android:id=""@+id/scrollView2"" android:layout_width=""0dp"" android:layout_height=""0dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toEndOf=""@+id/geocode_longitude_editText"" mapbox:layout_constraintTop_toBottomOf=""@+id/textView4""> <TextView android:id=""@+id/geocode_result_message"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:scrollbars=""vertical"" android:textSize=""15sp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toEndOf=""@+id/geocode_latitude_editText"" mapbox:layout_constraintTop_toTopOf=""@+id/geocode_latitude_editText"" /> </ScrollView> </androidx.constraintlayout.widget.ConstraintLayout> </LinearLayout> </androidx.cardview.widget.CardView> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.ListPopupWindow; import android.text.TextUtils; import android.view.View; import android.widget.AdapterView; import android.widget.ArrayAdapter; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; import android.widget.Toast; import com.mapbox.api.geocoding.v5.GeocodingCriteria; import com.mapbox.api.geocoding.v5.MapboxGeocoding; import com.mapbox.api.geocoding.v5.models.CarmenFeature; import com.mapbox.api.geocoding.v5.models.GeocodingResponse; import com.mapbox.core.exceptions.ServicesException; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import java.util.ArrayList; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; /** * Use the Mapbox Geocoding API to retrieve various information about a set of coordinates. */ public class GeocodingActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private MapboxMap mapboxMap; private Button chooseCityButton; private EditText latEditText; private EditText longEditText; private TextView geocodeResultTextView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_javaservices_geocoding); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initTextViews(); initButtons(); } }); } private void initTextViews() { latEditText = findViewById(R.id.geocode_latitude_editText); longEditText = findViewById(R.id.geocode_longitude_editText); geocodeResultTextView = findViewById(R.id.geocode_result_message); } private void initButtons() { Button mapCenterButton = findViewById(R.id.map_center_button); Button startGeocodeButton = findViewById(R.id.start_geocode_button); chooseCityButton = findViewById(R.id.choose_city_spinner_button); startGeocodeButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // Make sure the EditTexts aren't empty if (TextUtils.isEmpty(latEditText.getText().toString())) { latEditText.setError(getString(R.string.fill_in_a_value)); } else if (TextUtils.isEmpty(longEditText.getText().toString())) { longEditText.setError(getString(R.string.fill_in_a_value)); } else { if (latCoordinateIsValid(Double.valueOf(latEditText.getText().toString())) && longCoordinateIsValid(Double.valueOf(longEditText.getText().toString()))) { // Make a geocoding search with the values inputted into the EditTexts makeGeocodeSearch(new LatLng(Double.valueOf(latEditText.getText().toString()), Double.valueOf(longEditText.getText().toString()))); } else { Toast.makeText(GeocodingActivity.this, R.string.make_valid_lat, Toast.LENGTH_LONG).show(); } } } }); chooseCityButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { showCityListMenu(); } }); mapCenterButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // Get the map's target LatLng target = mapboxMap.getCameraPosition().target; // Fill the coordinate EditTexts with the target's coordinates setCoordinateEditTexts(target); // Make a geocoding search with the target's coordinates makeGeocodeSearch(target); } }); } private boolean latCoordinateIsValid(double value) { return value >= -90 && value <= 90; } private boolean longCoordinateIsValid(double value) { return value >= -180 && value <= 180; } private void setCoordinateEditTexts(LatLng latLng) { latEditText.setText(String.valueOf(latLng.getLatitude())); longEditText.setText(String.valueOf(latLng.getLongitude())); } private void showCityListMenu() { List<String> modes = new ArrayList<>(); modes.add(""Vancouver""); modes.add(""Helsinki""); modes.add(""Lima""); modes.add(""Osaka""); ArrayAdapter<String> profileAdapter = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, modes); final ListPopupWindow listPopup = new ListPopupWindow(this); listPopup.setAdapter(profileAdapter); listPopup.setAnchorView(chooseCityButton); listPopup.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView<?> adapterView, View view, int position, long longg) { LatLng cityLatLng = new LatLng(); if (position == 0) { // Vancouver cityLatLng = new LatLng(49.2827, -123.1207); setCoordinateEditTexts(cityLatLng); } else if (position == 1) { // Helsinki cityLatLng = new LatLng(60.1698, 24.938); setCoordinateEditTexts(cityLatLng); } else if (position == 2) { // Lima cityLatLng = new LatLng(-12.0463, -77.0427); setCoordinateEditTexts(cityLatLng); } else if (position == 3) { // Osaka cityLatLng = new LatLng(34.693, 135.5021); setCoordinateEditTexts(cityLatLng); } animateCameraToNewPosition(cityLatLng); makeGeocodeSearch(cityLatLng); listPopup.dismiss(); } }); listPopup.show(); } private void makeGeocodeSearch(final LatLng latLng) { try { // Build a Mapbox geocoding request MapboxGeocoding client = MapboxGeocoding.builder() .accessToken(getString(R.string.access_token)) .query(Point.fromLngLat(latLng.getLongitude(), latLng.getLatitude())) .geocodingTypes(GeocodingCriteria.TYPE_PLACE) .mode(GeocodingCriteria.MODE_PLACES) .build(); client.enqueueCall(new Callback<GeocodingResponse>() { @Override public void onResponse(Call<GeocodingResponse> call, Response<GeocodingResponse> response) { List<CarmenFeature> results = response.body().features(); if (results.size() > 0) { // Get the first Feature from the successful geocoding response CarmenFeature feature = results.get(0); geocodeResultTextView.setText(feature.toString()); animateCameraToNewPosition(latLng); } else { Toast.makeText(GeocodingActivity.this, R.string.no_results, Toast.LENGTH_SHORT).show(); } } @Override public void onFailure(Call<GeocodingResponse> call, Throwable throwable) { Timber.e(""Geocoding Failure: "" + throwable.getMessage()); } }); } catch (ServicesException servicesException) { Timber.e(""Error geocoding: "" + servicesException.toString()); servicesException.printStackTrace(); } } private void animateCameraToNewPosition(LatLng latLng) { mapboxMap.animateCamera(CameraUpdateFactory .newCameraPosition(new CameraPosition.Builder() .target(latLng) .zoom(13) .build()), 1500); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Make a geocode request,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Browser support,Learn which browsers support each Mapbox product.,https://docs.mapbox.com/help/troubleshooting/mapbox-browser-support/,troubleshooting,,,"Browser support The following is a list of browsers that are compatible with Mapbox tools. Mapbox Studio Mapbox Studio is supported in browsers that support WebGL, a method of generating dynamic 3D graphics using JavaScript, accelerated through hardware. Mapbox Studio is compatible with all modern browsers, specifically: Safari 9 and above. Chrome latest. Firefox latest. Microsoft Edge 13 (with the most recent Windows 10 update). The Mapbox Studio style editor and dataset editor are not compatible with Internet Explorer. But you can access all other pages and features located from in the Mapbox Studio dashboard using Internet Explorer 10+. This includes, but is not limited to, your account information, statistics, Mapbox Studio Classic styles, and Mapbox Editor projects. We cannot guarantee that Mapbox Studio will work with browsers that only support WebGL experimentally. For further information, see caniuse.com to check for the most recent supported browsers or see get.webgl.org to check if your browser supports WebGL. Mapbox GL JS Like Mapbox Studio, Mapbox GL JS is supported in most modern browsers. The same requirements for Mapbox Studio apply to Mapbox GL JS. In general, recent versions of Internet Explorer 11 and Microsoft Edge are compatible with Mapbox GL JS. But because certain versions of IE11 and Edge don't support necessary features for WebGL or offer fixes for related browser bugs, and because the underlying hardware must support WebGL, we can't guarantee support for all versions of either browser. To test your clients' support for your applications, see our example for checking browser compatibility. Mapbox.com Internet Explorer versions 9 and below are not supported on Mapbox.com. Mapbox.js Mapbox.js is supported in most modern browsers including Internet Explorer 8+. Support for Internet Explorer versions does not include those versions in previous-version compatibility modes, such as Internet Explorer 8 in IE7 Compatibility Mode. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Browser support,Mapbox.com,Mapbox.js,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add an animated icon to the map,Add an animated icon to the map that was generated at runtime with a Canvas.,https://docs.mapbox.com/mapbox-gl-js/example/add-image-animated/,example,JavaScript,,Add an animated icon to the map Add an animated icon to the map that was generated at runtime with a Canvas. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Add an animated icon to the map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Mark a place on the map with an image,Add a point annotation with a custom image.,https://docs.mapbox.com/ios/maps/examples/marker-image/,example,Swift,Objective-C,"Mark a place on the map with an image Download the Tower of Pisa asset catalog and add it to your project. This example uses MGLAnnotationImage, which is intended to be used with small, static images. For interactive annotations with larger images or animation, use MGLAnnotationView (example). To learn about more ways to add points to a map, see the Markers and annotations guide. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.lightStyleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .darkGray // Set the map's bounds to Pisa, Italy. let bounds = MGLCoordinateBounds( sw: CLLocationCoordinate2D(latitude: 43.7115, longitude: 10.3725), ne: CLLocationCoordinate2D(latitude: 43.7318, longitude: 10.4222)) mapView.setVisibleCoordinateBounds(bounds, animated: false) view.addSubview(mapView) // Set the map view‘s delegate property. mapView.delegate = self // Initialize and add the point annotation. let pisa = MGLPointAnnotation() pisa.coordinate = CLLocationCoordinate2D(latitude: 43.72305, longitude: 10.396633) pisa.title = ""Leaning Tower of Pisa"" mapView.addAnnotation(pisa) } func mapView(_ mapView: MGLMapView, imageFor annotation: MGLAnnotation) -> MGLAnnotationImage? { // Try to reuse the existing ‘pisa’ annotation image, if it exists. var annotationImage = mapView.dequeueReusableAnnotationImage(withIdentifier: ""pisa"") if annotationImage == nil { // Leaning Tower of Pisa by Stefan Spieler from the Noun Project. var image = UIImage(named: ""pisavector"")! // The anchor point of an annotation is currently always the center. To // shift the anchor point to the bottom of the annotation, the image // asset includes transparent bottom padding equal to the original image // height. // // To make this padding non-interactive, we create another image object // with a custom alignment rect that excludes the padding. image = image.withAlignmentRectInsets(UIEdgeInsets(top: 0, left: 0, bottom: image.size.height/2, right: 0)) // Initialize the ‘pisa’ annotation image with the UIImage we just loaded. annotationImage = MGLAnnotationImage(image: image, reuseIdentifier: ""pisa"") } return annotationImage } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Mark a place on the map with an image,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Tabletop AR,An overview of the tabletop AR example.,https://docs.mapbox.com/unity/maps/examples/tabletop-ar/,example,No code,,"Tabletop AR The tabletop AR example makes it possible to overlay 3D maps and location data onto the AR camera feed using Unity’s AR Interface and location services. This article outlines the setup and purpose of each major part of the Tabletop AR example. Getting started To open the example, navigate to MapboxAR > Examples > Scenes > TabletopAR and double-click to open. You’ll see an AR prerequisites warning. Some layers that aren’t included by default in a Unity project and are needed to run this scene. Select ARTabletopKit in the Hierarchy view. Add the following layers by clicking Layer and selecting Add Layer Specify the following layers: ARGameObject Map Path Both The ARTabletopKit contains: AR Root: The UnityInterface Prefab for building cross-platform AR apps. MapHolder: Places the map on the plane and contains MapRoot as a child object. MapRoot contains the Abstract Map script and is where you can change the map settings as shown below. FocusSquare: Finds the plane on which to place the map. Editing the scene Click on MapRoot and find the Latitude Longitude settings in the GENERAL settings of the Abstract Map script. Click Search and enter the coordinates of anywhere in the world. For this example, we used New York City. Running in the editor Once you set up your project layers, play the scene. You should see the map in the Scene and Game views: Running on a device First, check that your device supports ARKit or ARCore. Build settings differ for iOS and Android. Check your Player Settings before you build: iOS: ARKit supports the METAL graphics API only. Select Metal or Auto Graphics API. iOS: Be sure to include a Camera Usage Description and Location Usage Description Android: Use OPENGL ES or Auto Graphics API. After you build to your device, find a flat surface such as a table top and align your camera. Your map will be visualized once the AR plane is detected. Below is a screenshot of New York City. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Tabletop AR,Running in the editor,Running on a device,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,tileset ID,"Tileset IDs, previously known as Map IDs, are used to identify vector and raster tilesets.",https://docs.mapbox.com/help/glossary/tileset-id/,glossary,,,"tileset ID Tileset ID or map ID? Tileset IDs were previously known as map IDs, a convention that originated from past versions of Mapbox in which map styles and map tiles were a unified concept (for instance, in a Mapbox Studio Classic style). In more recent versions of Mapbox, this ID instead refers to the ID of a specific tileset. Any time you upload data to your account as a tileset, Mapbox gives it a tileset ID. Tileset IDs will always start with your Mapbox username, followed by the tileset's unique alphanumeric identifier: username.identifier. To find the tileset ID for a specific tileset, go to your tilesets page. Click the options menu (the icon) to the right of a tileset's name to find its tileset ID. Note that styles made in the Mapbox Studio style editor and datasets uploaded to Mapbox Studio or created through the Mapbox Studio dataset editor do not have tileset IDs. Rather, they are identified with style URLs and dataset IDs. You can request tilesets directly using the Mapbox Vector Tiles API (for vector tiles) or the Raster Tiles API (for raster tiles). Tileset IDs in Mapbox Editor and Mapbox Studio Classic projects Tileset IDs are also used to identify projects created with Mapbox Editor and styles created with Mapbox Studio Classic. Both Mapbox Editor and Mapbox Studio Classic are legacy products and are no longer in active development. To learn more about our newer mapping tools, use Mapbox Studio. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,tileset ID,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Add a custom icon,Upload an SVG and add it to the map as a custom icon.,https://docs.mapbox.com/studio-manual/examples/custom-icon/,example,No code,,"Add a custom icon About this style SVG assets: Scalable Vector Graphics (SVG) is a markup language for describing two-dimensional vector graphics. You can upload SVG images to your custom style in the Mapbox Studio style editor. You can click on the Images option in the top toolbar to manage the SVGs in your style. In this example, an icon called mapbox-logo has been uploaded. Read more about troubleshooting SVG uploads in our SVG asset errors in Mapbox Studio guide. Symbol layer: Icons are added to the map using a symbol layer. Symbol layers are the most complex style type in Mapbox Studio. Symbol layer styling is separated into four main groups: Text, Icon, Position, and Placement. In this example, the Icon and Position options have been modified. Click on the country-label layer to explore the style properties in this style: In the Icon tab, the mapbox-logo icon is applied to several countries using data conditions: if name_en is equal to any of the names of countries with a Mapbox office, set the Image property to mapbox-logo. In the Position tab, both the Text anchor and the Icon offset property have been modified to anchor the text below the data point it is labeling and the icon is offset to be above the data point. Sprite: A sprite is a single image containing all icons included in a style. Sprites are often used in web development and even video games to improve performance. If you’re using Mapbox Studio, you don’t have to worry about the technical underpinnings of sprites, but if you're interested in learning more, you can read about sprites on our Help page. Related resources Looking for more guidance? Read our tutorials. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Add a custom icon,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Opacity fade,Adjust the opacity of a satellite raster layer based on zoom level.,https://docs.mapbox.com/android/maps/examples/satellite-opacity-on-zoom/,example,Java,,"Opacity fade Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.basics.SimpleMapViewActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""30.044"" mapbox:mapbox_cameraTargetLng=""31.235"" mapbox:mapbox_cameraZoom=""10"" mapbox:mapbox_cameraZoomMin=""6"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.RasterLayer; import com.mapbox.mapboxsdk.style.sources.RasterSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.linear; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.rasterOpacity; /** * Create an effect of seamlessly fading from one map style to another with runtime styling opacity. * Go from the Mapbox Streets style to a satellite photo raster layer as the map camera zooms in. * This is similar to how Snap uses Mapbox for Snap Maps. */ public class SatelliteOpacityOnZoomActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_satellite_opacity_on_zoom); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Create a data source for the satellite raster image and add the source to the map style.addSource(new RasterSource(""SATELLITE_RASTER_SOURCE_ID"", ""mapbox://mapbox.satellite"", 512)); // Create a new map layer for the satellite raster images and add the satellite layer to the map. // Use runtime styling to adjust the satellite layer's opacity based on the map camera's zoom level style.addLayer( new RasterLayer(""SATELLITE_RASTER_LAYER_ID"", ""SATELLITE_RASTER_SOURCE_ID"").withProperties( rasterOpacity(interpolate(linear(), zoom(), stop(15, 0), stop(18, 1) )))); // Create a new camera position and animate the map camera to show the fade in/out UI of the satellite layer mapboxMap.animateCamera( CameraUpdateFactory.newCameraPosition(new CameraPosition.Builder() .zoom(19) .build()), 9000); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Opacity fade,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Style circles categorically,Using a categorical circle-color property function for a visualization.,https://docs.mapbox.com/android/maps/examples/style-circles-categorically/,example,Java,,"Style circles categorically Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.basics.SimpleMapViewActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.753574"" mapbox:mapbox_cameraTargetLng=""-122.447303"" mapbox:mapbox_cameraZoom=""12"" /> </RelativeLayout> Copy Activity View on GitHub Java Kotlin package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.match; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.expressions.Expression.zoom; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; /** * Use data-driven styling to set circles' colors based on imported vector data. */ public class StyleCirclesCategoricallyActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_dds_style_circles_categorically); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource(new VectorSource( ""ethnicity-source"", ""http://api.mapbox.com/v4/examples.8fgz4egr.json?access_token="" + Mapbox.getAccessToken() )); CircleLayer circleLayer = new CircleLayer(""population"", ""ethnicity-source""); circleLayer.setSourceLayer(""sf2010""); circleLayer.withProperties( circleRadius( interpolate( exponential(1.75f), zoom(), stop(12, 2f), stop(22, 180f) )), circleColor( match(get(""ethnicity""), rgb(0, 0, 0), stop(""white"", rgb(251, 176, 59)), stop(""Black"", rgb(34, 59, 83)), stop(""Hispanic"", rgb(229, 94, 94)), stop(""Asian"", rgb(59, 178, 208)), stop(""Other"", rgb(204, 204, 204))))); style.addLayer(circleLayer); } }); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Style circles categorically,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Transition from Mapbox.js to Mapbox GL JS,Learn about transitioning from using Mapbox.js to using Mapbox GL JS in your apps.,https://docs.mapbox.com/help/troubleshooting/transition-from-mapbox-js-to-mapbox-gl-js/,troubleshooting,,,"Transition from Mapbox.js to Mapbox GL JS Mapbox provides many tools to build maps into your website or web-based application, including Mapbox GL JS and Mapbox.js. Mapbox GL JS and Mapbox.js are both open source JavaScript libraries you can use to display your Mapbox maps, add interactivity, and customize the map experience in your application. There are some important differences between the two libraries, though, that will impact how you use them to build your apps. Mapbox.js No longer in active development Supports raster tiles Tiles are generated by the server Map styles can't be changed in the browser, but map overlays can be styled dynamically Mapbox GL JS In active development — we are adding new features, improving existing features, and fixing bugs Supports vector tiles Maps are rendered client-side by the browser Map data and styles can be changed dynamically If you’re using the Mapbox.js library, making the switch to Mapbox GL JS can lead to improvements with the performance of your existing applications. The advantages provided by Mapbox GL JS make the work required to switch from Mapbox.js to Mapbox GL JS worth the effort. The purpose of this guide is to highlight equivalent resources and transferrable resources that Mapbox users can take advantage of when they switch from Mapbox.js to Mapbox GL JS. While every use case is unique, this document will give you a good overview of the kind of work that will be necessary to make this transition. Equivalent resources When you transition from using Mapbox.js to using Mapbox GL JS, you will likely want to recreate your app's original functionality as closely as possible. This means that you will need to take advantage of resources that allow you to have the same action or effect in Mapbox GL JS that you had when using Mapbox.js. The following list of common Leaflet and Mapbox.js resources and their Mapbox GL JS equivalents will help you know which tools to use as you switch libraries. Initialize a map Constructing a new map object in Mapbox GL JS involves many of the same pieces of information that are needed to initialize a map in Mapbox.js. You need your Mapbox access token, a center point (an array of coordinates), a zoom level (a number between 0 and 22), and an HTML element in which to place the map (specified by referencing the HTML element's id). Both Mapbox.js and Mapbox GL JS also allow you to specify the style of the map. How the style is specified is the biggest difference you will see when initializing your map. Mapbox.js expects a tileset ID, which references a tileset. Mapbox GL JS expects a style URL, which refers to a style.json file (a JSON object that conforms to the Mapbox Style Specification and specifies what data to use and how to style that data). It is not possible to convert a tileset to style JSON. Refer to the initialization syntax below to see the differences in action. Mapbox.js In Mapbox.js, you can initialize a new map with the following JavaScript: var map = L.mapbox.map('map', 'mapbox.streets') // HTML container ID, Mapbox tileset .setView([40, -74.50], 9); // starting coordinates as [lat, lng], zoom level The L.mapbox.map method, inherited from Leaflet L.map, references map, the HTML container ID for the map. It uses the .setView method to set the map view’s starting position in [latitude,longitude] format as well as the initial zoom level. While Mapbox.js uses [latitude, longitude] coordinate order, Mapbox GL JS uses [longitude, latitude] order. It also references mapbox://styles/mapbox/streets-v10, a Mapbox map style added as a styleLayer. The map you see in your browser is composed of raster tiles. It is essentially a set of images that are arranged to display the whole world (at low zoom levels) or the area you are viewing (at higher zoom levels). View the Initialize a map example Mapbox GL JS In Mapbox GL JS, you can initialize a new map with the following JavaScript: var map = new mapboxgl.Map( { container: 'map', // HTML container ID style: 'mapbox://styles/mapbox/streets-v9', // style URL center: [-21.9270884, 64.1436456], // starting position as [lng, lat] zoom: 13 } ); The new mapboxgl.Map method references map, which again is the ID of the HTML container for the map. It also references the style URL for Mapbox Streets v9, a default Mapbox style. That style URL refers to Mapbox Streets v9's style.json file for information on how to style the data on the map. Finally, it sets the map's [longitude, latitude] starting position and the map's initial zoom level. Remember that Mapbox GL JS uses [longitude, latitude] coordinate format, while Mapbox.js uses [latitude, longitude] format. The map you see in your browser is rendered dynamically by combining vector tiles with the style.json file of the style that was referenced in the initialization code. View the Display a map example Add a marker The way that markers are added to a map in Mapbox GL JS is different than the way they are added in Mapbox.js. Mapbox.js allows you to use markers that are styled using simplestyle-spec to set the icon and color of the marker. With Mapbox GL JS, you do not use simplestyle to style markers. Instead, you can use the default marker style, or you can specify a background image for the marker div using CSS. Mapbox.js The Mapbox.js L.mapbox.marker.icon method, which inherits from L.Marker in Leaflet, lets you add a marker to a map and style it in the same step. The resulting marker is an actual image on top of the map. L.marker([37.9, -77], { // [lat, lng] coordinates to place the marker at icon: L.mapbox.marker.icon( { 'marker-size': 'large', // specify the size of the marker 'marker-symbol': 'bus', // specify the symbol to use in the marker 'marker-color': '#fa0' // specify the color of the marker } ) } ).addTo(map); // add the marker to the map View the Single marker example Mapbox GL JS The Mapbox GL JS new maboxgl.Marker.addTo method attaches the new marker image to the map as a DOM element. The default Mapbox marker is a light blue, droplet-shaped SVG marker. Since this default marker is a DOM element, you can override its styling with CSS if you choose to. (This technique is demonstrated in the Add custom icons with markers example.) var marker = new mapboxgl.Marker() .setLngLat([30.5, 50.5]) // [lng, lat] coordinates to place the marker at .addTo(map); // add the marker to the map This method works well for adding individual markers to a map. If you are using a lot of markers for point data, adding the data as symbol or circle layers provides better performance. But if you add the data to your map using map.addLayer, these new circle or symbol layers are specified in the style.json file and are not DOM elements. View the Add custom markers in Mapbox GL JS tutorial Add a layer One major difference between Mapbox.js and Mapbox GL JS is how these libraries treat feature layers. This has a big impact on how you will reference and use layers in your maps. Mapbox.js In Mapbox.js, a new layer can be added to a map with the following JavaScript: var featureLayer = L.mapbox.featureLayer('mapbox.dc-markers') .addTo(map); The L.mapbox.featureLayer method, which is inherited from Leaflet’s L.FeatureGroup method, allows you to add a new layer to your map. The source can be GeoJSON, or it can be a URL pointing to a tileset or map style. The new layer is added to your map as a DOM element. If you are using a GeoJSON source with Mapbox.js, you may be styling features using simplestyle. While you can't style features in Mapbox GL JS layers using simplestyle, you can repurpose the simplestyle-related properties in your GeoJSON to style features with data-driven styling in Mapbox GL JS. Use featureLayer with a GeoJSON source: View the Distance between two markers example Style layer features with simplestyle: View the L.mapbox.simplestyle with L.geoJson example Mapbox GL JS In Mapbox GL JS, each layer provides rules about how the renderer will draw certain data in the browser. The renderer uses these layers to draw the map on the screen. Every time you add a layer to a Mapbox GL JS map, you need to specify both a source and a layer: The source determines the geometry and will include any data properties (such as the name of a point or the rank of points of interest). The layer properties influences the appearance of the layer. This includes the type of layer (circle, symbol, fill, etc.), any paint or layout properties to specify the appearance of features, and the source (the geometries that these styles should be applied to). This makes adding a layer is a two-step process: first adding the source data with the map.addSource method, then rendering the layer properties on the map with the map.addLayer method. map.addSource('single-point', { type: 'geojson', // specify the kind of data being added data: { type: 'FeatureCollection', features: [] } } ); map.addLayer( { id: 'point', // the layer's ID source: 'single-point', type: 'circle', // the layer type paint: { 'circle-radius': 10, 'circle-color': '#007cbf' } } ); Note The process of specifying a source and then adding a layer can also be done in one step by specifying a source within the map.addLayer method. In Mapbox GL JS, new layers are added to the top of the style by default. You can also use a layer ID to specify a layer for the new layer to go on top of using addLayer's optional before parameter. This is not possible with Mapbox.js because the rendered map is a flat picture for which you cannot influence the order of the layers. View the Make a heatmap with Mapbox GL JS tutorial Transferable resources Moving from Mapbox.js to Mapbox GL JS will necessarily mean that you will need to recreate your maps using the new framework. Most developers, though, find that many of the resources that they used with Mapbox.js can also be used with Mapbox GL JS with little or no modification. Resource Transferable? Notes Default Mapbox style ✅ If you use a Default Mapbox style, you can update to the Mapbox GL JS version of that style. For example, if you used the Mapbox Classic Streets style with Mapbox.js, you could use Mapbox Streets v9 in your Mapbox GL JS app. Custom data ✅ If you use custom data in Mapbox.js or Leaflet, it can probably be repurposed in Mapbox GL JS. For more information about using data sources in Mapbox GL JS, see the Mapbox Style Specification. Custom markers ✅ In Mapbox GL JS, markers are rendered by the GPU, not the browser, so any images you want to use as markers have to be loaded into a sprite and referenced in your map’s style JSON. You can add custom markers to a sprite in Mapbox Studio. Custom classic style ❌ Custom classic styles made with Mapbox Studio Classic cannot be used with Mapbox GL JS. Recreate your Classic style in Mapbox Studio to take advantage of Studio’s advanced styling features. In a few cases, there are Leaflet or Mapbox.js features without exact equivalents in Mapbox GL JS. Our support staff can help you determine how to create the effect you’re trying to achieve, so contact us if you have questions. Learn more about using Mapbox GL JS To learn more about Mapbox GL JS and how to use it, explore the following resources: Mapbox GL JS examples Mapbox GL JS API reference Improve the performance of Mapbox GL JS maps Working with large GeoJSON sources in Mapbox GL JS Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Transition from Mapbox.js to Mapbox GL JS,Mapbox.js,Mapbox GL JS,Add a marker,Add a layer,Transferable resources,Learn more about using Mapbox GL JS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Improve the performance of Mapbox GL JS maps,Learn how to improve the performance of your Mapbox GL JS maps.,https://docs.mapbox.com/help/troubleshooting/mapbox-gl-js-performance/,troubleshooting,,,"Improve the performance of Mapbox GL JS maps Model of performance The performance of your Mapbox GL JS maps can be measured as render time, source update time, or layer update time. Render time The render time refers to how quickly Mapbox GL JS draws a map on your screen as you move around or zoom in and out of the map. Render time is a function of the number of sources, the number of layers, and the number of vertices in the features they contain: render time = constant time + [ number of sources * per source time ] + [ number of layers * per layer time ] + [ number of vertices * per vertex time ] Source update time The source update time refers to how quickly changes to a GeoJSON source are visible on the map. Source update time is a function of the number of layers that use the updated source and the number of vertices in the features it contains: source update time = constant time + [ number of layers using the source * per layer time ] + [ number of vertices * per vertex time ] Layer update time The layer update time refers to how quickly changes to a layer, using runtime styling, are visible on the map. Layer update time is a function of the number of vertices in the features the layer contains: layer update time = constant time + [ # of vertices in the layer's source * per vertex time ] Strategies for improving performance When looking for opportunities to improve the performance of your map, look for ways in which you can reduce the number of layers, number of sources, or the complexity of the features in the data that is being rendered. Combine layers Combining layers that use similar styles or that can be styled using data-driven styling will reduce the number of layers, in turn reducing the render time. This strategy works well for layers with many features of the same type (fill, line, circle, symbol, or fill-extrusion) that are either styled similarly or whose styles vary by the value of a specific data field. For more on data-driven styling see the Map design guide and our Graduated circle map tutorial with Mapbox GL JS data-driven styles tutorial. Use vector tileset sources Use vector tileset sources over GeoJSON data sources when possible. The renderer splits features in vector tilesets into tiles which allows GL JS to load only the features that are visible on the map. Feature geometries are also simplified meaning there are fewer vertices resulting in reduced render, source update, and layer update times. This strategy works well when working with large datasets that don't need to be updated quickly. You can create vector tilesets using the Mapbox Uploads API or by uploading data on the Mapbox Studio Tilesets page. Combine vector tile sources Combining sources will reduce the number of sources and, as a result, the render time. This strategy works well when you have data coming from many individual data files. You can combine vector tile sources by either using composited sources or by creating a single vector tileset source with multiple source layers. If you are creating vector tilesets by uploading data to Mapbox Studio, you can create a style and add vector tileset sources using the Mapbox Studio style editor. Vector sources are composited by default in the Mapbox Studio style editor. You can create a single vector tileset source with multiple source layers using the Mapbox Studio Classic desktop application or the command line tool, Tippecanoe. Remove unused features Only include features that are being used in the current style. This will reduce the number of vertices, in turn reducing both render time and source update time. This works well when you are using one of our template styles. You can remove unused features using style-optimized vector tiles. Style-optimized vector tiles are smaller and a way to reduce the size of offline caches. This feature of the Mapbox Vector Tiles API removes any layers or features in the tile that are not used in the style. You can use style-optimized vector tilesets in Mapbox GL JS by adding ?optimize=true to the end of your style URL: var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/outdoors-v10?optimize=true' // optimize=true } ); Example Say you have a style that references a tileset with four layers: campsites, mountains, forestland, and buildings. The final map includes icons for campsites, a pattern for forests, and a pattern for blue mountains, but does not use buildings. In a normal Mapbox GL map, the tiles loaded include all four layers even though they aren’t all needed. A style-optimized vector tile includes only campsites, forestland, and blue mountains. It removes unused layers and features based on attributes and zoom levels. The illustration on the left is a normal vector tileset and the one on the right is a style-optimized vector tileset. Optimize expressions Expressions offer enormous flexibility when filtering and styling map data. There are often several ways to achieve the same visual effect with expressions, but each approach has different performance implications. There are a few guidelines for identifying the most performant expression. Filter by zoom levels Add explicit minzoom and maxzoom values to style layers to prevent filters from being used for evaluation at zoom levels where all geometries will be false. For example, in the Mapbox Streets style, there is a state-label layer. The data for this layer comes from the place_label source layer. Features with a class equal to state only exist at zoom levels between 3 and 9. By specifying a minzoom of 3 and a maxzoom of 9, you avoid applying the filter to many features that you already know will not have the state class. More performant { ""id"": ""state-label"", ""type"": ""symbol"", ""source"": ""composite"", ""source-layer"": ""place_label"", ""minzoom"": 3, ""maxzoom"": 9, ""filter"": [ ""=="", [ ""get"", ""class"" ], ""state"" ] /* layout and paint properties */ } Less performant { ""id"": ""state-label"", ""type"": ""symbol"", ""source"": ""composite"", ""source-layer"": ""place_label"", ""filter"": [ ""=="", [ ""get"", ""class"" ], ""state"" ] /* layout and paint properties */ } Reduce the number of filters If you find yourself applying a significant number of filters to achieve a particular result, consider making adjustments to the data. For example, splitting geometries into multiple source layers to avoid the need for complex filter expressions. You can also adjust your styling strategy. Split your styling objectives into more than one layer so you can use more precise expressions for each layer. There are trade offs between simplifying filters using this approach and reducing layers by using data-driven expressions. Read more about reducing layers using data-driven styling above. Make sure expressions do not produce errors Before applying a condition to a data property, make sure the feature you are applying the condition to has that data property. The errors thrown when attempting to apply a conditional for a property that doesn't exist can have a significant effect on performance. For example, the Mapbox Streets style uses the all expression to filter the roads source layer to display highway shields. This expression first checks if a feature in the source layer has a particular property (reflen), then filters all features that do have the reflen property for those that are less than or equal to six. More performant ""filter"": [ ""all"", [""has"", ""reflen""], [ ""<="", [ ""get"", ""reflen"" ], 6 ], [ ""step"", [ ""zoom"" ], [ ""=="", [ ""geometry-type"" ], ""Point"" ], 11, [ "">"", [ ""get"", ""len"" ], 5000 ], 12, [ "">"", [ ""get"", ""len"" ], 2500 ], 13, [ "">"", [ ""get"", ""len"" ], 1000 ], 14, true ] ] Less performant ""filter"": [ ""all"", /* no `has` expression */ [ ""<="", [ ""get"", ""reflen"" ], 6 ], [ ""step"", [ ""zoom"" ], [ ""=="", [ ""geometry-type"" ], ""Point"" ], 11, [ "">"", [ ""get"", ""len"" ], 5000 ], 12, [ "">"", [ ""get"", ""len"" ], 2500 ], 13, [ "">"", [ ""get"", ""len"" ], 1000 ], 14, true ] ] Order filter conditions from more specific to less specific This will reduce number of geometries going through the next nested filter. Below is another example from the Mapbox Streets style. The Mapbox Streets style includes several tunnel layers. Data used for tunnel layers comes from the road source layer. The road source layer includes many features that are not tunnels. The expression below is used to filter the road source layer for the tunnel-primary-secondary-tertiary style layer: First it narrows from all road features to only features where structure is equal to tunnel. Then, it filters those tunnel features to only include features with primary, secondary, or tertiary classes. This condition is less specific than the first condition. In the entire road source layer, there are far more features with a class of primary, secondary, or tertiary than there are features where structure is equal to tunnel. Finally, it filters those primary, secondary, and tertiary tunnel features to only include lines (not, for example, labels). This condition is less specific than the first two conditions. In the entire road source layer, there are far more features that are lines than there are features with the class or structure listed above. More performant ""filter"": [ ""all"", [ ""=="", [ ""get"", ""structure"" ], ""tunnel"" ], [ ""match"", [ ""get"", ""class"" ], [ ""primary"", ""secondary"", ""tertiary"" ], true, false ], [ ""=="", [ ""geometry-type"" ], ""LineString"" ] ] Less performant ""filter"": [ ""all"", [ ""=="", [ ""geometry-type"" ], ""LineString"" ], [ ""match"", [ ""get"", ""class"" ], [ ""primary"", ""secondary"", ""tertiary"" ], true, false ] [ ""match"", [ ""get"", ""structure"" ], ""tunnel"", true, false ] ] Simplify expressions The simpler a filter or expression is, the better. For example, [""=="", [""get"", ""foo""], ""bar""] is simpler than [""match"", [""get"", ""foo""], ""bar"", true, false]. The match expression is implemented differently than the == expression. It builds a lookup object for matching, and while looking up objects in JS is fast, it is still slower than a simple comparison (which adds up if you do hundreds of thousands of matches for large amounts of data). More performant [ ""=="", [ ""get"", ""structure"" ], ""tunnel"" ] Less performant [ ""match"", [ ""get"", ""structure"" ], ""tunnel"", true, false ] Like match, the case and step expressions can also be simplified when they don't include multiple branches. Style denser features first It's common to group features (for example, landuse) into a single layer and use a data expression on paint properties to differentiate between them. Reorder dense or more visible data so their draw order is prioritized. In the example below, features with the shadow class are more visible than features with the highlight class. To optimize performance, assign a fill-color to shadow features first and highlight features will be assigned the fallback value. More performant ""fill-color"": [ ""match"", [""get"", ""class""], ""shadow"", ""hsl(56, 59%, 22%)"", ""hsl(0, 0%, 100%)"" ] Less performant ""fill-color"": [ ""match"", [""get"", ""class""], ""highlight"", ""hsl(0, 0%, 100%)"", ""hsl(56, 59%, 22%)"" ] Use a separate GeoJSON source for data that needs to be updated rapidly When using a GeoJSON source, any update to it requires Mapbox GL JS to reprocess the entire set of data. If updates must happen quickly and only ever affect a small number of features in a GeoJSON source (for example, changing a few features' property values or moving a single point's location), it may be beneficial to use two sources instead: one with the full, large dataset, used by layers that don't update, and a second one containing only the dynamic, or updated, features used by layers that are specifically showing those features. That way, when you update the dynamic source, you're only reprocessing a small number of features. Example If you have a large dataset with many features, and you want to create a hover effect for a single point at a time, you can use one large source for the regular features and a separate source with only one feature and the hover styles to improve update times. Use feature state Updating data is costly and can negatively impact performance. The feature-state expression allows you to insert new data into a feature at runtime, which will reduce the layer update time. When you need to make hover or selected styles for map features, use the map.setFeatureState method to avoid re-parsing all the geometries at each state change. Note that feature-state can only be used with paint properties that support data-driven styling. Similar layers Layers with matching properties type, source, source-layer, zoom, filter and layout are automatically grouped and rendered faster. For example, you could use a second water layer to create dimension, and because all properties except for those defined in paint are shared they qualify to be grouped and will render faster. Find opportunities for layers that may qualify to be grouped, and make sure they use the same type, source, source-layer, zoom, filter and layout to be grouped and rendered faster. { ""id"": ""water"", ""type"": ""fill"" ""layout"": { } , ""paint"": { ""fill-color"": ""blue"" } } , { ""id"": ""water"", ""type"": ""fill"" ""layout"": { } , ""paint"": { ""fill-color"": ""navy"", ""fill-translate"": [""literal"", [-1, -1]] } } Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Improve the performance of Mapbox GL JS maps,Source update time,Layer update time,Strategies for improving performance,Combine layers,Use vector tileset sources,Combine vector tile sources,Remove unused features,Optimize expressions,Filter by zoom levels,Reduce the number of filters,Make sure expressions do not produce errors,Order filter conditions from more specific to less specific,Simplify expressions,Style denser features first,Use a separate GeoJSON source for data that needs to be updated rapidly,,Use feature state,Similar layers,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Route progress,Learn how to use a user's progress information along a route with the Mapbox Navigation SDK for iOS.,https://docs.mapbox.com/ios/navigation/overview/route-progress/,guide,,,"Route progress Tracking a user's progress along a route is key to providing helpful and prompt navigation instructions. The RouteProgress class contains all the user's progress information along the route, including current leg and step information. This object allows you to get distance measurements, the percentage of route complete, current step index, and more. The RouteController tracks the user’s progress along a route, continuously provides an updated RouteProgress object, and posts notifications as the user reaches significant points along the route. Information about progress There are three classes that contain information on route progress at different levels of granularity: route, leg, and step. Route: The blue line represents a route. A route stretches between the origin and destination. Leg: The larger circles with a pink stroke represent waypoints, or stops, along the route. A leg is the part of the route between two waypoints. Step: The smaller circles with a green stroke represent maneuvers. A step is the part of the leg between two maneuvers. Read more about what properties are available in these three progress classes in the API reference documentation: RouteProgress: This class contains all progress information at any given time during a navigation session. This progress includes information for the current route, leg and step the user is traversing along. With every new valid location update, the route progress will be updated latest information. You can listen for routeControllerProgressDidChange notifications or implement the corresponding delegate method, NavigationServiceDelegate.navigationService(_:didUpdate:with:rawLocation:) to be notified when the route progress object changes. RouteLegProgress: This class is specific to the current leg the user is on. If there is only one leg in the directions route, much of this information will be the same as the parent RouteProgress. RouteStepProgress: This class is specific to the current step the user is on. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Route progress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Create a custom style,Alter a template style to create a custom map style.,https://docs.mapbox.com/help/tutorials/create-a-custom-style/,tutorial,No code,,"beginner No code Create a custom style This guide will walk through how to create a custom style in the Mapbox Studio style editor. The Mapbox Studio Basic style is customizable, which lets you create a map style that conforms to your company's branding. This tutorial will show you how to customize the Mapbox Basic style by changing colors, fonts, and label properties. After you have completed the tutorial, you will have created a map style that reflects the Mapbox brand colors at any zoom level and at any place across the world. Getting started You will need a few resources to get started: Mapbox account. Sign up for a free account on Mapbox. Style guidelines. It is often helpful to start a new custom map style with some broad style guidelines. Mapbox's brand has three primary colors (blue, gray, and pink) and a broader set of secondary colors. Every hue includes a dark, light, and faint variation. This tutorial will use a combination of these colors to style the background, water, buildings, and labels in a custom map style. Create a new style Log in to your Mapbox account and navigate to the Styles page. This is where all your map styles are listed. A style is a set of rules that defines how Mapbox draws your map on the page. It includes references to your data, map images (icons, markers, and patterns), fonts, and defines how all your data should be styled on the map. For more information about styles, read the Styles section of the Mapbox Studio Manual. To create a new style from your Styles page, click the New style button. Find the Basic Template style and click Customize Basic Template. The Mapbox Studio style editor will open, and you will be able to start creating a custom map style. Customize your style The style editor The Mapbox Studio style editor is a visual tool for creating custom map styles. Look at the layers on the left side of the style editor screen. Each layer can be customized in a variety of ways, including by changing its colors. You can also filter layers within the layer list and edit the properties of multiple layers at once. This is the easiest way to change the color of layers with similar properties. To learn more about the Mapbox Studio style editor, visit the Mapbox Studio Manual. In this section, you will change the color of the water, background, and building layers and alter the fonts for various labels to create a customized map. But first, change the name of your new style. Click into the name field in the upper left side of the screen and change the name to Mapbox Style. Style background and water layers When the style editor first opens with the Basic style template, the map is zoomed in at a high level. Zoom out to approximately zoom level 10 so that you can see a larger geographic region. In the search bar, type in San Francisco (or another region that gives you a good mix of water, land, and city features). You will start by altering the water and background layers so they match the colors from the Mapbox style guide. Style the water layer You will style the water layer with a bright blue color from the Mapbox style guide. Click on the water layer in the layer list. When the layer panel opens, click on the Color field if it is not highlighted already. Change the color to #314CCD. Style the background layer by zoom level Mapbox Studio lets you adjust styles based on specific data. In this case, you will use the style editor to change the color of the style's background based on the zoom level. Using zoom properties, the background color will become gradually lighter as the map zooms in. To style the background layer by zoom level: Click on the background layer in the layer list. When the layer panel opens, click the Color option if it's not already highlighted. You will see two zoom levels, each with a color. Click Edit next to each stop. The text field on the top right of the card is the zoom level and the text field on the bottom right is the color. When you're done adjusting the zoom level and the color for a specific stop, click Done. Edit the first stop so the zoom level is 6 and the color is #A9B6EF. Edit the second stop so the zoom level is 12 and the color is #EDF0FD. Now, when you zoom in, the background color changes gradually as the zoom level increases. Style the landuse and national park layers Now that you have changed the colors for the water and background layers, the green color that is used in the Basic style looks too bold. You will change the color of these layers to a light green from the style guide's secondary colors. Select the national_park layer. When the layer panel opens, select the Color field. Change the Color field to #E8F5EE. Select the landuse layer. Click on the Color field if it is not highlighted already. Click the ""class is park, pitch"" condition. Change the Color field to #E8F5EE. Update fonts Next, alter the fonts that are used as labels in your style. Click Filter layers at the top of the layers list. Choose Filter by value. Choose Fonts. Select Roboto Black. This will return the only layer in which this font is being used, state-label. Click on state-label, then click on Font. Change the font to Roboto Condensed Bold. Click on Filter layers again, and repeat this process for the font Roboto Regular, which you will change to Roboto Medium. You can select multiple layers at once by holding down command (Mac) or CTRL (Windows) while clicking to select layers Style labels After you have changed the fonts and set some general options, it's time to update the colors of the various label types used in your style. Click Filter layers at the top of the layers list and search for the word label. This search will return 9 layers with the word label in their names. Select country-label. When the layer panel opens, select the Color field and change it to #ffffff. Change the Halo color field to #314CCD. Change the following label layers to have the following attributes: place-neighborhood-suburb-label: color #EE4E8B, halo color #ffffff place-city-label: click Clear value and then specify the color #ffffff, halo color #273D56 Style buildings Next, change the color of the buildings in your style to a color from the Mapbox style guide: Click on the building layer in the layer list. When the layer panel opens, change the Color field to #aab7ef. Change the 1px stroke field to #aab7ef. To make sure that Mapbox template styles are performant, layers are not included at every zoom level. The building layer, for example, is visible only at zoom levels 15 and higher. You can use a zoom function to create a fade-in effect as you zoom past level 15 rather than buildings showing up abruptly once you hit zoom level 15: In the Opacity field of the building layer, select Style across zoom range. Click Edit to open and edit each stop: Edit the first stop so the zoom level is 15 and the opacity is 0. To change the opacity, move the opacity slider all the way to the left. Edit the second stop so the zoom level is 16 and the opacity is 1. Zoom in to see the buildings fade between zoom level 15 and 16. Your browser doesn't support embedded videos. This fade-in effect could also be applied to roads, parks, waterways, and any other layers you choose. Publish When you have finished editing your map style, publish your changes by clicking Publish in the upper right side of the screen. When you click the publish button, a window will display the difference between the previous and current version of this style. If you're happy with the changes, click Publish. Your style will now be available to share from a variety of tools and applications. Finished product You have created a map that reflects the Mapbox style guide, from a world view to the street level and at any location across the world. Explore your finished custom map style and take some time to view the style at various zoom levels. Next steps Mapbox Studio provides a wide variety of ways to use your new map style. You can use this map directly on your website or in a web or mobile application. Take a look at the Publish style section of the Mapbox Studio Manual to see all the ways you can use your style! Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Create a custom style,Customize your style,The style editor,Style background and water layers,Style the water layer,Style the background layer by zoom level,Style the landuse and national park layers,Update fonts,Style labels,Style buildings,Publish,Finished product,Next steps,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,map view,Map views were formerly used as a unit of measurement to track map usage on the web. Map views are now deprecated.,https://docs.mapbox.com/help/glossary/map-view/,glossary,,,"map view Map views are deprecated Map views are no longer used to track map usage for Mapbox products. For details on current pricing structures including map loads, see Pricing by product. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,map view,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Get features under the mouse pointer,Using queryRenderedFeatures to show properties of hovered-over map elements.,https://docs.mapbox.com/mapbox-gl-js/example/queryrenderedfeatures/,example,JavaScript,,Get features under the mouse pointer Using queryRenderedFeatures to show properties of hovered-over map elements. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Get features under the mouse pointer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,layer,Layers are used in styles to add styling rules to specific subsets of data.,https://docs.mapbox.com/help/glossary/layer/,glossary,,,"layer Layers are used in styles to add styling rules to specific subsets of data. (For example, if you wanted all the rivers in your map to be pink, you would create a layer in your style for it.) Layers contain both a reference to the data for which they're defining a style as well as the styling rules to be applied. Read more about layers in the Mapbox Style Specification. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,layer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Custom voice controller,Use a custom voice controller.,https://docs.mapbox.com/ios/navigation/examples/custom-voice-controller/,example,Swift,,"Custom voice controller import Foundation import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections import AVFoundation class CustomVoiceControllerUI: UIViewController { var voiceController: CustomVoiceController? override func viewDidLoad() { super.viewDidLoad() let origin = CLLocationCoordinate2DMake(37.77440680146262, -122.43539772352648) let destination = CLLocationCoordinate2DMake(37.76556957793795, -122.42409811526268) let options = NavigationRouteOptions(coordinates: [origin, destination]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) self.voiceController = CustomVoiceController(navigationService: navigationService) let navigationOptions = NavigationOptions(navigationService: navigationService, voiceController: self.voiceController) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) self.present(navigationViewController, animated: true, completion: nil) } } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) voiceController = nil } } class CustomVoiceController: MapboxVoiceController { // You will need audio files for as many or few cases as you'd like to handle // This example just covers left, right and straight. let turnLeft = NSDataAsset(name: ""turnleft"")!.data let turnRight = NSDataAsset(name: ""turnright"")!.data let straight = NSDataAsset(name: ""continuestraight"")!.data override func didPassSpokenInstructionPoint(notification: NSNotification) { let routeProgress = notification.userInfo![RouteControllerNotificationUserInfoKey.routeProgressKey] as! RouteProgress let soundForInstruction = audio(for: routeProgress.currentLegProgress.currentStep) play(soundForInstruction) } func audio(for step: RouteStep) -> Data { switch step.maneuverDirection { case .left: return turnLeft case .right: return turnRight default: return straight } } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Custom voice controller,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Create a timezone finder with Mapbox Tilequery API,Create a timezone finder app with Mapbox Tilequery API.,https://docs.mapbox.com/help/tutorials/create-a-timezone-finder-with-mapbox-tilequery-api/,tutorial,JavaScript,,"intermediate JavaScript Create a timezone finder with Mapbox Tilequery API Prerequisite Familiarity with front-end development concepts including JavaScript and API calls. The Mapbox Tilequery API enables users to get data from a tileset without necessarily needing to render a map. This tutorial shows you how to create an app that uses the Tilequery API and a custom tileset to determine which timezone a user is in. View fullscreen demo You will not be building a map in this tutorial. To see an example of how Mapbox Tilequery API can be used to interact with a rendered map, take a look at the Tilequery API Playground. Getting started There are a few resources you’ll need before getting started: An access token from your Mapbox account. You will use an access token to associate a map with your account. Your access token is on the Account page. Data. Your app will reference a tileset that contains timezone information. This data set was sourced from Evan Savage’s GitHub. For this tutorial, you don't have to download the data or upload it to Mapbox — we've done that for you already! Normally, you would need to upload this data to Mapbox using either Mapbox Studio or the Mapbox Uploads API. Mapbox Tilequery API. Our Tilequery API lets you query custom data without needing to render a map to the page. jQuery. jQuery is a JavaScript library you will use to add your API request to your application. Assembly. Assembly is an open source CSS framework that is maintained by Mapbox. A text editor. Use the text editor of your choice for writing HTML, CSS, and JavaScript. In this tutorial, you will create an interface using HTML and style it using Assembly, the CSS framework that Mapbox uses. Then you will add a call to the native HTML geolocation API, as well as a call to the Mapbox Tilequery API to query a custom tileset that contains timezone data. At the end of this tutorial, you will have created an app that, when a user clicks a button, determines their timezone. Structure the webpage Start by pasting the following code into your text editor. This code references a few items in the <head> of your file that you will take advantage of later in this tutorial: jQuery. Used to make the Tilequery API call and parse the response. Assembly. Using this framework will allow you to add styles to the HTML without having to write custom CSS. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title></title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <!-- import jQuery --> <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js'></script> <!-- import Assembly JavaScript --> <script async defer src='https://api.mapbox.com/mapbox-assembly/v0.21.2/assembly.js'></script> <!-- import Assembly CSS --> <link href='https://api.mapbox.com/mapbox-assembly/v0.21.2/assembly.min.css' rel='stylesheet'> </head> <body> <!-- the Assembly classes in the div below create a centered div with a top margin of 36px --> <!-- read the Assembly documentation for more info! --> <div class='mx-auto mt36 w600 prose'> <h2>Timezone finder</h2> <button id='tz-button' class='btn'>Find my timezone!</button> <!-- the textContainer div will display the success, error, and loading messages --> <div class='mt12 ml12' id='textContainer'> <!-- these Assembly classes will add an animation to the loading message! --> <p id='loading-message' class='inline-block round animation-pulse animation--infinite'></p> <p id='return-message'></p> </div> </div> </body> </html> Save this file and open it in your browser. The body of the code references a few different Assembly classes, so you do not need to add any additional styles (unless you want to!). This code doesn't do anything yet, so in the next few steps you will add more functionality to turn it into a fully realized timezone finder. Build the API request Next, you will build your request to the Mapbox Tilequery API and test it in your browser. After you have verified that it is returning the expected results, you will add the API call to your app! The format of a Tilequery API call is: https://api.mapbox.com/v4/ { tileset } /tilequery/ { longitude } , { latitude } .json?access_token= YOUR_MAPBOX_ACCESS_TOKEN In a Mapbox Tilequery API call, the tileset indicates the data that your API request will be querying. In this case, your app will query custom data that has been uploaded to Mapbox. You will reference this tileset id (examples.4ze9z6tv) in the API call. You can also tell the Tilequery API to ask questions of Mapbox’s default tilesets, such as Mapbox Streets or Mapbox Terrain. To visualize the results of a call to one of these tilesets, use the Tilequery API Playground. Parameters The only required parameters for a call to the Mapbox Tilequery API are the longitude and latitude of a desired location. To test the API, we will set this to -77.033835,38.89975, the coordinates of Mapbox’s Washington D.C. office. The Tilequery API also accepts several optional query parameters, including radius, that you will not need to use for this project. Read more about these optional parameters and how to use them in the Mapbox API Documentation’s Tilequery section. Access token The only required item left is your access token, which you will find on your Mapbox account page. The access token is required to track the requests you make from your account. Review the response When you put it all together, your request will look like: https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/-77.033835,38.89975.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN Now that you have a request, take a look at what you get in return by pasting the full URL into a new browser window. Make sure that access_token= is set equal to your access token. When you make your request, a JSON object is returned that contains, along with other information, a TZID property. This property shows the timezone of our test coordinates, the America/New_York timezone. { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -77.033835, 38.89975 ] } , ""properties"": { ""TZID"": ""America/New_York"", ""tilequery"": { ""distance"": 0, ""geometry"": ""polygon"", ""layer"": ""tz_world-c5z4hv"" } } } ] } Now that you understand how Mapbox Tilequery API requests and responses both work, you can use this API request to build out your app’s functionality. Add the API request to the app All modern browsers support the HTML geolocation API, which allows a browser to determine a user’s location if the user provides permission for it to do so. The timezone finder app will use the HTML geolocation API to get the longitude and latitude that will be used in the Mapbox Tilequery API call. First, add the following code to your file above the closing </body> tag. This creates a place for you to add the JavaScript the app needs. The accessToken variable stores the access token that will be used in the query. Add your own access token between the quotation marks. <script> var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here </script> Next, you will write a call to the HTML geolocation API to get the user's longitude and latitude. Add the following code after the accessToken variable you created: navigator.geolocation.getCurrentPosition(function(position) { var lon = position.coords.longitude; var lat = position.coords.latitude; console.log('Your location: ' + lon + ',' + lat); } ); Save your work and open this page in your browser. The browser will ask your permission to know your location. The console.log line will print the variables lon and lat to your browser’s console so that you can see the data that the HTML geolocation service returns. Now it’s time to use this information to construct a Tilequery API call! Include Tilequery API To use the Tilequery API, you will write a function called getUserLocation that will make a call to the API. This code will replace the call to the HTML geolocation API that you wrote in the last step, so erase that and replace it with the following code. Now the code between your opening and closing script tags should be: var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here function getUserLocation() { function success(position) { // create variables that will hold the // user's latitude and longitude data var lon = position.coords.longitude; var lat = position.coords.latitude; // construct a query to Tilequery API using the // longitude and latitude variables as parameters var query = 'https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/' + lon + ',' + lat + '.json?access_token=' + accessToken; // make the call to Tilequery API and parse the results $.ajax( { method: 'GET', url: query, } ).done(function(data) { // get the timezone from the resulting GeoJSON FeatureCollection var userTimezone = data.features[0].properties.TZID; } ); } // pass the results of a successful Tilequery API call // to the HTML geolocation API navigator.geolocation.getCurrentPosition(success); } Add interactivity Now you’re ready to add interactivity to your app! Add an event listener that calls the getUserLocation function when the user clicks the button. To access the button, you can use its id tz-button. Create a new variable in your JavaScript right below the accessToken variable: var tzButton = document.getElementById('tz-button'); Now add an onclick event listener that will trigger the getUserLocation function when the button is clicked. Add the following line to your JavaScript below the tzButton variable declaration: tzButton.onclick = getUserLocation; The code between your opening and closing script tags should now be: var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here // create a variable that selects the button var tzButton = document.getElementById('tz-button'); // when the button is clicked, call the getUserLocation function tzButton.onclick = getUserLocation; function getUserLocation() { function success(position) { var lon = position.coords.longitude; var lat = position.coords.latitude; var query = 'https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/' + lon + ',' + lat + '.json?access_token=' + accessToken; $.ajax( { method: 'GET', url: query, } ).done(function(data) { var userTimezone = data.features[0].properties.TZID; } ); } navigator.geolocation.getCurrentPosition(success); } Display messages The only thing left to do is display the user’s timezone to the page! In the HTML section of your app, you already created a div that contains p tags with the ids loading-message and return-message. These will be used to display the success, error, and loading messages for your app. In the getUserLocation function, create variables for these elements: var loadingMessage = document.getElementById('loading-message'); var returnMessage = document.getElementById('return-message'); Now that you have selected these elements, you can start adding messages to them. Add a loading message at the beginning of the getUserLocation function that lets users know that the app is working on returning their information. document.getElementById('loading-message').textContent = 'loading'; The message will stand out since you already added an Assembly animation class to the p tag! Now that you have a loading message, you need to remove the loading message add a success message. Since a success message is there to tell users when things have gone correctly, your app will display a message that tells users which area code they are in. First, though, you will need to remove the loading message. Add these lines to your JavaScript right below the userTimezone variable: loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'You are in the ' + userTimezone + ' timezone.'; There’s always the possibility for something to go wrong, and if that happens you need to let the user know. Add an error message near the end of the getUserLocation function: function error() { loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'Sorry, unable to determine your current location.'; } The code between your script tags will look like this now: var accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; // add your access token here var loadingMessage = document.getElementById('loading-message'); var returnMessage = document.getElementById('return-message'); var tzButton = document.getElementById('tz-button'); tzButton.onclick = getUserLocation; function getUserLocation() { // show a loading animation while we wait for the data document.getElementById('loading-message').textContent = 'loading'; function success(position) { var lon = position.coords.longitude; var lat = position.coords.latitude; var query = 'https://api.mapbox.com/v4/examples.4ze9z6tv/tilequery/' + lon + ',' + lat + '.json?access_token=' + accessToken; $.ajax( { method: 'GET', url: query, } ).done(function(data) { var userTimezone = data.features[0].properties.TZID; // on success, remove the loading message and display the user's timezone loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'You are in the ' + userTimezone + ' timezone.'; } ); } // if anything goes wrong, remove the loading message and display an error message function error() { loadingMessage.parentNode.removeChild(loadingMessage); returnMessage.textContent = 'Sorry, unable to determine your current location.'; } navigator.geolocation.getCurrentPosition(success, error); } Finished product You used the Mapbox Tilequery API to build an app that queries a custom tileset to determine a user’s timezone, without ever having to reference a rendered map. Open your app in the browser and try it out. View fullscreen demo Next steps To learn how to use cURL to upload large custom data sets like the one used in this tutorial to your Mapbox account, read the Upload to Mapbox using cURL tutorial. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Create a timezone finder with Mapbox Tilequery API,Build the API request,Parameters,Access token,Review the response,Add the API request to the app,Include Tilequery API,Add interactivity,Display messages,Finished product,Next steps,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Make a heatmap with Mapbox GL JS,"Add custom HTML markers, style them, and add tooltips with Mapbox GL JS.",https://docs.mapbox.com/help/tutorials/make-a-heatmap-with-mapbox-gl-js/,tutorial,JavaScript,,"intermediate JavaScript Make a heatmap with Mapbox GL JS Prerequisite Familiarity with front-end development concepts. In this guide, you will learn how to make a heatmap using Mapbox GL JS. Heatmaps can be used to display large amounts of points in a way that is visually engaging and encourages your audience to explore your map. Getting started A Mapbox account and access token. Sign up for an account at mapbox.com/signup. You can find your access tokens on your Account page. Mapbox GL JS. The Mapbox JavaScript API for building web maps. Data. In this tutorial, you’ll be using a GeoJSON file of street trees in the city of Pittsburgh from the Western Pennsylvania Regional Data Center. Download GeoJSON What is the purpose of a heatmap? The term ""heatmap"" can refer to a few different kinds of cartographic visualizations. You may see it applied to presidential election maps, population density maps, or even meteorological maps. Among maps you'll find on the web, there are two common categories of heatmaps: those that encourage the user to explore dense point data, and those that interpolate discrete values over a continuous surface, creating a smooth gradient between those points. The latter is less common and most often used in scientific publications or when a phenomenon is distributed over an area in a predictable way. For example, your town may only have a few weather stations, but your favorite weather app displays a smooth gradient of temperatures across the entire area of your town. For your local weather service, it is reasonable to assume that, if two adjacent stations report different temperatures, the temperature between them will transition gradually from one to the next. For the purposes of this tutorial, we are referring to a different kind of visualization that is more useful for showing the density of points over an area. This type of heatmap does not visualize density by aggregating features within a set of boundaries in the way a choropleth map does, but instead displays a continuous gradient between points. Heatmaps aren't only useful for visualizing point density. They can also help visualize relative differences between those points. You can assign each point a higher or lower importance based on the value of a particular property within the dataset. In this tutorial, you will weight your map by the DBH property in your data. DBH stands for ""diameter at breast height"" and is a standard way of measuring a tree's diameter at 4.5 feet above the ground. In general, it is safe to assume that a tree with a higher DBH is older and larger. When you give these larger trees a higher weight compared to smaller saplings, your visualization can be an effective approximation of the area that is shaded by trees' leaves. Heatmap paint properties To add a heatmap layer to your map, you will need to configure a few properties. Understanding what these properties mean is key to creating a heatmap that accurately represents your data and strikes the right balance between too much detail and being a single, generalized blob. heatmap-weight: Measures how much each individual point contributes to the appearace of your heatmap. Heatmap layers have a weight of one by default, which means that all points are weighted equally. Increasing the heatmap-weight property to five has the same effect as placing five points in the same location. You can use a stop function to set the weight of your points based on a specified property. heatmap-intensity: A multiplier on top of heatmap-weight that is primarily used as a convenient way to adjust the appearance of the heatmap based on zoom level. heatmap-color: Defines the heatmap's color gradient, from miniumum value to maximum value. The color displayed is dependent on the heatmap-density value of each pixel (ranging from 0.0 to 1.0). The value of this property is an expression that uses heatmap-density as the input. For inspiration on color choices for your heatmap, take a look at Color Brewer. heatmap-radius: Sets the radius for each point in pixels. The bigger the radius, the smoother the heatmap and the less amount of detail. heatmap-opacity: Controls the global opacity of the heatmap layer. Create your map using Mapbox GL JS Now that you understand the purpose of heatmaps and the paint properties you will be working with, it's time to set up your map. For this example, you will be using the Mapbox Dark template style. You can find the Style URLs for each of the template styles in our API documentation. In your text editor, create a new index.html file, then copy and paste the below code into it. Make sure to replace YOUR_MAPBOX_ACCESS_TOKEN with an access token that is associated with your account. Once you add this code and save your index.html file, you can preview the file in your browser to make sure you see the map. Note Be sure to save and store the GeoJSON file in the same directory as your project. You will also need to run this application from a local web server, otherwise you will receive a Cross-origin Resource Sharing (CORS) error. Python's SimpleHTTPServer is included on many computers and is a good choice if this is your first time running a local server. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title></title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <div id='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/dark-v 10 ', center: [-79.999732, 40.4374], zoom: 11 } ); // we will add more code here in the next steps </script> </body> </html> Add your data You will first need to add the GeoJSON you downloaded at the beginning of this guide as the source for your heatmap. You can do this by using the addSource method. This source will be used to create not only a heatmap layer but also a circle layer. The heatmap layer will fade out while the circle layer fades in to show individual data points at higher zoom levels. Add the following code after the map you initialized in the previous step. map.on('load', function() { map.addSource('trees', { type: 'geojson', data: './trees.geojson' } ); // add heatmap layer here // add circle layer here } ); Add the heatmap layer Next, use the addLayer method to create a new layer for your heatmap. Once you've created this layer, you will make use of the heatmap properties discussed earlier to fine-tune your heatmap's appearance. For heatmap-weight, specify a range that reflects your data (the dbh property ranges from 1-62 in the GeoJSON source). Because larger trees have a high dbh, give them more weight in your heatmap by creating a stop function that increases heatmap-weight as dbh increases. Since heatmap-intensity is a multiplier on top of heatmap-weight, heatmap-intensity can be increased as the map zooms in to preserve a similar appearance throughout the zoom range. The images below show the impact of heatmap-intensity on your map's appearance. The image on the left shows heatmap-intensity that increases with zoom level and the one on the right shows heatmap-intensity that uses the default of 1. For heatmap-color, add an interpolate expression that defines a linear relationship between heatmap-density and heatmap-color using a set of input-output pairs. If you are interested in learning more about Mapbox GL JS Expressions, read the Get Started with Mapbox GL JS expressions guide and the Mapbox GL JS documentation. Finish configuring your heatmap layer by setting values for heatmap-radius and heatmap-opacity. heatmap-radius should increase with zoom level to preserve the smoothness of the heatmap as the points become more dispersed. heatmap-opacity should be decreased from 1 to 0 between zoom levels 14 and 15 to provide a smooth transition as your circle layer fades in to replace the heatmap layer. Add the following code within the 'load' event handler after the addSource method. map.addLayer( { id: 'trees-heat', type: 'heatmap', source: 'trees', maxzoom: 15, paint: { // increase weight as diameter breast height increases 'heatmap-weight': { property: 'dbh', type: 'exponential', stops: [ [1, 0], [62, 1] ] } , // increase intensity as zoom level increases 'heatmap-intensity': { stops: [ [11, 1], [15, 3] ] } , // assign color values be applied to points depending on their density 'heatmap-color': [ 'interpolate', ['linear'], ['heatmap-density'], 0, 'rgba(236,222,239,0)', 0.2, 'rgb(208,209,230)', 0.4, 'rgb(166,189,219)', 0.6, 'rgb(103,169,207)', 0.8, 'rgb(28,144,153)' ], // increase radius as zoom increases 'heatmap-radius': { stops: [ [11, 15], [15, 20] ] } , // decrease opacity to transition into the circle layer 'heatmap-opacity': { default: 1, stops: [ [14, 1], [15, 0] ] } , } } , 'waterway-label'); Add the circle layer Next, add a circle layer. As you zoom in to your heatmap, the points stop overlapping visually and it is no longer necessary to show their distribution and density. At this point, you can show the points themselves and allow viewers to explore the data interactively. Remember how you used a stop function in the previous step to fade the heatmap layer out between zoom level 14 and 15? You'll need to replace that layer by fading your circle layer in, using a zoom function to increase its circle-opacity between zooms 14 and 15. For circle-radius, use a zoom-and-property function to increase the radius by zoom level and property (as demonstrated below). Add the following code after the heatmap layer you added in the last step. map.addLayer( { id: 'trees-point', type: 'circle', source: 'trees', minzoom: 14, paint: { // increase the radius of the circle as the zoom level and dbh value increases 'circle-radius': { property: 'dbh', type: 'exponential', stops: [ [ { zoom: 15, value: 1 } , 5], [ { zoom: 15, value: 62 } , 10], [ { zoom: 22, value: 1 } , 20], [ { zoom: 22, value: 62 } , 50], ] } , 'circle-color': { property: 'dbh', type: 'exponential', stops: [ [0, 'rgba(236,222,239,0)'], [10, 'rgb(236,222,239)'], [20, 'rgb(208,209,230)'], [30, 'rgb(166,189,219)'], [40, 'rgb(103,169,207)'], [50, 'rgb(28,144,153)'], [60, 'rgb(1,108,89)'] ] } , 'circle-stroke-color': 'white', 'circle-stroke-width': 1, 'circle-opacity': { stops: [ [14, 0], [15, 1] ] } } } , 'waterway-label'); Add some additional interactivity The following code adds interactivity to your map by allowing your viewers to click on your circle layer to view a popup containing the tree's DBH value. Include the code below after your circle layer. map.on('click', 'trees-point', function(e) { new mapboxgl.Popup() .setLngLat(e.features[0].geometry.coordinates) .setHTML('<b>DBH:</b> ' + e.features[0].properties.dbh) .addTo(map); } ); Finished product Congrats! You made your first heatmap with Mapbox GL JS! Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Make a heatmap with Mapbox GL JS,Heatmap paint properties,Create your map using Mapbox GL JS,Add your data,Add the heatmap layer,Add the circle layer,Add some additional interactivity,Finished product,,,,,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Draw a GeoJSON line,Draw a polyline by parsing a GeoJSON file with the Mapbox Maps SDK.,https://docs.mapbox.com/android/maps/examples/draw-a-geojson-line/,example,Java,,"Draw a GeoJSON line Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.dds.DrawGeojsonLineActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""45.5076"" mapbox:mapbox_cameraTargetLng=""-122.6736"" mapbox:mapbox_cameraZoom=""11""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.AsyncTask; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.geojson.FeatureCollection; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.Scanner; import timber.log.Timber; /** * Draw a polyline by parsing a GeoJSON file with the Mapbox Android SDK. */ public class DrawGeojsonLineActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private MapboxMap mapboxMap; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_annotation_geojson_line); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { new LoadGeoJson(DrawGeojsonLineActivity.this).execute(); } }); } private void drawLines(@NonNull FeatureCollection featureCollection) { if (mapboxMap != null) { mapboxMap.getStyle(style -> { if (featureCollection.features().size() > 0) { style.addSource(new GeoJsonSource(""line-source"", featureCollection)); // The layer properties for our line. This is where we make the line dotted, set the // color, etc. style.addLayer(new LineLayer(""linelayer"", ""line-source"") .withProperties(PropertyFactory.lineCap(Property.LINE_CAP_SQUARE), PropertyFactory.lineJoin(Property.LINE_JOIN_MITER), PropertyFactory.lineOpacity(.7f), PropertyFactory.lineWidth(7f), PropertyFactory.lineColor(Color.parseColor(""#3bb2d0"")))); } }); } } private static class LoadGeoJson extends AsyncTask<Void, Void, FeatureCollection> { private WeakReference<DrawGeojsonLineActivity> weakReference; LoadGeoJson(DrawGeojsonLineActivity activity) { this.weakReference = new WeakReference<>(activity); } @Override protected FeatureCollection doInBackground(Void... voids) { try { DrawGeojsonLineActivity activity = weakReference.get(); if (activity != null) { InputStream inputStream = activity.getAssets().open(""example.geojson""); return FeatureCollection.fromJson(convertStreamToString(inputStream)); } } catch (Exception exception) { Timber.e(""Exception Loading GeoJSON: %s"" , exception.toString()); } return null; } static String convertStreamToString(InputStream is) { Scanner scanner = new Scanner(is).useDelimiter(""\\A""); return scanner.hasNext() ? scanner.next() : """"; } @Override protected void onPostExecute(@Nullable FeatureCollection featureCollection) { super.onPostExecute(featureCollection); DrawGeojsonLineActivity activity = weakReference.get(); if (activity != null && featureCollection != null) { activity.drawLines(featureCollection); } } } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Draw a GeoJSON line,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Tilequery API playground,Retrieve features from vector tiles with the Mapbox Tilequery API.,https://docs.mapbox.com/help/interactive-tools/tilequery-api-playground/,playground,,,"Tilequery API playground The Mapbox Tilequery API allows you to retrieve features from vector tilesets based on a given longitude and latitude. The endpoint also gives you the ability to add a radius to the query to retrieve nearby features, as well as several other optional parameters for customizing the output. How to use this interactive tool: Paste your access token into the first field on the left. Select the tileset to query (or query both at once). Enter any desired optional parameters in the appropriate fields. Click a location on the map to visualize the results of your query! Use the GeoJSON tab to view the query results as raw GeoJSON. Note Use of the Mapbox Tilequery API endpoint is rate limited to 300 requests per minute. (If you require a higher rate limit, contact us.) Exceeding the limit of 300 requests per minute will result in an HTTP 429 Too Many Requests response. For information on rate limit headers, see the Rate limits section of the Mapbox API documentation.",,5c6adb81d3b68758d0c5c15a,Tilequery API playground,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,GeoJSON,GeoJSON is a file format for map data served by Mapbox web services and APIs.,https://docs.mapbox.com/help/glossary/geojson/,glossary,,,"GeoJSON GeoJSON is a file format for map data served by Mapbox web services and APIs. As a subset of the JSON format, it can be parsed in modern software and native to the JavaScript language. You can upload GeoJSON files to your Mapbox account to use in a custom map style. See the Mapbox Studio manual uploads page for details. Below is a sample GeoJSON file for reference. Download a sample GeoJSON file There are several open source tools for converting other geospatial data formats to GeoJSON. A few favorites are: togeojson, a node package for converting KML and GPX (XML formats). ogr2ogr, the ultimate 40-in-1 vector data conversion tool. geojson.net for creating, converting, and editing GeoJSON. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,GeoJSON,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,"Add points to a web map, part 2: create a style",Add a tileset to a template style and upload custom icons in Mapbox Studio.,https://docs.mapbox.com/help/tutorials/add-points-pt-2/,tutorial,No code,,"beginner No code Add points to a web map, part 2: create a style This is the second in a series of tutorials that will teach you how to add points to a map using the Mapbox Studio dataset editor, the Mapbox Studio style editor, and Mapbox GL JS. Part 2 focuses on the Mapbox Studio style editor. In this tutorial, you will learn how to: Create a new style using one of the Mapbox default styles Add a tileset as a layer Style the new layer Publish your style Getting started There are a few resources you will need to follow along with this guide: Tileset. You will need a tileset containing 10 Chicago parks. You can learn how to create this tileset in Add points to a web map, Part 1: create a dataset. Custom icon. This tutorial uses a custom icon to show the location of the parks. You will need to download the SVG icon to use in your style. Download SVG icon Add data to a style Web maps are comprised of map tiles. To add your data to a web map, Mapbox will cut it up into tiles so the data can display at various zoom levels. The collection of tiles that Mapbox cuts your map into is called a tileset. In Add points to a web map, part 1: create a dataset, you converted a dataset into a tileset to add it to a new map style. Create a new style After finishing Add points to a web map, part 1: create a dataset, create a new style using the Basic template. On your Styles page in Mapbox Studio, click the New style button. Find the Basic Template style and click Customize Basic Template. The style editor will open automatically. Rename your new style to Chicago Parks using the title field in the upper left side of the screen. Create a new layer You will add your tileset as a new layer here: When the style editor opens, click + Add layer in the upper left. In the list of Data sources, find your chicago-parks tileset, click the name of the tileset, and then click the source layer that appears to add it as the source for the layer. Mapbox Studio recognizes that the data you have uploaded is focused on a different location, so it displays the message ""This tileset isn't available from your map view."" Click Go to data, and the map view will refocus on Chicago. Click the Type option, and then choose the Symbol layer option so you can create a layer with markers. Click back to the Style tab. Style a layer In the Mapbox Studio style editor, you can specify the style properties of each layer. This includes the layers in the Mapbox default styles and any layers you’ve added with custom data. For this example, you will style a symbol layer. You can style symbol layers with both text and icons. Style as a symbol layer Click on the chicago-parks layer you created in the layer list on the left side of the style editor. When the style panel opens, click the Style tab if you're not already there. Select the Icon tab and click on Manage icons in your spritesheet. This opens the Images option in the top toolbar. Click the Upload SVG Image button to and choose the marker you downloaded at the beginning of this tutorial from your files. Once the icon has loaded, choose it from the list. If you would like to show all the markers, even if they overlap, click on the Placement tab. Scroll down to Allow icon overlap and set it to True. You should now see the marker icon appear on all your points. Publish a style Now that you have finished styling your map, you need to publish your style for those changes to be live on the web. Click the Publish button in the top right of the editor. A window will pop up asking you to review your changes. Click Publish. Your browser doesn't support embedded videos. Share The Share modal contains the resources you need to publish your style in a web app, mobile app, or with another third-party tool. Share Click Share in the upper right of the style editor. The Share modal contains a share URL that allows you to share a preview of your style with others. The modal also contains a style URL and your access token, both of which you will need in part three of this tutorial. Next Steps Head to Add points to a web map, part 3: add interactivity to add popups with information about each park to your map using Mapbox GL JS. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,"Add points to a web map, part 2: create a style",Create a new style,Create a new layer,Style a layer,Style as a symbol layer,Publish a style,Share,Next Steps,,,,,,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Maps SDK for React Native,A community-managed React Native library for integrating Mapbox maps into mobile apps.,https://docs.mapbox.com/help/glossary/maps-sdk-for-react-native/,glossary,,,Maps SDK for React Native The Maps SDK for React Native is a community-maintained React Native library that provides reusable JavaScript components for integrating Mapbox maps into iOS and Android apps. The Maps SDK for React Native is maintained by community volunteers. Issues and pull requests should be opened the project's GitHub repository. You need a Mapbox access token to create apps with the Maps SDK for React Native. Was this page helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Maps SDK for React Native,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Slowly fly to a location,Using flyTo with flyOptions.,https://docs.mapbox.com/mapbox-gl-js/example/flyto-options/,example,JavaScript,,Slowly fly to a location Using flyTo with flyOptions. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Slowly fly to a location,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,telemetry,Telemetry is the process in which anonymous sensors create maps based on where people are moving.,https://docs.mapbox.com/help/glossary/telemetry/,glossary,,,"telemetry Telemetry is a process in which automatic sensors create and update maps by gathering anonymized data about where and how people are moving. This is useful for discovering missing roads, tracking traffic information, and more. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,telemetry,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Change building color based on zoom level,Uses the interpolate expression to ease-in the building layer and smoothly fade from one color to the next.,https://docs.mapbox.com/mapbox-gl-js/example/change-building-color-based-on-zoom-level/,example,JavaScript,,Change building color based on zoom level Uses the interpolate expression to ease-in the building layer and smoothly fade from one color to the next. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Change building color based on zoom level,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for iOS,iOS,Examples,Code examples for the Mapbox Vision SDK for iOS.,https://docs.mapbox.com/ios/vision/examples/,,,,Getting started Set up an external camera source Use an external camera source instead of a device's built-in camera. AR Basic blue-line AR navigation Project a blue route line on the view of the road through your device. Safety Speeding alerts Display an alert when the vehicle is speeding.,,5c6adb81d3b68758d0c5c15a,Getting started,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Toggle interactions,Enable or disable UI handlers on a map.,https://docs.mapbox.com/mapbox-gl-js/example/toggle-interaction-handlers/,example,JavaScript,,Toggle interactions Enable or disable UI handlers on a map. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Toggle interactions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Display real-time traffic,Use the traffic plugin to display live car congestion data on top of a map.,https://docs.mapbox.com/android/plugins/examples/show-real-time-traffic-on-a-map/,example,Java,,"Display real-time traffic Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" android:layout_marginBottom=""0dp"" android:layout_marginLeft=""0dp"" android:layout_marginRight=""0dp"" android:layout_marginTop=""0dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintLeft_toLeftOf=""parent"" mapbox:layout_constraintRight_toRightOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""1.352506"" mapbox:mapbox_cameraTargetLng=""103.842874"" mapbox:mapbox_cameraZoom=""9.579712"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/traffic_toggle_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginBottom=""16dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" android:src=""@drawable/ic_directions_car_white_24dp"" mapbox:fabSize=""normal"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintRight_toRightOf=""parent""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.traffic.TrafficPlugin; /** * Toggle the Mapbox Traffic plugin to display real-time traffic data on top * of your map (not all regions supported at the moment). */ public class TrafficPluginActivity extends AppCompatActivity { private MapView mapView; private MapboxMap map; private TrafficPlugin trafficPlugin; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_traffic_plugin); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(final MapboxMap mapboxMap) { map = mapboxMap; mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { trafficPlugin = new TrafficPlugin(mapView, mapboxMap, style); // Enable the traffic view by default trafficPlugin.setVisibility(true); findViewById(R.id.traffic_toggle_fab).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (map != null) { trafficPlugin.setVisibility(!trafficPlugin.isVisible()); } } }); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Display real-time traffic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Global location search,"Add geocoding search functionality and UI for finding any region, country, place, or address in the world.",https://docs.mapbox.com/android/plugins/examples/global-location-search/,example,Java,,"Global location search Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLng=""-43.334931"" mapbox:mapbox_cameraZoom=""0.346515"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/fab_location_search"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_margin=""16dp"" android:tint=""@android:color/white"" app:backgroundTint=""@color/colorPrimary"" app:srcCompat=""@android:drawable/ic_search_category_default"" /> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.app.Activity; import android.content.Intent; import android.graphics.BitmapFactory; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import com.google.gson.JsonObject; import com.mapbox.api.geocoding.v5.models.CarmenFeature; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.places.autocomplete.PlaceAutocomplete; import com.mapbox.mapboxsdk.plugins.places.autocomplete.model.PlaceOptions; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Use the places plugin to take advantage of Mapbox's location search (""geocoding"") capabilities. The plugin * automatically makes geocoding requests, has built-in saved locations, includes location picker functionality, * and adds beautiful UI into your Android project. */ public class PlacesPluginActivity extends AppCompatActivity implements OnMapReadyCallback { private static final int REQUEST_CODE_AUTOCOMPLETE = 1; private MapView mapView; private MapboxMap mapboxMap; private CarmenFeature home; private CarmenFeature work; private String geojsonSourceLayerId = ""geojsonSourceLayerId""; private String symbolIconId = ""symbolIconId""; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_places_plugin); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initSearchFab(); addUserLocations(); // Add the symbol layer icon to map for future use style.addImage(symbolIconId, BitmapFactory.decodeResource( PlacesPluginActivity.this.getResources(), R.drawable.blue_marker_view)); // Create an empty GeoJSON source using the empty feature collection setUpSource(style); // Set up a new symbol layer for displaying the searched location's feature coordinates setupLayer(style); } }); } private void initSearchFab() { findViewById(R.id.fab_location_search).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent = new PlaceAutocomplete.IntentBuilder() .accessToken(Mapbox.getAccessToken()) .placeOptions(PlaceOptions.builder() .backgroundColor(Color.parseColor(""#EEEEEE"")) .limit(10) .addInjectedFeature(home) .addInjectedFeature(work) .build(PlaceOptions.MODE_CARDS)) .build(PlacesPluginActivity.this); startActivityForResult(intent, REQUEST_CODE_AUTOCOMPLETE); } }); } private void addUserLocations() { home = CarmenFeature.builder().text(""Mapbox SF Office"") .geometry(Point.fromLngLat(-122.3964485, 37.7912561)) .placeName(""50 Beale St, San Francisco, CA"") .id(""mapbox-sf"") .properties(new JsonObject()) .build(); work = CarmenFeature.builder().text(""Mapbox DC Office"") .placeName(""740 15th Street NW, Washington DC"") .geometry(Point.fromLngLat(-77.0338348, 38.899750)) .id(""mapbox-dc"") .properties(new JsonObject()) .build(); } private void setUpSource(@NonNull Style loadedMapStyle) { loadedMapStyle.addSource(new GeoJsonSource(geojsonSourceLayerId)); } private void setupLayer(@NonNull Style loadedMapStyle) { loadedMapStyle.addLayer(new SymbolLayer(""SYMBOL_LAYER_ID"", geojsonSourceLayerId).withProperties( iconImage(symbolIconId), iconOffset(new Float[] {0f, -8f}) )); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == Activity.RESULT_OK && requestCode == REQUEST_CODE_AUTOCOMPLETE) { // Retrieve selected location's CarmenFeature CarmenFeature selectedCarmenFeature = PlaceAutocomplete.getPlace(data); // Create a new FeatureCollection and add a new Feature to it using selectedCarmenFeature above. // Then retrieve and update the source designated for showing a selected location's symbol layer icon if (mapboxMap != null) { Style style = mapboxMap.getStyle(); if (style != null) { GeoJsonSource source = style.getSourceAs(geojsonSourceLayerId); if (source != null) { source.setGeoJson(FeatureCollection.fromFeatures( new Feature[] {Feature.fromJson(selectedCarmenFeature.toJson())})); } // Move map camera to the selected location mapboxMap.animateCamera(CameraUpdateFactory.newCameraPosition( new CameraPosition.Builder() .target(new LatLng(((Point) selectedCarmenFeature.geometry()).latitude(), ((Point) selectedCarmenFeature.geometry()).longitude())) .zoom(14) .build()), 4000); } } } } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Global location search,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Migrating to v1.4,A guide to migrating your project from earlier versions of the Maps SDK for Unity to v1.4+.,https://docs.mapbox.com/unity/maps/overview/migrate-version/,guide,,,"Migrating to v1.4 CAUTION: Create a back up of your project to a new folder before migrating to the Maps SDK for Unity v1.4 or higher. You will need this backup project to make the migration process smoothly. Upgrade the Maps SDK for Unity If you did not change any source files from the previous version, you can skip ahead to the Map setup section of this guide. Import the latest version of the Maps SDK for Unity to a newly created project named NewSDK1.4. Next, delete all the old Mapbox folders from your existing project (let’s call it OldSDK1.3). Tip: compare your project folders with the NewSDK1.4 project to see which files and folders to delete. Finally, copy the new folders from the NewSDK1.4 project to your existing project. Do a diff of all the files that changed. Use a file comparison/diff tool like Sourcetree or TortoiseGit to make this process easier. Pay close attention to any files from the Maps SDK for Unity that you changed earlier. If you changed any files, carefully make a manual merge rather than relying on a version control tool to do an automatic merge for you. Map setup Once you have resolved any compiler errors in Unity, the next step is to resolve the missing script reference on the map game object. AbstractMap has a lot more functionality in v1.4.0 and later versions. You no longer need to add explicit Map types (Basic Map, MapAtSpecificLocation etc.). AbstractMap can be set up to function the same way as any of the v1.3 Maps. To do so, drag and drop the AbstractMap script to replace the missing script field. Refer to the table below to select the correct option for your map. v1.3 Map name v1.4 Abstract Map Placement Type v1.4 Abstract Map Scaling Type Basic Map At Tile Center Custom Quad Tree Basic Map At Location Center Custom Map At Specific Location At Location Center Custom Map At World Scale At Location Center World Scale Tile provider setup You are no longer required to add TileProviders explicitly, because in v1.4+ they are added to the map using the ExtentOptions. If you still want to add a custom TileProvider, you can do this by selecting the Custom option from the Extent Options menu. Refer the table below to select the correct setting for your TileProvider. v1.3 Tile Provider v1.4.0 Extent Option Remove v1.3 Component CameraBoundsTileProvider CameraBounds Yes QuadTreeTileProvider CameraBounds Yes RangeTileProvider RangeAroundCenter Yes RangeAroundTransformTileProvider RangeAroundTransform Yes Any Custom Tile Provider Custom No MapVisualizer setup Starting with v1.4.0, MapVisualizer will be set up automatically using the settings under the IMAGE, TERRAIN and VECTOR sections. To migrate v1.3 MapVisualizers to v1.4, follow the steps below. Open two separate instances of Unity. One instance will be your existing project, and the other will be the new project with the updated version of the Maps SDK for Unity. Next, open the Map Editor on your existing project by navigating to Mapbox > Map Editor from the top menu. Carefully go through every node of in your existing project and populate the fields on the AbstractMap script in the new project. You can find information on how the AbstractMap script can configured on the Introduction to the Maps SDK page. Map Image Factory → IMAGE. MapImageFactory in v1.3 can now be set up using the options available under IMAGE section of AbstractMap. Terrain Factory → TERRAIN. TerrainFactory in v1.3 can now be set up using the options available under TERRAIN section of AbstractMap. v1.3 Terrain Factory name v1.4 Elevation Layer Type FlatTerrainFactory FlatTerrain LowPolyTerrainFactory LowPolygonTerrain TerrainFactory TerrainWithElevation ( Add SideWalls option unchecked) TerrainWithSideWallsFactory TerrainWithElevation ( Add SideWalls option checked) FlatSphereTerrainFactory GlobeTerrain Vector Tile Factory → VECTOR. VectorTileFactory in v1.3 can now be set up using the options available under VECTOR section of AbstractMap. The new AbstractMap automatically applies default modifiers when choosing Point, Line, Polygon in the Primitive Type settings. See the table below for the conversions: Primitive Type Default Mesh Modifiers Default Game Object Modifiers Polygon PolygonMeshModifier, UVModifier, HeightModifier MaterialModifier Line LineMeshModifier, HeightModifier MaterialModifier SnapTerrainModifier in v1.3 is now configured by the Snap To Terrain checkbox. If you are using a MergedModifierStack in 1.3, you will need to use the Group Features checkbox. ColliderModifier in v1.3 is now set by the Collider Type menu which allows you to choose the type of collider you want to add to the extruded geometry. Select Custom for the Primitive Type if you don’t want any default modifiers to be attached. Compare your new project to your old project, going through every game object one by one. Make sure all the scripts have the same values and have been serialized properly. API changes If you are using Initialize() to load a new location after you have already initialized the map, replace it with the new UpdateMap() method which takes in the same arguments. The AbstractMap class has the Initialize(), UpdateMap() and ResetMap() methods. If you are using InitializeMapWithLocationProvider, make sure that the Initialize On Start checkbox on the AbstractMap script is unchecked. The new LocationProviderFactory script has a serialized Map Manager reference. Make sure you have serialized it with the corresponding AbstractMap reference. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Migrating to v1.4,Tile provider setup,MapVisualizer setup,API changes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add an image,Dark vector baselayer with radar weather image overlay.,https://docs.mapbox.com/mapbox-gl-js/example/image-on-a-map/,example,JavaScript,,Add an image Dark vector baselayer with radar weather image overlay. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Add an image,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Custom destination marker,Add a custom marker to the destination.,https://docs.mapbox.com/ios/navigation/examples/custom-destination-marker/,example,Swift,,"Custom destination marker import Foundation import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections class CustomDestinationMarkerController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let origin = CLLocationCoordinate2DMake(37.77440680146262, -122.43539772352648) let destination = CLLocationCoordinate2DMake(37.76556957793795, -122.42409811526268) let options = NavigationRouteOptions(coordinates: [origin, destination]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) let navigationOptions = NavigationOptions(navigationService: navigationService) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) navigationViewController.mapView?.delegate = self self.present(navigationViewController, animated: true, completion: nil) } } } extension CustomDestinationMarkerController: MGLMapViewDelegate { func navigationViewController(_ navigationViewController: NavigationViewController, imageFor annotation: MGLAnnotation) -> MGLAnnotationImage? { var annotationImage = navigationViewController.mapView!.dequeueReusableAnnotationImage(withIdentifier: ""marker"") if annotationImage == nil { // Leaning Tower of Pisa by Stefan Spieler from the Noun Project. var image = UIImage(named: ""marker"")! // The anchor point of an annotation is currently always the center. To // shift the anchor point to the bottom of the annotation, the image // asset includes transparent bottom padding equal to the original image // height. // // To make this padding non-interactive, we create another image object // with a custom alignment rect that excludes the padding. image = image.withAlignmentRectInsets(UIEdgeInsets(top: 0, left: 0, bottom: image.size.height / 2, right: 0)) // Initialize the ‘pisa’ annotation image with the UIImage we just loaded. annotationImage = MGLAnnotationImage(image: image, reuseIdentifier: ""marker"") } return annotationImage } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Custom destination marker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Manage large data files for Mapbox Studio with Tippecanoe,Learn how to manage big data files and make a scale-independent view of your data.,https://docs.mapbox.com/help/troubleshooting/large-data-tippecanoe/,troubleshooting,,,"Manage large data files for Mapbox Studio with Tippecanoe If your data is large in size and exceeds the maximum upload limit, you may not be able to upload it to Mapbox Studio. This guide will show you how to use Tippecanoe, a command-line utility, to convert your data into smaller files suitable for uploading to Mapbox Studio. About Tippecanoe Tippecanoe creates vector tilesets from large GeoJSON feature collections. The output is an MBTiles file that can be uploaded to Mapbox. Getting started Before you begin, your data must be in the form of a GeoJSON file. There are many tools you can use to do this conversion — we recommend using ogr2ogr. You will also need to install Tippecanoe. Please note that Tippecanoe is not supported on Windows. Reducing the size of a large data file The GeoJSON file in the example below (new-york_new-york_buildings.geojson) is 761.5 MB in size. Since this exceeds the upload limit for a GeoJSON file, Tippecanoe will need to be used to reduce the size of this file. Converting GeoJSON to vector tiles Once Tippecanoe is installed, you can convert your GeoJSON file to MBTiles. In your command line, navigate to the directory that contains the GeoJSON file, and then run the following command: tippecanoe -o nyc-buildings.mbtiles new-york_new-york_buildings.geojson Where new-york_new-york_buildings.geojson is the name of your GeoJSON file, and nyc-buildings.mbtiles is the name you should give to the resulting MBTiles file. Tippecanoe will then read and sort the features and convert them to the MBTiles data format. Tippecanoe has many other options, but you will stick to the command above for this guide. The resulting MBTiles file will be saved in your current directory. You now have a new vector tileset that has a size of 4.7 Mb - dramatically less than the original GeoJSON file! Next steps Now that you've converted your GeoJSON file to a vector tileset, you can upload it to Mapbox Studio to use in a custom style. Read the Mapbox Studio Manual uploads section to learn more about uploading your custom data. Once your data has been uploaded, take a look at the Mapbox Studio Manual style section for more information on styling line layers, fill layers, fill-extrusion layers, circle layers, and symbol layers in the Mapbox Studio style editor. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Manage large data files for Mapbox Studio with Tippecanoe,Reducing the size of a large data file,Converting GeoJSON to vector tiles,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Data-driven circles,Dynamically style a circle layer with data-driven styling.,https://docs.mapbox.com/ios/maps/examples/dds-circle-layer/,example,Swift,Objective-C,"Data-driven circles Source data originates from a GeoJSON file uploaded to create a tileset in Mapbox Studio. Refer to the Working with GeoJSON data guide for more information about working with GeoJSON source data. Learn more about creating data visualizations in our Predicates and expressions guide. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() // Create a new map view using the Mapbox Light style. mapView = MGLMapView(frame: view.bounds) mapView.styleURL = MGLStyle.lightStyleURL mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .darkGray // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 38.897, longitude: -77.039), animated: false) mapView.zoomLevel = 10.5 mapView.delegate = self view.addSubview(mapView) } // Wait until the style is loaded before modifying the map style. func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { // ""mapbox://examples.2uf7qges"" is a map ID referencing a tileset. For more // more information, see mapbox.com/help/define-map-id/ let source = MGLVectorTileSource(identifier: ""trees"", configurationURL: URL(string: ""mapbox://examples.2uf7qges"")!) style.addSource(source) let layer = MGLCircleStyleLayer(identifier: ""tree-style"", source: source) // The source name from the source's TileJSON metadata: mapbox.com/api-documentation/maps/#retrieve-tilejson-metadata layer.sourceLayerIdentifier = ""yoshino-trees-a0puw5"" // Stops based on age of tree in years. let stops = [ 0: UIColor(red: 1.00, green: 0.72, blue: 0.85, alpha: 1.0), 2: UIColor(red: 0.69, green: 0.48, blue: 0.73, alpha: 1.0), 4: UIColor(red: 0.61, green: 0.31, blue: 0.47, alpha: 1.0), 7: UIColor(red: 0.43, green: 0.20, blue: 0.38, alpha: 1.0), 16: UIColor(red: 0.33, green: 0.17, blue: 0.25, alpha: 1.0) ] // Style the circle layer color based on the above stops dictionary. layer.circleColor = NSExpression(format: ""mgl_step:from:stops:(AGE, %@, %@)"", UIColor(red: 1.0, green: 0.72, blue: 0.85, alpha: 1.0), stops) layer.circleRadius = NSExpression(forConstantValue: 3) style.addLayer(layer) } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Data-driven circles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Route generation,Learn how to generate routes for use in the Mapbox Navigation SDK or Navigation UI SDK for Android.,https://docs.mapbox.com/android/navigation/overview/route-generation/,guide,Java,Kotlin,"Route generation SDKs covered: Navigation SDK Navigation UI SDK Route generation and the Navigation UI SDK This guide does not describe any specific options in the Navigation UI SDK, but, the concepts described in this guide are important to understand if you are using the Navigation UI SDK. You will need to provide either a valid DirectionsRoute object or both an origin and destination Point object to the NavigationView. If you provide both, only the DirectionsRoute will be used. For details on default and custom route styling using the Navigation UI, see Map and application design. The core Navigation SDK uses routes generated by the Mapbox Directions API. The Navigation SDK's NavigationRoute class wraps the MapboxDirections class with parameters that must be set in order for a navigation session to successfully begin. You can use the NavigationRoute.Builder class to create a new request to the Mapbox Directions API. There are over a dozen methods that can be used to customize your request, but only three are required: accessToken origin destination The response will be a NavigationRoute object, which you can use to display a route on a map or start a navigation sequence. Java Kotlin // From Mapbox to The White House Point origin = Point.fromLngLat(-77.03613, 38.90992); Point destination = Point.fromLngLat(-77.0365, 38.8977); NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin) .destination(destination) .build() .getRoute(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { } @Override public void onFailure(Call<DirectionsResponse> call, Throwable t) { } }); Copy Request a route in a specific direction Consider the direction a user’s device is facing, and request a route starting in a specific direction. To receive a route that starts off in the same direction the user is already traveling, pass in the user’s location bearingvalue (between 0 and 355 degrees). If you need to request a route that's continuing along the path that the user is traveling, specify a bearing and a tolerance that determines how far you are willing to deviate from the provided bearing. This is useful for off-route scenarios. Device location: In the adjacent diagram, the blue dot with white stroke is the device location. Bearing: The bearing tells you the direction a user's device is facing. It is an angle clockwise from true north between 0 and 359. For example, if the device is facing north, the bearing will be 0°, and if the user is facing due east, the bearing will be 90°. In the adjacent diagram, the pink arrow is the direction that the device is facing (which is due west or 270°). Tolerance: Tolerance is the range of degrees by which a route can deviate from the bearing angle and still be recommended. The semi-transparent blue area illustrates tolerance. In this example tolerance is 90° (45° in either direction from the bearing angle). This can be applied to the origin, waypoints, and the destination using NavigationRoute: Java Kotlin // An Android Location object double bearing = Float.valueOf(location.getBearing()).doubleValue(); double tolerance = 90d; NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin, bearing, tolerance) .destination(destination) .build(); Copy Specify a side of the road to approach You can state from which side of the road to approach a waypoint by adding approaches to the NavigationRoute builder. There are three options found in DirectionsCriteria.ApproachesCriteria: ""unrestricted"" (default): the route can approach waypoints from either side of the road. ""curb"": the route will be returned so that on arrival, the waypoint will be found on the side that corresponds with the driving_side of the region in which the returned route is located. null: if no option is specified, it is translated internally to """", which has the same result as setting an approach to ""unrestricted"". If provided, the list of approaches must be the same length as the list of waypoints (including the origin and the destination) and in that particular order (origin, waypoints, destination). If a re-route occurs and approaches were used to fetch the DirectionsRoute that was originally provided to the NavigationView, the new route fetched will take the same approaches criteria into account. Java Kotlin NavigationRoute.Builder builder = NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin) .addWaypoint(pickup) .destination(destination); builder.addApproaches(""unrestricted"", ""curb"", ""curb""); builder.build(); Copy Include multiple stops If your navigation involves several pick-up and drop-off points, you can add up to 25 coordinates (including the origin and destination) to the NavigationRoute builder using the driving profile or three coordinates using the driving-traffic profile. These coordinates are treated as stops in between the origin and destination Points (in the order that you add them — the first waypoint is the first stop): Java Kotlin NavigationRoute.Builder builder = NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin) .destination(destination); for (Point waypoint : waypoints) { builder.addWaypoint(waypoint); } builder.build(); Copy More about route generation Read more about route generation in: Localization: Customize the language and units of measurement returned for both text and voice instructions or use the language preferences set on the device. Offline routing: Provide routing functionality from the Navigation SDK in non-connected environments. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Route generation,Include multiple stops,More about route generation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,World-scale AR,An overview of the world-scale AR example provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/world-scale-ar/,example,No code,,"World-scale AR The world-scale AR example allows for overlaying 3D maps and location data onto the AR camera feed using Unity’s AR Interface and location services. This article outlines the setup and purpose of each major part of the World-scale AR example. Concepts AR Session: In AR apps, the scene’s main camera is positioned automatically to match the real-world device’s position, but only from the moment the app is initialized. Map Alignment: To make an AR session location aware, the WorldAlignmentKit prefab aligns a 3D map around the AR camera. Customization: Once the Map is aligned, you have access to all Mapbox’s data and customization to build world-scale experiences. Getting started To open the example, navigate to MapboxAR > Examples > Scenes > WorldScaleAR and double-click to open. You’ll see an AR prerequisites warning. Some layers that aren’t included by default in a Unity project are needed to run this scene. Select WorldAlignmentKit in the Hierarchy view. To get things going, add the following layers by clicking Layer and selecting Add Layer Next, add: ARGameObject Map Path Both The WorldAlignmentKit contains: ARRoot: The UnityInterface Prefab for building cross-platform AR apps. MapCamera: A top-down view of the map, used to view gps traces, AR position, and the current map alignment. View in play mode with the Map Checkbox. ArAlignedMap: The map, aligned to AR Root using your devices location services. Renders orange debug buildings by default. DebugCanvas: A detailed debug log of location services and AR activity viewable by pressing the ‘LOG’ icon in play mode and on devices. This is included as a unity UI element to make debugging easier on-location. LocationProvider: Provides GPS data to the map, and spoofs data for testing in the editor. Running in the editor Once your project layers are set up, play the scene. you should see the GPS position: In the Editor, the map is positioned based on EditorLocationProvider settings, a component attached to WorldAlignmentKit > LocationProvider > Editor in the hierarchy. The WorldAlignmentKit shows GPS movement in blue, and AR movement in red. The blue dot is the current GPS trace. In the editor, test this out by using the ""w,a,s,d"" keys to move the AR camera in the editor. After some distance, you should see an AR trace in red, and the last GPS fix in blue. In the editor, the GPS fix won’t update automatically. On a device, you’ll see blue traces as well as red. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,World-scale AR,Running in the editor,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Traffic Data,Examples,Learn how to use Python to manipulate and parse the Traffic Data CSV files.,https://docs.mapbox.com/traffic-data/overview/example/,guide,,,"Examples We are providing you with a zipped file that contains example data so that you can experiment with the format of the Typical speeds file. This sample file uses OpenStreetMap node pairs to identify road segments within the 0320122 quadkey, which includes Wilmington, NC. This data is not up-to-date, and is for testing purposes only. Mapbox Enterprise customers have access to the most up-to-date Typical files, Live files, and files that use OpenLR identifiers. If you are not an Enterprise customer and would like to access these assets, contact the Mapbox Sales team. An example file with data referenced by OpenLR Strings can be found at the bottom of this page. Download file The sample code in these examples use Python and the pandas library. Calculate aggregated traffic metrics You may be interested in calculating aggregated traffic metrics using the Typical speeds file. An example of this would be averaging speeds for each road across all five-minute intervals between 9:00 AM and 10:00 AM on Monday morning. The first two columns of a row in the file identify the node pair that makes up a road segment. Because there are 396 five-minute intervals in the week between Sunday at 0:00 AM and Monday at 9:00 AM, this means the data to be aggregated exists between the 399th column and the 410th column of the Typical speeds CSV. The following Python code consumes the sample Typical speeds file and generates the aggregated data described above as a pandas.DataFrame called monday_9_10_nodes_speeds: import pandas as pd all_speeds = pd.read_csv('0320122-America-New_York.csv.gz', header=None, compression='gzip') monday_9_10_speeds = all_speeds.iloc[:, 398:410].mean(axis=1).round(2) monday_9_10_nodes_speeds = pd.concat([all_speeds[[0, 1]]monday_9_10_speeds], axis=1) monday_9_10_nodes_speeds.columns = ['start_node', 'end_node', 'average'] print(monday_9_10_nodes_speeds.head()) # Expected output: # # start_node end_node average # 0 113054533 113096757 55.58 # 1 170190194 4525170049 93.92 # 2 4525170049 4525170048 93.92 # 3 4525170048 170198969 93.92 # 4 170198969 170181217 93.92 Represent one point in time You may also be interested in parsing the Typical speeds file to represent data at one point in time. To do so, you can manipulate the data so that it matches the format of the Live speeds file (start node, end node, speed). This format is useful if you want to provide traffic updates based on typical traffic patterns to a routing engine like OSRM. Because there are two columns that represent the start and end nodes as well as 396 columns for the five-minute intervals between Sunday at 0:00 AM and Monday at 9:00 AM, this means the data for 9:00 AM Monday exists at the 399th column of the Typical speeds CSV. The following Python code generates a simplified file that contains the start and end nodes and the speed data from 9:00-9:05 AM on Monday. import pandas as pd all_speeds = pd.read_csv('0320122-America-New_York.csv.gz', header=None, compression='gzip') monday_9am = all_speeds[[0, 1, 398]] monday_9am.to_csv('9am_speeds.csv', header=False, index=False) If you want to use the resulting file to supply traffic data to OSRM, the OSRM Wiki entry on traffic updates has instructions specific to this use case. This workflow enables you to load a single snapshot of traffic data, rather than an array of speeds that maps to times of the day or week. It is up to you to arrange for continuous updating if that is your intention. If you are interested in applying frequent speed updates to OSRM (on the scale of minutes rather than hours), we recommend you use the Multi-level Dijkstra (MLD) preprocessing pipeline as described in the OSRM traffic updates wiki page. Sample OpenLR file Download OpenLR file Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Examples,Sample OpenLR file,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Sort stores by distance,This guide walks you through all the code that you need to build a store locator which lets you search for the nearest location.,https://docs.mapbox.com/help/tutorials/geocode-and-sort-stores/,tutorial,JavaScript,,"advanced JavaScript Sort stores by distance Prerequisite Familiarity with front-end development concepts. Some advanced JavaScript required. This guide will walk you through how to use Mapbox GL JS, the Mapbox GL Geocoder plugin, and Turf.js to sort store locations based on distance from a geocoded point. This guide extends the map created in the Build a store locator using Mapbox GL JS tutorial. If haven't completed that tutorial yet, be sure to do so before starting this project. If you're new to Mapbox GL JS, you may also want to read our Web applications guide first. Getting started For this project, we recommend that you create a local folder called ""sort-store-locator"" to house your project files. You'll see this folder referred to as your project folder. There are a few resources you'll need before getting started: Store locator final project. This tutorial builds off of the code created in the Build a store locator using Mapbox GL JS tutorial. Make sure you've created a copy of the final version of that code for this new project or downloaded the starter code. Download starter code An access token from your account. You will use an access token to associate a map with your account. Your access token is on the Account page. Mapbox GL JS. The Mapbox JavaScript library that uses WebGL to render interactive maps from Mapbox GL styles. Mapbox GL Geocoder plug-in. The Mapbox GL JS wrapper library for the Mapbox Geocoding API. Turf.js. An open-source analysis library that performs spatial analysis in the browser and in Node.js. A text editor. You'll be writing HTML, CSS, and JavaScript. Add plugins and initialize the map Download the starter-code zip file. Inside you'll find an index.html file and an img folder that contains the custom marker you'll be using to show store locations. Open the index.html file in a text editor. Make sure you use your own access token and set it equal to mapboxgl.accessToken. Add Mapbox GL geocoder plugin and Turf.js Next, set up your document by adding the Mapbox GL Geocoder plug-in and Turf.js library links to the head of your HTML file. Copy and paste the following code after your links to Mapbox GL JS. <!-- Geocoder plugin --> <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.min.js'></script> <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.css' type='text/css' /> <!-- Turf.js plugin --> <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script> Add geocoder control Add the geocoder control to your JavaScript code using the constructor new mapboxgl.Geocoder. In this case, you'll limit the search results to the Washington DC area using the bbox parameter. There are several other parameters you can specify. You can read more about the available parameters in the documentation on GitHub. The code below should be added inside map.on('load', function (e) { ... } ); in your script tags. var geocoder = new MapboxGeocoder( { accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style bbox: [-77.210763, 38.803367, -76.853675, 39.052643] // Set the bounding box coordinates } ); map.addControl(geocoder, 'top-left'); Now add some CSS to style your new geocoding search bar. You can add this code right before your closing </style> tag. .mapboxgl-ctrl-geocoder { border: 0; border-radius: 0; position: relative; top: 0; width: 800px; margin-top: 0; } .mapboxgl-ctrl-geocoder > div { min-width: 100%; margin-left: 0; } Save your HTML document, and refresh the page in your web browser. The result should look like this. Notice what happens when you search for an address using the geocoding form you have created. The map will fly to the location you've specified, but doesn't visualize the matching location. In the next step, you'll add a point once you've successfully found a location using Mapbox GL Geocoder. Add point on search Adding a custom marker style The Mapbox GL Geocoder sets a marker at the search result location by default. This example adds a custom marker as a new layer instead. If you want to use the default marker provided by the geocoder, remove the line marker: false, from the new geocoder instantiation. Now that your geocoder is working, you can write code to add a point to your map at the location you searched. All this code will go inside map.on('load', function (e) { ... } ); directly following the code you added in the previous step. First, you need to add an empty source using map.addSource() where you will store your geocoder result, and a styled layer from that source using map.addLayer(). map.addSource('single-point', { type: 'geojson', data: { type: 'FeatureCollection', features: [] // Notice that initially there are no features } } ); map.addLayer( { id: 'point', source: 'single-point', type: 'circle', paint: { 'circle-radius': 10, 'circle-color': '#007cbf', 'circle-stroke-width': 3, 'circle-stroke-color': '#fff' } } ); Next, create an event listener that fires when the user selects a geocoder result. When the user selects a place from the list of returned locations, save the coordinates in a variable called searchResult. Then, set the data in the source with the id single-point you declared above to searchResult. Copy and paste this code after the map.addSource() and map.addLayer() functions. geocoder.on('result', function(ev) { var searchResult = ev.result.geometry; map.getSource('single-point').setData(searchResult); } ); The result should look like this: Sort store list by distance Next, calculate the distance between the searched location and the stores, add the results to your GeoJSON data, and sort the store listings by distance from the searched point. Find distance from all locations Next you'll use Turf.js to find the distances between your new point and each of the restaurant locations. Turf.js can do a wide variety of spatial analysis functions, which you can read about in the documentation. In this tutorial you are going to use distance. Within your geocoder.on('result', function() { ... } ); function, use a forEach loop to iterate through all the store locations in your GeoJSON (remember, you stored these in the stores variable earlier), define a new property for each object called distance, and set the value of that property to the distance between the coordinates stored in the searchResult and the coordinates of each store location. You will do this using the turf.distance() method, which accepts three arguments: from, to, options. var options = { units: 'miles' } ; stores.features.forEach(function(store) { Object.defineProperty(store.properties, 'distance', { value: turf.distance(searchResult, store.geometry, options), writable: true, enumerable: true, configurable: true } ); } ); For each feature in your GeoJSON, a distance property is applied or will be updated each time a new geocoder result is selected. Sort store list by distance Now that you have the distance value for each store location, you can use it to sort the list of stores by distance. First, sort the objects in the stores array by the distance property you added earlier. Copy and paste the following code snippet inside the geocoder.on('result', function() { ... } ); function. stores.features.sort(function(a, b) { if (a.properties.distance > b.properties.distance) { return 1; } if (a.properties.distance < b.properties.distance) { return -1; } // a must be equal to b return 0; } ); Then, remove the current list of stores and rebuild the list using the reordered array you created. The individual listings are nested within the div with id listings. var listings = document.getElementById('listings'); while (listings.firstChild) { listings.removeChild(listings.firstChild); } buildLocationList(stores); Now the listing for each store will be in ascending order of distance from the point that was searched. To make the new list of locations more useful to your viewers, add text that describes each listing's distance from the point they searched for. When you built your initial interactive store locator in the previous tutorial, you created a buildLocationListing() function. You will need to find and change that function to check if there is a distance property, and if there is, add the value of that property to each listing. Copy and paste the following code before the link.addEventListener() function within the buildLocationListing() function. if (prop.distance) { var roundedDistance = Math.round(prop.distance * 100) / 100; details.innerHTML += '<p><strong>' + roundedDistance + ' miles away</strong></p>'; } The result should look like this: Fit bounds to search result and closest store Finally, when you search for a location, you can change the view to include both the location that was searched and the closest store to show more context. You can do this by using map.fitBounds() and specifying a bounding box. But the bounds need to be in a specific order. The first point you specify should be the lower left corner of the bounding box, and the second should be the upper right corner. Add the following code inside the geocoder.on() function to create a bbox with this syntax from the geocoded location and the closest store, fly to it, and open the closest store's popup. function sortLonLat(storeIdentifier) { var lats = [stores.features[storeIdentifier].geometry.coordinates[1], searchResult.coordinates[1]]; var lons = [stores.features[storeIdentifier].geometry.coordinates[0], searchResult.coordinates[0]]; var sortedLons = lons.sort(function(a, b) { if (a > b) { return 1; } if (a.distance < b.distance) { return -1; } return 0; } ); var sortedLats = lats.sort(function(a, b) { if (a > b) { return 1; } if (a.distance < b.distance) { return -1; } return 0; } ); map.fitBounds([ [sortedLons[0], sortedLats[0]], [sortedLons[1], sortedLats[1]] ], { padding: 100 } ); } sortLonLat(0); createPopUp(stores.features[0]); Finished product You have created a store locator with geocoding and spatial analysis. Next steps After this guide, you should have everything you need to create your own store locator. You can complete the Create a custom style tutorial to create a branded map style or use Cartogram, a drag and drop tool, to create a custom style from your logo in minutes. To do more with Mapbox GL JS, explore our examples page and the Mapbox GL JS on the help page. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Sort stores by distance,Add Mapbox GL geocoder plugin and Turf.js,Add geocoder control,Add point on search,Sort store list by distance,Find distance from all locations,Fit bounds to search result and closest store,Finished product,Next steps,,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Style lines with a data-driven property,Creating a visualization with a data expression for line-color.,https://docs.mapbox.com/mapbox-gl-js/example/data-driven-lines/,example,JavaScript,,Style lines with a data-driven property Creating a visualization with a data expression for line-color. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Style lines with a data-driven property,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Use custom Mapbox styles in Tableau,General configuration guidance and tips for using custom Mapbox maps in Tableau.,https://docs.mapbox.com/help/troubleshooting/use-custom-mapbox-styles-in-tableau/,troubleshooting,,,"Use custom Mapbox styles in Tableau The latest versions of Tableau Server, Desktop, Public, and Online all use Mapbox vector maps by default. This guide shows you how to import and use custom Mapbox styles in Tableau. Find a Mapbox style's integration URL To use a Mapbox style in Tableau, you need that style's integration URL. Go to your Mapbox Studio styles page and click on the style that you would like to use as your background map in Tableau. Click on the Share button in the options bar at the top of the screen. Click the Production tab. In the Develop bar, click the Third party option. Choose Tableau from the dropdown menu. Click on the clipboard button to copy the Integration URL to your computer's clipboard. You will use this URL to connect to your Mapbox style from Tableau. Change your background map to a custom Mapbox map To use a custom Mapbox map as your background map in Tableau: In Tableau, click on Map > Background Maps > Map Services. In the Map Services panel, click the Add button. Select Mapbox Maps. Give the style a name in the Style Name field. You will be able to use this name later to identify the style, so make it descriptive. In the Add Mapbox Map modal, paste the Mapbox integration URL into the URL field. The API access token, Username, and Style ID fields will automatically populate. Click the OK button. The background map will automatically switch the Mapbox map style you imported in the last step. Use background maps in Tableau Desktop You can access the Mapbox maps you've added to Tableau through the Maps menu: Click on Map in the Tableau menu bar. Select Background Maps. Click on your desired Mapbox style. The background map will be updated to use the style that you select. Show or hide layers in a custom Mapbox map When you set your Tableau background map to use a custom Mapbox map style, you can use the Map Layers panel to either show or hide layers within that Mapbox style. The layers used in a custom Mapbox map style will likely be different than the layers used in the default Tableau map styles, which are described in the Tableau Customize how your map looks guide. All your style's layers that are displayed in the Mapbox Studio style editor will be displayed automatically in the Tableau view. To hide a layer, click on the checkbox next to the layer name to deselect it. For further guidance on how to customize maps in Tableau, consult the Tableau documentation. Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Use custom Mapbox styles in Tableau,Use background maps in Tableau Desktop,Show or hide layers in a custom Mapbox map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Center the map on a clicked symbol,Using events and flyTo to center the map on a symbol.,https://docs.mapbox.com/mapbox-gl-js/example/center-on-symbol/,example,JavaScript,,Center the map on a clicked symbol Using events and flyTo to center the map on a symbol. Was this example helpful? Yes No,,5c6adb81d3b68758d0c5c15a,Center the map on a clicked symbol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,monthly active users,Monthly active users (MAU) is the number of users who accessed Mapbox services within your applications during a given month.,https://docs.mapbox.com/help/glossary/monthly-active-users/,glossary,,,"monthly active users Mapbox tracks monthly active users (MAU), also known as mobile users, for native mobile applications built with the Mapbox Maps, Navigation, and Vision SDKs for iOS, Android, or Unity. This is the number of users who accessed Mapbox services within your applications during a given month. There are a couple different mobile usage measurements that use monthly active users as a unit. The line items that appear on your invoice will vary based on the product and version you are using: Product Version Usage units Maps SDK for Android 8.0.0 and higher Maps SDKs for mobile MAUs Maps SDK for Android less than 8.0.0 Legacy SDKs for mobile MAUs Maps SDK for iOS 5.0.0 and higher Maps SDKs for mobile MAUs Maps SDK for iOS less than 5.0.0 Legacy SDKs for mobile MAUs Maps SDK for Unity all available versions Legacy SDK MAUs Navigation SDK for Android all available versions Legacy SDKs for mobile MAUs + Directions API requests Navigation SDK for iOS all available versions Legacy SDKs for mobile MAUs + Directions API requests Vision SDK for Android 0.6.0 and higher Vision SDKs for mobile MAUs Vision SDK for Android less than 0.6.0 Legacy SDKs for mobile MAUs Vision SDK for iOS 0.6.0 and higher Vision SDKs for mobile MAUs Vision SDK for iOS less than 0.6.0 Legacy SDKs for mobile MAUs Cost per MAU There are 50,000 Legacy SDK MAUs per month included in the free tier. You will be billed $0.50 for every additional 500 MAUs beyond the 50,000 per month included in the free tier. Find information about pricing for Maps MAUs and Vision MAUs on the pricing page. Related resources: Accounts and pricing: Pricing by products Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,monthly active users,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Traffic,Discover how to display real-time road traffic on your Android map with the Mapbox Android Traffic Plugin. All it requires is two lines of code.,https://docs.mapbox.com/android/plugins/overview/traffic/,guide,Java,Kotlin,"Traffic The Mapbox Traffic Plugin adds a real-time traffic layer to any Mapbox base map. If you want to display a traffic layer inside your application, you only need to include the dependency in your project and initialize the plugin. Various shades of colors show the congestion level for any given part of a road segment. If there's not enough traffic data available for a given road, then the plugin will not show road information. Like other plugins, a third optional parameter in the traffic plugin's constructor which is useful for specifying the layer in which you want the traffic to display below. If the layer ID's missing in the third parameter, the plugin will try to place the traffic below all symbol layers so that text and icons on the map are still visible on top of the traffic lines. It is always a good idea to pass in a string ID rather than relying on the Plugin to try to place the traffic below a symbol layer since it isn't guaranteed to work properly. Install the Traffic Plugin To start developing an application using the Traffic Plugin, you'll need to add the appropriate dependencies inside your build.gradle file. This dependency includes the Maps SDK for Android. You can find all dependencies given on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-traffic- v8. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-traffic- v8 : 0.9.0 ' } Add traffic Since the Traffic Plugin requires the mapboxMap object, it's necessary to initialize the plugin either inside onMapReady (recommended) or in another place you know the mapboxMap will not be null. Once initialized, trafficPlugin.setVisibility() to true will enable the traffic. You can use isVisible() which returns a boolean true if the traffic's visible, otherwise false. Java Kotlin @Override public void onMapReady(MapboxMap mapboxMap) { TrafficPlugin trafficPlugin = new TrafficPlugin(mapView, mapboxMap); trafficPlugin.setVisibility(true); // Enable the traffic view } Copy Traffic colors The table below provides information for each color displayed in the traffic layer and what the corresponding congestion level is. Color Hex value Congestion level Green #39c66d Low Yellow #ff8c1a Moderate Orange #ff0015 Heavy Red #981b25 Severe Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Traffic,Add traffic,Traffic colors,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add annotation views and images,Add multiple annotations containing views and images.,https://docs.mapbox.com/ios/maps/examples/annotation-view-image/,example,Swift,Objective-C,"Add annotation views and images Download the Camera asset catalog and add it to your project. MyCustomPointAnnotation is a custom subclass of MGLPointAnnotation. To learn about more ways to add points to a map, see the Markers and annotations guide. Swift Objective C import Mapbox // MGLPointAnnotation subclass class MyCustomPointAnnotation: MGLPointAnnotation { var willUseImage: Bool = false } // end MGLPointAnnotation subclass class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() // Create a new map view using the Mapbox Light style. let mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.lightStyleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 36.54, longitude: -116.97), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.delegate = self // Create four new point annotations with specified coordinates and titles. let pointA = MyCustomPointAnnotation() pointA.coordinate = CLLocationCoordinate2D(latitude: 36.4623, longitude: -116.8656) pointA.title = ""Stovepipe Wells"" pointA.willUseImage = true let pointB = MyCustomPointAnnotation() pointB.coordinate = CLLocationCoordinate2D(latitude: 36.6071, longitude: -117.1458) pointB.title = ""Furnace Creek"" pointB.willUseImage = true let pointC = MyCustomPointAnnotation() pointC.title = ""Zabriskie Point"" pointC.coordinate = CLLocationCoordinate2D(latitude: 36.4208, longitude: -116.8101) let pointD = MyCustomPointAnnotation() pointD.title = ""Mesquite Flat Sand Dunes"" pointD.coordinate = CLLocationCoordinate2D(latitude: 36.6836, longitude: -117.1005) // Fill an array with four point annotations. let myPlaces = [pointA, pointB, pointC, pointD] // Add all annotations to the map all at once, instead of individually. mapView.addAnnotations(myPlaces) } // This delegate method is where you tell the map to load a view for a specific annotation based on the willUseImage property of the custom subclass. func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? { if let castAnnotation = annotation as? MyCustomPointAnnotation { if (castAnnotation.willUseImage) { return nil } } // Assign a reuse identifier to be used by both of the annotation views, taking advantage of their similarities. let reuseIdentifier = ""reusableDotView"" // For better performance, always try to reuse existing annotations. var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: reuseIdentifier) // If there’s no reusable annotation view available, initialize a new one. if annotationView == nil { annotationView = MGLAnnotationView(reuseIdentifier: reuseIdentifier) annotationView?.frame = CGRect(x: 0, y: 0, width: 30, height: 30) annotationView?.layer.cornerRadius = (annotationView?.frame.size.width)! / 2 annotationView?.layer.borderWidth = 4.0 annotationView?.layer.borderColor = UIColor.white.cgColor annotationView!.backgroundColor = UIColor(red: 0.03, green: 0.80, blue: 0.69, alpha: 1.0) } return annotationView } // This delegate method is where you tell the map to load an image for a specific annotation based on the willUseImage property of the custom subclass. func mapView(_ mapView: MGLMapView, imageFor annotation: MGLAnnotation) -> MGLAnnotationImage? { if let castAnnotation = annotation as? MyCustomPointAnnotation { if (!castAnnotation.willUseImage) { return nil } } // For better performance, always try to reuse existing annotations. var annotationImage = mapView.dequeueReusableAnnotationImage(withIdentifier: ""camera"") // If there is no reusable annotation image available, initialize a new one. if(annotationImage == nil) { annotationImage = MGLAnnotationImage(image: UIImage(named: ""camera"")!, reuseIdentifier: ""camera"") } return annotationImage } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Add annotation views and images,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Datasets API,"The Mapbox Datasets API allows you to read, create, update, and remove datasets and dataset features.",https://docs.mapbox.com/help/glossary/datasets-api/,glossary,,,"Datasets API The Mapbox Datasets API supports creating, editing, and managing datasets and dataset features. A sample Datasets API request to retrieve a dataset looks like: https://api.mapbox.com/datasets/v1/ { username } / { dataset_id } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN Related resources: Datasets API documentation How datasets work Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Datasets API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Data time lapse,Use data-driven styling to visualize point data with a time lapse effect; rainfall in China in this example.,https://docs.mapbox.com/android/maps/examples/data-time-lapse/,example,Java,,"Data time lapse Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.dds.AddRainFallStyleActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:mapbox_cameraTargetLat=""36"" app:mapbox_cameraTargetLng=""106"" app:mapbox_cameraZoom=""3.6"" app:mapbox_uiAttribution=""false"" app:mapbox_uiLogo=""false""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import android.os.Handler; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.Property.VISIBLE; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; /** * Style a rainfall map by get data from url */ public class AddRainFallStyleActivity extends AppCompatActivity implements OnMapReadyCallback { public static final String ID_SOURCE = ""source-id""; public static final String ID_LAYER = ""layer-id""; public static final String SOURCE_URL = ""mapbox://examples.dwtmhwpu""; private MapView mapView; private Handler handler; private FillLayer layer; private int index = 1; private RefreshGeoJsonRunnable refreshGeoJsonRunnable; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the account manager setContentView(R.layout.activity_style_rainfall); handler = new Handler(); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { addRadarData(style); refreshGeoJsonRunnable = new RefreshGeoJsonRunnable(); do { handler.postDelayed(refreshGeoJsonRunnable, 1000); } while (index == 37); } }); } private class RefreshGeoJsonRunnable implements Runnable { @Override public void run() { layer.setFilter(eq((Expression.get(""idx"")), literal(index))); index++; if (index == 37) { index = 0; } handler.postDelayed(this, 1000); } } private void addRadarData(@NonNull Style loadedMapStyle) { VectorSource vectorSource = new VectorSource( ID_SOURCE, SOURCE_URL ); loadedMapStyle.addSource(vectorSource); layer = loadedMapStyle.getLayerAs(ID_LAYER); if (layer == null) { layer = new FillLayer(ID_LAYER, ID_SOURCE); layer.withSourceLayer(""201806261518""); layer.setFilter(eq((get(""idx"")), literal(0))); layer.setProperties(PropertyFactory.visibility(VISIBLE), fillColor(interpolate(Expression.exponential(1f), get(""value""), stop(8, Expression.rgb(20, 160, 240)), stop(18, Expression.rgb(20, 190, 240)), stop(36, Expression.rgb(20, 220, 240)), stop(54, Expression.rgb(20, 250, 240)), stop(72, Expression.rgb(20, 250, 160)), stop(90, Expression.rgb(135, 250, 80)), stop(108, Expression.rgb(250, 250, 0)), stop(126, Expression.rgb(250, 180, 0)), stop(144, Expression.rgb(250, 110, 0)), stop(162, Expression.rgb(250, 40, 0)), stop(180, Expression.rgb(180, 40, 40)), stop(198, Expression.rgb(110, 40, 80)), stop(216, Expression.rgb(80, 40, 110)), stop(234, Expression.rgb(50, 40, 140)), stop(252, Expression.rgb(20, 40, 170)) ) ), PropertyFactory.fillOpacity(0.7f)); loadedMapStyle.addLayer(layer); } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); handler.removeCallbacks(refreshGeoJsonRunnable); refreshGeoJsonRunnable = null; handler = null; } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,5c6adb81d3b68758d0c5c15a,Data time lapse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a new layer below labels,"Using the second argument of addLayer, you can be more precise.",https://docs.mapbox.com/mapbox-gl-js/example/geojson-layer-in-stack/,example,JavaScript,,"Add a new layer below labels Using the second argument of addLayer, you can be more precise. Was this example helpful? Yes No",,Add a new layer below labels,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,dataset ID,Use the dataset ID to make requests related to the dataset using the Datasets API.,https://docs.mapbox.com/help/glossary/dataset-id/,glossary,,,dataset ID Any time you create a dataset with the Mapbox Studio dataset editor it generates a dataset ID. You can use the dataset ID to make requests related to the dataset using the Mapbox Datasets API. Was this page helpful? Yes No,,dataset ID,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Replace features,An overview of the replace features example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/replace-features/,example,No code,,"Replace features This example demonstrates how you can use the ReplaceFeatureModifier to swap out a default extruded building with a custom 3D object. With this modifier, you can replace your corporate office locations with a branded building model, or spawn a highly detailed 3D object in place of a monument or building. Game object modifiers Game object modifiers are ScriptableObjects that work with meshes and game objects to further allow you to decorate, enhance, or make modifications to your game objects. To create a new modifier, right click in your project window and navigate to Create > Mapbox > Modifiers You can also create modifiers by clicking Add New in the Game Object Modifiers > Behavior Modifiers section of the AbstractMap script. ReplaceFeatureModifier overview To open the modifier for this example, navigate to MAP LAYERS > FEATURES, and then select the ExtrudedBuildings Map Feature. Next, with ExtrudedBuildings selected, open the Behavior Modifiers section. Under Game Object Modifiers, double click on ReplaceFeatureModifier. This will open the modifier in your Inspector window and you will see the following settings: Active: This boolean setting toggles the modifier on and off. Prefab: This is the 3D object to spawn in place of the feature is specified. Scale down with world: This setting scales the specified prefab to the size of the tile. Prefab Locations: This is an array that holds all locations to all the buildings and features to be replaced with the supplied prefab. You can increase the value of Size to add new elements to the array. Click Search to find a feature, or paste in the latitude and longitude coordinates. Explicitly Blocked Feature Ids: This is a list of ids on the ExtrudedBuildings layer to prevent from spawning. You can leave this empty unless you find an issue where the latitude and longitude coordinates are not properly filtering out the correct building to replaced. Note that in the Advanced section of ExtrudedBuildings that Buildings with Unique Ids is checked. Also, in the same layer Group Features is unchecked. These settings are required for feature replacement to work as expected. Replace a building with a 3D model Follow the steps below or in this video tutorial to replace the Empire State Building with a custom 3D model. To replace a building with a 3D model, you can configure a new ReplaceFeatureModifier. In your Project window, open up the CitySimulator scene found in the Mapbox > Examples > 0_PrefabScenes folder. Alternatively, you can create a new scene and add the CitySimulatorMap prefab to the scene. Select the CitySimulatorMap game object in your Hierarchy window. On the AbstractMap navigate to MAP LAYERS > FEATURES, and then select the ExtrudedBuildings Map Features. Select ExtrudedBuildings, and open Behavior Modifiers. Under Game Object Modifiers, click Add New and select ReplaceFeatureModifier This will create a new modifier. Double click NewReplaceFeatureModifier to open the modifier in your Inspector window. Assign the Building Pivot prefab. You can use your own model here if you would like. Click Prefab Locations and change the Size to 1. Click Search to search for Empire State Building or paste in 40.748333333333, -73.985277777778 to Element 0. To make sure that the location of the Empire State Building is in view of the camera, select CitySimulatorMap in your Hierarchy. Then, inside the GENERAL settings of the AbstractMap script, set the Latitude Longitude to 40.748333333333, -73.985277777778 which is the location of the building. Enter Play mode to see the prefab spawned in place of the Empire State Building! Was this page helpful? Yes No",,Replace features,ReplaceFeatureModifier overview,Replace a building with a 3D model,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Tilequery,Official documentation on the Mapbox Java SDK Tilequery API.,https://docs.mapbox.com/android/java/overview/tilequery/,guide,Java,,"Tilequery The Mapbox Tilequery API allows you to retrieve data about specific features from a vector tileset, based on a given latitude and longitude. The API makes it possible to query for features within a radius, do point in polygon queries, query for features in multiple composite layers, and augment data from the Mapbox Geocoding API with custom data. For more information about this API, see the Mapbox Tilequery API documentation. Building the query URL To begin with, you'll need to create a new instance of the MapboxTilequery object and use its builder to customize your query. The options offered in the builder includes choices such as the query coordinate, the type of GeoJSON geometry you're searching for, and the search area radius. Java Kotlin MapboxTilequery tilequery = MapboxTilequery.builder() .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .mapIds(mapId) .query(Point.fromLngLat(LONGITUDE,LATITUDE)) .radius(radiusInMeters) .limit(maxNumOfFeaturesReturned) .geometry(geoJsonShape) .dedupe(boolean) .layers(singleOrListOfMapLayerIds) .build(); Copy Tilequery Playground playground Explore how to use the Tilequery API to retrieve features from vector tiles. Query response You can access the Tilequery API's response inside of the onResponse callback. The onResponse callback is built with Retrofit, like the Java SDK's other services' callbacks. The response will include a List<Feature> if the query you built has any Features in it. But, there's no guarantee that the response will have any Feature objects in it. Java Kotlin tilequery.enqueueCall(new Callback<FeatureCollection>() { @Override public void onResponse(Call<FeatureCollection> call, Response<FeatureCollection> response) { List<Feature> featureCollection = response.body().features(); } @Override public void onFailure(Call<FeatureCollection> call, Throwable throwable) { Log.d(""Request failed: %s"", throwable.getMessage()); } }); Copy Each Feature in the response has a distance, geometry, and layer property associated with it: Java Kotlin tilequery.enqueueCall(new Callback<FeatureCollection>() { @Override public void onResponse(Call<FeatureCollection> call, Response<FeatureCollection> response) { // The FeatureCollection that is inside the API response List<Feature> featureCollection = response.body().features(); // Distance that the Feature is from the original Tilequery Point coordinate String distance = featureCollection.get(0).getProperty(""tilequery"").getAsJsonObject().get(""distance"").toString(); // The Feature's GeoJSON geometry type String geometryType = featureCollection.get(0).getProperty(""tilequery"").getAsJsonObject().get(""geometry"").toString(); // The id of the map layer which the Feature is a part of String layerId = featureCollection.get(0).getProperty(""tilequery"").getAsJsonObject().get(""layer"").toString(); } @Override public void onFailure(Call<FeatureCollection> call, Throwable throwable) { Log.d(""Request failed: %s"", throwable.getMessage()); } }); Copy Was this page helpful? Yes No",,Tilequery,Query response,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add a line style layer from GeoJSON,Add a polyline from a GeoJSON source and style it dynamically.,https://docs.mapbox.com/ios/maps/examples/runtime-add-line/,example,Swift,,"Add a line style layer from GeoJSON Related examples: drawing a GeoJSON line and animated line. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter( CLLocationCoordinate2D(latitude: 45.5076, longitude: -122.6736), zoomLevel: 11, animated: false) view.addSubview(mapView) mapView.delegate = self } // Wait until the map is loaded before adding to the map. func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { loadGeoJson() } func loadGeoJson() { DispatchQueue.global().async { // Get the path for example.geojson in the app’s bundle. guard let jsonUrl = Bundle.main.url(forResource: ""example"", withExtension: ""geojson"") else { preconditionFailure(""Failed to load local GeoJSON file"") } guard let jsonData = try? Data(contentsOf: jsonUrl) else { preconditionFailure(""Failed to parse GeoJSON file"") } DispatchQueue.main.async { self.drawPolyline(geoJson: jsonData) } } } func drawPolyline(geoJson: Data) { // Add our GeoJSON data to the map as an MGLGeoJSONSource. // We can then reference this data from an MGLStyleLayer. // MGLMapView.style is optional, so you must guard against it not being set. guard let style = self.mapView.style else { return } guard let shapeFromGeoJSON = try? MGLShape(data: geoJson, encoding: String.Encoding.utf8.rawValue) else { fatalError(""Could not generate MGLShape"") } let source = MGLShapeSource(identifier: ""polyline"", shape: shapeFromGeoJSON, options: nil) style.addSource(source) // Create new layer for the line. let layer = MGLLineStyleLayer(identifier: ""polyline"", source: source) // Set the line join and cap to a rounded end. layer.lineJoin = NSExpression(forConstantValue: ""round"") layer.lineCap = NSExpression(forConstantValue: ""round"") // Set the line color to a constant blue color. layer.lineColor = NSExpression(forConstantValue: UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1)) // Use `NSExpression` to smoothly adjust the line width from 2pt to 20pt between zoom levels 14 and 18. The `interpolationBase` parameter allows the values to interpolate along an exponential curve. layer.lineWidth = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [14: 2, 18: 20]) // We can also add a second layer that will draw a stroke around the original line. let casingLayer = MGLLineStyleLayer(identifier: ""polyline-case"", source: source) // Copy these attributes from the main line layer. casingLayer.lineJoin = layer.lineJoin casingLayer.lineCap = layer.lineCap // Line gap width represents the space before the outline begins, so should match the main line’s line width exactly. casingLayer.lineGapWidth = layer.lineWidth // Stroke color slightly darker than the line color. casingLayer.lineColor = NSExpression(forConstantValue: UIColor(red: 41/255, green: 145/255, blue: 171/255, alpha: 1)) // Use `NSExpression` to gradually increase the stroke width between zoom levels 14 and 18. casingLayer.lineWidth = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [14: 1, 18: 4]) // Just for fun, let’s add another copy of the line with a dash pattern. let dashedLayer = MGLLineStyleLayer(identifier: ""polyline-dash"", source: source) dashedLayer.lineJoin = layer.lineJoin dashedLayer.lineCap = layer.lineCap dashedLayer.lineColor = NSExpression(forConstantValue: UIColor.white) dashedLayer.lineOpacity = NSExpression(forConstantValue: 0.5) dashedLayer.lineWidth = layer.lineWidth // Dash pattern in the format [dash, gap, dash, gap, ...]. You’ll want to adjust these values based on the line cap style. dashedLayer.lineDashPattern = NSExpression(forConstantValue: [0, 1.5]) style.addLayer(layer) style.addLayer(dashedLayer) style.insertLayer(casingLayer, below: layer) } } Copy Was this page helpful? Yes No",,Add a line style layer from GeoJSON,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Display 3D building height based on vector data,Use extrusions to display 3D building height based on imported vector data.,https://docs.mapbox.com/android/maps/examples/display-3d-building-height-based-on-vector-data/,example,Java,,"Display 3D building height based on vector data Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.extrusions.PopulationDensityExtrusionActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:layout_constraintBottom_toBottomOf=""parent"" app:layout_constraintHorizontal_bias=""0.0"" app:layout_constraintLeft_toLeftOf=""parent"" app:layout_constraintRight_toRightOf=""parent"" app:layout_constraintTop_toTopOf=""parent"" app:layout_constraintVertical_bias=""0.0"" mapbox:mapbox_cameraTargetLat=""37.784282779035216"" mapbox:mapbox_cameraTargetLng=""-122.4232292175293"" mapbox:mapbox_cameraZoom=""12"" mapbox:mapbox_cameraZoomMax=""16"" mapbox:mapbox_cameraZoomMin=""12"" mapbox:mapbox_cameraTilt=""45"" > </com.mapbox.mapboxsdk.maps.MapView> <androidx.constraintlayout.widget.Guideline android:id=""@+id/guideline4"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:orientation=""vertical"" app:layout_constraintGuide_begin=""20dp""/> <androidx.constraintlayout.widget.Guideline android:id=""@+id/guideline5"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:orientation=""vertical"" app:layout_constraintGuide_begin=""20dp""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.extrusions; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.Menu; import android.view.MenuItem; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillExtrusionLayer; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.all; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.gt; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.lt; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionBase; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionHeight; /** * Use imported vector data to set the height of 3D building extrusions */ public class PopulationDensityExtrusionActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private MapboxMap mapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_population_density_extrusion); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource( new VectorSource(""population"", ""mapbox://peterqliu.d0vin3el"") ); addFillsLayer(style); addExtrusionsLayer(style); } }); } private void addFillsLayer(@NonNull Style loadedMapStyle) { FillLayer fillsLayer = new FillLayer(""fills"", ""population""); fillsLayer.setSourceLayer(""outgeojson""); fillsLayer.setFilter(all(lt(get(""pkm2""), literal(300000)))); fillsLayer.withProperties( fillColor(interpolate(exponential(1f), get(""pkm2""), stop(0, rgb(22, 14, 35)), stop(14500, rgb(0, 97, 127)), stop(145000, rgb(85, 223, 255))))); loadedMapStyle.addLayerBelow(fillsLayer, ""water""); } private void addExtrusionsLayer(@NonNull Style loadedMapStyle) { FillExtrusionLayer fillExtrusionLayer = new FillExtrusionLayer(""extrusions"", ""population""); fillExtrusionLayer.setSourceLayer(""outgeojson""); fillExtrusionLayer.setFilter(all(gt(get(""p""), 1), lt(get(""pkm2""), 300000))); fillExtrusionLayer.withProperties( fillExtrusionColor(interpolate(exponential(1f), get(""pkm2""), stop(0, rgb(22, 14, 35)), stop(14500, rgb(0, 97, 127)), stop(145000, rgb(85, 233, 255)))), fillExtrusionBase(0f), fillExtrusionHeight(interpolate(exponential(1f), get(""pkm2""), stop(0, 0f), stop(1450000, 20000f)))); loadedMapStyle.addLayerBelow(fillExtrusionLayer, ""airport-label""); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_population_density_spinner_menu_cities, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.san_francisco: goToNewLocation(37.784282779035216, -122.4232292175293); return true; case R.id.los_angeles: goToNewLocation(34.04412546508576, -118.28636169433594); return true; case R.id.seattle: goToNewLocation(47.60651025683697, -122.33327865600585); return true; case R.id.new_orleans: goToNewLocation(29.946159058399612, -90.10042190551758); return true; case R.id.chicago: goToNewLocation(41.87531293759582, -87.6240348815918); return true; case R.id.philadelphia: goToNewLocation(39.95370120254379, -75.1626205444336); return true; case R.id.new_york: goToNewLocation(40.72228267283148, -73.99772644042969); return true; case R.id.atlanta: goToNewLocation(33.74910736130734, -84.39079284667969); return true; case R.id.portland: goToNewLocation(45.522104713562825, -122.67179489135742); return true; case R.id.denver: goToNewLocation(39.74428621972816, -104.99565124511719); return true; case R.id.minneapolis: goToNewLocation(44.969656023708175, -93.26637268066406); return true; case R.id.miami: goToNewLocation(25.773846629676616, -80.19624710083008); return true; case android.R.id.home: finish(); return true; default: return super.onOptionsItemSelected(item); } } private void goToNewLocation(double lat, double longitude) { LatLng newPosition = new LatLng(); newPosition.setLatitude(lat); newPosition.setLongitude(longitude); CameraPosition position = new CameraPosition.Builder() .target(newPosition) .build(); mapboxMap.moveCamera(CameraUpdateFactory .newCameraPosition(position)); } } Copy Was this page helpful? Yes No",,Display 3D building height based on vector data,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Navigation Map Route,Shows different styles using NavigationMapRoute.,https://docs.mapbox.com/android/navigation/examples/navigation-map-route/,example,Java,,"Navigation Map Route Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <android.support.design.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".activity.navigationui.NavigationMapRouteActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:mapbox_cameraZoom=""12""/> <ProgressBar android:id=""@+id/routeLoadingProgressBar"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""center"" android:visibility=""invisible""/> <FrameLayout android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""top|center"" android:clipToPadding=""false"" android:paddingBottom=""16dp"" app:layout_anchor=""@id/fabStyles"" app:layout_anchorGravity=""top|center""> <android.support.design.widget.FloatingActionButton android:id=""@+id/fabRemoveRoute"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:visibility=""invisible"" app:backgroundTint=""@color/red"" app:srcCompat=""@drawable/ic_cancel""/> </FrameLayout> <android.support.design.widget.FloatingActionButton android:id=""@+id/fabStyles"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""end|bottom"" android:layout_margin=""16dp"" android:tint=""@android:color/white"" app:backgroundTint=""@color/colorAccent"" app:srcCompat=""@drawable/ic_layers""/> </android.support.design.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.services.android.navigation.testapp.activity.navigationui; import android.annotation.SuppressLint; import android.content.Context; import android.os.Build; import android.os.Bundle; import android.os.VibrationEffect; import android.os.Vibrator; import android.support.annotation.NonNull; import android.support.design.widget.FloatingActionButton; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.ProgressBar; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Point; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.annotations.Marker; import com.mapbox.mapboxsdk.annotations.MarkerOptions; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.modes.CameraMode; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.services.android.navigation.testapp.R; import com.mapbox.services.android.navigation.ui.v5.route.NavigationMapRoute; import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute; import java.util.List; import butterknife.BindView; import butterknife.ButterKnife; import butterknife.OnClick; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; public class NavigationMapRouteActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapLongClickListener, Callback<DirectionsResponse> { private static final int ONE_HUNDRED_MILLISECONDS = 100; @BindView(R.id.mapView) MapView mapView; @BindView(R.id.routeLoadingProgressBar) ProgressBar routeLoading; @BindView(R.id.fabRemoveRoute) FloatingActionButton fabRemoveRoute; private MapboxMap mapboxMap; private NavigationMapRoute navigationMapRoute; private StyleCycle styleCycle = new StyleCycle(); private Marker originMarker; private Marker destinationMarker; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_navigation_map_route); ButterKnife.bind(this); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @OnClick(R.id.fabStyles) public void onStyleFabClick() { if (mapboxMap != null) { mapboxMap.setStyle(styleCycle.getNextStyle()); } } @OnClick(R.id.fabRemoveRoute) public void onRemoveRouteClick(View fabRemoveRoute) { removeRouteAndMarkers(); fabRemoveRoute.setVisibility(View.INVISIBLE); } @Override public void onMapReady(MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(styleCycle.getStyle(), style -> { initializeLocationComponent(mapboxMap); navigationMapRoute = new NavigationMapRoute(null, mapView, mapboxMap); mapboxMap.addOnMapLongClickListener(this); Snackbar.make(mapView, ""Long press to select route"", Snackbar.LENGTH_SHORT).show(); }); } @Override public boolean onMapLongClick(@NonNull LatLng point) { handleClicked(point); return true; } @Override public void onResponse(@NonNull Call<DirectionsResponse> call, @NonNull Response<DirectionsResponse> response) { if (response.isSuccessful() && response.body() != null && !response.body().routes().isEmpty()) { List<DirectionsRoute> routes = response.body().routes(); navigationMapRoute.addRoutes(routes); routeLoading.setVisibility(View.INVISIBLE); fabRemoveRoute.setVisibility(View.VISIBLE); } } @Override public void onFailure(@NonNull Call<DirectionsResponse> call, @NonNull Throwable throwable) { Timber.e(throwable); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); if (navigationMapRoute != null) { navigationMapRoute.onStart(); } } @Override protected void onStop() { super.onStop(); mapView.onStop(); if (navigationMapRoute != null) { navigationMapRoute.onStop(); } } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @SuppressWarnings(""MissingPermission"") private void initializeLocationComponent(MapboxMap mapboxMap) { LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent(this, mapboxMap.getStyle()); locationComponent.setLocationComponentEnabled(true); locationComponent.setRenderMode(RenderMode.COMPASS); locationComponent.setCameraMode(CameraMode.TRACKING); locationComponent.zoomWhileTracking(10d); } private void handleClicked(@NonNull LatLng point) { vibrate(); if (originMarker == null) { originMarker = mapboxMap.addMarker(new MarkerOptions().position(point)); Snackbar.make(mapView, ""Origin selected"", Snackbar.LENGTH_SHORT).show(); } else if (destinationMarker == null) { destinationMarker = mapboxMap.addMarker(new MarkerOptions().position(point)); Point originPoint = Point.fromLngLat( originMarker.getPosition().getLongitude(), originMarker.getPosition().getLatitude()); Point destinationPoint = Point.fromLngLat( destinationMarker.getPosition().getLongitude(), destinationMarker.getPosition().getLatitude()); Snackbar.make(mapView, ""Destination selected"", Snackbar.LENGTH_SHORT).show(); findRoute(originPoint, destinationPoint); routeLoading.setVisibility(View.VISIBLE); } } @SuppressLint(""MissingPermission"") private void vibrate() { Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); if (vibrator == null) { return; } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { vibrator.vibrate(VibrationEffect.createOneShot(ONE_HUNDRED_MILLISECONDS, VibrationEffect.DEFAULT_AMPLITUDE)); } else { vibrator.vibrate(ONE_HUNDRED_MILLISECONDS); } } private void removeRouteAndMarkers() { mapboxMap.removeMarker(originMarker); originMarker = null; mapboxMap.removeMarker(destinationMarker); destinationMarker = null; navigationMapRoute.removeRoute(); } public void findRoute(Point origin, Point destination) { NavigationRoute.builder(this) .accessToken(Mapbox.getAccessToken()) .origin(origin) .destination(destination) .alternatives(true) .build() .getRoute(this); } private static class StyleCycle { private static final String[] STYLES = new String[] { Style.MAPBOX_STREETS, Style.OUTDOORS, Style.LIGHT, Style.DARK, Style.SATELLITE_STREETS }; private int index; private String getNextStyle() { index++; if (index == STYLES.length) { index = 0; } return getStyle(); } private String getStyle() { return STYLES[index]; } } } Copy Was this page helpful? Yes No",,Navigation Map Route,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Satellite styles,Use the satellite base layer on your map.,https://docs.mapbox.com/ios/maps/examples/satellite-style/,example,Swift,,"Satellite styles If you’re using an Interface Builder storyboard, set the Style URL inspectable to one of the following: mapbox://styles/mapbox/satellite-v9 mapbox://styles/mapbox/satellite-streets-v9 (includes labels) Swift Objective C import Mapbox class ViewController: UIViewController { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() // A hybrid style with unobtrusive labels is also available via satelliteStreetsStyleURL. mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.satelliteStyleURL) // Tint the ℹ️ button. mapView.attributionButton.tintColor = .white mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 45.5188, longitude: -122.6748), zoomLevel: 13, animated: false) view.addSubview(mapView) } } Copy Was this page helpful? Yes No",,Satellite styles,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox.js,Mapbox.js is a JavaScript library that allows you to add an your interactive map to your website.,https://docs.mapbox.com/help/glossary/mapbox-js/,glossary,,,"Mapbox.js Note Mapbox.js is no longer in active development. To learn more about our newer mapping tools see the Mapbox GL JS documentation. Mapbox.js is a JavaScript library that allows you to add an interactive map to your website. It is a plugin for Leaflet, and is an open source library that's free to use. You can use any Mapbox Studio style or Mapbox Studio Classic style as a basemap in Mapbox.js. For more information, see the Mapbox.js documentation. Was this page helpful? Yes No",,Mapbox.js,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Circle radius,Set the radii of a circle layer's circles based on a data property.,https://docs.mapbox.com/android/maps/examples/circle-radius/,example,Java,,"Circle radius Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:tools=""http://schemas.android.com/tools"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.dds.CircleRadiusActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""38.9098"" mapbox:mapbox_cameraTargetLng=""-77.0295"" mapbox:mapbox_cameraZoom=""15"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.Bundle; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.CircleLayer; import com.mapbox.mapboxsdk.style.sources.VectorSource; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import static com.mapbox.mapboxsdk.style.expressions.Expression.exponential; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.circleRadius; /** * Set the radii of a CircleLayer's circles based on a data property. */ public class CircleRadiusActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_circle_radius_activity); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // replace examples.8mj5l1r9 with the map ID for the tileset // you created by uploading data to your Mapbox account style.addSource(new VectorSource(""trees-source"", ""mapbox://examples.8mj5l1r9"")); CircleLayer circleLayer = new CircleLayer(""trees-style"", ""trees-source""); // replace street-trees-DC-9gvg5l with the name of your source layer circleLayer.setSourceLayer(""street-trees-DC-9gvg5l""); circleLayer.withProperties( circleOpacity(0.6f), circleColor(Color.parseColor(""#ffffff"")), circleRadius( interpolate(exponential(1.0f), get(""DBH""), stop(0, 0f), stop(1, 1f), stop(110, 11f) ) ) ); style.addLayer(circleLayer); } }); } }); } // Add the mapView's own lifecycle methods to the activity's lifecycle methods @Override public void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Circle radius,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for Android,Android,Speeding alerts,Display an alert when the vehicle is speeding.,https://docs.mapbox.com/android/vision/examples/speeding-alerts/,example,Java,,"Speeding alerts Java Kotlin package com.mapbox.vision.examples; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.vision.VisionManager; import com.mapbox.vision.mobile.core.interfaces.VisionEventsListener; import com.mapbox.vision.mobile.core.models.AuthorizationStatus; import com.mapbox.vision.mobile.core.models.Camera; import com.mapbox.vision.mobile.core.models.Country; import com.mapbox.vision.mobile.core.models.FrameSegmentation; import com.mapbox.vision.mobile.core.models.classification.FrameSignClassifications; import com.mapbox.vision.mobile.core.models.detection.FrameDetections; import com.mapbox.vision.mobile.core.models.position.VehicleState; import com.mapbox.vision.mobile.core.models.road.RoadDescription; import com.mapbox.vision.mobile.core.models.world.WorldDescription; import com.mapbox.vision.safety.VisionSafetyManager; import com.mapbox.vision.safety.core.VisionSafetyListener; import com.mapbox.vision.safety.core.models.CollisionObject; import com.mapbox.vision.safety.core.models.RoadRestrictions; import org.jetbrains.annotations.NotNull; /** * Example shows how overspeed can be detected using Vision and VisionSafety SDKs combined. */ public class SafetyActivity extends AppCompatActivity { private Float maxAllowedSpeed = -1f; // this listener handles events from Vision SDK private VisionEventsListener visionEventsListener = new VisionEventsListener() { @Override public void onAuthorizationStatusUpdated(@NotNull AuthorizationStatus authorizationStatus) {} @Override public void onFrameSegmentationUpdated(@NotNull FrameSegmentation frameSegmentation) {} @Override public void onFrameDetectionsUpdated(@NotNull FrameDetections frameDetections) {} @Override public void onFrameSignClassificationsUpdated(@NotNull FrameSignClassifications frameSignClassifications) {} @Override public void onRoadDescriptionUpdated(@NotNull RoadDescription roadDescription) {} @Override public void onWorldDescriptionUpdated(@NotNull WorldDescription worldDescription) {} @Override public void onVehicleStateUpdated(@NotNull VehicleState vehicleState) { // current speed of our car Float mySpeed = vehicleState.getSpeed(); // display toast with overspeed warning if our speed is greater than maximum allowed speed if (mySpeed > maxAllowedSpeed && maxAllowedSpeed > 0) { Toast.makeText( SafetyActivity.this, ""Overspeeding! Current speed : "" + mySpeed + "", allowed speed : "" + maxAllowedSpeed, Toast.LENGTH_LONG ).show(); } } @Override public void onCameraUpdated(@NotNull Camera camera) {} @Override public void onCountryUpdated(@NotNull Country country) {} @Override public void onUpdateCompleted() {} }; private VisionSafetyListener visionSafetyListener = new VisionSafetyListener() { @Override public void onCollisionsUpdated(@NotNull CollisionObject[] collisions) {} @Override public void onRoadRestrictionsUpdated(@NotNull RoadRestrictions roadRestrictions) { maxAllowedSpeed = roadRestrictions.getSpeedLimits().getCar().getMax(); } }; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override protected void onStart() { super.onStart(); VisionManager.create(); VisionManager.start(visionEventsListener); VisionSafetyManager.create(VisionManager.INSTANCE, visionSafetyListener); } @Override protected void onStop() { super.onStop(); VisionSafetyManager.destroy(); VisionManager.stop(); VisionManager.destroy(); } } Copy Was this page helpful? Yes No",,Speeding alerts,,,Kotlin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
China plugin for iOS,iOS,Introduction,A brief introduction to the Mapbox China plugin for iOS.,https://docs.mapbox.com/ios/plugins/overview/,guide,,,"Mapbox China plugin for iOS Current version: v 0.0.2 Support users in China Shift coordinates to GCJ-02 The Mapbox China Plugin for iOS provides a foundation for using Mapbox China maps. The plugin contains convenience methods for using Mapbox China styles, a transformer that shifts WGS-84 coordinates to GCJ-02, and a custom location manager that provides location updates as GCJ-02 coordinates. Getting started To access Mapbox China styles, you will need a special access token. Contact our sales team to start the process of receiving this special access token. You will not be able to access Mapbox China vector tiles without this access token. Installation Set up the Mapbox China Plugin by installing both the Mapbox Maps SDK for iOS and the Mapbox China Plugin. The Maps SDK can be installed by following the instructions in our installation guide. CocoaPods Add the following to your Podfile: pod 'MapboxChinaPlugin' Then update your project by running pod update in the command line. Carthage Add the following to your Cartfile: binary ""https://www.mapbox.cn/mapbox-china-plugin/ios/Mapbox-iOS-China-Plugin.json"" ~> 0.0.2 Then update your project by running carthage update in Terminal. Setting up your project Change the API endpoint To receive Mapbox China vector tiles, add MGLMapboxAPIBaseURL to your Info.plist as a key, with https://api.mapbox.cn as its value. This switches the API endpoint for your map's style. Mapbox China styles Mapbox currently offers three government-approved map styles: Mapbox China Streets, Dark, and Light. The plugin automatically converts Mapbox Streets, Dark, and Light to their China counterparts, and uses Mapbox China Streets by default. The plugin provides convenience methods to use to update the map's style URL. Style Name URL String Convenience Methods on MGLStyle Streets mapbox://styles/mapbox/streets-zh-v1 mbcn_streetsChineseStyleURL Dark mapbox://styles/mapbox/dark-zh-v1 mbcn_darkChineseStyleURL Light mapbox://styles/mapbox/light-zh-v1 mbcn_lightChineseStyleURL Using the Mapbox China Plugin Add the plugin The -addToMapView: method adds the China Plugin to an already initialized MGLMapView. This method switches the map's style URL to a China style and configures a location manager that uses GCJ-02 coordinates. Swift Objective C import MapboxChinaPlugin class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) let chinaPlugin = MBXChinaPlugin() chinaPlugin.add(to: mapView) view.addSubview(mapView) } } Copy Shift coordinates By default, the Maps SDK uses WGS-84 coordinates. This plugin offers a value transformer which shifts WGS-84 coordinates to GCJ-02, in compliance with Chinese government mapping requirements. Currently, this plugin supports shifting CLLocationCoordinate2D and MGLShape objects. The shift is managed by NSValueTransformer, and MGLConvertToDatumTransformerName, which is an NSValueTransformerName. MGLConvertToDatumTransformerName becomes available either by adding the plugin to the map view, or by initializing MBCNGCJCoordinateTransformer directly. Swift Objective C let transformerName = NSValueTransformerName(rawValue: MGLConvertToDatumTransformerName) let transformer = ValueTransformer(forName: transformerName) Copy To shift an annotation, shift the coordinate property of that annotation. This converts a WGS-84 coordinate to a GCJ-02 coordinate. This can also be used to set the center coordinate of the map view. Swift Objective C let unshiftedCoordinate = CLLocationCoordinate2D(latitude: 31.22894, longitude: 121.45434) // Use the value transformer to shift the coordinate. guard let transformedValue = transformer.transformedValue(NSValue(mglCoordinate: unshiftedCoordinate)) as? NSValue else { return } let annotation = MGLPointAnnotation() // Convert the NSValue back to an CLLocationCoordinate2D. Set the annotation's coordinate property to that shifted value. let shiftedCoordinate = transformedValue.mglCoordinateValue annotation.coordinate = shiftedCoordinate mapView.addAnnotation(annotation) // Set the center coordinate for the map view to the transformed coordinate. mapView.setCenter(shiftedCoordinate, zoomLevel: 15, animated: false) Copy This approach also applies to MGLShape and MGLFeature objects, including those created with GeoJSON. Swift Objective C let originalShape = [ CLLocationCoordinate2D(latitude: 31.22869, longitude: 121.4534), CLLocationCoordinate2D(latitude: 31.22894, longitude: 121.45319), CLLocationCoordinate2D(latitude: 31.2287, longitude: 121.45279), CLLocationCoordinate2D(latitude: 31.22844, longitude: 121.45301), CLLocationCoordinate2D(latitude: 31.22869, longitude: 121.4534) ] let shape = MGLPolygon(coordinates: originalShape, count: UInt(originalShape.count)) // Shift the shape's coordinates. let transformedValue = transformer.transformedValue(shape) as! MGLPolygon Copy Questions? If you have any questions about getting started with Mapbox China Plugin for iOS, please contact us. Was this page helpful? Yes No",,Mapbox China plugin for iOS,Installation,CocoaPods,,Carthage,Setting up your project,Change the API endpoint,Mapbox China styles,Using the Mapbox China Plugin,Add the plugin,Shift coordinates,Questions?,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Vector tiles,Introduction,Reference documentation for Mapbox-maintained vector tilesets.,https://docs.mapbox.com/vector-tiles/reference/,reference,,,"Vector tiles A broad collection of natural, built, and place data Global elevation data Constantly updating traffic data Open standard Vector tiles make huge maps fast while offering full design flexibility. They are the vector data equivalent of image tiles for web mapping, applying the strengths of tiling — developed for caching, scaling and serving map imagery rapidly — to vector data. How web maps work Traditionally, maps are created from image tiles. Like for instance this PNG image tile depicting the corner of lower Manhattan with roads, building footprints, and parks: To get the underlying vector tile data that makes up this image, you can request it specifically: http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=<your access token> As the name suggests, vector tiles contain vector data instead of the rendered image. They contain geometries and metadata — like road names, place names, house numbers — in a compact, structured format. Vector tiles are rendered only when requested by a client, like a web browser or a mobile app. Rendering happens either in the client (Mapbox GL JS, Mapbox iOS SDK, Mapbox Android SDK) or dynamically on the server (map API). Read the Mapbox Vector Tile Specification to learn more. Benefits of vector tiles Vector tiles have two important advantages over fully rendered image tiles: Styling: as vectors, tiles can be styled when requested, allowing for many map styles on global data Size: vector tiles are really small, enabling global high resolution maps, fast map loads, and efficient caching Mapbox Streets, our global basemap, is entirely made of vector tiles. Any map data you upload with Mapbox Studio is converted into vector tiles before styling. Open standard Vector tiles are an open standard under a Creative Commons Attribution 3.0 US License. We support vector tiles across our products and there is a large list of vector tile implementation by other vendors. Read the Mapbox Vector Tile Spec on GitHub and get in touch with us there with feedback and improvements. Was this page helpful? Yes No",,Vector tiles,Benefits of vector tiles,Open standard,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Geospatial data,Learn how uploading data works in Mapbox Studio.,https://docs.mapbox.com/studio-manual/overview/geospatial-data/,guide,,,"Geospatial data With Mapbox Studio, you can upload and manage custom data to be added to a map. Mapbox Studio topics covered in this section: Upload Dataset Tileset Template style Custom style Add data to style Style data Publish Types of uploads Datasets and tilesets are two different formats you can create when uploading custom data to your Mapbox account. If you want to upload data and edit it before adding to a map, upload as a dataset. If you want to upload data to add directly to a map, upload as a tileset. Note If you are uploading raster data, you must upload as a tileset. Uploading data you can edit (datasets) When you upload your data as a dataset, feature geometries (points, lines, and polygons) and properties (attributes) can be edited, added, or removed in the Mapbox Studio dataset editor. Once you have finished editing your dataset, you will need to save it and export it as a tileset to add it to a style. Uploading data to add to a map (tilesets) Tilesets are lightweight collections of vector or raster data that are optimized for rendering and are not editable but can be styled in the Mapbox Studio style editor. When you upload vector data as a tileset, it is simplified and cut up into vector tiles that can be used directly in your style. Once data is converted to a tileset, it is no longer editable. Your browser doesn't support embedded videos. Preparing your data for upload Mapbox Studio allows you to upload your own custom data to use in your map styles. You can upload your files on the Tilesets page. For a smooth upload process, it helps to make sure that: Geospatial data has been projected to Web Mercator (EPSG:3857). GeoJSON files have been validated for proper syntax. Unnecessary properties have been removed. Uploading using the Uploads API Or, you can use the Mapbox Uploads API to upload an accepted file that is transformed into a tileset. With the Uploads API, Mapbox provides you with a temporary S3 bucket to stage uploads that can be started and monitored. Accepted file types and transfer limits The accepted file types and transfer limits for dataset and tileset uploads include: File type Datasets Tilesets Transfer limits CSV 5 MB for datasets, 1 GB for tilesets GeoJSON 5 MB for datasets, 1 GB for tilesets MBTiles 25 GB KML 260 MB with 15 layers or fewer GPX 260 MB Shapefile 260 MB (combined uncompressed size of .shp and .dbf files) You must upload shapefiles as a compressed .zip file. GeoTIFF 10 GB If your file size exceeds these limits or if you run into errors, see our troubleshooting guide. Note Multiple files can be uploaded to the same dataset without limit — they need to be loaded 5 MB at a time. The size of a dataset is unlimited, but the Mapbox Studio dataset editor can only display datasets of 20 MB or smaller. These datasets can still be downloaded from Mapbox Studio and accessed through the Datasets API. Zoom levels and simplification When an upload is completed in Mapbox Studio, it is rendered into a tileset. After the tileset is created, your data is sometimes simplified at lower zoom levels to reduce the complexity of the data and make sure that each tile is below a certain size. Mapbox Studio does this to make your map load faster in areas where details wouldn't be normally noticed. Uploaded tilesets are also given a zoom extent. This zoom extent is the total zoom range in which features are visible, which is listed on the tileset information page. If you need your tileset to be visible at a different zoom extent, you can adjust this manually. Note Zoom extents for vector tiles affect the zoom levels at which tiles are generated. This is different from the zoom levels at which the data is visible: Vector tilesets can be styled up to zoom level 22, and zoom levels higher than the zoom extent will be styled using the highest zoom tiles available. More about tilesets See the Tilesets section for more information on how to upload and manage tilesets in Mapbox Studio. Read about tilesets More about datasets See the Datasets section for more information on how to upload, manage, and edit datasets in Mapbox Studio. Read about datasets Troubleshooting common upload errors Having trouble with uploads? Try our troubleshooting guides. View troubleshooting guides Next page: Publish your style Learn how to publish map styles made in Mapbox Studio. Was this page helpful? Yes No",,Geospatial data,Uploading data you can edit (datasets),Uploading data to add to a map (tilesets),,Preparing your data for upload,Uploading using the Uploads API,Accepted file types and transfer limits,Zoom levels and simplification,More about tilesets,More about datasets,Troubleshooting common upload errors,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,CartoCSS,CartoCSS is a language used by Mapbox Studio Classic to build classic styles.,https://docs.mapbox.com/help/glossary/cartocss/,glossary,,,"CartoCSS Note Mapbox Studio Classic, which uses CartoCSS, is no longer in active development. To learn more about our newer mapping tools see Mapbox Studio. CartoCSS is a language used by Mapbox Studio Classic to build classic styles. You can use CartoCSS to choose colors, apply different rendering at specific zoom levels, and generally apply styles to your vector data. Here's an example of CartoCSS to style road labels: #road_label { text-name: @name; text-placement: line; text-face-name: @sans; text-fill: #333; text-halo-fill: fadeout(#fff, 75%); text-halo-radius: 2; text-halo-rasterizer: fast; text-size: 12; text-margin: 20; text-avoid-edges: true; [zoom>=15] { text-size: 13; } } As the name suggests, CartoCSS is like CSS, the language used to style HTML. CartoCSS is CSS for map data. Read the CartoCSS documentation to learn more. Was this page helpful? Yes No",,CartoCSS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Custom destination marker,Add a custom marker to the destination.,https://docs.mapbox.com/ios/navigation/examples/custom-destination-marker/,example,Swift,,"Custom destination marker import Foundation import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections class CustomDestinationMarkerController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let origin = CLLocationCoordinate2DMake(37.77440680146262, -122.43539772352648) let destination = CLLocationCoordinate2DMake(37.76556957793795, -122.42409811526268) let options = NavigationRouteOptions(coordinates: [origin, destination]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) let navigationOptions = NavigationOptions(navigationService: navigationService) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) navigationViewController.mapView?.delegate = self self.present(navigationViewController, animated: true, completion: nil) } } } extension CustomDestinationMarkerController: MGLMapViewDelegate { func navigationViewController(_ navigationViewController: NavigationViewController, imageFor annotation: MGLAnnotation) -> MGLAnnotationImage? { var annotationImage = navigationViewController.mapView!.dequeueReusableAnnotationImage(withIdentifier: ""marker"") if annotationImage == nil { // Leaning Tower of Pisa by Stefan Spieler from the Noun Project. var image = UIImage(named: ""marker"")! // The anchor point of an annotation is currently always the center. To // shift the anchor point to the bottom of the annotation, the image // asset includes transparent bottom padding equal to the original image // height. // // To make this padding non-interactive, we create another image object // with a custom alignment rect that excludes the padding. image = image.withAlignmentRectInsets(UIEdgeInsets(top: 0, left: 0, bottom: image.size.height / 2, right: 0)) // Initialize the ‘pisa’ annotation image with the UIImage we just loaded. annotationImage = MGLAnnotationImage(image: image, reuseIdentifier: ""marker"") } return annotationImage } } Copy Was this page helpful? Yes No",,Custom destination marker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Manage large data files for Mapbox Studio with Tippecanoe,Learn how to manage big data files and make a scale-independent view of your data.,https://docs.mapbox.com/help/troubleshooting/large-data-tippecanoe/,troubleshooting,,,"Manage large data files for Mapbox Studio with Tippecanoe If your data is large in size and exceeds the maximum upload limit, you may not be able to upload it to Mapbox Studio. This guide will show you how to use Tippecanoe, a command-line utility, to convert your data into smaller files suitable for uploading to Mapbox Studio. About Tippecanoe Tippecanoe creates vector tilesets from large GeoJSON feature collections. The output is an MBTiles file that can be uploaded to Mapbox. Getting started Before you begin, your data must be in the form of a GeoJSON file. There are many tools you can use to do this conversion — we recommend using ogr2ogr. You will also need to install Tippecanoe. Please note that Tippecanoe is not supported on Windows. Reducing the size of a large data file The GeoJSON file in the example below (new-york_new-york_buildings.geojson) is 761.5 MB in size. Since this exceeds the upload limit for a GeoJSON file, Tippecanoe will need to be used to reduce the size of this file. Converting GeoJSON to vector tiles Once Tippecanoe is installed, you can convert your GeoJSON file to MBTiles. In your command line, navigate to the directory that contains the GeoJSON file, and then run the following command: tippecanoe -o nyc-buildings.mbtiles new-york_new-york_buildings.geojson Where new-york_new-york_buildings.geojson is the name of your GeoJSON file, and nyc-buildings.mbtiles is the name you should give to the resulting MBTiles file. Tippecanoe will then read and sort the features and convert them to the MBTiles data format. Tippecanoe has many other options, but you will stick to the command above for this guide. The resulting MBTiles file will be saved in your current directory. You now have a new vector tileset that has a size of 4.7 Mb - dramatically less than the original GeoJSON file! Next steps Now that you've converted your GeoJSON file to a vector tileset, you can upload it to Mapbox Studio to use in a custom style. Read the Mapbox Studio Manual uploads section to learn more about uploading your custom data. Once your data has been uploaded, take a look at the Mapbox Studio Manual style section for more information on styling line layers, fill layers, fill-extrusion layers, circle layers, and symbol layers in the Mapbox Studio style editor. Was this page helpful? Yes No",,Manage large data files for Mapbox Studio with Tippecanoe,Getting started,Reducing the size of a large data file,,Converting GeoJSON to vector tiles,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Data-driven circles,Dynamically style a circle layer with data-driven styling.,https://docs.mapbox.com/ios/maps/examples/dds-circle-layer/,example,Swift,,"Data-driven circles Source data originates from a GeoJSON file uploaded to create a tileset in Mapbox Studio. Refer to the Working with GeoJSON data guide for more information about working with GeoJSON source data. Learn more about creating data visualizations in our Predicates and expressions guide. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() // Create a new map view using the Mapbox Light style. mapView = MGLMapView(frame: view.bounds) mapView.styleURL = MGLStyle.lightStyleURL mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.tintColor = .darkGray // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 38.897, longitude: -77.039), animated: false) mapView.zoomLevel = 10.5 mapView.delegate = self view.addSubview(mapView) } // Wait until the style is loaded before modifying the map style. func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { // ""mapbox://examples.2uf7qges"" is a map ID referencing a tileset. For more // more information, see mapbox.com/help/define-map-id/ let source = MGLVectorTileSource(identifier: ""trees"", configurationURL: URL(string: ""mapbox://examples.2uf7qges"")!) style.addSource(source) let layer = MGLCircleStyleLayer(identifier: ""tree-style"", source: source) // The source name from the source's TileJSON metadata: mapbox.com/api-documentation/maps/#retrieve-tilejson-metadata layer.sourceLayerIdentifier = ""yoshino-trees-a0puw5"" // Stops based on age of tree in years. let stops = [ 0: UIColor(red: 1.00, green: 0.72, blue: 0.85, alpha: 1.0), 2: UIColor(red: 0.69, green: 0.48, blue: 0.73, alpha: 1.0), 4: UIColor(red: 0.61, green: 0.31, blue: 0.47, alpha: 1.0), 7: UIColor(red: 0.43, green: 0.20, blue: 0.38, alpha: 1.0), 16: UIColor(red: 0.33, green: 0.17, blue: 0.25, alpha: 1.0) ] // Style the circle layer color based on the above stops dictionary. layer.circleColor = NSExpression(format: ""mgl_step:from:stops:(AGE, %@, %@)"", UIColor(red: 1.0, green: 0.72, blue: 0.85, alpha: 1.0), stops) layer.circleRadius = NSExpression(forConstantValue: 3) style.addLayer(layer) } } Copy Was this page helpful? Yes No",,Data-driven circles,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Route generation,Learn how to generate routes for use in the Mapbox Navigation SDK or Navigation UI SDK for Android.,https://docs.mapbox.com/android/navigation/overview/route-generation/,guide,Java,,"Route generation SDKs covered: Navigation SDK Navigation UI SDK Route generation and the Navigation UI SDK This guide does not describe any specific options in the Navigation UI SDK, but, the concepts described in this guide are important to understand if you are using the Navigation UI SDK. You will need to provide either a valid DirectionsRoute object or both an origin and destination Point object to the NavigationView. If you provide both, only the DirectionsRoute will be used. For details on default and custom route styling using the Navigation UI, see Map and application design. The core Navigation SDK uses routes generated by the Mapbox Directions API. The Navigation SDK's NavigationRoute class wraps the MapboxDirections class with parameters that must be set in order for a navigation session to successfully begin. You can use the NavigationRoute.Builder class to create a new request to the Mapbox Directions API. There are over a dozen methods that can be used to customize your request, but only three are required: accessToken origin destination The response will be a NavigationRoute object, which you can use to display a route on a map or start a navigation sequence. Java Kotlin // From Mapbox to The White House Point origin = Point.fromLngLat(-77.03613, 38.90992); Point destination = Point.fromLngLat(-77.0365, 38.8977); NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin) .destination(destination) .build() .getRoute(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { } @Override public void onFailure(Call<DirectionsResponse> call, Throwable t) { } }); Copy Request a route in a specific direction Consider the direction a user’s device is facing, and request a route starting in a specific direction. To receive a route that starts off in the same direction the user is already traveling, pass in the user’s location bearingvalue (between 0 and 355 degrees). If you need to request a route that's continuing along the path that the user is traveling, specify a bearing and a tolerance that determines how far you are willing to deviate from the provided bearing. This is useful for off-route scenarios. Device location: In the adjacent diagram, the blue dot with white stroke is the device location. Bearing: The bearing tells you the direction a user's device is facing. It is an angle clockwise from true north between 0 and 359. For example, if the device is facing north, the bearing will be 0°, and if the user is facing due east, the bearing will be 90°. In the adjacent diagram, the pink arrow is the direction that the device is facing (which is due west or 270°). Tolerance: Tolerance is the range of degrees by which a route can deviate from the bearing angle and still be recommended. The semi-transparent blue area illustrates tolerance. In this example tolerance is 90° (45° in either direction from the bearing angle). This can be applied to the origin, waypoints, and the destination using NavigationRoute: Java Kotlin // An Android Location object double bearing = Float.valueOf(location.getBearing()).doubleValue(); double tolerance = 90d; NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin, bearing, tolerance) .destination(destination) .build(); Copy Specify a side of the road to approach You can state from which side of the road to approach a waypoint by adding approaches to the NavigationRoute builder. There are three options found in DirectionsCriteria.ApproachesCriteria: ""unrestricted"" (default): the route can approach waypoints from either side of the road. ""curb"": the route will be returned so that on arrival, the waypoint will be found on the side that corresponds with the driving_side of the region in which the returned route is located. null: if no option is specified, it is translated internally to """", which has the same result as setting an approach to ""unrestricted"". If provided, the list of approaches must be the same length as the list of waypoints (including the origin and the destination) and in that particular order (origin, waypoints, destination). If a re-route occurs and approaches were used to fetch the DirectionsRoute that was originally provided to the NavigationView, the new route fetched will take the same approaches criteria into account. Java Kotlin NavigationRoute.Builder builder = NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin) .addWaypoint(pickup) .destination(destination); builder.addApproaches(""unrestricted"", ""curb"", ""curb""); builder.build(); Copy Include multiple stops If your navigation involves several pick-up and drop-off points, you can add up to 25 coordinates (including the origin and destination) to the NavigationRoute builder using the driving profile or three coordinates using the driving-traffic profile. These coordinates are treated as stops in between the origin and destination Points (in the order that you add them — the first waypoint is the first stop): Java Kotlin NavigationRoute.Builder builder = NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin) .destination(destination); for (Point waypoint : waypoints) { builder.addWaypoint(waypoint); } builder.build(); Copy More about route generation Read more about route generation in: Localization: Customize the language and units of measurement returned for both text and voice instructions or use the language preferences set on the device. Offline routing: Provide routing functionality from the Navigation SDK in non-connected environments. Was this page helpful? Yes No",,Route generation,Specify a side of the road to approach,Include multiple stops,Kotlin,More about route generation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,World-scale AR,An overview of the world-scale AR example provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/world-scale-ar/,example,No code,,"World-scale AR The world-scale AR example allows for overlaying 3D maps and location data onto the AR camera feed using Unity’s AR Interface and location services. This article outlines the setup and purpose of each major part of the World-scale AR example. Concepts AR Session: In AR apps, the scene’s main camera is positioned automatically to match the real-world device’s position, but only from the moment the app is initialized. Map Alignment: To make an AR session location aware, the WorldAlignmentKit prefab aligns a 3D map around the AR camera. Customization: Once the Map is aligned, you have access to all Mapbox’s data and customization to build world-scale experiences. Getting started To open the example, navigate to MapboxAR > Examples > Scenes > WorldScaleAR and double-click to open. You’ll see an AR prerequisites warning. Some layers that aren’t included by default in a Unity project are needed to run this scene. Select WorldAlignmentKit in the Hierarchy view. To get things going, add the following layers by clicking Layer and selecting Add Layer Next, add: ARGameObject Map Path Both The WorldAlignmentKit contains: ARRoot: The UnityInterface Prefab for building cross-platform AR apps. MapCamera: A top-down view of the map, used to view gps traces, AR position, and the current map alignment. View in play mode with the Map Checkbox. ArAlignedMap: The map, aligned to AR Root using your devices location services. Renders orange debug buildings by default. DebugCanvas: A detailed debug log of location services and AR activity viewable by pressing the ‘LOG’ icon in play mode and on devices. This is included as a unity UI element to make debugging easier on-location. LocationProvider: Provides GPS data to the map, and spoofs data for testing in the editor. Running in the editor Once your project layers are set up, play the scene. you should see the GPS position: In the Editor, the map is positioned based on EditorLocationProvider settings, a component attached to WorldAlignmentKit > LocationProvider > Editor in the hierarchy. The WorldAlignmentKit shows GPS movement in blue, and AR movement in red. The blue dot is the current GPS trace. In the editor, test this out by using the ""w,a,s,d"" keys to move the AR camera in the editor. After some distance, you should see an AR trace in red, and the last GPS fix in blue. In the editor, the GPS fix won’t update automatically. On a device, you’ll see blue traces as well as red. Was this page helpful? Yes No",,World-scale AR,Getting started,Running in the editor,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Traffic Data,Examples,Learn how to use Python to manipulate and parse the Traffic Data CSV files.,https://docs.mapbox.com/traffic-data/overview/example/,guide,,,"Examples We are providing you with a zipped file that contains example data so that you can experiment with the format of the Typical speeds file. This sample file uses OpenStreetMap node pairs to identify road segments within the 0320122 quadkey, which includes Wilmington, NC. This data is not up-to-date, and is for testing purposes only. Mapbox Enterprise customers have access to the most up-to-date Typical files, Live files, and files that use OpenLR identifiers. If you are not an Enterprise customer and would like to access these assets, contact the Mapbox Sales team. An example file with data referenced by OpenLR Strings can be found at the bottom of this page. Download file The sample code in these examples use Python and the pandas library. Calculate aggregated traffic metrics You may be interested in calculating aggregated traffic metrics using the Typical speeds file. An example of this would be averaging speeds for each road across all five-minute intervals between 9:00 AM and 10:00 AM on Monday morning. The first two columns of a row in the file identify the node pair that makes up a road segment. Because there are 396 five-minute intervals in the week between Sunday at 0:00 AM and Monday at 9:00 AM, this means the data to be aggregated exists between the 399th column and the 410th column of the Typical speeds CSV. The following Python code consumes the sample Typical speeds file and generates the aggregated data described above as a pandas.DataFrame called monday_9_10_nodes_speeds: import pandas as pd all_speeds = pd.read_csv('0320122-America-New_York.csv.gz', header=None, compression='gzip') monday_9_10_speeds = all_speeds.iloc[:, 398:410].mean(axis=1).round(2) monday_9_10_nodes_speeds = pd.concat([all_speeds[[0, 1]]monday_9_10_speeds], axis=1) monday_9_10_nodes_speeds.columns = ['start_node', 'end_node', 'average'] print(monday_9_10_nodes_speeds.head()) # Expected output: # # start_node end_node average # 0 113054533 113096757 55.58 # 1 170190194 4525170049 93.92 # 2 4525170049 4525170048 93.92 # 3 4525170048 170198969 93.92 # 4 170198969 170181217 93.92 Represent one point in time You may also be interested in parsing the Typical speeds file to represent data at one point in time. To do so, you can manipulate the data so that it matches the format of the Live speeds file (start node, end node, speed). This format is useful if you want to provide traffic updates based on typical traffic patterns to a routing engine like OSRM. Because there are two columns that represent the start and end nodes as well as 396 columns for the five-minute intervals between Sunday at 0:00 AM and Monday at 9:00 AM, this means the data for 9:00 AM Monday exists at the 399th column of the Typical speeds CSV. The following Python code generates a simplified file that contains the start and end nodes and the speed data from 9:00-9:05 AM on Monday. import pandas as pd all_speeds = pd.read_csv('0320122-America-New_York.csv.gz', header=None, compression='gzip') monday_9am = all_speeds[[0, 1, 398]] monday_9am.to_csv('9am_speeds.csv', header=False, index=False) If you want to use the resulting file to supply traffic data to OSRM, the OSRM Wiki entry on traffic updates has instructions specific to this use case. This workflow enables you to load a single snapshot of traffic data, rather than an array of speeds that maps to times of the day or week. It is up to you to arrange for continuous updating if that is your intention. If you are interested in applying frequent speed updates to OSRM (on the scale of minutes rather than hours), we recommend you use the Multi-level Dijkstra (MLD) preprocessing pipeline as described in the OSRM traffic updates wiki page. Sample OpenLR file Download OpenLR file Was this page helpful? Yes No",,Examples,Represent one point in time,Sample OpenLR file,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Sort stores by distance,This guide walks you through all the code that you need to build a store locator which lets you search for the nearest location.,https://docs.mapbox.com/help/tutorials/geocode-and-sort-stores/,tutorial,JavaScript,,"advanced JavaScript Sort stores by distance Prerequisite Familiarity with front-end development concepts. Some advanced JavaScript required. This guide will walk you through how to use Mapbox GL JS, the Mapbox GL Geocoder plugin, and Turf.js to sort store locations based on distance from a geocoded point. This guide extends the map created in the Build a store locator using Mapbox GL JS tutorial. If haven't completed that tutorial yet, be sure to do so before starting this project. If you're new to Mapbox GL JS, you may also want to read our Web applications guide first. Getting started For this project, we recommend that you create a local folder called ""sort-store-locator"" to house your project files. You'll see this folder referred to as your project folder. There are a few resources you'll need before getting started: Store locator final project. This tutorial builds off of the code created in the Build a store locator using Mapbox GL JS tutorial. Make sure you've created a copy of the final version of that code for this new project or downloaded the starter code. Download starter code An access token from your account. You will use an access token to associate a map with your account. Your access token is on the Account page. Mapbox GL JS. The Mapbox JavaScript library that uses WebGL to render interactive maps from Mapbox GL styles. Mapbox GL Geocoder plug-in. The Mapbox GL JS wrapper library for the Mapbox Geocoding API. Turf.js. An open-source analysis library that performs spatial analysis in the browser and in Node.js. A text editor. You'll be writing HTML, CSS, and JavaScript. Add plugins and initialize the map Download the starter-code zip file. Inside you'll find an index.html file and an img folder that contains the custom marker you'll be using to show store locations. Open the index.html file in a text editor. Make sure you use your own access token and set it equal to mapboxgl.accessToken. Add Mapbox GL geocoder plugin and Turf.js Next, set up your document by adding the Mapbox GL Geocoder plug-in and Turf.js library links to the head of your HTML file. Copy and paste the following code after your links to Mapbox GL JS. <!-- Geocoder plugin --> <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.min.js'></script> <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/ v4.2.0 /mapbox-gl-geocoder.css' type='text/css' /> <!-- Turf.js plugin --> <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script> Add geocoder control Add the geocoder control to your JavaScript code using the constructor new mapboxgl.Geocoder. In this case, you'll limit the search results to the Washington DC area using the bbox parameter. There are several other parameters you can specify. You can read more about the available parameters in the documentation on GitHub. The code below should be added inside map.on('load', function (e) { ... } ); in your script tags. var geocoder = new MapboxGeocoder( { accessToken: mapboxgl.accessToken, // Set the access token mapboxgl: mapboxgl, // Set the mapbox-gl instance marker: false, // Do not use the default marker style bbox: [-77.210763, 38.803367, -76.853675, 39.052643] // Set the bounding box coordinates } ); map.addControl(geocoder, 'top-left'); Now add some CSS to style your new geocoding search bar. You can add this code right before your closing </style> tag. .mapboxgl-ctrl-geocoder { border: 0; border-radius: 0; position: relative; top: 0; width: 800px; margin-top: 0; } .mapboxgl-ctrl-geocoder > div { min-width: 100%; margin-left: 0; } Save your HTML document, and refresh the page in your web browser. The result should look like this. Notice what happens when you search for an address using the geocoding form you have created. The map will fly to the location you've specified, but doesn't visualize the matching location. In the next step, you'll add a point once you've successfully found a location using Mapbox GL Geocoder. Add point on search Adding a custom marker style The Mapbox GL Geocoder sets a marker at the search result location by default. This example adds a custom marker as a new layer instead. If you want to use the default marker provided by the geocoder, remove the line marker: false, from the new geocoder instantiation. Now that your geocoder is working, you can write code to add a point to your map at the location you searched. All this code will go inside map.on('load', function (e) { ... } ); directly following the code you added in the previous step. First, you need to add an empty source using map.addSource() where you will store your geocoder result, and a styled layer from that source using map.addLayer(). map.addSource('single-point', { type: 'geojson', data: { type: 'FeatureCollection', features: [] // Notice that initially there are no features } } ); map.addLayer( { id: 'point', source: 'single-point', type: 'circle', paint: { 'circle-radius': 10, 'circle-color': '#007cbf', 'circle-stroke-width': 3, 'circle-stroke-color': '#fff' } } ); Next, create an event listener that fires when the user selects a geocoder result. When the user selects a place from the list of returned locations, save the coordinates in a variable called searchResult. Then, set the data in the source with the id single-point you declared above to searchResult. Copy and paste this code after the map.addSource() and map.addLayer() functions. geocoder.on('result', function(ev) { var searchResult = ev.result.geometry; map.getSource('single-point').setData(searchResult); } ); The result should look like this: Sort store list by distance Next, calculate the distance between the searched location and the stores, add the results to your GeoJSON data, and sort the store listings by distance from the searched point. Find distance from all locations Next you'll use Turf.js to find the distances between your new point and each of the restaurant locations. Turf.js can do a wide variety of spatial analysis functions, which you can read about in the documentation. In this tutorial you are going to use distance. Within your geocoder.on('result', function() { ... } ); function, use a forEach loop to iterate through all the store locations in your GeoJSON (remember, you stored these in the stores variable earlier), define a new property for each object called distance, and set the value of that property to the distance between the coordinates stored in the searchResult and the coordinates of each store location. You will do this using the turf.distance() method, which accepts three arguments: from, to, options. var options = { units: 'miles' } ; stores.features.forEach(function(store) { Object.defineProperty(store.properties, 'distance', { value: turf.distance(searchResult, store.geometry, options), writable: true, enumerable: true, configurable: true } ); } ); For each feature in your GeoJSON, a distance property is applied or will be updated each time a new geocoder result is selected. Sort store list by distance Now that you have the distance value for each store location, you can use it to sort the list of stores by distance. First, sort the objects in the stores array by the distance property you added earlier. Copy and paste the following code snippet inside the geocoder.on('result', function() { ... } ); function. stores.features.sort(function(a, b) { if (a.properties.distance > b.properties.distance) { return 1; } if (a.properties.distance < b.properties.distance) { return -1; } // a must be equal to b return 0; } ); Then, remove the current list of stores and rebuild the list using the reordered array you created. The individual listings are nested within the div with id listings. var listings = document.getElementById('listings'); while (listings.firstChild) { listings.removeChild(listings.firstChild); } buildLocationList(stores); Now the listing for each store will be in ascending order of distance from the point that was searched. To make the new list of locations more useful to your viewers, add text that describes each listing's distance from the point they searched for. When you built your initial interactive store locator in the previous tutorial, you created a buildLocationListing() function. You will need to find and change that function to check if there is a distance property, and if there is, add the value of that property to each listing. Copy and paste the following code before the link.addEventListener() function within the buildLocationListing() function. if (prop.distance) { var roundedDistance = Math.round(prop.distance * 100) / 100; details.innerHTML += '<p><strong>' + roundedDistance + ' miles away</strong></p>'; } The result should look like this: Fit bounds to search result and closest store Finally, when you search for a location, you can change the view to include both the location that was searched and the closest store to show more context. You can do this by using map.fitBounds() and specifying a bounding box. But the bounds need to be in a specific order. The first point you specify should be the lower left corner of the bounding box, and the second should be the upper right corner. Add the following code inside the geocoder.on() function to create a bbox with this syntax from the geocoded location and the closest store, fly to it, and open the closest store's popup. function sortLonLat(storeIdentifier) { var lats = [stores.features[storeIdentifier].geometry.coordinates[1], searchResult.coordinates[1]]; var lons = [stores.features[storeIdentifier].geometry.coordinates[0], searchResult.coordinates[0]]; var sortedLons = lons.sort(function(a, b) { if (a > b) { return 1; } if (a.distance < b.distance) { return -1; } return 0; } ); var sortedLats = lats.sort(function(a, b) { if (a > b) { return 1; } if (a.distance < b.distance) { return -1; } return 0; } ); map.fitBounds([ [sortedLons[0], sortedLats[0]], [sortedLons[1], sortedLats[1]] ], { padding: 100 } ); } sortLonLat(0); createPopUp(stores.features[0]); Finished product You have created a store locator with geocoding and spatial analysis. Next steps After this guide, you should have everything you need to create your own store locator. You can complete the Create a custom style tutorial to create a branded map style or use Cartogram, a drag and drop tool, to create a custom style from your logo in minutes. To do more with Mapbox GL JS, explore our examples page and the Mapbox GL JS on the help page. Was this page helpful? Yes No",,Sort stores by distance,Add plugins and initialize the map,Add Mapbox GL geocoder plugin and Turf.js,,Add geocoder control,Add point on search,Sort store list by distance,Find distance from all locations,Fit bounds to search result and closest store,Finished product,Next steps,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Style lines with a data-driven property,Creating a visualization with a data expression for line-color.,https://docs.mapbox.com/mapbox-gl-js/example/data-driven-lines/,example,JavaScript,,Style lines with a data-driven property Creating a visualization with a data expression for line-color. Was this example helpful? Yes No,,Style lines with a data-driven property,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Use custom Mapbox styles in Tableau,General configuration guidance and tips for using custom Mapbox maps in Tableau.,https://docs.mapbox.com/help/troubleshooting/use-custom-mapbox-styles-in-tableau/,troubleshooting,,,"Use custom Mapbox styles in Tableau The latest versions of Tableau Server, Desktop, Public, and Online all use Mapbox vector maps by default. This guide shows you how to import and use custom Mapbox styles in Tableau. Find a Mapbox style's integration URL To use a Mapbox style in Tableau, you need that style's integration URL. Go to your Mapbox Studio styles page and click on the style that you would like to use as your background map in Tableau. Click on the Share button in the options bar at the top of the screen. Click the Production tab. In the Develop bar, click the Third party option. Choose Tableau from the dropdown menu. Click on the clipboard button to copy the Integration URL to your computer's clipboard. You will use this URL to connect to your Mapbox style from Tableau. Change your background map to a custom Mapbox map To use a custom Mapbox map as your background map in Tableau: In Tableau, click on Map > Background Maps > Map Services. In the Map Services panel, click the Add button. Select Mapbox Maps. Give the style a name in the Style Name field. You will be able to use this name later to identify the style, so make it descriptive. In the Add Mapbox Map modal, paste the Mapbox integration URL into the URL field. The API access token, Username, and Style ID fields will automatically populate. Click the OK button. The background map will automatically switch the Mapbox map style you imported in the last step. Use background maps in Tableau Desktop You can access the Mapbox maps you've added to Tableau through the Maps menu: Click on Map in the Tableau menu bar. Select Background Maps. Click on your desired Mapbox style. The background map will be updated to use the style that you select. Show or hide layers in a custom Mapbox map When you set your Tableau background map to use a custom Mapbox map style, you can use the Map Layers panel to either show or hide layers within that Mapbox style. The layers used in a custom Mapbox map style will likely be different than the layers used in the default Tableau map styles, which are described in the Tableau Customize how your map looks guide. All your style's layers that are displayed in the Mapbox Studio style editor will be displayed automatically in the Tableau view. To hide a layer, click on the checkbox next to the layer name to deselect it. For further guidance on how to customize maps in Tableau, consult the Tableau documentation. Was this page helpful? Yes No",,Use custom Mapbox styles in Tableau,Change your background map to a custom Mapbox map,Use background maps in Tableau Desktop,,Show or hide layers in a custom Mapbox map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Transparent render surface,Create a transparent background and fill it with something such as moving water.,https://docs.mapbox.com/android/maps/examples/transparent-background/,example,Java,,"Transparent render surface Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" android:id=""@+id/coordinator_layout"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <VideoView android:id=""@+id/videoView"" android:layout_width=""match_parent"" android:scaleX=""1.8"" android:scaleY=""1.8"" android:layout_height=""match_parent"" android:layout_gravity=""center"" /> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:mapbox_cameraTargetLat=""48.507879"" app:mapbox_cameraTargetLng=""8.363795"" app:mapbox_cameraZoom=""2"" app:mapbox_cameraZoomMin=""1.3"" app:mapbox_renderTextureMode=""true"" app:mapbox_renderTextureTranslucentSurface=""true"" /> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.content.Context; import android.media.MediaPlayer; import android.net.Uri; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.RawRes; import androidx.appcompat.app.AppCompatActivity; import android.widget.VideoView; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.io.StringWriter; import java.io.Writer; import timber.log.Timber; /** * Create a transparent render surface and add whatever you want to the background. This example * has a video of moving water behind Earth's land. */ public class TransparentBackgroundActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private VideoView backgroundWaterVideoView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_transparent_render_background); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { try { // Switch the map to a style that has no background mapboxMap.setStyle(new Style.Builder().fromJson(readRawResource(this, R.raw.no_bg_style)), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initVideoView(); } }); } catch (IOException exception) { Timber.e(exception); } } /** * Place the video of moving water behind the map */ private void initVideoView() { backgroundWaterVideoView = findViewById(R.id.videoView); String path = ""android.resource://"" + getPackageName() + ""/"" + R.raw.moving_background_water; backgroundWaterVideoView.setVideoURI(Uri.parse(path)); backgroundWaterVideoView.start(); backgroundWaterVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { backgroundWaterVideoView.start(); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { if (backgroundWaterVideoView != null) { backgroundWaterVideoView.stopPlayback(); } super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } /** * Get the map style JSON from the raw file in the app's raw folder */ public static String readRawResource(Context context, @RawRes int rawResource) throws IOException { String json = """"; if (context != null) { Writer writer = new StringWriter(); char[] buffer = new char[1024]; try (InputStream is = context.getResources().openRawResource(rawResource)) { Reader reader = new BufferedReader(new InputStreamReader(is, ""UTF-8"")); int numRead; while ((numRead = reader.read(buffer)) != -1) { writer.write(buffer, 0, numRead); } } json = writer.toString(); } return json; } } Copy Was this page helpful? Yes No",,Transparent render surface,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Optimization API,The Mapbox Optimization API returns a duration-optimized route between provided input coordinates.,https://docs.mapbox.com/help/glossary/optimization-api/,glossary,,,"Optimization API The Mapbox Optimization API returns a duration-optimized route between provided input coordinates. Optimized trips can be retrieved for three different Mapbox routing profiles: mapbox/driving, mapbox/walking, and mapbox/cycling. A sample Optimization API request looks like: https://api.mapbox.com/optimized-trips/v1/mapbox/driving/-122.42,37.78;-122.45,37.91;-122.48,37.73?access_token= YOUR_MAPBOX_ACCESS_TOKEN The Optimization API has optional parameters that can be used to refine the results of a request. Related resources: Optimization API documentation Generate an optimized route tutorial Was this page helpful? Yes No",,Optimization API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Symbol layer info window,"Use SymbolLayer and icons to show data in a BubbleLayout ""info window"".",https://docs.mapbox.com/android/maps/examples/symbol-layer-info-window/,example,Java,,"Symbol layer info window Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""42.149683"" mapbox:mapbox_cameraTargetLng=""-119.155770"" mapbox:mapbox_cameraZoom=""3.853171"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.content.Context; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.PointF; import android.os.AsyncTask; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.LayoutInflater; import android.view.View; import android.widget.TextView; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.annotations.BubbleLayout; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.HashMap; import java.util.List; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.layers.Property.ICON_ANCHOR_BOTTOM; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAnchor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Use a SymbolLayer to show a BubbleLayout above a SymbolLayer icon. This is a more performant * way to show the BubbleLayout that appears when using the MapboxMap.addMarker() method. */ public class InfoWindowSymbolLayerActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private static final String GEOJSON_SOURCE_ID = ""GEOJSON_SOURCE_ID""; private static final String MARKER_IMAGE_ID = ""MARKER_IMAGE_ID""; private static final String MARKER_LAYER_ID = ""MARKER_LAYER_ID""; private static final String CALLOUT_LAYER_ID = ""CALLOUT_LAYER_ID""; private static final String PROPERTY_SELECTED = ""selected""; private static final String PROPERTY_NAME = ""name""; private static final String PROPERTY_CAPITAL = ""capital""; private MapView mapView; private MapboxMap mapboxMap; private GeoJsonSource source; private FeatureCollection featureCollection; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_info_window_symbol_layer); // Initialize the map view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { new LoadGeoJsonDataTask(InfoWindowSymbolLayerActivity.this).execute(); mapboxMap.addOnMapClickListener(InfoWindowSymbolLayerActivity.this); } }); } @Override public boolean onMapClick(@NonNull LatLng point) { return handleClickIcon(mapboxMap.getProjection().toScreenLocation(point)); } /** * Sets up all of the sources and layers needed for this example * * @param collection the FeatureCollection to set equal to the globally-declared FeatureCollection */ public void setUpData(final FeatureCollection collection) { featureCollection = collection; if (mapboxMap != null) { mapboxMap.getStyle(style -> { setupSource(style); setUpImage(style); setUpMarkerLayer(style); setUpInfoWindowLayer(style); }); } } /** * Adds the GeoJSON source to the map */ private void setupSource(@NonNull Style loadedStyle) { source = new GeoJsonSource(GEOJSON_SOURCE_ID, featureCollection); loadedStyle.addSource(source); } /** * Adds the marker image to the map for use as a SymbolLayer icon */ private void setUpImage(@NonNull Style loadedStyle) { loadedStyle.addImage(MARKER_IMAGE_ID, BitmapFactory.decodeResource( this.getResources(), R.drawable.red_marker)); } /** * Updates the display of data on the map after the FeatureCollection has been modified */ private void refreshSource() { if (source != null && featureCollection != null) { source.setGeoJson(featureCollection); } } /** * Setup a layer with maki icons, eg. west coast city. */ private void setUpMarkerLayer(@NonNull Style loadedStyle) { loadedStyle.addLayer(new SymbolLayer(MARKER_LAYER_ID, GEOJSON_SOURCE_ID) .withProperties( iconImage(MARKER_IMAGE_ID), iconAllowOverlap(true), iconOffset(new Float[] {0f, -8f}) )); } /** * Setup a layer with Android SDK call-outs * <p> * name of the feature is used as key for the iconImage * </p> */ private void setUpInfoWindowLayer(@NonNull Style loadedStyle) { loadedStyle.addLayer(new SymbolLayer(CALLOUT_LAYER_ID, GEOJSON_SOURCE_ID) .withProperties( /* show image with id title based on the value of the name feature property */ iconImage(""{name}""), /* set anchor of icon to bottom-left */ iconAnchor(ICON_ANCHOR_BOTTOM), /* all info window and marker image to appear at the same time*/ iconAllowOverlap(true), /* offset the info window to be above the marker */ iconOffset(new Float[] {-2f, -28f}) ) /* add a filter to show only when selected feature property is true */ .withFilter(eq((get(PROPERTY_SELECTED)), literal(true)))); } /** * This method handles click events for SymbolLayer symbols. * <p> * When a SymbolLayer icon is clicked, we moved that feature to the selected state. * </p> * * @param screenPoint the point on screen clicked */ private boolean handleClickIcon(PointF screenPoint) { List<Feature> features = mapboxMap.queryRenderedFeatures(screenPoint, MARKER_LAYER_ID); if (!features.isEmpty()) { String name = features.get(0).getStringProperty(PROPERTY_NAME); List<Feature> featureList = featureCollection.features(); for (int i = 0; i < featureList.size(); i++) { if (featureList.get(i).getStringProperty(PROPERTY_NAME).equals(name)) { if (featureSelectStatus(i)) { setFeatureSelectState(featureList.get(i), false); } else { setSelected(i); } } } return true; } else { return false; } } /** * Set a feature selected state. * * @param index the index of selected feature */ private void setSelected(int index) { Feature feature = featureCollection.features().get(index); setFeatureSelectState(feature, true); refreshSource(); } /** * Selects the state of a feature * * @param feature the feature to be selected. */ private void setFeatureSelectState(Feature feature, boolean selectedState) { feature.properties().addProperty(PROPERTY_SELECTED, selectedState); refreshSource(); } /** * Checks whether a Feature's boolean ""selected"" property is true or false * * @param index the specific Feature's index position in the FeatureCollection's list of Features. * @return true if ""selected"" is true. False if the boolean property is false. */ private boolean featureSelectStatus(int index) { if (featureCollection == null) { return false; } return featureCollection.features().get(index).getBooleanProperty(PROPERTY_SELECTED); } /** * Invoked when the bitmaps have been generated from a view. */ public void setImageGenResults(HashMap<String, Bitmap> imageMap) { if (mapboxMap != null) { mapboxMap.getStyle(style -> { // calling addImages is faster as separate addImage calls for each bitmap. style.addImages(imageMap); }); } } /** * AsyncTask to load data from the assets folder. */ private static class LoadGeoJsonDataTask extends AsyncTask<Void, Void, FeatureCollection> { private final WeakReference<InfoWindowSymbolLayerActivity> activityRef; LoadGeoJsonDataTask(InfoWindowSymbolLayerActivity activity) { this.activityRef = new WeakReference<>(activity); } @Override protected FeatureCollection doInBackground(Void... params) { InfoWindowSymbolLayerActivity activity = activityRef.get(); if (activity == null) { return null; } String geoJson = loadGeoJsonFromAsset(activity, ""us_west_coast.geojson""); return FeatureCollection.fromJson(geoJson); } @Override protected void onPostExecute(FeatureCollection featureCollection) { super.onPostExecute(featureCollection); InfoWindowSymbolLayerActivity activity = activityRef.get(); if (featureCollection == null || activity == null) { return; } // This example runs on the premise that each GeoJSON Feature has a ""selected"" property, // with a boolean value. If your data's Features don't have this boolean property, // add it to the FeatureCollection 's features with the following code: for (Feature singleFeature : featureCollection.features()) { singleFeature.addBooleanProperty(PROPERTY_SELECTED, false); } activity.setUpData(featureCollection); new GenerateViewIconTask(activity).execute(featureCollection); } static String loadGeoJsonFromAsset(Context context, String filename) { try { // Load GeoJSON file from local asset folder InputStream is = context.getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (Exception exception) { throw new RuntimeException(exception); } } } /** * AsyncTask to generate Bitmap from Views to be used as iconImage in a SymbolLayer. * <p> * Call be optionally be called to update the underlying data source after execution. * </p> * <p> * Generating Views on background thread since we are not going to be adding them to the view hierarchy. * </p> */ private static class GenerateViewIconTask extends AsyncTask<FeatureCollection, Void, HashMap<String, Bitmap>> { private final HashMap<String, View> viewMap = new HashMap<>(); private final WeakReference<InfoWindowSymbolLayerActivity> activityRef; private final boolean refreshSource; GenerateViewIconTask(InfoWindowSymbolLayerActivity activity, boolean refreshSource) { this.activityRef = new WeakReference<>(activity); this.refreshSource = refreshSource; } GenerateViewIconTask(InfoWindowSymbolLayerActivity activity) { this(activity, false); } @SuppressWarnings(""WrongThread"") @Override protected HashMap<String, Bitmap> doInBackground(FeatureCollection... params) { InfoWindowSymbolLayerActivity activity = activityRef.get(); if (activity != null) { HashMap<String, Bitmap> imagesMap = new HashMap<>(); LayoutInflater inflater = LayoutInflater.from(activity); FeatureCollection featureCollection = params[0]; for (Feature feature : featureCollection.features()) { BubbleLayout bubbleLayout = (BubbleLayout) inflater.inflate(R.layout.symbol_layer_info_window_layout_callout, null); String name = feature.getStringProperty(PROPERTY_NAME); TextView titleTextView = bubbleLayout.findViewById(R.id.info_window_title); titleTextView.setText(name); String style = feature.getStringProperty(PROPERTY_CAPITAL); TextView descriptionTextView = bubbleLayout.findViewById(R.id.info_window_description); descriptionTextView.setText( String.format(activity.getString(R.string.capital), style)); int measureSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); bubbleLayout.measure(measureSpec, measureSpec); int measuredWidth = bubbleLayout.getMeasuredWidth(); bubbleLayout.setArrowPosition(measuredWidth / 2 - 5); Bitmap bitmap = SymbolGenerator.generate(bubbleLayout); imagesMap.put(name, bitmap); viewMap.put(name, bubbleLayout); } return imagesMap; } else { return null; } } @Override protected void onPostExecute(HashMap<String, Bitmap> bitmapHashMap) { super.onPostExecute(bitmapHashMap); InfoWindowSymbolLayerActivity activity = activityRef.get(); if (activity != null && bitmapHashMap != null) { activity.setImageGenResults(bitmapHashMap); if (refreshSource) { activity.refreshSource(); } } Toast.makeText(activity, R.string.tap_on_marker_instruction, Toast.LENGTH_SHORT).show(); } } /** * Utility class to generate Bitmaps for Symbol. */ private static class SymbolGenerator { /** * Generate a Bitmap from an Android SDK View. * * @param view the View to be drawn to a Bitmap * @return the generated bitmap */ static Bitmap generate(@NonNull View view) { int measureSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); view.measure(measureSpec, measureSpec); int measuredWidth = view.getMeasuredWidth(); int measuredHeight = view.getMeasuredHeight(); view.layout(0, 0, measuredWidth, measuredHeight); Bitmap bitmap = Bitmap.createBitmap(measuredWidth, measuredHeight, Bitmap.Config.ARGB_8888); bitmap.eraseColor(Color.TRANSPARENT); Canvas canvas = new Canvas(bitmap); view.draw(canvas); return bitmap; } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,Symbol layer info window,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Display water depth,Use data-driven styling to show bathymetry (water depth) data.,https://docs.mapbox.com/android/maps/examples/bathymetry/,example,Java,,"Display water depth Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""44.934448"" mapbox:mapbox_cameraTargetLng=""-85.671378"" mapbox:mapbox_cameraZoom=""15.69"" mapbox:mapbox_cameraZoomMin=""14.9"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.geojson.FeatureCollection; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.io.InputStream; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.geometryType; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.linear; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.rgb; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textField; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textSize; public class BathymetryActivity extends AppCompatActivity implements OnMapReadyCallback { private static final String GEOJSON_SOURCE_ID = ""GEOJSON_SOURCE_ID""; private static final LatLngBounds LAKE_BOUNDS = new LatLngBounds.Builder() .include(new LatLng(44.936236, -85.673450)) .include(new LatLng(44.932955, -85.669272)) .build(); private FeatureCollection featureCollection; private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_bathymetry); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.OUTDOORS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Set bounds to Lawrence Lake, Michigan mapboxMap.setLatLngBoundsForCameraTarget(LAKE_BOUNDS); // Remove lake label layer style.removeLayer(""water-label""); // Initialize FeatureCollection object for future use with layers featureCollection = FeatureCollection.fromJson(loadGeoJsonFromAsset( ""bathymetry-data.geojson"")); // Retrieve GeoJSON from local file and add it to the map style.addSource(new GeoJsonSource(GEOJSON_SOURCE_ID, featureCollection)); setUpDepthFillLayers(style); setUpDepthNumberSymbolLayer(style); } }); } /** * Adds a FillLayer and uses data-driven styling to display the lake's areas */ private void setUpDepthFillLayers(@NonNull Style loadedMapStyle) { FillLayer depthPolygonFillLayer = new FillLayer(""DEPTH_POLYGON_FILL_LAYER_ID"", GEOJSON_SOURCE_ID); depthPolygonFillLayer.withProperties( fillColor(interpolate(linear(), get(""depth""), stop(5, rgb(16, 158, 210)), stop(10, rgb(37, 116, 145)), stop(15, rgb(69, 102, 124)), stop(30, rgb(31, 52, 67)))), fillOpacity(.7f)); // Only display Polygon Features in this layer depthPolygonFillLayer.setFilter(eq(geometryType(), literal(""Polygon""))); loadedMapStyle.addLayer(depthPolygonFillLayer); } /** * Adds a SymbolLayer to display the depth of the lake's areas */ private void setUpDepthNumberSymbolLayer(@NonNull Style loadedMapStyle) { SymbolLayer depthNumberSymbolLayer = new SymbolLayer(""DEPTH_NUMBER_SYMBOL_LAYER_ID"", GEOJSON_SOURCE_ID); depthNumberSymbolLayer.withProperties( textField(""{depth}""), textSize(17f), textColor(Color.WHITE), textAllowOverlap(true) ); // Only display Point Features in this layer depthNumberSymbolLayer.setFilter(eq(geometryType(), literal(""Point""))); loadedMapStyle.addLayerAbove(depthNumberSymbolLayer, ""DEPTH_POLYGON_FILL_LAYER_ID""); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private String loadGeoJsonFromAsset(String filename) { try { // Load GeoJSON file InputStream is = getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (Exception exception) { Timber.e(""Exception Loading GeoJSON: %s"", exception.toString()); exception.printStackTrace(); return null; } } } Copy Was this page helpful? Yes No",,Display water depth,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Draw a polygon,Draw a vector polygon on a map with the Mapbox Maps SDK.,https://docs.mapbox.com/android/maps/examples/draw-a-polygon/,example,Java,,"Draw a polygon Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.dds.DrawPolygonActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""45.520486"" mapbox:mapbox_cameraTargetLng=""-122.673541"" mapbox:mapbox_cameraZoom=""11""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.geojson.Point; import com.mapbox.geojson.Polygon; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.List; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; /** * Draw a vector polygon on a map with the Mapbox Android SDK. */ public class DrawPolygonActivity extends AppCompatActivity { private MapView mapView; private static final List<List<Point>> POINTS = new ArrayList<>(); private static final List<Point> OUTER_POINTS = new ArrayList<>(); static { OUTER_POINTS.add(Point.fromLngLat(-122.685699, 45.522585)); OUTER_POINTS.add(Point.fromLngLat(-122.708873, 45.534611)); OUTER_POINTS.add(Point.fromLngLat(-122.678833, 45.530883)); OUTER_POINTS.add(Point.fromLngLat(-122.667503, 45.547115)); OUTER_POINTS.add(Point.fromLngLat(-122.660121, 45.530643)); OUTER_POINTS.add(Point.fromLngLat(-122.636260, 45.533529)); OUTER_POINTS.add(Point.fromLngLat(-122.659091, 45.521743)); OUTER_POINTS.add(Point.fromLngLat(-122.648792, 45.510677)); OUTER_POINTS.add(Point.fromLngLat(-122.664070, 45.515008)); OUTER_POINTS.add(Point.fromLngLat(-122.669048, 45.502496)); OUTER_POINTS.add(Point.fromLngLat(-122.678489, 45.515369)); OUTER_POINTS.add(Point.fromLngLat(-122.702007, 45.506346)); OUTER_POINTS.add(Point.fromLngLat(-122.685699, 45.522585)); POINTS.add(OUTER_POINTS); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_annotation_polygon); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource(new GeoJsonSource(""source-id"", Polygon.fromLngLats(POINTS))); style.addLayerBelow(new FillLayer(""layer-id"", ""source-id"").withProperties( fillColor(Color.parseColor(""#3bb2d0""))), ""settlement-label"" ); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } } Copy Was this page helpful? Yes No",,Draw a polygon,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Location picker,Drop a marker at a specific location and then perform reverse geocoding.,https://docs.mapbox.com/android/maps/examples/location-picker/,example,Java,,"Location picker Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraZoom=""15"" /> <Button android:id=""@+id/select_location_button"" android:layout_width=""fill_parent"" android:layout_height=""wrap_content"" android:layout_alignParentBottom=""true"" android:layout_margin=""8dp"" android:background=""@color/colorPrimary"" android:text=""Select a location"" android:textColor=""@android:color/white""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.graphics.BitmapFactory; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.core.content.ContextCompat; import androidx.appcompat.app.AppCompatActivity; import android.view.Gravity; import android.view.View; import android.view.ViewGroup; import android.widget.Button; import android.widget.FrameLayout; import android.widget.ImageView; import android.widget.Toast; import com.mapbox.android.core.permissions.PermissionsListener; import com.mapbox.android.core.permissions.PermissionsManager; import com.mapbox.api.geocoding.v5.GeocodingCriteria; import com.mapbox.api.geocoding.v5.MapboxGeocoding; import com.mapbox.api.geocoding.v5.models.CarmenFeature; import com.mapbox.api.geocoding.v5.models.GeocodingResponse; import com.mapbox.core.exceptions.ServicesException; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.modes.CameraMode; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.Property.NONE; import static com.mapbox.mapboxsdk.style.layers.Property.VISIBLE; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.visibility; /** * Drop a marker at a specific location and then perform * reverse geocoding to retrieve and display the location's address */ public class LocationPickerActivity extends AppCompatActivity implements PermissionsListener, OnMapReadyCallback { private static final String TAG = ""LocationPickerActivity""; private static final String DROPPED_MARKER_LAYER_ID = ""DROPPED_MARKER_LAYER_ID""; private MapView mapView; private MapboxMap mapboxMap; private Button selectLocationButton; private PermissionsManager permissionsManager; private ImageView hoveringMarker; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_location_picker); // Initialize the mapboxMap view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { LocationPickerActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { enableLocationPlugin(style); // Toast instructing user to tap on the mapboxMap Toast.makeText( LocationPickerActivity.this, getString(R.string.move_map_instruction), Toast.LENGTH_SHORT).show(); // When user is still picking a location, we hover a marker above the mapboxMap in the center. // This is done by using an image view with the default marker found in the SDK. You can // swap out for your own marker image, just make sure it matches up with the dropped marker. hoveringMarker = new ImageView(LocationPickerActivity.this); hoveringMarker.setImageResource(R.drawable.red_marker); FrameLayout.LayoutParams params = new FrameLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.CENTER); hoveringMarker.setLayoutParams(params); mapView.addView(hoveringMarker); // Initialize, but don't show, a SymbolLayer for the marker icon which will represent a selected location. initDroppedMarker(style); // Button for user to drop marker or to pick marker back up. selectLocationButton = findViewById(R.id.select_location_button); selectLocationButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (hoveringMarker.getVisibility() == View.VISIBLE) { // Use the map target's coordinates to make a reverse geocoding search final LatLng mapTargetLatLng = mapboxMap.getCameraPosition().target; // Hide the hovering red hovering ImageView marker hoveringMarker.setVisibility(View.INVISIBLE); // Transform the appearance of the button to become the cancel button selectLocationButton.setBackgroundColor( ContextCompat.getColor(LocationPickerActivity.this, R.color.colorAccent)); selectLocationButton.setText(getString(R.string.location_picker_select_location_button_cancel)); // Show the SymbolLayer icon to represent the selected map location if (style.getLayer(DROPPED_MARKER_LAYER_ID) != null) { GeoJsonSource source = style.getSourceAs(""dropped-marker-source-id""); if (source != null) { source.setGeoJson(Point.fromLngLat(mapTargetLatLng.getLongitude(), mapTargetLatLng.getLatitude())); } style.getLayer(DROPPED_MARKER_LAYER_ID).setProperties(visibility(VISIBLE)); } // Use the map camera target's coordinates to make a reverse geocoding search reverseGeocode(style, Point.fromLngLat(mapTargetLatLng.getLongitude(), mapTargetLatLng.getLatitude())); } else { // Switch the button appearance back to select a location. selectLocationButton.setBackgroundColor( ContextCompat.getColor(LocationPickerActivity.this, R.color.colorPrimary)); selectLocationButton.setText(getString(R.string.location_picker_select_location_button_select)); // Show the red hovering ImageView marker hoveringMarker.setVisibility(View.VISIBLE); // Hide the selected location SymbolLayer if (style.getLayer(DROPPED_MARKER_LAYER_ID) != null) { style.getLayer(DROPPED_MARKER_LAYER_ID).setProperties(visibility(NONE)); } } } }); } }); } private void initDroppedMarker(@NonNull Style loadedMapStyle) { // Add the marker image to map loadedMapStyle.addImage(""dropped-icon-image"", BitmapFactory.decodeResource( getResources(), R.drawable.blue_marker)); loadedMapStyle.addSource(new GeoJsonSource(""dropped-marker-source-id"")); loadedMapStyle.addLayer(new SymbolLayer(DROPPED_MARKER_LAYER_ID, ""dropped-marker-source-id"").withProperties( iconImage(""dropped-icon-image""), visibility(NONE), iconAllowOverlap(true), iconIgnorePlacement(true) )); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override @SuppressWarnings( {""MissingPermission""}) protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { permissionsManager.onRequestPermissionsResult(requestCode, permissions, grantResults); } @Override public void onExplanationNeeded(List<String> permissionsToExplain) { Toast.makeText(this, R.string.user_location_permission_explanation, Toast.LENGTH_LONG).show(); } @Override public void onPermissionResult(boolean granted) { if (granted && mapboxMap != null) { Style style = mapboxMap.getStyle(); if (style != null) { enableLocationPlugin(style); } } else { Toast.makeText(this, R.string.user_location_permission_not_granted, Toast.LENGTH_LONG).show(); finish(); } } /** * This method is used to reverse geocode where the user has dropped the marker. * * @param style style * @param point The location to use for the search */ private void reverseGeocode(@NonNull final Style style, final Point point) { try { MapboxGeocoding client = MapboxGeocoding.builder() .accessToken(getString(R.string.access_token)) .query(Point.fromLngLat(point.longitude(), point.latitude())) .geocodingTypes(GeocodingCriteria.TYPE_ADDRESS) .build(); client.enqueueCall(new Callback<GeocodingResponse>() { @Override public void onResponse(Call<GeocodingResponse> call, Response<GeocodingResponse> response) { List<CarmenFeature> results = response.body().features(); if (results.size() > 0) { CarmenFeature feature = results.get(0); // If the geocoder returns a result, we take the first in the list and show a Toast with the place name. if (style.isFullyLoaded() && style.getLayer(DROPPED_MARKER_LAYER_ID) != null) { Toast.makeText(LocationPickerActivity.this, String.format(getString(R.string.location_picker_place_name_result), feature.placeName()), Toast.LENGTH_SHORT).show(); } } else { Toast.makeText(LocationPickerActivity.this, getString(R.string.location_picker_dropped_marker_snippet_no_results), Toast.LENGTH_SHORT).show(); } } @Override public void onFailure(Call<GeocodingResponse> call, Throwable throwable) { Timber.e(""Geocoding Failure: %s"", throwable.getMessage()); } }); } catch (ServicesException servicesException) { Timber.e(""Error geocoding: %s"", servicesException.toString()); servicesException.printStackTrace(); } } @SuppressWarnings( {""MissingPermission""}) private void enableLocationPlugin(@NonNull Style loadedMapStyle) { // Check if permissions are enabled and if not request if (PermissionsManager.areLocationPermissionsGranted(this)) { // Get an instance of the component. Adding in LocationComponentOptions is also an optional // parameter LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent(this, loadedMapStyle); locationComponent.setLocationComponentEnabled(true); // Set the component's camera mode locationComponent.setCameraMode(CameraMode.TRACKING); locationComponent.setRenderMode(RenderMode.NORMAL); } else { permissionsManager = new PermissionsManager(this); permissionsManager.requestLocationPermissions(this); } } } Copy Was this page helpful? Yes No",,Location picker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Center the map on a clicked symbol,Using events and flyTo to center the map on a symbol.,https://docs.mapbox.com/mapbox-gl-js/example/center-on-symbol/,example,JavaScript,,Center the map on a clicked symbol Using events and flyTo to center the map on a symbol. Was this example helpful? Yes No,,Center the map on a clicked symbol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,monthly active users,Monthly active users (MAU) is the number of users who accessed Mapbox services within your applications during a given month.,https://docs.mapbox.com/help/glossary/monthly-active-users/,glossary,,,"monthly active users Mapbox tracks monthly active users (MAU), also known as mobile users, for native mobile applications built with the Mapbox Maps, Navigation, and Vision SDKs for iOS, Android, or Unity. This is the number of users who accessed Mapbox services within your applications during a given month. There are a couple different mobile usage measurements that use monthly active users as a unit. The line items that appear on your invoice will vary based on the product and version you are using: Product Version Usage units Maps SDK for Android 8.0.0 and higher Maps SDKs for mobile MAUs Maps SDK for Android less than 8.0.0 Legacy SDKs for mobile MAUs Maps SDK for iOS 5.0.0 and higher Maps SDKs for mobile MAUs Maps SDK for iOS less than 5.0.0 Legacy SDKs for mobile MAUs Maps SDK for Unity all available versions Legacy SDK MAUs Navigation SDK for Android all available versions Legacy SDKs for mobile MAUs + Directions API requests Navigation SDK for iOS all available versions Legacy SDKs for mobile MAUs + Directions API requests Vision SDK for Android 0.6.0 and higher Vision SDKs for mobile MAUs Vision SDK for Android less than 0.6.0 Legacy SDKs for mobile MAUs Vision SDK for iOS 0.6.0 and higher Vision SDKs for mobile MAUs Vision SDK for iOS less than 0.6.0 Legacy SDKs for mobile MAUs Cost per MAU There are 50,000 Legacy SDK MAUs per month included in the free tier. You will be billed $0.50 for every additional 500 MAUs beyond the 50,000 per month included in the free tier. Find information about pricing for Maps MAUs and Vision MAUs on the pricing page. Related resources: Accounts and pricing: Pricing by products Was this page helpful? Yes No",,monthly active users,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Traffic,Discover how to display real-time road traffic on your Android map with the Mapbox Android Traffic Plugin. All it requires is two lines of code.,https://docs.mapbox.com/android/plugins/overview/traffic/,guide,Java,,"Traffic The Mapbox Traffic Plugin adds a real-time traffic layer to any Mapbox base map. If you want to display a traffic layer inside your application, you only need to include the dependency in your project and initialize the plugin. Various shades of colors show the congestion level for any given part of a road segment. If there's not enough traffic data available for a given road, then the plugin will not show road information. Like other plugins, a third optional parameter in the traffic plugin's constructor which is useful for specifying the layer in which you want the traffic to display below. If the layer ID's missing in the third parameter, the plugin will try to place the traffic below all symbol layers so that text and icons on the map are still visible on top of the traffic lines. It is always a good idea to pass in a string ID rather than relying on the Plugin to try to place the traffic below a symbol layer since it isn't guaranteed to work properly. Install the Traffic Plugin To start developing an application using the Traffic Plugin, you'll need to add the appropriate dependencies inside your build.gradle file. This dependency includes the Maps SDK for Android. You can find all dependencies given on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-traffic- v8. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-traffic- v8 : 0.9.0 ' } Add traffic Since the Traffic Plugin requires the mapboxMap object, it's necessary to initialize the plugin either inside onMapReady (recommended) or in another place you know the mapboxMap will not be null. Once initialized, trafficPlugin.setVisibility() to true will enable the traffic. You can use isVisible() which returns a boolean true if the traffic's visible, otherwise false. Java Kotlin @Override public void onMapReady(MapboxMap mapboxMap) { TrafficPlugin trafficPlugin = new TrafficPlugin(mapView, mapboxMap); trafficPlugin.setVisibility(true); // Enable the traffic view } Copy Traffic colors The table below provides information for each color displayed in the traffic layer and what the corresponding congestion level is. Color Hex value Congestion level Green #39c66d Low Yellow #ff8c1a Moderate Orange #ff0015 Heavy Red #981b25 Severe Was this page helpful? Yes No",,Traffic,Add the dependency,Add traffic,Kotlin,Traffic colors,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add annotation views and images,Add multiple annotations containing views and images.,https://docs.mapbox.com/ios/maps/examples/annotation-view-image/,example,Swift,,"Add annotation views and images Download the Camera asset catalog and add it to your project. MyCustomPointAnnotation is a custom subclass of MGLPointAnnotation. To learn about more ways to add points to a map, see the Markers and annotations guide. Swift Objective C import Mapbox // MGLPointAnnotation subclass class MyCustomPointAnnotation: MGLPointAnnotation { var willUseImage: Bool = false } // end MGLPointAnnotation subclass class ViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() // Create a new map view using the Mapbox Light style. let mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.lightStyleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 36.54, longitude: -116.97), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.delegate = self // Create four new point annotations with specified coordinates and titles. let pointA = MyCustomPointAnnotation() pointA.coordinate = CLLocationCoordinate2D(latitude: 36.4623, longitude: -116.8656) pointA.title = ""Stovepipe Wells"" pointA.willUseImage = true let pointB = MyCustomPointAnnotation() pointB.coordinate = CLLocationCoordinate2D(latitude: 36.6071, longitude: -117.1458) pointB.title = ""Furnace Creek"" pointB.willUseImage = true let pointC = MyCustomPointAnnotation() pointC.title = ""Zabriskie Point"" pointC.coordinate = CLLocationCoordinate2D(latitude: 36.4208, longitude: -116.8101) let pointD = MyCustomPointAnnotation() pointD.title = ""Mesquite Flat Sand Dunes"" pointD.coordinate = CLLocationCoordinate2D(latitude: 36.6836, longitude: -117.1005) // Fill an array with four point annotations. let myPlaces = [pointA, pointB, pointC, pointD] // Add all annotations to the map all at once, instead of individually. mapView.addAnnotations(myPlaces) } // This delegate method is where you tell the map to load a view for a specific annotation based on the willUseImage property of the custom subclass. func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? { if let castAnnotation = annotation as? MyCustomPointAnnotation { if (castAnnotation.willUseImage) { return nil } } // Assign a reuse identifier to be used by both of the annotation views, taking advantage of their similarities. let reuseIdentifier = ""reusableDotView"" // For better performance, always try to reuse existing annotations. var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: reuseIdentifier) // If there’s no reusable annotation view available, initialize a new one. if annotationView == nil { annotationView = MGLAnnotationView(reuseIdentifier: reuseIdentifier) annotationView?.frame = CGRect(x: 0, y: 0, width: 30, height: 30) annotationView?.layer.cornerRadius = (annotationView?.frame.size.width)! / 2 annotationView?.layer.borderWidth = 4.0 annotationView?.layer.borderColor = UIColor.white.cgColor annotationView!.backgroundColor = UIColor(red: 0.03, green: 0.80, blue: 0.69, alpha: 1.0) } return annotationView } // This delegate method is where you tell the map to load an image for a specific annotation based on the willUseImage property of the custom subclass. func mapView(_ mapView: MGLMapView, imageFor annotation: MGLAnnotation) -> MGLAnnotationImage? { if let castAnnotation = annotation as? MyCustomPointAnnotation { if (!castAnnotation.willUseImage) { return nil } } // For better performance, always try to reuse existing annotations. var annotationImage = mapView.dequeueReusableAnnotationImage(withIdentifier: ""camera"") // If there is no reusable annotation image available, initialize a new one. if(annotationImage == nil) { annotationImage = MGLAnnotationImage(image: UIImage(named: ""camera"")!, reuseIdentifier: ""camera"") } return annotationImage } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } } Copy Was this page helpful? Yes No",,Add annotation views and images,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Datasets API,"The Mapbox Datasets API allows you to read, create, update, and remove datasets and dataset features.",https://docs.mapbox.com/help/glossary/datasets-api/,glossary,,,"Datasets API The Mapbox Datasets API supports creating, editing, and managing datasets and dataset features. A sample Datasets API request to retrieve a dataset looks like: https://api.mapbox.com/datasets/v1/ { username } / { dataset_id } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN Related resources: Datasets API documentation How datasets work Was this page helpful? Yes No",,Datasets API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Data time lapse,Use data-driven styling to visualize point data with a time lapse effect; rainfall in China in this example.,https://docs.mapbox.com/android/maps/examples/data-time-lapse/,example,Java,,"Data time lapse Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.dds.AddRainFallStyleActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:mapbox_cameraTargetLat=""36"" app:mapbox_cameraTargetLng=""106"" app:mapbox_cameraZoom=""3.6"" app:mapbox_uiAttribution=""false"" app:mapbox_uiLogo=""false""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.os.Bundle; import android.os.Handler; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.expressions.Expression; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.PropertyFactory; import com.mapbox.mapboxsdk.style.sources.VectorSource; import static com.mapbox.mapboxsdk.style.expressions.Expression.eq; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.expressions.Expression.interpolate; import static com.mapbox.mapboxsdk.style.expressions.Expression.literal; import static com.mapbox.mapboxsdk.style.expressions.Expression.stop; import static com.mapbox.mapboxsdk.style.layers.Property.VISIBLE; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; /** * Style a rainfall map by get data from url */ public class AddRainFallStyleActivity extends AppCompatActivity implements OnMapReadyCallback { public static final String ID_SOURCE = ""source-id""; public static final String ID_LAYER = ""layer-id""; public static final String SOURCE_URL = ""mapbox://examples.dwtmhwpu""; private MapView mapView; private Handler handler; private FillLayer layer; private int index = 1; private RefreshGeoJsonRunnable refreshGeoJsonRunnable; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the account manager setContentView(R.layout.activity_style_rainfall); handler = new Handler(); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { addRadarData(style); refreshGeoJsonRunnable = new RefreshGeoJsonRunnable(); do { handler.postDelayed(refreshGeoJsonRunnable, 1000); } while (index == 37); } }); } private class RefreshGeoJsonRunnable implements Runnable { @Override public void run() { layer.setFilter(eq((Expression.get(""idx"")), literal(index))); index++; if (index == 37) { index = 0; } handler.postDelayed(this, 1000); } } private void addRadarData(@NonNull Style loadedMapStyle) { VectorSource vectorSource = new VectorSource( ID_SOURCE, SOURCE_URL ); loadedMapStyle.addSource(vectorSource); layer = loadedMapStyle.getLayerAs(ID_LAYER); if (layer == null) { layer = new FillLayer(ID_LAYER, ID_SOURCE); layer.withSourceLayer(""201806261518""); layer.setFilter(eq((get(""idx"")), literal(0))); layer.setProperties(PropertyFactory.visibility(VISIBLE), fillColor(interpolate(Expression.exponential(1f), get(""value""), stop(8, Expression.rgb(20, 160, 240)), stop(18, Expression.rgb(20, 190, 240)), stop(36, Expression.rgb(20, 220, 240)), stop(54, Expression.rgb(20, 250, 240)), stop(72, Expression.rgb(20, 250, 160)), stop(90, Expression.rgb(135, 250, 80)), stop(108, Expression.rgb(250, 250, 0)), stop(126, Expression.rgb(250, 180, 0)), stop(144, Expression.rgb(250, 110, 0)), stop(162, Expression.rgb(250, 40, 0)), stop(180, Expression.rgb(180, 40, 40)), stop(198, Expression.rgb(110, 40, 80)), stop(216, Expression.rgb(80, 40, 110)), stop(234, Expression.rgb(50, 40, 140)), stop(252, Expression.rgb(20, 40, 170)) ) ), PropertyFactory.fillOpacity(0.7f)); loadedMapStyle.addLayer(layer); } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); handler.removeCallbacks(refreshGeoJsonRunnable); refreshGeoJsonRunnable = null; handler = null; } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Data time lapse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Change a layer's color,Using layer set to change a layer's fill color.,https://docs.mapbox.com/android/maps/examples/change-a-layers-color/,example,Java,,"Change a layer's color Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical"" tools:context="".examples.styles.ColorSwitcherActivity""> <LinearLayout android:id=""@+id/color_picker_content"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_alignParentBottom=""true"" android:background=""#ffffff"" android:orientation=""vertical"" android:paddingBottom=""10dp"" android:paddingEnd=""24dp"" android:paddingLeft=""24dp"" android:paddingRight=""24dp"" android:paddingStart=""24dp"" android:paddingTop=""24dp""> <Spinner android:id=""@+id/spinner_layer_picker"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:entries=""@array/layer_spinner_array""/> <LinearLayout android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:orientation=""horizontal""> <TextView android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:text=""Red""/> <SeekBar android:id=""@+id/red_seek_bar"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:max=""255"" android:progress=""202""/> </LinearLayout> <LinearLayout android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:orientation=""horizontal""> <TextView android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:text=""Green""/> <SeekBar android:id=""@+id/green_seek_bar"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:max=""255"" android:progress=""210""/> </LinearLayout> <LinearLayout android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:orientation=""horizontal""> <TextView android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:text=""Blue""/> <SeekBar android:id=""@+id/blue_seek_bar"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:max=""255"" android:progress=""211""/> </LinearLayout> </LinearLayout> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_above=""@id/color_picker_content"" mapbox:mapbox_cameraTargetLat=""45.4385"" mapbox:mapbox_cameraTargetLng=""12.338"" mapbox:mapbox_cameraZoom=""17.4""/> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.AdapterView; import android.widget.SeekBar; import android.widget.Spinner; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; /** * Using setPaintProperty to change a layer's fill color. */ public class ColorSwitcherActivity extends AppCompatActivity { private MapView mapView; FillLayer water; FillLayer building; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_color_switcher); final SeekBar redSeekBar = findViewById(R.id.red_seek_bar); final SeekBar greenSeekBar = findViewById(R.id.green_seek_bar); final SeekBar blueSeekBar = findViewById(R.id.blue_seek_bar); final Spinner layerPicker = findViewById(R.id.spinner_layer_picker); layerPicker.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { @Override public void onItemSelected(AdapterView<?> adapterView, View view, int position, long id) { if (layerPicker.getSelectedItem().toString().equals(""Building"")) { if (building != null) { redSeekBar.setProgress(Color.red(building.getFillColorAsInt())); greenSeekBar.setProgress(Color.green(building.getFillColorAsInt())); blueSeekBar.setProgress(Color.blue(building.getFillColorAsInt())); } } else if (layerPicker.getSelectedItem().toString().equals(""Water"")) { if (water != null) { redSeekBar.setProgress(Color.red(water.getFillColorAsInt())); greenSeekBar.setProgress(Color.green(water.getFillColorAsInt())); blueSeekBar.setProgress(Color.blue(water.getFillColorAsInt())); } } } @Override public void onNothingSelected(AdapterView<?> adapterView) { } }); redSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { if (water != null && layerPicker.getSelectedItem().equals(""Water"") && fromUser) { water.setProperties( fillColor(Color.rgb(progress, greenSeekBar.getProgress(), blueSeekBar.getProgress())) ); } else if (building != null && layerPicker.getSelectedItem().equals(""Building"") && fromUser) { building.setProperties( fillColor(Color.rgb(progress, greenSeekBar.getProgress(), blueSeekBar.getProgress())) ); } } @Override public void onStartTrackingTouch(SeekBar seekBar) { } @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); greenSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { if (water != null && layerPicker.getSelectedItem().equals(""Water"") && fromUser) { water.setProperties( fillColor(Color.rgb(redSeekBar.getProgress(), progress, blueSeekBar.getProgress())) ); } else if (building != null && layerPicker.getSelectedItem().equals(""Building"") && fromUser) { building.setProperties( fillColor(Color.rgb(progress, greenSeekBar.getProgress(), blueSeekBar.getProgress())) ); } } @Override public void onStartTrackingTouch(SeekBar seekBar) { } @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); blueSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { if (water != null && layerPicker.getSelectedItem().equals(""Water"") && fromUser) { water.setProperties( fillColor(Color.rgb(redSeekBar.getProgress(), greenSeekBar.getProgress(), progress)) ); } else if (building != null && layerPicker.getSelectedItem().equals(""Building"") && fromUser) { building.setProperties( fillColor(Color.rgb(progress, greenSeekBar.getProgress(), blueSeekBar.getProgress())) ); } } @Override public void onStartTrackingTouch(SeekBar seekBar) { } @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { water = (FillLayer) style.getLayer(""water""); building = (FillLayer) style.getLayer(""building""); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Change a layer's color,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Fit to the bounds of a LineString,Get the bounds of a LineString by passing its first coordinates to LngLatBounds and chaining extend to include the last coordinates.,https://docs.mapbox.com/mapbox-gl-js/example/zoomto-linestring/,example,JavaScript,,Fit to the bounds of a LineString Get the bounds of a LineString by passing its first coordinates to LngLatBounds and chaining extend to include the last coordinates. Was this example helpful? Yes No,,Fit to the bounds of a LineString,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Add 3D buildings to a Mapbox Studio style,Add a 3D building layer to a map style in Mapbox Studio.,https://docs.mapbox.com/help/tutorials/add-3d-buildings-studio/,tutorial,No code,,"beginner No code Add 3D buildings to a Mapbox Studio style This tutorial will walk you through the process of adding a 3D building layer to a map style using Mapbox Studio. Getting started Before you start this tutorial, you need to create a Mapbox account by signing up at mapbox.com/account. Create a new style To begin, you will create a new map style in Mapbox Studio. Log in to your Mapbox account and navigate to the Styles page. Click the New style button. Find the Basic Template style and click Customize Basic Template. In Mapbox Studio style editor, rename this new style so that you can find it later. Click into the title field in the upper left side of the screen and change the title to 3D buildings. In the search bar in the upper right corner, type in ""Empire State Building"" and select the first result. The map view will move so that it is centered on the Empire State building in New York City. Edit the building layer Next, you will edit the style's building layer. In the layer panel on the left side of the screen, select the building layer. Click Select data. This opens the x-ray view, which displays the data from the building layer. Click the Type option in the New layer panel and select the Fill extrusion option. If prompted to do so, click Okay to confirm that you want to change the layer's type. Remove all existing filters on this layer. Click + Create filter and select the extrude data property. Leave the dropdown menu set to is any of and click the Empty button. Select true. Click the Style option to return to the building layer's styling panel. Now that the building layer's type has been changed, its style settings need to be adjusted to show the desired 3D effect. Note This tutorial takes advantage of the building layer in Mapbox Streets v7. If you have custom building data that you would like to use in a map style instead, that data can be uploaded to Mapbox as a tileset using either Mapbox Studio or the Mapbox Uploads API. Adjust the layer's style settings Next, you will adjust the layer's height and base height properties to achieve the desired 3D effect. Set the height property Select the building layer and click on the Height property. Choose the Style across data range option. In the Choose a numeric data field panel, click on height. The first stop is already set to a height of 0 and a Fill height of 0. Leave these settings as they are. In the second stop, leave the height set to 999 and change the Fill height option to 999. Set the base height property The base height property of the layer also needs to be adjusted. This will handle any cases where a building has a base as well as a separate taller part that has a different architectural shape. If you do not set the base height property, then buildings will lose some of their nuanced architectural features. Select the building layer and click on Base height. Choose the Style across data range option. In the Choose a numeric data field panel, select min_height. The first stop is already set to a height of 0 and a Fill base height of 0. Leave these settings as they are. In the second stop, leave the height set to 999 and change the Fill base height option to 999. Make the layer more prominent Since the building layer has many items above it in the layers list, those items render on top of the buildings in this style. To make the buildings more prominent, you will move the building layer to the top of the layers list and hide the POI label layer. In the layers list, click and drag the building layer to the top of the layer list. Click on the poi-label layer to select it. Click on the Hide layer button at the top of the layer list to hide the layer. You can use the Hide layer button to hide any layer that you do not want to display in your final map style. Change the building color The default black color of the buildings makes it hard to distinguish details, so this style will use a lighter color. Click on the Color field and change it to #778899. Change the camera pitch It's difficult to see the impact of changing these settings because the default map view looks straight ""down"". To adjust the pitch and make the 3D buildings easier to see: Right click on the map view and drag the mouse. Move the map until you reach the desired pitch. Your browser doesn't support embedded videos. Adjust the style's lighting Changing the lighting intensity for a fill extrusion layer highlights architectural details and makes it easier to distinguish between different buildings. In the toolbar on the upper right side of the screen, click the Light tab to open the Extrusion Lighting panel. Use the Intensity slider to change the light intensity to 0.75. Publish the style When you have finished editing your new map style, you will publish your changes. Click the Publish button in the upper right side of the screen. When you click the publish button, a window will display the difference between the previous version and the current version. If you're happy with the edits you made, click Publish. Your style will now be available to share from a variety of tools and applications. Click the Share button in the top toolbar to see all options. Finished product You have created a new map style with a 3D building layer. Next steps There are many different ways that you can use your new Mapbox Studio style. You can use this map on your website, or in a web or mobile application. Take a look at the Publish style section of the Mapbox Studio Manual to read about all the ways you can use your map style. Was this page helpful? Yes No",,Add 3D buildings to a Mapbox Studio style,Create a new style,Edit the building layer,,Adjust the layer's style settings,Set the height property,Set the base height property,Make the layer more prominent,Change the building color,Change the camera pitch,Adjust the style's lighting,Publish the style,1,Finished product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a GeoJSON polygon,Style a polygon with the fill layer type.,https://docs.mapbox.com/mapbox-gl-js/example/geojson-polygon/,example,JavaScript,,Add a GeoJSON polygon Style a polygon with the fill layer type. Was this example helpful? Yes No,,Add a GeoJSON polygon,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Locate the user,Geolocate the user and then track their current location on the map using the GeolocateControl.,https://docs.mapbox.com/mapbox-gl-js/example/locate-user/,example,JavaScript,,Locate the user Geolocate the user and then track their current location on the map using the GeolocateControl. Was this example helpful? Yes No,,Locate the user,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Vector tiles,Mapbox Terrain v2,Reference documentation for the Mapbox Terrain v2 tileset.,https://docs.mapbox.com/vector-tiles/reference/mapbox-terrain-v2/,reference,,,"Mapbox Terrain v2 Source id: mapbox.mapbox-terrain-v2 This is a guide to the layers and data inside the Mapbox Terrain vector tile source to help with styling. Overview Mapbox Terrain provides hillshades, elevation contours, and landcover data all in vector form. Mapbox Terrain is based on data from a variety of sources. When using the Mapbox Terrain layer publicly in a design or application you must provide proper attribution. A geometry in the vector tile can be one of 3 types: Point Linestring / multilinestring Polygon / multipolygon Layer Reference #landcover buffer: 8 The landcover layer provides a generalized backdrop of vegetation, agriculture, and permanent ice & snow. It is intended for stylistic use and not appropriate for science or other analysis. Empty space in the landcover layer is either water or bare earth, rock, sand, and built-up areas. Classes The class field is used for styling different types of landcover. The classes are designed to look best when there is a smooth color gradient across from wood → scrub → grass → crop → map background → snow. Thin strips of ""grass"" or ""crop"" along the edge of a wooded area might not necessarily represent actual grass or cropland, but are there to smooth the transition from wood to bare land. Value Description 'wood' The area is mostly wooded or forest-like. 'scrub' The area is either mostly bushy or a mix of wooded and grassy 'grass' The area is mostly grassy. 'crop' The area is mostly agricultural, or thin/patchy grass 'snow' The area is mostly permanent ice, glacier or snow CartoCSS example: Map { background-color: cornsilk; } #landcover { [class='wood'] { polygon-fill: darkseagreen; } [class='scrub'] { polygon-fill: mix(darkseagreen,cornsilk,75%); } [class='grass'] { polygon-fill: mix(darkseagreen,cornsilk,50%); } [class='crop'] { polygon-fill: mix(darkseagreen,cornsilk,25%); } [class='snow'] { polygon-fill: white; } } #hillshade buffer: 8 The hillshade layer contains polygons that when styled appropriately display shaded relief of hills. The lighting direction is not realistic, but from the north-west (as is traditional in shaded relief). At zoom levels above 14 you may want to blur, fade, or completely hide the hillshade layer as the resolution of the data is not enough to hold up at the largest scales. Classes The class field is for simple styling of the different levels of light and shadow. With low polygon-opacity or certain polygon-comp-op settings, you can style all 6 brightness levels with 2 filters. Value Description 'shadow' These should be styled darker than the background color. 'highlight' These should be styled lighter than the background color. CartoCSS example: #hillshade { [class='shadow'] { polygon-fill: black; polygon-opacity: 0.05; } [class='highlight'] { polygon-fill: white; polygon-opacity: 0.10; } } Levels The level field allows for more granular styling of the different levels of light and shadow. The numbers represent the brightness threshold percentages that were used to generate the hillshading polygons. Value Description 94 The brightest highlights 90 Medium highlights 89 Areas of faint shadow 78 Areas of medium shadow 67 Areas of dark shadow 56 Areas of extreme shadow CartoCSS example: #hillshade[class='shadow'] { polygon-fill: black; [level=89] { polygon-opacity: 0.02; } [level=78] { polygon-opacity: 0.04; } [level=67] { polygon-opacity: 0.06; } [level=56] { polygon-opacity: 0.08; } } #contour buffer: 4 Contour lines show vertical dimension on a region by joining points of equal elevation. Full contour line coverage begins at zoom 12, while index lines are available at zoom 9 + in values specified below. Elevation The ele field stores the elevation of each contour line in meters and can be used for labeling or filtering. Ideally the values range from -410 near the shore of the Dead Sea to 8840 near the peak of Mt Everest, but due to bugs and inconsistencies values outside this range may exist. Zoom level Contour Interval 9 500 meters 10 200 meters 11 100 meters 12 50 meters 13 20 meters 14+ 10 meters CartoCSS example: #contour { text-name: [ele]+' m'; text-face-name: 'Open Sans Regular'; } Index lines The index field can be used to emphasize index contours, but it can also be used to reduce the contour density if you wish. The highest value that applies to a contour will be the index value, so if you want to highlight every fifth line, you need to select both index=5 and index=10. If you want to highlight every other line, you need to select both index=2 and index=10 (or both index=1 and index=5). Value Description -1 Sea level coastline 1 Every 1st line 2 Every 2nd line 5 Every 5th line 10 Every 10th line CartoCSS example: #contour { /* only show every other contour line */ [index=10], [ele=2] { line-width: 1; } } Changelog A summary of the changes from v1: Various elevation data improvements and updates (notably over most of Europe and Africa) class field in the #hillshade layer simplified to 2 classes: highlight, shadow level field added to the #hillshade layer for more granular styling Coastlines have an index value of -1 in the #contour layer Was this page helpful? Yes No",,Mapbox Terrain v2,Layer Reference,#landcover,,Classes,#hillshade,Levels,#contour,Elevation,Index lines,Changelog,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Address geocoding format guide,Follow these best practices when formatting addresses for geocoding.,https://docs.mapbox.com/help/troubleshooting/address-geocoding-format-guide/,troubleshooting,,,"Address geocoding format guide Forward geocoding converts location text into geographic coordinates, turning 2 Lincoln Memorial Circle NW into -77.050,38.889. Follow these address formatting guidelines to make sure that your Mapbox Geocoding API requests retrieve the right results: Use one building number, not a number range Use a single building number rather than a range of numbers when constructing a query. Examples ✅ 123 Main St ❌ 123-127 Main St Format address components consistently For addresses in the United States, pass in the address components in the format { house number } { street } { city } { state } { zip }. For geocoding in countries other than the United States, you have a few options. You can either submit the components in the same order as you would use for an address in the United States, or you can follow local address formatting standards for those countries. If you need to pick one standard order to use for multiple countries, pass the address components to the geocoder in order from most granular to least granular: { house number } { street } { postcode } { city } { state }. Examples ✅ 123 Main St Boston MA 02111 (US only) ✅ 123 Main St Swindon SN2 2DQ (UK only) ✅ 123 Main St 02111 Boston MA (multiple countries) Use the country parameter If you need to limit results to one country, use the country parameter in the API request instead of including the country in the search text. The country parameter will limit results to only locations within the specified country. Examples ✅ Results will only include locations within the United States https://api.mapbox.com/geocoding/v5/mapbox.places/123%20Main%20St%20Boston%20MA.json?country=US&access_token= YOUR_MAPBOX_ACCESS_TOKEN ❌ Results could potentially include locations outside of the US https://api.mapbox.com/geocoding/v5/mapbox.places/123%20Main%20St%20Boston%20MA%20United%20States.json?&access_token= YOUR_MAPBOX_ACCESS_TOKEN ` Zip code formatting For addresses in the United States, you can use either the five- or the nine-digit zip code. Both zip code formats will return the same coordinate results when used in a forward geocoding query. Examples ✅ 02919 ✅ 02919-3232 Secondary address information Secondary address information like apartment or suite number does not influence the coordinate results returned by a forward geocoding query. A query that uses this secondary address information, as well as any associated special characters like commas (,) and pound symbols (#), will return the same coordinates as a query with this information stripped out. Examples ✅ 123 Main St ✅ 123 Main St #456 ✅ 123 Main St, Suite 7 ✅ 123 Main St, Building A Was this page helpful? Yes No",,Address geocoding format guide,Examples,Format address components consistently,,Use the country parameter,Zip code formatting,Secondary address information,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Custom maps,An overview of using custom data and styles in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/overview/custom-maps/,guide,,,"Custom maps Use a custom style Image, terrain, and vector layers now come with default styles. These are default sources which provide a way to access Mapbox's rich data. You can select one of the generic Mapbox styles, or select Custom to use a custom style. For a walkthrough on how to configure a custom style, follow the Custom maps style for Unity tutorial. For image layers, select Custom to use a custom style from Mapbox Studio. There are two ways to specify a custom style: Copy a style URL from your Mapbox Studio account and paste it into the Id field of your image factory. Search for a style linked to your account. Note: To search for a style, you may have to generate a new access token with styles:list scope enabled. If you had to create a new access token, remember to swap it out with the old token in your Mapbox Setup panel. After specifying a custom style, the map will render the new style when you play the scene. You can further customize your map style in Mapbox Studio. Note that there may be some differences in color quality and resolution between Mapbox Studio and Unity: this is expected. ""Mapbox Streets With Building IDs"" combines Mapbox-Streets-v7 vector data with our experimental 3D buildings data, which assigns unique IDs to building features to avoid visual artifacts for buildings at tile borders. Use custom data You can use your own data with a custom tileset using the Maps SDK for Mapbox Unity. To do so, you'll need to first create a dataset and export it to a tileset using Mapbox Studio. For example: This custom population density tileset contains a layer outgeojson, which contains the properties id, p, and pkm2. The tileset contains the population per square kilometer in the property (pkm2) for all areas of the United States. You can configure your AbstractMap component in the following way to render extrusions of various blocks of a city and visualize that data on a map. Right click MAP LAYERS on the AbstractMap component. Select Custom for the Data Source Enter the tileset IDs peterqliu.d0vin3el in the Map Id field. Note that you can specify any tileset ID in this field. Click Add Visualizer to create a new visualizer. Next, name it by clicking Untitled once, specifying a title and pressing Enter. PopulationDensity is used for this example, but you can name this whatever you want. In the Vector Layer Visualizer settings, set the Primitive Type to Polygon. Enter outgeojson for the Layer Name. This must match the Layer details for the specified tileset. For this tileset, it is outgeojson. Set the Extrusion Type to Property Height. Enter pkm2 for the Property Name. This value must equal the name of a property on the specified tileset. For this tileset, it is pkm2. Change the Texturing Style to Custom, and add a material of your choice to the Top Material and Side Material fields. Note that the PopulationMat material file is what produces the gradient style seen below. It is from custom code that uses the pkm2 value to style the blocks differently. It is not included in the Maps SDK for Unity. Here’s the output of that configuration when you play the scene. The screenshot below shows the population density of different blocks in San Francisco. Was this page helpful? Yes No",,Custom maps,Use custom data,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Collaboration best practices,Learn best practices for setting up an account and collaborating on projects.,https://docs.mapbox.com/help/troubleshooting/collaboration-best-practices/,troubleshooting,,,"Collaboration best practices This guide outlines best practices for setting up an account so that necessary stakeholders can access it. We also highlight recommendations for multiple collaborators working together on a project. If you are locked out of an account and need to regain access, please contact support. Best practices for setting up an account There are a few guidelines you can follow to set your account up for collaboration from the beginning. Developers, designers, and consultants Account setup. When on contract with an organization, start by setting up a new account in the organization’s name, like CompanyName. This is an important step because usernames cannot be changed and access tokens are non-transferable between accounts. Client accounts. If you are building projects for multiple clients, set up a unique Mapbox account for each of them. Pay-as-you-go accounts come equipped with a certain amount of API calls for free each month. When you set up a separate Mapbox account for each client, they will get their own set of free API usage. Individual client accounts also makes tracking usage much easier since invoices and full account statistics will only be tied to one organization's API usage. Access tokens. It's best practice to use a distinct Mapbox account for each of your clients' projects. Though, if you are managing multiple clients' projects from one Mapbox account, use a unique named token for each project. Be cautious about using your own access tokens while developing for an organization, since their maps & billing will be tied to your account. When the time comes to hand off the account, rotate tokens so that your client's maps are tied to their own access tokens. Take extra care not to delete an access token that is in production for a project you collaborated on before. Login credentials. At the end of the project, share the account credentials with the organization so the owners can change the email and change the password. Encourage the organization to use an email address multiple people have access to and to save their new password in a shared password manager, like 1Password. Inheriting an account from a developer, designer, or consultant Shared email address. If someone creates your Mapbox account for you, encourage them to use a shared email like mapbox@yourcompany.com. This will allow stakeholders to log in to the account as well as receive invoices, notifications, and password reset emails. Forwarding rules for emails. Consider setting forwarding rules in your email client so that stakeholders in your company receive important emails. For example, if you'd like your billing department to receive billing emails like payment receipts, set any email from billing@mapbox.com to automatically forward to them. Password manager. When you receive and/or create your Mapbox account credentials, store them in a shared-secure location, like a 1Password vault and/or Okta. This will help keep your password safe and available when you or your teammates need it. Access Tokens. Taking care to rotate your access tokens upon receiving the account allows you to limit the risk of a consulting developer or former teammate deleting an access token that is used by a production application. Make sure that the location services for your applications are tied to your account, using distinct access tokens for granular statistics & billing. Collaborating on projects Provisioning access tokens. Tokens can be created and deleted with the Access Tokens page or the Tokens API on the command line. With scoped tokens, developers can read, write, and upload data without needing to log into your Mapbox account. If your organization already has an existing Mapbox account and/or you hire developers (independently, or through our Developer Network), consider administering the developers access tokens with limited scopes. Design reviews. Throughout the project you can share your work with your Map Style's Share URL or by setting up a small example application. If collaboration on editing a style is required, but you don't share access to the same Mapbox account, follow the guide to transferring styles between accounts to work together in a design review. Still have questions? Explore our Account documentation or send us a note. We're here to help. Was this page helpful? Yes No",,Collaboration best practices,"Developers, designers, and consultants","Inheriting an account from a developer, designer, or consultant",,Collaborating on projects,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display a non-interactive map,Setting interactive: false to create a static map.,https://docs.mapbox.com/mapbox-gl-js/example/interactive-false/,example,JavaScript,,Display a non-interactive map Setting interactive: false to create a static map. Was this example helpful? Yes No,,Display a non-interactive map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,MarkerView,Read docs on the Mapbox MarkerView Plugin for Android. Quickly customize and add Android view-based markers to a Mapbox map.,https://docs.mapbox.com/android/plugins/overview/markerview/,guide,Java,,"MarkerView The MarkerView Plugin for Android provides a simplified way to add map markers that are Android views. Alternative option Please be aware that Android views are the less performant and less customizable option for adding icons to a map. The Mapbox Maps SDK's SymbolLayer is the recommended way to add icons. View the Mapbox Annotation Plugin for Android for more information about using a SymbolLayer. Install the MarkerView plugin To start developing an application using the MarkerView Plugin, you'll need to add the appropriate dependencies inside your build.gradle file. This dependency includes the Maps SDK for Android. You can find all dependencies given below on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-markerview- v8. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-markerview- v8 : 0.3.0 ' } Initialize the plugin The plugin includes a manager class for adding and removing markers. The MarkerViewManager class requires initialized MapboxMap and MapView objects to be created. You should create a MarkerViewManager object within onMapReady() to be sure that the markers can be added to a successfully built map. Java Kotlin mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(MapboxMap mapboxMap) { MarkerViewManager markerViewManager = new MarkerViewManager(mapView, mapboxMap); } }); Copy Adding a marker The plugin is all about Android views, so you'll need to first create whatever view that you want to use for the marker image. Once you've constructed the view, use it to create a MarkerView class and then eventually pass the MarkerView object to the MarkerViewManager. Java Kotlin MarkerView markerView = new MarkerView(new LatLng(LAT,LONG), customView); markerViewManager.addMarker(markerView); Copy Removing a marker The MarkerViewManager can also remove a specific MarkerView. Java Kotlin markerViewManager.removeMarker(markerView); Copy Destroying the manager Don't forget to destroy your MarkerViewManager object. The destruction should happen in onDestroy() if you're using an activity. It should happen in the onDestroyView() method of a fragment. Activity: Java Kotlin @Override protected void onDestroy() { super.onDestroy(); markerViewManager.onDestroy(); mapView.onDestroy(); } Copy Fragment: Java Kotlin @Override public void onDestroyView() { super.onDestroyView(); markerViewManager.onDestroy(); mapView.onDestroy(); } Copy Was this page helpful? Yes No",,MarkerView,Add the dependency,Initialize the plugin,Kotlin,Adding a marker,Removing a marker,Destroying the manager,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Filter features within map view,Move the map to query viewable features in a vector tile layer and filter by typing in an input.,https://docs.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/,example,JavaScript,,Filter features within map view Move the map to query viewable features in a vector tile layer and filter by typing in an input. Was this example helpful? Yes No,,Filter features within map view,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,API,Maps service,Overview of the Mapbox Maps service APIs.,https://docs.mapbox.com/api/maps/,API,,,,,Maps service,Retrieve vector tiles,Example request: Retrieve vector tiles,,Response: Retrieve vector tiles,Vector Tiles API errors,Vector Tiles API restrictions and limits,Raster Tiles,Retrieve raster tiles,Example request: Retrieve raster tiles,Response: Retrieve raster tiles,Raster Tiles API errors,,Raster Tiles API restrictions and limits,Static Images,Retrieve a static map from a style,Example request: Retrieve a static map from a style,Response: Retrieve a static map from a style,Overlay options,GeoJSON,Marker,Custom marker,Path,Static Images API errors,Static Images API restrictions and limits,Static Tiles,Retrieve raster tiles from styles,Example request: Retrieve raster tiles from styles,Response: Retrieve raster tiles from styles,Static Tiles API errors,Static Tiles API restrictions and limits,Styles,Mapbox styles,The style object,Drafts,Example style object,Retrieve a style,Example request: Retrieve a style,Response: Retrieve a style,Example response: Retrieve a style,List styles,Example request: List styles,Response: List styles,Example response: List styles,Create a style,Example request: Create a style,Example request body: Create a style,Response: Create a style,Example response: Create a style,Update a style,Example request: Update a style,Example request body: Update a style,Response: Update a style,Example response: Update a style,Delete a style,Example request: Delete a style,Response: Delete a style,Request embeddable HTML,Example: Request embeddable HTML,Retrieve a map's WMTS document,Example request: Retrieve a map's WMTS document,Response: Retrieve a map's WMTS document,Sprites,Retrieve a sprite image or JSON,Example request: Retrieve a sprite image or JSON,Response: Retrieve a sprite image or JSON,Example response: Retrieve a sprite image or JSON,Add new image to sprite,Example request: Add new image to sprite,Response: Add new image to sprite,Example response: Add new image to sprite,Delete image from sprite,Example request: Delete image from sprite,Response: Delete image from sprite,Example response: Delete image from sprite,Styles API errors,Styles API restrictions and limits,Styles API sprites restrictions and limits,Tilequery,Retrieve features from vector tiles,Point-in-polygon queries,Example request: Retrieve features from vector tiles,Response: Retrieve features from vector tiles,Example response: Retrieve features from vector tiles,Tilequery API errors,Tilequery API restrictions and limits,Uploads,Retrieve S3 credentials,Example request: Retrieve S3 credentials,Example AWS CLI usage,Response: Retrieve S3 credentials,Example response: Retrieve S3 credentials,Create an upload,Example request: Create an upload,Example request body: Create an upload (AWS S3 bucket not required),Response: Create an upload,Example response: Create an upload,Retrieve upload status,Example request: Retrieve upload status,Response: Retrieve upload status,Example response: Retrieve upload status,Retrieve recent upload statuses,Example request: Retrieve recent upload statuses,Response: Retrieve recent upload statuses,Example response: Retrieve recent upload statuses,Remove an upload status,Example request: Remove an upload status,Response: Remove an upload status,Uploads API errors,Uploads API restrictions and limits,Tilesets,The Tilesets CLI,Creating new tilesets with the Tilesets API,Line-delimited GeoJSON and the Tilesets API,Create a tileset source,Limits,Example request: Create a tileset source,Response: Create a tileset source,Example response: Create a tileset source,Retrieve tileset source information,Example request: Retrieve tileset source information,Response: Retrieve tileset source information,Example response: Retrieve tileset source information,List tileset sources,Example request: List tileset sources,Response: List tileset sources,Example response: List tileset sources,Delete a tileset source,Example request: Delete a tileset source,Response: Delete a tileset source,Create a tileset,Example request: Create a tileset,Example request body: Create a tileset,Response: Create a tileset,Publish a tileset,Example request: Publish a tileset,Response: Publish a tileset,Update a tileset,Retrieve the status of a tileset,Example request: Retrieve the status of a tileset,Response: Retrieve the status of a tileset,Example response: Retrieve the status of a tileset,Retrieve a single tileset job,Example request: Retrieve a single tileset job,Response: Retrieve a single tileset job,Example response: Retrieve a single tileset job,List all jobs for a tileset,Example request: List all jobs for a tileset,Response: List all jobs for a tileset,Example response: List all jobs for a tileset,View the Tilesets API global queue,Example request: View the Tilesets API global queue,Response: View the Tilesets API global queue,Example response: View the Tilesets API global queue,Validate a recipe,Example request: Validate a recipe,Response: Validate a recipe,Example response: Validate a recipe,Retrieve a tileset's recipe,Example request: Retrieve a tileset's recipe,Response: Retrieve a tileset's recipe,Example response: Retrieve a tileset's recipe,Update a tileset's recipe,Example request: Update a tileset's recipe,Response: Update a tileset's recipe,List tilesets,Example request: List tilesets,Response: List tilesets,Example response: List tilesets,Delete tileset,Example request: Delete tileset,Response: Delete tileset,Retrieve TileJSON metadata,Example request: Retrieve TileJSON metadata,Response: Retrieve TileJSON metadata,Example response: Retrieve TileJSON metadata,Tilesets API errors,Tilesets API restrictions and limits,Datasets,The dataset object,Example dataset object,List datasets,Example request: List datasets,Response: List datasets,Example response: List datasets,Create a dataset,Example request: Create a dataset,Example request body: Create a dataset,Response: Create a dataset,Example response: Create a dataset,Retrieve a dataset,Example request: Retrieve a dataset,Response: Retrieve a dataset,Example response: Retrieve a dataset,Update a dataset,Example request: Update a dataset,Example request body: Update a dataset,Response: Update a dataset,Example response: Update a dataset,Delete a dataset,Example request: Delete a dataset,Response: Delete a dataset,The feature object,Example feature object,List features,Example request: List features,Response: List features,Example response: List features,Insert or update a feature,Example request: Insert or update a feature,Example request body: Insert or update a feature,Response: Insert or update a feature,Example response: Insert or update a feature,Retrieve a feature,Example request: Retrieve a feature,Response: Retrieve a feature,Example response: Retrieve a feature,Delete a feature,Example request: Delete a feature,Response: Delete a feature,Datasets API errors,Datasets API restrictions and limits,Fonts,Retrieve font glyph ranges,Example request: Retrieve font glyph ranges,Response: Retrieve font glyph ranges,Fonts API errors,Fonts API restrictions and limits
,Help,Tracking device location for Android,Display a Mapbox map on an Android device and receive updates on the device's current location.,https://docs.mapbox.com/help/tutorials/android-location-listening/,tutorial,Java,,,,Tracking device location for Android,Handle location permissions,Initialize the LocationEngine,,Enable the LocationComponent,Listen to location updates,Finished product,Next steps,,,,,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,CarPlay support in the Navigation SDK,Learn how to use the Mapbox Navigation SDK for iOS with CarPlay.,https://docs.mapbox.com/ios/navigation/overview/carplay/,guide,,,"CarPlay support in the Navigation SDK CarPlay is supported by default in the Mapbox Navigation SDK for iOS. This means that any app using the Navigation SDK can connect directly to CarPlay-enabled car infotainment screens. Get started with CarPlay The Mapbox Navigation SDK for iOS provides useful building blocks of functionality built on top of the CarPlay framework. Before you start using the Navigation SDK for iOS with CarPlay, you need to: Get an entitlement from Apple. Before you can develop and run an app on the iOS simulator or device, including the Mapbox example app that’s included in the Navigation SDK for iOS, your Apple Developer Program team agent needs to get a CarPlay entitlement from Apple. Read the CarPlay Navigation App Programming Guide. It’s important for you to understand the CarPlay framework and design for its strengths and limitations. This will help you create an optimal product experience for your users as you build with the Navigation SDK. Apple’s CarPlay Navigation App Programming Guide contains a lot of useful information, and we highly recommend reading it before you begin your development process. Design your app Mapbox provides building blocks for creating CarPlay-enabled iOS applications using Mapbox maps and navigation. But it’s still up to you to design and build the product that you want to deliver! Consider the user’s journey with your app while they are connected, as well as when they are connecting or disconnecting with the CarPlay unit, and design your application with the user’s safety in mind. While the Mapbox Navigation SDK for iOS includes default map styles with traffic and incidents, you can also design your own custom map styles using Mapbox Studio and display them to your users on CarPlay. User activities to consider Mapbox provides building blocks and a CarPlay example app to help speed up your development for each user activity. Ultimately, though, it’s up to you to design and build the experience you want to deliver and to make sure there are no user interface ""dead ends"" in your application. The user experience on CarPlay's top bar navigation and map view functionality is logically divided into three distinct user activities: browsing, previewing, and navigating. Learn more about how to develop for these user activities using the Navigation SDK in the Mapbox Navigation SDK for iOS CarPlay Reference. Browsing In the browsing state, the user can browse the application menus. For example, they could search for a destination or browse a list of favorites, history, or recommended nearby locations. The map view will also follow the user as they drive. The user can zoom and pan the map, and recenter it on themselves if they choose to do so. While Mapbox provides some example CarPlay template buttons and views, we strongly recommend that you design your own experience and implement your own template buttons and provide them to the Mapbox CarPlay integration via your CarPlayManagerDelegate implementation when requested by the CarPlayManager. Previewing When the user searches for a route, one or more results will be returned. To start active guidance, the user will need to select which route to follow and confirm. If more than one route is returned, the user will be able to switch between them to preview the routes before continuing. It is possible to provide different top bar buttons for the user when they are selecting and confirming a route, and we recommend doing so. For example, you could give users the opportunity to cancel, or to save a route for later, depending on your user experience design. When the app enters this state, the CarPlayManager will ask its delegate for updated buttons appropriate for this user activity. Navigating After the navigation process begins in your app, the user receives turn-by-turn directions to navigate their chosen route. If they stray from the route, a new route is generated. After the journey is complete, you can also present the user with a feedback screen to collect user input. Again, we strongly recommend that you provide your users with different activity-specific functionality using different top bar buttons. For example, you could give users the option to cancel a route, enable or disable voice instructions, and other activity-specific functions. The CarPlayManager will ask its delegate for updated buttons appropriate for this activity. Design carefully for this activity, and allow your users to safely arrive at their destination while avoiding the unnecessary distraction of a sub-optimal user experience. Make sure there are no dead-ends in your app’s user experience when navigating the top bar menus. Begin your integration Apple has designed the CarPlay framework with a protocol based on the UIApplicationDelegate protocol, CPApplicationDelegate. Mapbox provides an example implementation of key CPApplicationDelegate methods that configures the shared CarPlayManager object. This example implementation should be placed in your application delegate, possibly as an extension or as another delegate class. The Mapbox Example-CarPlay application included in the Navigation SDK for iOS codebase includes an example of this integration. In addition to configuring the CarPlayManager object in your CPApplicationDelegate implementation, you can also use the CPApplicationDelegate methods to trigger your own application events, such as a user interface change on the phone or logging an application-specific event. CarPlayManagerDelegate offers additional opportunities for customization beyond connection and disconnection. Using this protocol, the Mapbox Navigation SDK for iOS will notify your application of key transitions in application state between the three activities described above, request updated leading, trailing, and map template buttons, and other important events. Test your integration As with all iOS applications, it is important to test your app on a real device in the real world. Testing is even more important with CarPlay since available head units have a wide variety of different capabilities, screen resolutions, and input devices. You should plan to devote considerable design and development time to testing with real hardware to understand how your application experience changes when it is connected to a vehicle. Further resources Mapbox Navigation SDK CarPlay API reference CarPlay developer documentation CarPlay audio and navigation apps introduction Was this page helpful? Yes No",,CarPlay support in the Navigation SDK,Design your app,User activities to consider,,Browsing,Previewing,Navigating,Begin your integration,Test your integration,Further resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,bounding box,A bounding box is a mechanism for describing a particular area of a map.,https://docs.mapbox.com/help/glossary/bounding-box/,glossary,,,"bounding box A bounding box is a mechanism for describing a particular area of a map. It is typically expressed as an array of coordinate pairs, with the first coordinate pair referring to the southwestern corner of the box and the second referring to the northeastern corner of the box. Any Mapbox library that creates maps or initiates geocoding requests has a class or object for using bounding boxes in your code: Mapbox.js and Leaflet - L.LatLngBounds Mapbox GL JS - LngLatBounds Turf.js - turf.bbox Mapbox Maps SDK for iOS - MGLCoordinateBounds Mapbox Maps SDK for Android - BoundingBox class Mapbox Java SDK – MapboxGeocoding.Builder.bbox() method MapboxGeocoder.swift – RectangularRegion class Was this page helpful? Yes No",,bounding box,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,City simulator,An overview of the city simulator example scene provided in the Mapbox Maps SDK for Unity.,https://docs.mapbox.com/unity/maps/examples/city-simulator/,example,No code,,"City simulator You can use the City simulator as a starting point for applications that need a scene with 3D features such as buildings and terrain with elevation. To visualize a map, this example scene comes ready with the CitySimulatorMap prefab. Visualize a map Click on CitySimulatorMap in the Hierarchy to open the Inspector to see and edit the settings. By default, City Simulator uses the Mapbox Streets style. The style is specified in the IMAGE settings under the Data Source menu. You can change to another Mapbox default style or use a custom style. Elevation data is provided in the TERRAIN settings by the Mapbox Terrain-RGB raster tileset. The MAP LAYERS settings are where the vector tileset is configured. This example uses Mapbox Streets With Building Ids for the default. To change the tileset, select another option in the Data Source field. You can see where the example configures the Map Layers in the FEATURES settings. This example sets ExtrudedBuildings and Roads. Select ExtrudedBuildings to see the settings for the visualizer. This feature makes use of the building layer in the Mapbox Streets v7 tileset. This data is used to create and style the layer's feature on the map. The styling is determined by the Extrusion Type and Texturing settings. You can change the texture of the mesh by specifying another option in the Style Type settings of the Texturing section. Add a custom feature The scene can be extended to add any other vector features that you want. To add a custom vector feature, follow the steps below: Click the Add Feature button and select Custom. Specify a title for the new feature. Change the Data Layer to the layer you require. For this example the water layer has been specified. Change the Texturing Style Type to Custom and then specify a Top Material and Side Material. For this example MapboxBlue, which is included in the SDK, has been selected. Was this page helpful? Yes No",,City simulator,Add a custom feature,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Maneuver instructions,Learn how default and custom milestones are used to trigger text and voice instructions in the core Mapbox Navigation SDK and Navigation UI SDK for Android.,https://docs.mapbox.com/android/navigation/overview/milestones/,guide,Java,,"Maneuver instructions SDKs covered: Navigation SDK Navigation UI SDK Navigation milestones inside the SDK provide a powerful way to give your user instructions or get cues to hide or show custom UI elements at defined locations along their route. Use default milestones to trigger voice and text instructions or create custom milestones that fit your particular app needs. Default milestones There are two default milestones that are used to trigger voice and text instructions: VoiceInstructionMilestone and BannerInstructionMilestone. BannerInstructionMilestone BannerInstructionMilestone fires every time textual instructions should be updated, most of the time in the format of a ""banner"" view on the top of the screen. This milestone provides a BannerInstructions object for the given point along the route. This object contains text and URLs for shield images that can be displayed on screen at the time the milestone fires. VoiceInstructionMilestone VoiceInstructionMilestone fires every time it's time to announce an instruction along a given DirectionsRoute. This milestone provides a plain text instruction with VoiceInstructionMilestone#getInstruction as well as a SSML version of the same instruction with VoiceInstructionMilestone#getSsmlAnnouncement. SSML stands for Speech Synthesis Markup Language and is designed to work with AWS Polly. Navigation UI SDK In the Navigation UI SDK, banner and voice instructions are triggered by the default milestones described above. There are default styling rules for banner instructions and default settings for voice instructions. Instructions can be customized to an extent including overriding default behaviors when instructions are triggered and customizing the style of banner instructions. You must create custom milestones with the core Navigation SDK. Note For customizing the language used in instructions, see Localization. Instruction triggers Using NavigationView in your XML gives you the ability to listen to different updates or events that may occur during navigation. BannerInstructionsListener willDisplay(BannerInstructions instructions) will be triggered when a BannerInstructions is about to be displayed. The listener gives you the option to override any values and pass as the return value, which will be the value used for the banner instructions. You can return null and the instructions will be ignored. SpeechAnnouncementListener willVoice(SpeechAnnouncement announcement) will be triggered when a voice announcement is about to be voiced. The listener gives you the option to override any values and pass as the return value, which will be the value used for the voice announcement. You can return null and the announcement will be ignored. To use these listeners, add them to your NavigationViewOptions before you call navigationView.startNavigation(NavigationViewOptions options): Java Kotlin NavigationViewOptions options = NavigationViewOptions.builder() .navigationListener(this) .routeListener(this) .feedbackListener(this) .build(); Copy Instruction styling You also have the option to add the custom Views used in the turn-by-turn UI to your XML. The top View that displays the maneuver image, instruction text, and sound button is called InstructionView. <com.mapbox.services.android.navigation.ui.v5.instruction.InstructionView android:id=""@+id/instructionView"" android:layout_width=""match_parent"" android:layout_height=""wrap_content""/> Once inflated in your Activity, the InstructionView can be updated with RouteProgress and Milestone objects inside a ProgressChangeListener and MilestoneEventListener respectively. Java Kotlin @Override public void onProgressChange(Location location, RouteProgress routeProgress) { instructionView.updateDistanceWith(routeProgress); } @Override public void onMilestoneEvent(RouteProgress routeProgress, String instruction, Milestone milestone) { instructionView.updateBannerInstructionsWith(milestone); } Copy Prior to the first time you want to update the InstructionView, you can control the distance formatting with InstructionView#setDistanceFormatter(DistanceFormatter distanceFormatter). This will determine how distances are displayed in the view: Java Kotlin String unitType = DirectionsCriteria.METRIC; String language = Locale.US.getLanguage(); int roundingIncrement = NavigationConstants.ROUNDING_INCREMENT_TWENTY_FIVE; DistanceFormatter distanceFormatter = new DistanceFormatter(getContext(), language, unitType, roundingIncrement); instructionView.setDistanceFormatter(distanceFormatter); } Copy If this is not set, the view will create its own based on inferred parameters from the device's Android configuration. Please also make sure to set our default theme: R.style.NavigationViewLight (or create your own) and set it in your Activity or Fragment before super.onCreate(). The custom Views will now look for the attributes in the default theme to set text and background colors: Java Kotlin @Override protected void onCreate(Bundle savedInstanceState) { setTheme(R.style.NavigationViewLight); super.onCreate(savedInstanceState); setContentView(R.layout.activity_navigation); ... } Copy Milestone event listener All milestones use the onMilestoneEvent callback to alert when they get triggered. If you want to make use of the milestones API, you will want to attach a MilestoneEventListener inside your app. When all the milestone trigger conditions are true, the callback is invoked and provides you with the latest routeProgress along with the milestone's corresponding String instruction and the Milestone itself that was triggered. You can use your text-to-speech engine of choice and have it consume the instruction. Java Kotlin @Override public void onMilestoneEvent(RouteProgress routeProgress, String instruction, Milestone milestone) { exampleInstructionPlayer.play(instruction); } Copy Custom instructions When using the milestone event listener, the callback provides a String instruction value. During the milestone creation process, you can add the logic that generates this instruction. Begin by creating a new Instruction object which will provide an override method, buildInstruction, which provides a RouteProgress object for producing the instructions string. With the provided route progress, you can add information such as distance and duration remaining until the next maneuver. Once the Instruction is initialized, you will need to give it to the milestone using setInstruction. The example below shows how to add the Directions API instruction as the milestone instruction with no modifications. Java Kotlin Instruction myInstruction = new Instruction() { @Override public String buildInstruction(RouteProgress routeProgress) { return routeProgress.currentLegProgress().upComingStep().maneuver().instruction(); } }; Copy Load banner instructions into a TextView If you would like to use your own TextView and load a given BannerText instruction, you can do so with the InstructionLoader. The loader takes care of organizing text, loading road shields, and abbreviating text (if it doesn't fit in the TextView). Paired with our MilestoneEventListener, you can load instruction updates into your TextView: Java Kotlin @Override public void onMilestoneEvent(RouteProgress routeProgress, String instruction, Milestone milestone) { if (milestone instanceof BannerInstructionMilestone) { BannerText primaryInstruction = ((BannerInstructionMilestone) milestone).getBannerInstructions().primary(); InstructionLoader loader = new InstructionLoader(textView, primaryInstruction); loader.loadInstruction(); } } } Copy Listen for the start or stop of a navigation session The onRunning callback notifies you when the navigation session has started, the user has canceled the session, or the user has arrived at their final destination. From this information, you can decide when to show navigation notifications, know when it's safe to stop requesting user location updates, and more. Java Kotlin navigation.addNavigationEventListener(new NavigationEventListener() { @Override public void onRunning(boolean running) { } }); Copy Custom milestones Milestones bring flexibility to your app and how it handles navigation events. You can create a milestone in a few steps. First, choose how often you'd like the milestone to be triggered. Two options are provided: StepMilestone, which is triggered each step in the route. RouteMilestone, which will only be triggered once during the entire route. You can also implement your own behavior for triggers by extending the Milestone class. Give the milestone a unique identifier that can be used to determine which milestone triggered the onMilestoneEvent callback. Set the triggers using any combination of the properties shown in the table below. It is important to note that trigger properties have different corresponding variable types that need to be accounted for when setting up the milestone. Lastly, build the milestone and pass it into the MapboxNavigation instance using addMilestone(). The snippet of code below shows the creation of a RouteMilestone with two conditions, both of which need to be true for the milestone to be triggered. Since it is a RouteMilestone, the milestone event only occurs once along the route. You can read the trigger statement as: both the step index must be less than three and the current step total distance must be greater than 200 meters for the milestone to be triggered. Java Kotlin navigation.addOffRouteListener(new OffRouteListener() { @Override public void userOffRoute(Location location) { navigation.addMilestone(new RouteMilestone.Builder() .setIdentifier(""begin-route-milestone"") .setTrigger( Trigger.all( Trigger.lt(TriggerProperty.STEP_INDEX, 3), Trigger.gt(TriggerProperty.STEP_DISTANCE_TOTAL_METERS, 200))).build() ); Copy Trigger conditions Besides the triggers already mentioned above, the SDK comes equipped to handle pretty much any case you'd like to build. The table below shows all the conditions offered inside the SDK and whether it is a compound statement or a simple statement. Condition name Type Description all Compound Logical equivalent to an AND statement, all the conditions must be true for the trigger to occur. any Compound Logical equivalent to an OR statement, any of the conditions can be true to cause a trigger. none Compound Logical equivalent to a NOR statement, all statements must equate to false for a trigger to occur. eq Simple Equality. The trigger property's current value must equal the exact value defined. neq Simple Inequality. The trigger property's current value must not equal the exact value defined. gt Simple Greater than. The trigger property's current value must be greater than the defined value. gte Simple Greater than or equal. The trigger property's current value must be greater than or equal to the defined value. lt Simple Less than. The trigger property's current value must be less than the defined value lte Simple Less than or equal. The trigger property's current value must be less than or equal to the defined property. Trigger properties Below are the available trigger properties that can be used along with the conditions above to filter when a milestone should be triggered. Note that instead of the boolean types using the primitive type true or false, the TriggerProperty class uses custom boolean values for the triggers. Property name Type Description STEP_INDEX integer Which step or steps the user must be on the trigger the milestone. STEP_DISTANCE_TOTAL_METERS double The length that the current step must be. STEP_DISTANCE_REMAINING_METERS double Will trigger the milestone based on the distance remaining. STEP_DURATION_REMAINING_SECONDS double Will trigger the milestone based on the duration remaining. STEP_DURATION_TOTAL_SECONDS double Will trigger the milestone based on the total step duration. STEP_DISTANCE_TRAVELED_METERS double Will trigger the milestone based on the distance the user has traveled along the step already. NEW_STEP boolean When the user completes a maneuver and begins traversing along a new step. FIRST_STEP boolean When the user begins a navigation session and is on the first step. LAST_STEP boolean When the user is on the second to last step. Note the final step in direction route will only contain a point representing the final maneuver. NEXT_STEP_DISTANCE_METERS double The next step's total distance in meters. FIRST_LEG boolean When the user is on the first leg. LAST_LEG boolean When the user is on the last leg. Open an issue on GitHub if you feel a trigger property is missing and include the use case. Was this page helpful? Yes No",,Maneuver instructions,BannerInstructionMilestone,VoiceInstructionMilestone,Kotlin,Navigation UI SDK,Instruction triggers,BannerInstructionsListener,SpeechAnnouncementListener,Instruction styling,Milestone event listener,Custom instructions,Load banner instructions into a TextView,,Listen for the start or stop of a navigation session,Custom milestones,Trigger conditions,Trigger properties,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Rotate and tilt with 3D buildings,Rotate and tilt device to change camera and see all around 3D buildings.,https://docs.mapbox.com/android/maps/examples/rotate-extrustions/,example,Java,,"Rotate and tilt with 3D buildings Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.706"" mapbox:mapbox_cameraTargetLng=""-74.011"" mapbox:mapbox_cameraTilt=""45"" mapbox:mapbox_cameraZoom=""16.5"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.extrusions; import android.content.Context; import android.graphics.Color; import android.hardware.Sensor; import android.hardware.SensorEvent; import android.hardware.SensorEventListener; import android.hardware.SensorManager; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.building.BuildingPlugin; import timber.log.Timber; /** * Change the camera's bearing and tilt based on device movement while viewing building extrusions */ public class RotationExtrusionActivity extends AppCompatActivity implements SensorEventListener { private MapView mapView; private MapboxMap mapboxMap; private SensorManager sensorManager; private SensorControl sensorControl; private float[] gravityArray; private float[] magneticArray; private float[] inclinationMatrix = new float[9]; private float[] rotationMatrix = new float[9]; // Amplifiers that translate small phone orientation movements into larger viewable map changes. // Pitch is negative to compensate for the negative readings from the device while face up // 90 is used based on the viewable angle when viewing the map (from phone being flat to facing you). private static final int PITCH_AMPLIFIER = -90; private static final int BEARING_AMPLIFIER = 90; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_extrusion_rotation); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap map) { mapboxMap = map; mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { setupBuildingExtrusionPlugin(style); } }); } }); } private void setupBuildingExtrusionPlugin(@NonNull Style style) { BuildingPlugin buildingPlugin = new BuildingPlugin(mapView, mapboxMap, style); buildingPlugin.setColor(Color.LTGRAY); buildingPlugin.setOpacity(0.6f); buildingPlugin.setMinZoomLevel(15); buildingPlugin.setVisibility(true); } @Override protected void onStart() { super.onStart(); mapView.onStart(); sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE); sensorControl = new SensorControl(sensorManager); registerSensorListeners(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); sensorManager.unregisterListener(this, sensorControl.getGyro()); sensorManager.unregisterListener(this, sensorControl.getMagnetic()); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public void onSensorChanged(SensorEvent event) { if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) { gravityArray = event.values; } if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) { magneticArray = event.values; } if (gravityArray != null && magneticArray != null) { boolean success = SensorManager.getRotationMatrix(rotationMatrix, inclinationMatrix, gravityArray, magneticArray); if (success) { if (mapboxMap != null) { int mapCameraAnimationMillisecondsSpeed = 100; mapboxMap.animateCamera(CameraUpdateFactory .newCameraPosition(createNewCameraPosition()), mapCameraAnimationMillisecondsSpeed ); } } } } @Override public void onAccuracyChanged(Sensor sensor, int accuracy) { // Intentionally left empty } private CameraPosition createNewCameraPosition() { float[] orientation = new float[3]; SensorManager.getOrientation(rotationMatrix, orientation); float pitch = orientation[1]; float roll = orientation[2]; CameraPosition position = new CameraPosition.Builder() .tilt(pitch * PITCH_AMPLIFIER) .bearing(roll * BEARING_AMPLIFIER) .build(); return position; } private void registerSensorListeners() { int sensorEventDeliveryRate = 200; if (sensorControl.getGyro() != null) { sensorManager.registerListener(this, sensorControl.getGyro(), sensorEventDeliveryRate); } else { Timber.d(""Whoops, no accelerometer sensor""); Toast.makeText(this, R.string.no_accelerometer, Toast.LENGTH_SHORT).show(); } if (sensorControl.getMagnetic() != null) { sensorManager.registerListener(this, sensorControl.getMagnetic(), sensorEventDeliveryRate); } else { Timber.d(""Whoops, no magnetic sensor""); Toast.makeText(this, R.string.no_magnetic, Toast.LENGTH_SHORT).show(); } } private class SensorControl { private Sensor gyro; private Sensor magnetic; SensorControl(SensorManager sensorManager) { this.gyro = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); this.magnetic = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD); } Sensor getGyro() { return gyro; } Sensor getMagnetic() { return magnetic; } } } Copy Was this page helpful? Yes No",,Rotate and tilt with 3D buildings,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Use a custom render function with a geocoder,Use a custom html rendering function with the mapbox-gl-geocoder to customize how the dropdown menu is displayed.,https://docs.mapbox.com/mapbox-gl-js/example/mapbox-gl-geocoder-custom-render/,example,JavaScript,,Use a custom render function with a geocoder Use a custom html rendering function with the mapbox-gl-geocoder to customize how the dropdown menu is displayed. Was this example helpful? Yes No,,Use a custom render function with a geocoder,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Attribution,"Learn when, why, and how you are required to add attribution to applications built with Mapbox.",https://docs.mapbox.com/help/how-mapbox-works/attribution/,guide,,,"Attribution Maps using Mapbox map designs or data must display the Mapbox wordmark and text attribution. This guide explains when, why, and how you are required to add these forms of attribution. Mapbox © Mapbox © OpenStreetMap Improve this map Mapbox static map with custom attribution and wordmark applied. How attribution works Mapbox requires two types of attribution: a wordmark and text attribution. Mapbox wordmark The Mapbox wordmark is a small image containing the stylized word ""Mapbox"". It typically resides on the bottom left corner of a map. While you may move the wordmark to a different corner of the map, we require the Mapbox wordmark to appear on our maps so that Mapbox and its maps get proper credit. If you wish to otherwise move or remove the Mapbox wordmark, please contact our sales team to discuss options available under our Enterprise plans. Text attribution The text attribution contains at least three links: © Mapbox, © OpenStreetMap and Improve this map. This attribution is strictly required when using the Mapbox Streets tileset due to OpenStreetMap's data source ODbL license. Some other Mapbox-provided tilesets require additional attribution which is stored in the TileJSON of the tileset. When do you have to provide attribution? Maps using Mapbox map designs or data supplied by Mapbox must display both the Mapbox wordmark and text attribution. This includes: Maps using a Mapbox template style such as Mapbox Streets, Mapbox Outdoors or Mapbox Light, or a style derived from those styles. Maps using a Mapbox tileset, such as Mapbox Streets, Mapbox Terrain, and Mapbox Satellite. You must also display the Mapbox wordmark if your map uses a custom style or custom data hosted by Mapbox. (This is the case for most maps built with Mapbox Studio.) If you do not use Mapbox designs or data supplied by Mapbox, you may omit text attribution. If your map does not use Mapbox designs, data, hosting, or other Mapbox APIs, Mapbox does not require you to provide attribution in either form. Adding attribution When creating a map with Mapbox tools, attribution is usually added automatically, but it may not be added in every case! Depending on how you publish your map, you may need to add attribution manually. Note: You can adjust the font color and size of the attribution to match your theme, but attribution must be legible. You may not style the Mapbox wordmark. Mapbox Studio When viewing a share URL generated with Mapbox Studio, the Mapbox wordmark and attribution will be included automatically. Mapbox GL JS Maps created with Mapbox GL JS will automatically include attribution on the bottom right corner of the map. For additional display options, see the API documentation for AttributionControl. Mapbox.js Maps created with Mapbox.js automatically include the Mapbox wordmark and attribution. If you are using Mapbox map styles or data with Mapbox.js, you need to attribute Mapbox. For display options, see the API documentation for L.control.attribution. Mapbox.js is an open source project that you can download and edit or use the hosted version. You can even use it with services other than Mapbox. If you use Mapbox.js in a project, you don’t need to attribute your use of the library. If you include its source in an open source project, please read and follow its BSD license. Mapbox Maps SDK for iOS Maps that use the Mapbox Maps SDK for iOS will include an information button that reveals an action sheet when tapped. By default, the information button is located on the bottom right of the map. You may move the information button to a different position within the map view. Mapbox includes this built-in information button for your convenience. If you decide not to use it, you must include attribution on the map in a text format. The attribution must include © Mapbox as a link to https://www.mapbox.com/about/maps/, ""© OpenStreetMap"" as a link to http://www.openstreetmap.org/copyright, and ""Improve this map"" as a link to https://www.mapbox.com/map-feedback/. If you choose to use one of our Satellite styles, you must also include © DigitalGlobe as a link to https://www.digitalglobe.com/. Note that in the future, Mapbox may update the information on the action sheet and require additional attribution to our suppliers. Additionally, you must provide a telemetry opt-out option elsewhere in your application if you do not plan to use the built-in information button. If you choose to do so, you must provide an alternative opt-out in one of two ways: Add a setting to your application’s section in the system Settings app using a Settings.bundle in your application bundle. An example Settings.bundle is included with the SDK if you install it manually. If you installed the SDK via CocoaPods or Carthage, you can download an example bundle. Integrate the setting directly into your app. Hook a UISwitch control up to the MGLMapboxMetricsEnabled Boolean user default, which should be YES by default. Then set MGLMapboxMetricsEnabledSettingShownInApp to YES in your app’s Info.plist file. Mapbox Maps SDK for Android Maps that use the Mapbox Maps SDK for Android include a Mapbox wordmark and an information button automatically. The information button reveals an attribution panel when tapped. By default, the Mapbox wordmark and information button are located on the bottom left of the map. You may move these elements to a different position, but they must stay on the map view. For display options, see the API documentation for the UiSettings class. You may also reposition these elements within the activity’s XML layout. Mapbox includes this built-in information button for your convenience. If you decide not to use it, you must include attribution on the map in a text format. The attribution must include © Mapbox as a link to https://www.mapbox.com/about/maps/, ""© OpenStreetMap"" as a link to http://www.openstreetmap.org/copyright, and ""Improve this map"" as a link to https://www.mapbox.com/map-feedback/. If you choose to use one of our Satellite styles, you must also include © DigitalGlobe as a link to https://www.digitalglobe.com/. Note that in the future, Mapbox may update the information on the attribution panel and require additional attribution to our suppliers. Additionally, you must provide a telemetry opt-out option elsewhere in your application if you choose not to use the built-in information button. Mapbox Maps SDK for Unity You must include the Mapbox wordmark and attribution notice on any map that uses the Mapbox Maps SDK for Unity. We provide an Attribution prefab with the Maps SDK for Unity that includes all required information. This prefab utilizes UGUI for integration and customization. You may adjust the position of the Mapbox wordmark and attribution notice, but they must stay visible on the map. You may also change the background (transparent by default) and text color of the text attribution notice to match your design aesthetics, but all information must be legible. You may not otherwise alter the Mapbox wordmark or text attribution notice. If you wish to otherwise move or remove the Mapbox wordmark, please contact our sales team to discuss options available under our Enterprise plans. Static & print Static and print maps need to be attributed in the same fashion as you would cite a photograph: in a textual description near the image. If you can include HTML, use this code snippet that includes links to Mapbox & OpenStreetMap: © <a href='https://www.mapbox.com/about/maps/'>Mapbox</a> © <a href='http://www.openstreetmap.org/copyright'>OpenStreetMap</a> <strong><a href='https://www.mapbox.com/map-feedback/' target='_blank'>Improve this map</a></strong> Images generated from the Mapbox Studio print export option also require Mapbox attribution. For prints, where you can't include links, use the Mapbox logo and this text-only attribution: © Mapbox, © OpenStreetMap To print images generated from the Mapbox Studio print export option for any use, contact us. Other mapping frameworks If you are using Mapbox maps with another open source library, like Leaflet or OpenLayers, the Mapbox wordmark and attribution are still required. These libraries may not automatically add necessary attribution, so you'll need to add it yourself. With Leaflet, you can attribute Mapbox and OpenStreetMap with the attribution control, using the addAttribution() function: // This assumes your map is the variable 'map' var credits = L.control.attribution().addTo(map); credits.addAttribution('© <a href=""https://www.mapbox.com/about/maps/"">Mapbox</a> © <a href=""http://www.openstreetmap.org/copyright"">OpenStreetMap</a> <strong><a href=""https://www.mapbox.com/map-feedback/"" target=""_blank"">Improve this map</a></strong>'); If you're using a mapping library without an attribution control, you will need to insert the HTML attribution and Mapbox wordmark with the code below. Use the following HTML and CSS to the wordmark and attribution manually: HTML <div id='map'> <a href=""http://mapbox.com/about/maps"" class='mapbox-wordmark' target=""_blank"">Mapbox</a> <div class=""mapbox-attribution-container""> <a href=""https://www.mapbox.com/about/maps/"">© Mapbox | </a> <a href=""http://www.openstreetmap.org/copyright"">© OpenStreetMap | </a> <a href=""https://www.mapbox.com/map-feedback/"" target=""_blank""><strong>Improve this map</strong></a> </div> </div> CSS #map { position: absolute; top: 0; bottom: 0; width: 100%; } .mapbox-attribution-container { bottom: 0; right: 0; position: absolute; display: block; margin: 0 10 5; } .mapbox-wordmark { position: absolute; display: block; height: 20px; width: 65px; left: 10px; bottom: 10px; text-indent: -9999px; z-index: 99999; overflow: hidden; /* `background-image` contains the Mapbox wordmark */ background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgODAuNDcgMjAuMDIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDgwLjQ3IDIwLjAyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe29wYWNpdHk6MC42O2ZpbGw6I0ZGRkZGRjtlbmFibGUtYmFja2dyb3VuZDpuZXcgICAgO30uc3Qxe29wYWNpdHk6MC42O2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyAgICA7fTwvc3R5bGU+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTc5LjI5LDEzLjYxYzAsMC4xMS0wLjA5LDAuMi0wLjIsMC4yaC0xLjUzYy0wLjEyLDAtMC4yMy0wLjA2LTAuMjktMC4xNmwtMS4zNy0yLjI4bC0xLjM3LDIuMjhjLTAuMDYsMC4xLTAuMTcsMC4xNi0wLjI5LDAuMTZoLTEuNTNjLTAuMDQsMC0wLjA4LTAuMDEtMC4xMS0wLjAzYy0wLjA5LTAuMDYtMC4xMi0wLjE4LTAuMDYtMC4yN2MwLDAsMCwwLDAsMGwyLjMxLTMuNWwtMi4yOC0zLjQ3Yy0wLjAyLTAuMDMtMC4wMy0wLjA3LTAuMDMtMC4xMWMwLTAuMTEsMC4wOS0wLjIsMC4yLTAuMmgxLjUzYzAuMTIsMCwwLjIzLDAuMDYsMC4yOSwwLjE2bDEuMzQsMi4yNWwxLjMzLTIuMjRjMC4wNi0wLjEsMC4xNy0wLjE2LDAuMjktMC4xNmgxLjUzYzAuMDQsMCwwLjA4LDAuMDEsMC4xMSwwLjAzYzAuMDksMC4wNiwwLjEyLDAuMTgsMC4wNiwwLjI3YzAsMCwwLDAsMCwwTDc2Ljk2LDEwbDIuMzEsMy41Qzc5LjI4LDEzLjUzLDc5LjI5LDEzLjU3LDc5LjI5LDEzLjYxeiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik02My4wOSw5LjE2Yy0wLjM3LTEuNzktMS44Ny0zLjEyLTMuNjYtMy4xMmMtMC45OCwwLTEuOTMsMC40LTIuNiwxLjEyVjMuMzdjMC0wLjEyLTAuMS0wLjIyLTAuMjItMC4yMmgtMS4zM2MtMC4xMiwwLTAuMjIsMC4xLTAuMjIsMC4yMnYxMC4yMWMwLDAuMTIsMC4xLDAuMjIsMC4yMiwwLjIyaDEuMzNjMC4xMiwwLDAuMjItMC4xLDAuMjItMC4yMnYtMC43YzAuNjgsMC43MSwxLjYyLDEuMTIsMi42LDEuMTJjMS43OSwwLDMuMjktMS4zNCwzLjY2LTMuMTNDNjMuMjEsMTAuMyw2My4yMSw5LjcyLDYzLjA5LDkuMTZMNjMuMDksOS4xNnogTTU5LjEyLDEyLjQxYy0xLjI2LDAtMi4yOC0xLjA2LTIuMy0yLjM2VjkuOTljMC4wMi0xLjMxLDEuMDQtMi4zNiwyLjMtMi4zNnMyLjMsMS4wNywyLjMsMi4zOVM2MC4zOSwxMi40MSw1OS4xMiwxMi40MXoiLz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNNjguMjYsNi4wNGMtMS44OS0wLjAxLTMuNTQsMS4yOS0zLjk2LDMuMTNjLTAuMTIsMC41Ni0wLjEyLDEuMTMsMCwxLjY5YzAuNDIsMS44NSwyLjA3LDMuMTYsMy45NywzLjE0YzIuMjQsMCw0LjA2LTEuNzgsNC4wNi0zLjk5UzcwLjUxLDYuMDQsNjguMjYsNi4wNHogTTY4LjI0LDEyLjQyYy0xLjI3LDAtMi4zLTEuMDctMi4zLTIuMzlzMS4wMy0yLjQsMi4zLTIuNHMyLjMsMS4wNywyLjMsMi4zOVM2OS41MSwxMi40MSw2OC4yNCwxMi40Mkw2OC4yNCwxMi40MnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNTkuMTIsNy42M2MtMS4yNiwwLTIuMjgsMS4wNi0yLjMsMi4zNnYwLjA2YzAuMDIsMS4zMSwxLjA0LDIuMzYsMi4zLDIuMzZzMi4zLTEuMDcsMi4zLTIuMzlTNjAuMzksNy42Myw1OS4xMiw3LjYzeiBNNTkuMTIsMTEuMjNjLTAuNiwwLTEuMDktMC41My0xLjExLTEuMTlWMTBjMC4wMS0wLjY2LDAuNTEtMS4xOSwxLjExLTEuMTlzMS4xMSwwLjU0LDEuMTEsMS4yMVM1OS43NCwxMS4yMyw1OS4xMiwxMS4yM3oiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNjguMjQsNy42M2MtMS4yNywwLTIuMywxLjA3LTIuMywyLjM5czEuMDMsMi4zOSwyLjMsMi4zOXMyLjMtMS4wNywyLjMtMi4zOVM2OS41MSw3LjYzLDY4LjI0LDcuNjN6IE02OC4yNCwxMS4yM2MtMC42MSwwLTEuMTEtMC41NC0xLjExLTEuMjFzMC41LTEuMiwxLjExLTEuMnMxLjExLDAuNTQsMS4xMSwxLjIxUzY4Ljg1LDExLjIzLDY4LjI0LDExLjIzeiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00My41Niw2LjI0aC0xLjMzYy0wLjEyLDAtMC4yMiwwLjEtMC4yMiwwLjIydjAuN2MtMC42OC0wLjcxLTEuNjItMS4xMi0yLjYtMS4xMmMtMi4wNywwLTMuNzUsMS43OC0zLjc1LDMuOTlzMS42OSwzLjk5LDMuNzUsMy45OWMwLjk5LDAsMS45My0wLjQxLDIuNi0xLjEzdjAuN2MwLDAuMTIsMC4xLDAuMjIsMC4yMiwwLjIyaDEuMzNjMC4xMiwwLDAuMjItMC4xLDAuMjItMC4yMlY2LjQ0YzAtMC4xMS0wLjA5LTAuMjEtMC4yMS0wLjIxQzQzLjU3LDYuMjQsNDMuNTcsNi4yNCw0My41Niw2LjI0eiBNNDIuMDIsMTAuMDVjLTAuMDEsMS4zMS0xLjA0LDIuMzYtMi4zLDIuMzZzLTIuMy0xLjA3LTIuMy0yLjM5czEuMDMtMi40LDIuMjktMi40YzEuMjcsMCwyLjI4LDEuMDYsMi4zLDIuMzZMNDIuMDIsMTAuMDV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTM5LjcyLDcuNjNjLTEuMjcsMC0yLjMsMS4wNy0yLjMsMi4zOXMxLjAzLDIuMzksMi4zLDIuMzlzMi4yOC0xLjA2LDIuMy0yLjM2VjkuOTlDNDIsOC42OCw0MC45OCw3LjYzLDM5LjcyLDcuNjN6IE0zOC42MiwxMC4wMmMwLTAuNjcsMC41LTEuMjEsMS4xMS0xLjIxYzAuNjEsMCwxLjA5LDAuNTMsMS4xMSwxLjE5djAuMDRjLTAuMDEsMC42NS0wLjUsMS4xOC0xLjExLDEuMThTMzguNjIsMTAuNjgsMzguNjIsMTAuMDJ6Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTQ5LjkxLDYuMDRjLTAuOTgsMC0xLjkzLDAuNC0yLjYsMS4xMlY2LjQ1YzAtMC4xMi0wLjEtMC4yMi0wLjIyLTAuMjJoLTEuMzNjLTAuMTIsMC0wLjIyLDAuMS0wLjIyLDAuMjJ2MTAuMjFjMCwwLjEyLDAuMSwwLjIyLDAuMjIsMC4yMmgxLjMzYzAuMTIsMCwwLjIyLTAuMSwwLjIyLTAuMjJ2LTMuNzhjMC42OCwwLjcxLDEuNjIsMS4xMiwyLjYxLDEuMTJjMi4wNywwLDMuNzUtMS43OCwzLjc1LTMuOTlTNTEuOTgsNi4wNCw0OS45MSw2LjA0eiBNNDkuNiwxMi40MmMtMS4yNiwwLTIuMjgtMS4wNi0yLjMtMi4zNlY5Ljk5YzAuMDItMS4zMSwxLjA0LTIuMzcsMi4yOS0yLjM3YzEuMjYsMCwyLjMsMS4wNywyLjMsMi4zOVM1MC44NiwxMi40MSw0OS42LDEyLjQyTDQ5LjYsMTIuNDJ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTQ5LjYsNy42M2MtMS4yNiwwLTIuMjgsMS4wNi0yLjMsMi4zNnYwLjA2YzAuMDIsMS4zMSwxLjA0LDIuMzYsMi4zLDIuMzZzMi4zLTEuMDcsMi4zLTIuMzlTNTAuODYsNy42Myw0OS42LDcuNjN6IE00OS42LDExLjIzYy0wLjYsMC0xLjA5LTAuNTMtMS4xMS0xLjE5VjEwQzQ4LjUsOS4zNCw0OSw4LjgxLDQ5LjYsOC44MWMwLjYsMCwxLjExLDAuNTUsMS4xMSwxLjIxUzUwLjIxLDExLjIzLDQ5LjYsMTEuMjN6Ii8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTM0LjM2LDEzLjU5YzAsMC4xMi0wLjEsMC4yMi0wLjIyLDAuMjJoLTEuMzRjLTAuMTIsMC0wLjIyLTAuMS0wLjIyLTAuMjJWOS4yNGMwLTAuOTMtMC43LTEuNjMtMS41NC0xLjYzYy0wLjc2LDAtMS4zOSwwLjY3LTEuNTEsMS41NGwwLjAxLDQuNDRjMCwwLjEyLTAuMSwwLjIyLTAuMjIsMC4yMmgtMS4zNGMtMC4xMiwwLTAuMjItMC4xLTAuMjItMC4yMlY5LjI0YzAtMC45My0wLjctMS42My0xLjU0LTEuNjNjLTAuODEsMC0xLjQ3LDAuNzUtMS41MiwxLjcxdjQuMjdjMCwwLjEyLTAuMSwwLjIyLTAuMjIsMC4yMmgtMS4zM2MtMC4xMiwwLTAuMjItMC4xLTAuMjItMC4yMlY2LjQ0YzAuMDEtMC4xMiwwLjEtMC4yMSwwLjIyLTAuMjFoMS4zM2MwLjEyLDAsMC4yMSwwLjEsMC4yMiwwLjIxdjAuNjNjMC40OC0wLjY1LDEuMjQtMS4wNCwyLjA2LTEuMDVoMC4wM2MxLjA0LDAsMS45OSwwLjU3LDIuNDgsMS40OGMwLjQzLTAuOSwxLjMzLTEuNDgsMi4zMi0xLjQ5YzEuNTQsMCwyLjc5LDEuMTksMi43NiwyLjY1TDM0LjM2LDEzLjU5eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik04MC4zMiwxMi45N2wtMC4wNy0wLjEyTDc4LjM4LDEwbDEuODUtMi44MWMwLjQyLTAuNjQsMC4yNS0xLjQ5LTAuMzktMS45MmMtMC4wMS0wLjAxLTAuMDItMC4wMS0wLjAzLTAuMDJjLTAuMjItMC4xNC0wLjQ4LTAuMjEtMC43NC0wLjIxaC0xLjUzYy0wLjUzLDAtMS4wMywwLjI4LTEuMywwLjc0bC0wLjMyLDAuNTNsLTAuMzItMC41M2MtMC4yOC0wLjQ2LTAuNzctMC43NC0xLjMxLTAuNzRoLTEuNTNjLTAuNTcsMC0xLjA4LDAuMzUtMS4yOSwwLjg4Yy0yLjA5LTEuNTgtNS4wMy0xLjQtNi45MSwwLjQzYy0wLjMzLDAuMzItMC42MiwwLjY5LTAuODUsMS4wOWMtMC44NS0xLjU1LTIuNDUtMi42LTQuMjgtMi42Yy0wLjQ4LDAtMC45NiwwLjA3LTEuNDEsMC4yMlYzLjM3YzAtMC43OC0wLjYzLTEuNDEtMS40LTEuNDFoLTEuMzNjLTAuNzcsMC0xLjQsMC42My0xLjQsMS40djMuNTdjLTAuOS0xLjMtMi4zOC0yLjA4LTMuOTctMi4wOWMtMC43LDAtMS4zOSwwLjE1LTIuMDIsMC40NWMtMC4yMy0wLjE2LTAuNTEtMC4yNS0wLjgtMC4yNWgtMS4zM2MtMC40MywwLTAuODMsMC4yLTEuMSwwLjUzYy0wLjAyLTAuMDMtMC4wNC0wLjA1LTAuMDctMC4wOGMtMC4yNy0wLjI5LTAuNjUtMC40NS0xLjA0LTAuNDVoLTEuMzJjLTAuMjksMC0wLjU3LDAuMDktMC44LDAuMjVDNDAuOCw1LDQwLjEyLDQuODUsMzkuNDIsNC44NWMtMS43NCwwLTMuMjcsMC45NS00LjE2LDIuMzhjLTAuMTktMC40NC0wLjQ2LTAuODUtMC43OS0xLjE5Yy0wLjc2LTAuNzctMS44LTEuMTktMi44OC0xLjE5aC0wLjAxYy0wLjg1LDAuMDEtMS42NywwLjMxLTIuMzQsMC44NGMtMC43LTAuNTQtMS41Ni0wLjg0LTIuNDUtMC44NGgtMC4wM2MtMC4yOCwwLTAuNTUsMC4wMy0wLjgyLDAuMWMtMC4yNywwLjA2LTAuNTMsMC4xNS0wLjc4LDAuMjdjLTAuMi0wLjExLTAuNDMtMC4xNy0wLjY3LTAuMTdoLTEuMzNjLTAuNzgsMC0xLjQsMC42My0xLjQsMS40djcuMTRjMCwwLjc4LDAuNjMsMS40LDEuNCwxLjRoMS4zM2MwLjc4LDAsMS40MS0wLjYzLDEuNDEtMS40MWMwLDAsMCwwLDAsMFY5LjM1YzAuMDMtMC4zNCwwLjIyLTAuNTYsMC4zNC0wLjU2YzAuMTcsMCwwLjM2LDAuMTcsMC4zNiwwLjQ1djQuMzVjMCwwLjc4LDAuNjMsMS40LDEuNCwxLjRoMS4zNGMwLjc4LDAsMS40LTAuNjMsMS40LTEuNGwtMC4wMS00LjM1YzAuMDYtMC4zLDAuMjQtMC40NSwwLjMzLTAuNDVjMC4xNywwLDAuMzYsMC4xNywwLjM2LDAuNDV2NC4zNWMwLDAuNzgsMC42MywxLjQsMS40LDEuNGgxLjM0YzAuNzgsMCwxLjQtMC42MywxLjQtMS40di0wLjM2YzAuOTEsMS4yMywyLjM0LDEuOTYsMy44NywxLjk2YzAuNywwLDEuMzktMC4xNSwyLjAyLTAuNDVjMC4yMywwLjE2LDAuNTEsMC4yNSwwLjgsMC4yNWgxLjMyYzAuMjksMCwwLjU3LTAuMDksMC44LTAuMjV2MS45MWMwLDAuNzgsMC42MywxLjQsMS40LDEuNGgxLjMzYzAuNzgsMCwxLjQtMC42MywxLjQtMS40di0xLjY5YzAuNDYsMC4xNCwwLjk0LDAuMjIsMS40MiwwLjIxYzEuNjIsMCwzLjA3LTAuODMsMy45Ny0yLjF2MC41YzAsMC43OCwwLjYzLDEuNCwxLjQsMS40aDEuMzNjMC4yOSwwLDAuNTctMC4wOSwwLjgtMC4yNWMwLjYzLDAuMywxLjMyLDAuNDUsMi4wMiwwLjQ1YzEuODMsMCwzLjQzLTEuMDUsNC4yOC0yLjZjMS40NywyLjUyLDQuNzEsMy4zNiw3LjIyLDEuODljMC4xNy0wLjEsMC4zNC0wLjIxLDAuNS0wLjM0YzAuMjEsMC41MiwwLjcyLDAuODcsMS4yOSwwLjg2aDEuNTNjMC41MywwLDEuMDMtMC4yOCwxLjMtMC43NGwwLjM1LTAuNThsMC4zNSwwLjU4YzAuMjgsMC40NiwwLjc3LDAuNzQsMS4zMSwwLjc0aDEuNTJjMC43NywwLDEuMzktMC42MywxLjM4LTEuMzlDODAuNDcsMTMuMzgsODAuNDIsMTMuMTcsODAuMzIsMTIuOTdMODAuMzIsMTIuOTd6IE0zNC4xNSwxMy44MWgtMS4zNGMtMC4xMiwwLTAuMjItMC4xLTAuMjItMC4yMlY5LjI0YzAtMC45My0wLjctMS42My0xLjU0LTEuNjNjLTAuNzYsMC0xLjM5LDAuNjctMS41MSwxLjU0bDAuMDEsNC40NGMwLDAuMTItMC4xLDAuMjItMC4yMiwwLjIyaC0xLjM0Yy0wLjEyLDAtMC4yMi0wLjEtMC4yMi0wLjIyVjkuMjRjMC0wLjkzLTAuNy0xLjYzLTEuNTQtMS42M2MtMC44MSwwLTEuNDcsMC43NS0xLjUyLDEuNzF2NC4yN2MwLDAuMTItMC4xLDAuMjItMC4yMiwwLjIyaC0xLjMzYy0wLjEyLDAtMC4yMi0wLjEtMC4yMi0wLjIyVjYuNDRjMC4wMS0wLjEyLDAuMS0wLjIxLDAuMjItMC4yMWgxLjMzYzAuMTIsMCwwLjIxLDAuMSwwLjIyLDAuMjF2MC42M2MwLjQ4LTAuNjUsMS4yNC0xLjA0LDIuMDYtMS4wNWgwLjAzYzEuMDQsMCwxLjk5LDAuNTcsMi40OCwxLjQ4YzAuNDMtMC45LDEuMzMtMS40OCwyLjMyLTEuNDljMS41NCwwLDIuNzksMS4xOSwyLjc2LDIuNjVsMC4wMSw0LjkxQzM0LjM3LDEzLjcsMzQuMjcsMTMuOCwzNC4xNSwxMy44MUMzNC4xNSwxMy44MSwzNC4xNSwxMy44MSwzNC4xNSwxMy44MXogTTQzLjc4LDEzLjU5YzAsMC4xMi0wLjEsMC4yMi0wLjIyLDAuMjJoLTEuMzNjLTAuMTIsMC0wLjIyLTAuMS0wLjIyLTAuMjJ2LTAuNzFDNDEuMzQsMTMuNiw0MC40LDE0LDM5LjQyLDE0Yy0yLjA3LDAtMy43NS0xLjc4LTMuNzUtMy45OXMxLjY5LTMuOTksMy43NS0zLjk5YzAuOTgsMCwxLjkyLDAuNDEsMi42LDEuMTJ2LTAuN2MwLTAuMTIsMC4xLTAuMjIsMC4yMi0wLjIyaDEuMzNjMC4xMS0wLjAxLDAuMjEsMC4wOCwwLjIyLDAuMmMwLDAuMDEsMCwwLjAxLDAsMC4wMlYxMy41OXogTTQ5LjkxLDE0Yy0wLjk4LDAtMS45Mi0wLjQxLTIuNi0xLjEydjMuNzhjMCwwLjEyLTAuMSwwLjIyLTAuMjIsMC4yMmgtMS4zM2MtMC4xMiwwLTAuMjItMC4xLTAuMjItMC4yMlY2LjQ1YzAtMC4xMiwwLjEtMC4yMSwwLjIyLTAuMjFoMS4zM2MwLjEyLDAsMC4yMiwwLjEsMC4yMiwwLjIydjAuN2MwLjY4LTAuNzIsMS42Mi0xLjEyLDIuNi0xLjEyYzIuMDcsMCwzLjc1LDEuNzcsMy43NSwzLjk4UzUxLjk4LDE0LDQ5LjkxLDE0eiBNNjMuMDksMTAuODdDNjIuNzIsMTIuNjUsNjEuMjIsMTQsNTkuNDMsMTRjLTAuOTgsMC0xLjkyLTAuNDEtMi42LTEuMTJ2MC43YzAsMC4xMi0wLjEsMC4yMi0wLjIyLDAuMjJoLTEuMzNjLTAuMTIsMC0wLjIyLTAuMS0wLjIyLTAuMjJWMy4zN2MwLTAuMTIsMC4xLTAuMjIsMC4yMi0wLjIyaDEuMzNjMC4xMiwwLDAuMjIsMC4xLDAuMjIsMC4yMnYzLjc4YzAuNjgtMC43MSwxLjYyLTEuMTIsMi42LTEuMTFjMS43OSwwLDMuMjksMS4zMywzLjY2LDMuMTJDNjMuMjEsOS43Myw2My4yMSwxMC4zMSw2My4wOSwxMC44N0w2My4wOSwxMC44N0w2My4wOSwxMC44N3ogTTY4LjI2LDE0LjAxYy0xLjksMC4wMS0zLjU1LTEuMjktMy45Ny0zLjE0Yy0wLjEyLTAuNTYtMC4xMi0xLjEzLDAtMS42OWMwLjQyLTEuODUsMi4wNy0zLjE1LDMuOTctMy4xNGMyLjI1LDAsNC4wNiwxLjc4LDQuMDYsMy45OVM3MC41LDE0LjAxLDY4LjI2LDE0LjAxTDY4LjI2LDE0LjAxeiBNNzkuMDksMTMuODFoLTEuNTNjLTAuMTIsMC0wLjIzLTAuMDYtMC4yOS0wLjE2bC0xLjM3LTIuMjhsLTEuMzcsMi4yOGMtMC4wNiwwLjEtMC4xNywwLjE2LTAuMjksMC4xNmgtMS41M2MtMC4wNCwwLTAuMDgtMC4wMS0wLjExLTAuMDNjLTAuMDktMC4wNi0wLjEyLTAuMTgtMC4wNi0wLjI3YzAsMCwwLDAsMCwwbDIuMzEtMy41bC0yLjI4LTMuNDdjLTAuMDItMC4wMy0wLjAzLTAuMDctMC4wMy0wLjExYzAtMC4xMSwwLjA5LTAuMiwwLjItMC4yaDEuNTNjMC4xMiwwLDAuMjMsMC4wNiwwLjI5LDAuMTZsMS4zNCwyLjI1bDEuMzQtMi4yNWMwLjA2LTAuMSwwLjE3LTAuMTYsMC4yOS0wLjE2aDEuNTNjMC4wNCwwLDAuMDgsMC4wMSwwLjExLDAuMDNjMC4wOSwwLjA2LDAuMTIsMC4xOCwwLjA2LDAuMjdjMCwwLDAsMCwwLDBMNzYuOTYsMTBsMi4zMSwzLjVjMC4wMiwwLjAzLDAuMDMsMC4wNywwLjAzLDAuMTFDNzkuMjksMTMuNzIsNzkuMiwxMy44MSw3OS4wOSwxMy44MUM3OS4wOSwxMy44MSw3OS4wOSwxMy44MSw3OS4wOSwxMy44MUw3OS4wOSwxMy44MXoiLz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTAsMS4yMWMtNC44NywwLTguODEsMy45NS04LjgxLDguODFzMy45NSw4LjgxLDguODEsOC44MXM4LjgxLTMuOTUsOC44MS04LjgxQzE4LjgxLDUuMTUsMTQuODcsMS4yMSwxMCwxLjIxeiBNMTQuMTgsMTIuMTljLTEuODQsMS44NC00LjU1LDIuMi02LjM4LDIuMmMtMC42NywwLTEuMzQtMC4wNS0yLTAuMTVjMCwwLTAuOTctNS4zNywyLjA0LTguMzljMC43OS0wLjc5LDEuODYtMS4yMiwyLjk4LTEuMjJjMS4yMSwwLDIuMzcsMC40OSwzLjIzLDEuMzVDMTUuOCw3LjczLDE1Ljg1LDEwLjUsMTQuMTgsMTIuMTl6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEwLDAuMDJjLTUuNTIsMC0xMCw0LjQ4LTEwLDEwczQuNDgsMTAsMTAsMTBzMTAtNC40OCwxMC0xMEMxOS45OSw0LjUsMTUuNTIsMC4wMiwxMCwwLjAyeiBNMTAsMTguODNjLTQuODcsMC04LjgxLTMuOTUtOC44MS04LjgxUzUuMTMsMS4yLDEwLDEuMnM4LjgxLDMuOTUsOC44MSw4LjgxQzE4LjgxLDE0Ljg5LDE0Ljg3LDE4LjgzLDEwLDE4LjgzeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNC4wNCw1Ljk4Yy0xLjc1LTEuNzUtNC41My0xLjgxLTYuMi0wLjE0QzQuODMsOC44Niw1LjgsMTQuMjMsNS44LDE0LjIzczUuMzcsMC45Nyw4LjM5LTIuMDRDMTUuODUsMTAuNSwxNS44LDcuNzMsMTQuMDQsNS45OHogTTExLjg4LDkuODdsLTAuODcsMS43OGwtMC44Ni0xLjc4TDguMzgsOS4wMWwxLjc3LTAuODZsMC44Ni0xLjc4bDAuODcsMS43OGwxLjc3LDAuODZMMTEuODgsOS44N3oiLz48cG9seWdvbiBjbGFzcz0ic3QwIiBwb2ludHM9IjEzLjY1LDkuMDEgMTEuODgsOS44NyAxMS4wMSwxMS42NSAxMC4xNSw5Ljg3IDguMzgsOS4wMSAxMC4xNSw4LjE1IDExLjAxLDYuMzcgMTEuODgsOC4xNSAiLz48L2c+PC9zdmc+); background-repeat: no-repeat; background-position: 0 0; background-size: 65px 20px; } Result: Mapbox © Mapbox © OpenStreetMap Improve this map Mapbox static map with custom attribution and wordmark applied. When you're not using a map Some Mapbox services can be used off of a Mapbox map. You are responsible for providing the correct attribution for the Mapbox services that you use. This attribution must be displayed prominently next to the Mapbox service that you are using. The following code is intended to give you a starting point for how to add attribution for Mapbox services if you are not using those services directly on a map. Mapbox cannot provide you with specific guidelines on how to add attribution since the final implementation will be dependent on your use case and your configuration details. In this example, the Mapbox service being used is the Directions API, and the attribution is placed at the end of the list of instructions. HTML <div>Directions content goes here!</div> <div style=""border: 2px solid black;padding: 3px;"">Directions powered by <a href=""http://mapbox.com/about/maps""><svg viewBox=""0 0 81 20"" style=""width: 81px; height: 20px; vertical-align: middle;""><path d=""M9.07917722,0.0888888889 C4.06575949,0.0888888889 0,4.52222222 0,9.98888889 C0,15.4555556 4.06575949,19.8888889 9.07917722,19.8888889 C14.0925949,19.8888889 18.1583544,15.4555556 18.1583544,9.98888889 C18.1583544,4.52222222 14.0925949,0.0888888889 9.07917722,0.0888888889 Z M55.7284177,2.27777778 C55.6061392,2.27777778 55.5042405,2.38888889 55.5042405,2.52222222 L55.5042405,13.9888889 C55.5042405,14.1222222 55.6061392,14.2333333 55.7284177,14.2333333 L57.0938608,14.2333333 C57.2161392,14.2333333 57.318038,14.1222222 57.318038,13.9888889 L57.318038,13.2 C58.0211392,14 58.9891772,14.4555556 59.9979747,14.4555556 C62.1276582,14.4555556 63.8599367,12.4555556 63.8599367,9.97777778 C63.8599367,7.5 62.1276582,5.51111111 59.9979747,5.51111111 C58.9789873,5.51111111 58.0109494,5.96666667 57.318038,6.76666667 L57.318038,2.52222222 C57.318038,2.38888889 57.2161392,2.27777778 57.0938608,2.27777778 L55.7284177,2.27777778 Z M10.0166456,3.93333333 C11.1782911,3.96666667 12.3501266,4.46666667 13.2468354,5.45555556 C15.050443,7.42222222 15.1115823,10.5333333 13.3894937,12.4222222 C10.2815823,15.8111111 4.74848101,14.7222222 4.74848101,14.7222222 C4.74848101,14.7222222 3.74987342,8.68888889 6.85778481,5.3 C7.72392405,4.36666667 8.86518987,3.91111111 10.0166456,3.93333333 Z M26.3510127,5.51111111 C25.515443,5.51111111 24.7308228,5.95555556 24.231519,6.68888889 L24.231519,5.97777778 C24.231519,5.84444444 24.1296203,5.73333333 24.0073418,5.73333333 L22.6418987,5.73333333 C22.5196203,5.73333333 22.4177215,5.84444444 22.4177215,5.97777778 L22.4177215,14 C22.4177215,14.1333333 22.5196203,14.2444444 22.6418987,14.2444444 L24.0073418,14.2444444 C24.1296203,14.2444444 24.231519,14.1333333 24.231519,14 L24.231519,9.2 C24.2824684,8.12222222 24.9651899,7.27777778 25.8007595,7.27777778 C26.6668987,7.27777778 27.3903797,8.06666667 27.3903797,9.11111111 L27.3903797,14 C27.3903797,14.1333333 27.4922785,14.2444444 27.614557,14.2444444 L28.9901899,14.2444444 C29.1124684,14.2444444 29.2143671,14.1333333 29.2143671,14 L29.2041772,9.01111111 C29.3264557,8.03333333 29.9786076,7.27777778 30.7632278,7.27777778 C31.6293671,7.27777778 32.3528481,8.06666667 32.3528481,9.11111111 L32.3528481,14 C32.3528481,14.1333333 32.4547468,14.2444444 32.5770253,14.2444444 L33.9526582,14.2444444 C34.0749367,14.2444444 34.1768354,14.1333333 34.1768354,14 L34.1666456,8.48888889 C34.1972152,6.84444444 32.9132911,5.51111111 31.3236709,5.51111111 C30.3046835,5.52222222 29.3672152,6.16666667 28.9290506,7.17777778 C28.419557,6.14444444 27.4311392,5.5 26.3510127,5.51111111 L26.3510127,5.51111111 Z M39.3838608,5.51111111 C37.2541772,5.51111111 35.5218987,7.51111111 35.5218987,9.98888889 C35.5218987,12.4666667 37.2541772,14.4666667 39.3838608,14.4666667 C40.4028481,14.4666667 41.3708861,14.0111111 42.0637975,13.2111111 L42.0637975,14 C42.0637975,14.1333333 42.1656962,14.2444444 42.2879747,14.2444444 L43.6534177,14.2444444 C43.7756962,14.2444444 43.8775949,14.1333333 43.8775949,14 L43.8775949,5.97777778 C43.8877848,5.84444444 43.7858861,5.73333333 43.6534177,5.73333333 L42.2879747,5.73333333 C42.1656962,5.73333333 42.0637975,5.84444444 42.0637975,5.97777778 L42.0637975,6.76666667 C41.3606962,5.96666667 40.3926582,5.51111111 39.3838608,5.51111111 Z M50.1953165,5.51111111 C49.1763291,5.51111111 48.2082911,5.96666667 47.5153797,6.76666667 L47.5153797,5.97777778 C47.5153797,5.84444444 47.413481,5.73333333 47.2912025,5.73333333 L45.9257595,5.73333333 C45.803481,5.73333333 45.7015823,5.84444444 45.7015823,5.97777778 L45.7015823,17.4444444 C45.7015823,17.5777778 45.803481,17.6888889 45.9257595,17.6888889 L47.2912025,17.6888889 C47.413481,17.6888889 47.5153797,17.5777778 47.5153797,17.4444444 L47.5153797,13.2 C48.218481,14 49.186519,14.4555556 50.1953165,14.4555556 C52.325,14.4555556 54.0572785,12.4555556 54.0572785,9.97777778 C54.0572785,7.5 52.325,5.51111111 50.1953165,5.51111111 Z M69.0975316,5.51111111 C66.7844304,5.51111111 64.9196835,7.51111111 64.9196835,9.98888889 C64.9196835,12.4666667 66.7946203,14.4666667 69.0975316,14.4666667 C71.400443,14.4666667 73.2753797,12.4666667 73.2753797,9.98888889 C73.2753797,7.51111111 71.4106329,5.51111111 69.0975316,5.51111111 Z M73.7237342,5.73333333 C73.6116456,5.73333333 73.5199367,5.83333333 73.5199367,5.95555556 C73.5199367,6 73.5301266,6.04444444 73.5505063,6.07777778 L75.8941772,9.96666667 L73.5199367,13.9 C73.4587975,14 73.4791772,14.1444444 73.5810759,14.2111111 C73.6116456,14.2333333 73.6524051,14.2444444 73.6931646,14.2444444 L75.2725949,14.2444444 C75.3948734,14.2444444 75.506962,14.1777778 75.5681013,14.0666667 L76.9743038,11.5 L78.3805063,14.0666667 C78.4416456,14.1777778 78.5537342,14.2444444 78.6760127,14.2444444 L80.255443,14.2444444 C80.3675316,14.2444444 80.4592405,14.1444444 80.4592405,14.0222222 C80.4592405,13.9777778 80.4490506,13.9444444 80.4286709,13.9 L78.0544304,9.96666667 L80.3981013,6.07777778 C80.4592405,5.97777778 80.4388608,5.83333333 80.336962,5.76666667 C80.3063924,5.74444444 80.2656329,5.73333333 80.2248734,5.73333333 L78.645443,5.73333333 C78.5231646,5.73333333 78.4110759,5.8 78.3499367,5.91111111 L76.9743038,8.43333333 L75.5986709,5.91111111 C75.5375316,5.8 75.425443,5.73333333 75.3031646,5.73333333 L73.7237342,5.73333333 Z M10.1185443,5.88888889 L9.23202532,7.88888889 L7.40803797,8.85555556 L9.23202532,9.82222222 L10.1185443,11.8222222 L11.0152532,9.82222222 L12.8392405,8.85555556 L11.0152532,7.88888889 L10.1185443,5.88888889 Z M39.6997468,7.3 C40.9938608,7.3 42.0434177,8.48888889 42.0637975,9.95555556 L42.0637975,10.0222222 C42.0536076,11.4888889 40.9938608,12.6777778 39.6997468,12.6777778 C38.395443,12.6777778 37.3356962,11.4777778 37.3356962,9.98888889 C37.3356962,8.5 38.395443,7.3 39.6997468,7.3 L39.6997468,7.3 Z M49.8692405,7.3 C51.1735443,7.3 52.2332911,8.5 52.2332911,9.98888889 C52.2332911,11.4777778 51.1735443,12.6777778 49.8692405,12.6777778 C48.5751266,12.6777778 47.5255696,11.4888889 47.5051899,10.0222222 L47.5051899,9.95555556 C47.5255696,8.48888889 48.5751266,7.3 49.8692405,7.3 L49.8692405,7.3 Z M59.6820886,7.3 C60.9863924,7.3 62.0461392,8.5 62.0461392,9.98888889 C62.0461392,11.4777778 60.9863924,12.6777778 59.6820886,12.6777778 C58.3879747,12.6777778 57.3384177,11.4888889 57.318038,10.0222222 L57.318038,9.95555556 C57.3384177,8.48888889 58.3879747,7.3 59.6820886,7.3 L59.6820886,7.3 Z M69.0771519,7.3 C70.3814557,7.3 71.4412025,8.5 71.4412025,9.98888889 C71.4412025,11.4777778 70.3814557,12.6777778 69.0771519,12.6777778 C67.7728481,12.6777778 66.7131013,11.4777778 66.7131013,9.98888889 C66.7131013,8.5 67.7728481,7.3 69.0771519,7.3 Z"" id=""Shape""></path></svg></a>, <a href=""http://www.openstreetmap.org/copyright"">OpenStreetMap</a> </div> Result Sample Directions App Start: Head west. Turn left onto Northeast 7th Avenue. Make a slight right to stay on Northeast 7th Avenue. Turn right. End: You have arrived at your destination, on the left. Directions powered by , OpenStreetMap When you're using a non-Mapbox map If you are using Mapbox services on a non-Mapbox map, these Mapbox services must be properly attributed. You are responsible for providing the correct attribution for the Mapbox services that you use. This attribution must be displayed prominently on or next to the non-Mapbox map you are using. The following code is intended to give you a starting point for how to add attribution for Mapbox services if you are using them on a non-Mapbox map. Mapbox cannot provide you with specific guidelines on how to add attribution since the final implementation will be dependent on your use case and your configuration details. In this example, the Mapbox service being used is the Isochrone API, and the attribution is placed below the non-Mapbox map. HTML <div id='map'></div> <div style=""margin: 0 10%;float: right;"">Isochrones powered by <a href=""http://mapbox.com/about/maps""><svg viewBox=""0 0 81 20"" style=""width: 81px; height: 20px; vertical-align: middle;""><path d=""M9.07917722,0.0888888889 C4.06575949,0.0888888889 0,4.52222222 0,9.98888889 C0,15.4555556 4.06575949,19.8888889 9.07917722,19.8888889 C14.0925949,19.8888889 18.1583544,15.4555556 18.1583544,9.98888889 C18.1583544,4.52222222 14.0925949,0.0888888889 9.07917722,0.0888888889 Z M55.7284177,2.27777778 C55.6061392,2.27777778 55.5042405,2.38888889 55.5042405,2.52222222 L55.5042405,13.9888889 C55.5042405,14.1222222 55.6061392,14.2333333 55.7284177,14.2333333 L57.0938608,14.2333333 C57.2161392,14.2333333 57.318038,14.1222222 57.318038,13.9888889 L57.318038,13.2 C58.0211392,14 58.9891772,14.4555556 59.9979747,14.4555556 C62.1276582,14.4555556 63.8599367,12.4555556 63.8599367,9.97777778 C63.8599367,7.5 62.1276582,5.51111111 59.9979747,5.51111111 C58.9789873,5.51111111 58.0109494,5.96666667 57.318038,6.76666667 L57.318038,2.52222222 C57.318038,2.38888889 57.2161392,2.27777778 57.0938608,2.27777778 L55.7284177,2.27777778 Z M10.0166456,3.93333333 C11.1782911,3.96666667 12.3501266,4.46666667 13.2468354,5.45555556 C15.050443,7.42222222 15.1115823,10.5333333 13.3894937,12.4222222 C10.2815823,15.8111111 4.74848101,14.7222222 4.74848101,14.7222222 C4.74848101,14.7222222 3.74987342,8.68888889 6.85778481,5.3 C7.72392405,4.36666667 8.86518987,3.91111111 10.0166456,3.93333333 Z M26.3510127,5.51111111 C25.515443,5.51111111 24.7308228,5.95555556 24.231519,6.68888889 L24.231519,5.97777778 C24.231519,5.84444444 24.1296203,5.73333333 24.0073418,5.73333333 L22.6418987,5.73333333 C22.5196203,5.73333333 22.4177215,5.84444444 22.4177215,5.97777778 L22.4177215,14 C22.4177215,14.1333333 22.5196203,14.2444444 22.6418987,14.2444444 L24.0073418,14.2444444 C24.1296203,14.2444444 24.231519,14.1333333 24.231519,14 L24.231519,9.2 C24.2824684,8.12222222 24.9651899,7.27777778 25.8007595,7.27777778 C26.6668987,7.27777778 27.3903797,8.06666667 27.3903797,9.11111111 L27.3903797,14 C27.3903797,14.1333333 27.4922785,14.244444",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,Attribution,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,OpenStreetMap,OpenStreetMap is a collaborative mapping project that creates a worldwide base map.,https://docs.mapbox.com/help/glossary/osm/,glossary,,,OpenStreetMap OpenStreetMap is a collaborative map of the world that creates a worldwide base map that anyone can contribute to. OpenStreetMap's data is free to share and use. The Mapbox Streets tileset source data is derived from OpenStreetMap. The routing network that powers our Directions API and related APIs is also based on OpenStreetMap. Was this page helpful? Yes No,,OpenStreetMap,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Feature count,Get the feature count inside a bounding box and highlight all the buildings.,https://docs.mapbox.com/android/maps/examples/count-features-in-a-selected-area/,example,Java,,"Feature count Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:id=""@+id/query_feature_count_map_container"" tools:context="".examples.query.FeatureCountActivity""> <RelativeLayout android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.73581"" mapbox:mapbox_cameraTargetLng=""-73.99155"" mapbox:mapbox_cameraZoom=""16""/> <FrameLayout android:id=""@+id/selection_box"" android:layout_width=""150dp"" android:layout_height=""150dp"" android:layout_centerInParent=""true"" android:alpha=""0.3"" android:background=""#A4A4E5""/> </RelativeLayout> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.query; import android.graphics.Color; import android.graphics.RectF; import android.os.Bundle; import androidx.annotation.NonNull; import com.google.android.material.snackbar.Snackbar; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.List; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; /** * Get the feature count inside of a bounding box and highlight all of the buildings in the box. */ public class FeatureCountActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_query_feature_count); // Define our views, ones the center box and the others our view container used for the // snackbar. final View selectionBox = findViewById(R.id.selection_box); final View viewContainer = findViewById(R.id.query_feature_count_map_container); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { style.addSource(new GeoJsonSource(""highlighted-shapes-source"")); // add a layer to the map that highlights the maps buildings inside the bounding box. style.addLayer( new FillLayer(""highlighted-shapes-layer"", ""highlighted-shapes-source"") .withProperties(fillColor(Color.parseColor(""#50667F"")))); // Toast instructing user to tap on the box Toast.makeText( FeatureCountActivity.this, getString(R.string.tap_on_feature_box_instruction), Toast.LENGTH_LONG ).show(); selectionBox.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // Perform feature query within the selectionBox. The bounding box is // calculated using the view but you can also use a map bounding box made up // of latitudes and longitudes. int top = selectionBox.getTop() - mapView.getTop(); int left = selectionBox.getLeft() - mapView.getLeft(); RectF box = new RectF(left, top, left + selectionBox.getWidth(), top + selectionBox.getHeight()); List<Feature> features = mapboxMap.queryRenderedFeatures(box, ""building""); // Show the features count Snackbar.make( viewContainer, String.format(getString(R.string.feature_count_snackbar_feature_size), features.size()), Snackbar.LENGTH_LONG).show(); GeoJsonSource source = style.getSourceAs(""highlighted-shapes-source""); if (source != null) { source.setGeoJson(FeatureCollection.fromFeatures(features)); } } }); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Feature count,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display a satellite map,Satellite raster baselayer.,https://docs.mapbox.com/mapbox-gl-js/example/satellite-map/,example,JavaScript,,Display a satellite map Satellite raster baselayer. Was this example helpful? Yes No,,Display a satellite map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Source limits in Mapbox Studio styles,Read about strategies for reducing the number of tileset sources in Mapbox Studio styles.,https://docs.mapbox.com/help/troubleshooting/reduce-tileset-sources/,troubleshooting,,,"Source limits in Mapbox Studio styles Styles made with the Mapbox Studio style editor or uploaded to your Mapbox account have a limit of 15 sources. If you try to add more than 15 sources to your style, you will receive the error message Failed to update style. Check number of sources used You can check the number of sources used in your style in the Mapbox Studio style editor. Open the style in the style editor, click on the Settings option in the top toolbar, and scroll to the Layer overview section. Your browser doesn't support embedded videos. Reduce the number of sources There are several strategies you can use to reduce the number of sources you're using in your style. Combine sources outside Mapbox Studio The most effective way to reduce the number of sources you're using in a style is to combine data from multiple data files or tilesets into a single tileset. You can do this in several ways: GIS application: Use a tool outside of Mapbox, such as QGIS or ArcGIS, to merge your geospatial data before you upload it to Mapbox. Tippecanoe: Use our open source command line tool, Tippecanoe, to add multiple data files to a single tileset source, export to MBTiles, and upload them all at once to Mapbox. Mapbox Studio Classic: Use our legacy desktop tool Mapbox Studio Classic to add multiple data files to a single tileset source, export to MBTiles, and upload them all at once to Mapbox. Learn more about creating sources with multiple data layers in the Mapbox Studio Classic Manual. Style combined sources Once you've combined sources, there are a few different ways to style the data in the Mapbox Studio style editor: Data-driven styling: You can use the style editor to assign styles based on your data's properties. Learn more about creating data-driven styles in the Mapbox Studio Manual styles section and our Make a choropleth map tutorial series. Filtering: As long as your data has properties that uniquely identify each of the original datasets, you can also use Mapbox Studio's filter functionality to create distinct style layers from a single tileset source. Learn more about filtering in the Mapbox Studio Manual styles section. Make sure source compositing is on Sources used in a Mapbox Studio style are composited, or combined, by default. Source compositing does not reduce the number of sources counted toward this limit, but if source compositing is on, tileset sources that are not being used in any style layers will automatically be removed from the composite source. To check whether source compositing is on, open your style in the style editor, click on the Settings option in the top toolbar, and scroll to the Source compositing section. Your browser doesn't support embedded videos. Was this page helpful? Yes No",,Source limits in Mapbox Studio styles,Reduce the number of sources,Combine sources outside Mapbox Studio,,Style combined sources,Make sure source compositing is on,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Location,Offical documentation about the Mapbox Android Location Layer Plugin. Show the Android device's location on a Mapbox Map in a few quick steps.,https://docs.mapbox.com/android/plugins/overview/location-layer/,guide,Java,,"Location The Mapbox Location Layer Plugin for Android has been deprecated Device location work is continuing in the LocationComponent class which is in the Mapbox Maps SDK for Android. Use the Maps SDK's LocationComponent instead of this Location Layer Plugin. See the Maps SDK LocationComponent documentation. Install the Location Layer Plugin To start developing an application using the Location Layer Plugin, you'll need to add the appropriate dependencies inside your build.gradle file. This dependency includes the Maps SDK for Android. You can find all dependencies given below on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-locationlayer-v7. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-locationlayer: 0.11.0 ' } Setup permissions Before using the location layer plugin, you'll need to include either the coarse or fine location permission inside your applications manifest. <manifest xmlns:android=""http://schemas.android.com/apk/res/android"" package=""com.example.myapp"" > ... <!-- Coarse location --> <uses-permission android:name=""android.permission.ACCESS_COARSE_LOCATION""/> <!-- Or fine location --> <uses-permission android:name=""android.permission.ACCESS_FINE_LOCATION""/> ... </manifest> If your application's targeting Android 6.0 (API 23) or higher, you'll want to use the new permissions model which request permissions at runtime rather than during the installation process. It's important to request the permission either during the application startup or when the location layer gets initialized. PermissionsManager is a utility offered as part of the Mapbox Java SDK package inside of the Maps SDK. It streamlines the permission request process. Lifecycles It's important to include the location layer onStart() and onStop() lifecycle events in their respective activity methods. This prevents memory leaks from occurring and reduces battery consumption. The plugin has support for the new LifecycleObserver APIs, by adding the plugin as a lifecycle observer in your activity, you won't need to handle the lifecycles manually. Add the location layer You'll need to pass in both a MapView and MapboxMap object to initialize the Location Layer Plugin. Depending on whether you'd like the plugin to track the user's location automatically or not, you can either use a default LocationEngine, pass in your own or null. Java Kotlin // Use the default engine LocationLayerPlugin locationLayerPlugin = new LocationLayerPlugin(mapView, mapboxMap); // Pass in your own LocationLayerPlugin locationLayerPlugin = new LocationLayerPlugin(mapView, mapboxMap, locationEngine); Copy If a null location engine is provided, you are responsible for updating the location position manually using LocationLayerPlugin#forceLocationUpdate(@Nullable Location location). Enabling or disabling the LocationLayerPlugin There is a single method to either enable or disable the plugin: LocationLayerPlugin#setLocationLayerEnabled(boolean isEnabled) When disabled, this method will hide the icon showing the user location and stop map camera animations from occurring. The plugin is enabled by default. Showing the user location with RenderMode LocationLayerPlugin#setLocationLayerEnabled() has now been replaced with LocationLayerPlugin#setRenderMode(@RenderMode.Mode int renderMode). This new method is not in charge of enabling or disabling the plugin. If you change the render mode while the plugin is disabled, nothing will happen with regard to how the location is rendered. There are three types of RenderMode: RenderMode Description NORMAL This mode shows the user location, ignoring both compass and GPS bearing (no arrow rendered). COMPASS This mode shows the user location, as well as an arrow that is considering the compass of the device. GPS This mode shows the user location with the icon bearing updated from the Location updates being provided to the plugin. RenderMode.NORMAL RenderMode.COMPASS RenderMode.GPS Note: the Drawable icon for RenderMode.GPS is highly customizable with methods such as LocationLayerOptions#foregroundDrawable() and LocationLayerOptions#backgroundDrawable(). Following the device location with CameraMode The method LocationLayerPlugin#setCameraMode(@CameraMode.Mode int cameraMode) allows developers to track Location updates with the MapboxMap camera. There are 7 modes available: CameraMode Description NONE No camera tracking. NONE_COMPASS Camera does not track location, but does track compass bearing. NONE_GPS Camera does not track location, but does track GPS Location bearing. TRACKING Camera tracks the user location, no bearing is considered. TRACKING_COMPASS Camera tracks the user location, tracking bearing provided by the device compass. TRACKING_GPS Camera tracks the user location, with bearing provided by a normalized Location#getBearing(). TRACKING_GPS_NORTH Camera tracks the user location, with bearing always set to north (0). Here are a few examples from the LocationLayerModesActivity in the plugin's test application: CameraMode.NORMAL CameraMode.COMPASS CameraMode.GPS Traditional camera transitions will be canceled when any of the camera modes, besides CameraMode#NONE, are engaged. Use LocationLayerPlugin#zoomWhileTracking and LocationLayerPlugin#tiltWhileTracking to manipulate the camera in a tracking state. Use these two in combination with MapboxMap#CancelableCallback to schedule fluid transitions. When instantiating the location layer plugin for the first time, the map's max/min zoom levels will be set toLocationLayerOptions#MAX_ZOOM_DEFAULT and LocationLayerOptions#MIN_ZOOM_DEFAULT respectively. Adjust the zoom range with the maxZoom() and minZoom() methods in the LocationLayerOptions class. Gesture thresholds to dismiss camera tracking The plugin is integrated with the Mapbox Gestures library. You have the option to adjust thresholds for tracking a user’s interaction with the map, and then, breaking camera tracking if the threshold is exceeded: LocationLayerOptions#trackingInitialMoveThreshold(float) adjusts the minimum single pointer movement in pixels required to break camera tracking. LocationLayerOptions#trackingMultiFingerMoveThreshold(float) adjusts minimum multi pointer movement in pixels required to break camera tracking (for example during scale gesture). If either of these thresholds are exceeded and tracking is dismissed, developers can listen to this with a OnCameraTrackingChangedListener: Java Kotlin locationLayerPlugin.addOnCameraTrackingChangedListener(new OnCameraTrackingChangedListener() { @Override public void onCameraTrackingDismissed() { // Tracking has been dismissed } @Override public void onCameraTrackingChanged(int currentMode) { // CameraMode has been updated } }); Copy Usage with navigation Once a navigation session has started using the Mapbox Navigation SDK, you will need to make a few adjustments to the plugin to improve its performance and behavior. If you plan to use the snapped location provided by the Navigation SDK, you'll need to use locationLayerPlugin.setLocationEngine() to null to prevent location coordinates that aren't snapped to update the icon's location. Instead, you'll need to add forceLocationUpdate() inside of the Navigation SDK's onProgressChange() callback, which does provide the snapped location. For more specific information and code snippets about displaying a user's location during the navigation experience, see the Mapbox tutorial for building a navigation app for Android. Customization The plugin allows for several customizations such as drawables, opacities, and more by passing in a style or a LocationLayerOptions object either while constructing the plugin or by using the provided applyStyle() API. For example, if you'd like to change the location layer icon from the default blue to a red, you first generate a new icon drawable showing the change. Then add the drawable to your project and then create a new style with the parentLayout being LocationLayer. Here is a list of all the attributes that can be customized. Was this page helpful? Yes No",,Location,Add the dependency,Setup permissions,Kotlin,Lifecycles,Add the location layer,Enabling or disabling the LocationLayerPlugin,Showing the user location with RenderMode,Following the device location with CameraMode,Gesture thresholds to dismiss camera tracking,Usage with navigation,Customization,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Join local JSON data with vector tile geometries,Style a choropleth by merging local JSON data with vector tile geometries.,https://docs.mapbox.com/mapbox-gl-js/example/data-join/,example,JavaScript,,Join local JSON data with vector tile geometries Style a choropleth by merging local JSON data with vector tile geometries. Was this example helpful? Yes No,,Join local JSON data with vector tile geometries,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a vector tile source,Add a vector source to a map.,https://docs.mapbox.com/mapbox-gl-js/example/vector-source/,example,JavaScript,,Add a vector tile source Add a vector source to a map. Was this example helpful? Yes No,,Add a vector tile source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Introduction,Get started with Mapbox Atlas.,https://docs.mapbox.com/atlas/overview/,guide,,,"Mapbox Atlas Current version: v 2.5.2 On-premises vector tile maps Offline Mapbox Studio Full suite of Mapbox APIs behind your firewall Contact us Mapbox Atlas allows you to run Mapbox global maps on your own infrastructure, including behind a firewall or completely offline. Atlas includes an offline instance of the Mapbox Studio style editor, vector tiles, and has built-in support for custom tilesets. This means that you can run the Mapbox Maps APIs and Studio on a specific server or virtual private cloud that you have complete control over, then deploy to your web, mobile, or AR app. Mapbox Atlas supports the latest Mapbox vector map technology, including Mapbox GL JS, so maps render quickly and are highly customizable. Atlas license To install and use Atlas, you must have a Mapbox user account with a valid Atlas license. Atlas ships with a single-user account that can be shared concurrently among many users. Need an Atlas license? Contact us to learn more. Atlas installer The Atlas installer is a command line interface (CLI) utility used to download and set up Atlas on a host server. The installer has many commands that can support different network topologies. The installer is available for both macOS and Linux. System requirements You can run the Mapbox Atlas server on the following operating systems: macOS* CentOS 7 Ubuntu 14.04 Ubuntu 16.04 Ubuntu 18.04 Red Hat Enterprise Linux 7 * Recommended for development only Tileset size Below are approximate sizes for each tileset. Exact tileset file sizes are subject to change with new data from weekly updates. Tileset Dev Production mapbox.mapbox-terrain-v2 450 MB 40 GB mapbox.mapbox-streets-v7 300 MB 100 GB mapbox.satellite-full 850 MB 260 GB mapbox.satellite-watermark 140 MB 7 GB Total 1.75 GB 407 GB Enterprise Boundaries Tileset size Below are approximate sizes for each Enterprise Boundaries tileset. Exact tileset file sizes are subject to change with new data from yearly updates. Tileset Production mapbox.enterprise-boundaries-a0-v2 1.45 GB mapbox.enterprise-boundaries-a1-v2 960.9 MB mapbox.enterprise-boundaries-a2-v2 903.1 MB mapbox.enterprise-boundaries-a3-v2 293.4 MB mapbox.enterprise-boundaries-a4-v2 82 MB mapbox.enterprise-boundaries-a5-v2 47.9 MB mapbox.enterprise-boundaries-aL-v2 439.7 MB mapbox.enterprise-boundaries-p1-v2 88.3 MB mapbox.enterprise-boundaries-p2-v2 159.4 MB mapbox.enterprise-boundaries-p3-v2 873.6 MB mapbox.enterprise-boundaries-p4-v2 944.4 MB mapbox.enterprise-boundaries-s1-v2 441.8 MB mapbox.enterprise-boundaries-s2-v2 219.8 MB mapbox.enterprise-boundaries-s3-v2 70.5 MB mapbox.enterprise-boundaries-s4-v2 35.4 MB Total 7.01 GB Hardware configuration We recommend the following hardware configurations. The development configuration is appropriate for testing and evaluating Atlas, and is not recommended for production workloads. Development Production 2 CPU 4 CPU 8 GB RAM 16 GB RAM 60 GB SSD 1000 GB SSD Connectivity requirements The Atlas installer has been specifically designed for situations in which the host server has no internet connectivity. You must run the installer's install or download command from a connected server to download required dependencies. Once the dependencies have been downloaded, they can be copied over to the host to complete the set up process. Was this page helpful? Yes No",,Mapbox Atlas,Atlas installer,System requirements,,Tileset size,Enterprise Boundaries Tileset size,Hardware configuration,Connectivity requirements,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Click on single layer,Click on and highlight a selected GeoJSON polygon.,https://docs.mapbox.com/android/maps/examples/click-on-a-single-layer/,example,Java,,"Click on single layer Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""50.503887"" mapbox:mapbox_cameraTargetLng=""4.46993599"" mapbox:mapbox_cameraZoom=""5"" /> </LinearLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.query; import android.graphics.PointF; import android.graphics.RectF; import android.os.Bundle; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.net.URI; import java.util.List; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; /** * Detect click events on a polygon that was added as a GeoJsonSource. */ public class ClickOnLayerActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapClickListener { private MapView mapView; private MapboxMap mapboxMap; private static final String geoJsonSourceId = ""geoJsonData""; private static final String geoJsonLayerId = ""polygonFillLayer""; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_click_on_layer); Toast.makeText(ClickOnLayerActivity.this, R.string.click_on_polygon_toast_instruction, Toast.LENGTH_SHORT).show(); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { ClickOnLayerActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { mapboxMap.addOnMapClickListener(ClickOnLayerActivity.this); addGeoJsonSourceToMap(style); // Create FillLayer with GeoJSON source and add the FillLayer to the map if (style != null) { style.addLayer(new FillLayer(geoJsonLayerId, geoJsonSourceId) .withProperties(fillOpacity(0.5f))); } } }); } @Override public boolean onMapClick(@NonNull LatLng point) { PointF pointf = mapboxMap.getProjection().toScreenLocation(point); RectF rectF = new RectF(pointf.x - 10, pointf.y - 10, pointf.x + 10, pointf.y + 10); List<Feature> featureList = mapboxMap.queryRenderedFeatures(rectF, geoJsonLayerId); if (featureList.size() > 0) { for (Feature feature : featureList) { Timber.d(""Feature found with %1$s"", feature.toJson()); Toast.makeText(ClickOnLayerActivity.this, R.string.click_on_polygon_toast, Toast.LENGTH_SHORT).show(); } return true; } return false; } private void addGeoJsonSourceToMap(@NonNull Style loadedMapStyle) { try { // Add GeoJsonSource to map loadedMapStyle.addSource(new GeoJsonSource(geoJsonSourceId, new URI(""https://gist.githubusercontent"" + "".com/tobrun/cf0d689c8187d42ebe62757f6d0cf137/raw/4d8ac3c8333f1517df9d303"" + ""d58f20f4a1d8841e8/regions.geojson""))); } catch (Throwable throwable) { Timber.e(""Couldn't add GeoJsonSource to map - %s"", throwable); } } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnMapClickListener(this); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Click on single layer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Offline routing,Mapbox offline navigation provides routing functionality from the Navigation SDK for Android in non-connected environments.,https://docs.mapbox.com/android/navigation/overview/offline-routing/,guide,Java,,"Offline routing SDKs covered: Navigation SDK Navigation UI SDK Downloading offline routing packs Access to offline routing is restricted to Mapbox Enterprise customers. If you're interested in moving to an Enterprise plan, contact us. Mapbox offline navigation provides routing functionality from the Navigation SDK in non-connected environments. In areas of no cellular connectivity, or on a device with no SIM card, end users can use turn-by-turn navigation and request new routes. If they go off-route, the system can reroute and keep them headed to their destination without requiring network connectivity. Offline routing moves the routing engine and the routing data from the server onto the end user’s device, so there’s no need to make HTTP API calls for routing information. For detailed information about the methods discussed in this guide, see the MapboxOfflineRouter documentation. Test offline routing Offline routing is restricted to Enterprise customers, and you need to get an Enterprise API token to download offline routing tiles for arbitrary regions. If you do not have an Enterprise access token but want to try out the feature and begin your integration, you can download routing tiles and generate routes on the Faroe Islands. If you don't have an Enterprise API token and try to download offline routing tiles for any region other than the Faroe Islands, you will receive an HTTP 402 response. Offline maps and offline routing To use offline routing with the Navigation SDK, we recommend that you also download offline map tiles with the Maps SDK for Android. The Maps SDK enables you to create offline maps, access a list of offline maps stored on the device, and remove offline maps that are no longer needed. We recommend downloading offline map tiles for the optimal user experience, but you could instead allow your users to build up a local cache of map tiles passively as they use your app. For more information on how to download offline maps, see the Offline maps documentation in the Maps SDK for Android API reference. Integrate offline routing in your app If you have installed the Navigation SDK's navigation components, Android Studio will find the router class after you add the navigation dependency. You must have permission to save files to use MapboxOfflineRouter. For example: <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE""/> Integrating offline routing in your app involves a few steps: Retrieve the list of available routing tile versions Before you download data, first you need to determine which tile version to download using MapboxOfflineRouter.fetchAvailableTileVersions. Each routing tile version in the list is returned as a string that you can sort by date. Versions with more recent dates have newer data than older versions do. Example use Java Kotlin offlineRouter.fetchAvailableTileVersions(Mapbox.getAccessToken(), new OnTileVersionsFoundCallback() { @Override public void onVersionsFound(List<String> availableVersions) { // Choose an available version for downloading tiles } @Override public void onError(@NonNull OfflineError error) { Toast.makeText(getApplicationContext(), ""Unable to get versions"", Toast.LENGTH_LONG).show(); } }); Copy Initialize the offline router and download offline routing tiles Downloading offline routing packs If you have already downloaded routing tiles of a specific version, you should keep using that version to avoid having to download an area again. This behavior, though, can vary depending on your use-case. For example, if you have a good connection, want to get the freshest data every day, and only need a small routing tile area, then you should be fine downloading tiles again. But if you have downloaded routing tiles for a large area, like the whole eastern United States, and now want to download tiles for another large area, like the western United States, we suggest you download the second area using the same tile version you used for the first. Tile versions cannot be mixed, as connectivity between them is not guaranteed. During instantiation, MapboxOfflineRouter takes an offlinePath parameter, which must be a valid path to a file system location with write permissions. If you see the error Error occurred downloading tiles: null file found, this is likely the result of passing an arbitrary string to MapboxOfflineRouter as an offlinePath, rather than a fully-qualified path to a file system location with write permissions. Next, you will update your app to use MapboxOfflineRouter.downloadTiles, which allows the app to get the data it needs for offline routing in the desired region. The MapboxOfflineRouter.downloadTiles method takes an OfflineTiles and a RouteTileDownloadListener. The Mapbox Navigation SDK for Android includes an example of downloading offline routing tiles in the Navigation SDK for Android example app. You can explore this example to see how to download offline routing tiles in an application. Example use Java Kotlin OfflineTiles builder = OfflineTiles.builder() .accessToken(Mapbox.getAccessToken()) .version(versionString) .boundingBox(boundingBox); MapboxOfflineRouter offlineRouter = MapboxOfflineRouter(offlinePath) offlineRouter.downloadTiles(builder.build(), new RouteTileDownloadListener() { @Override public void onError(@NonNull OfflineError error) { // Will trigger if an error occurs during the download } @Override public void onProgressUpdate(int percent) { // Will update with percent progress of the download } @Override public void onCompletion() { // Download has completed } }); Copy The offline dataset that is downloaded includes data for the following modes of travel: driving, cycling, and walking. Once the routing tile download is finished, the downloaded routing tiles are unpacked onto local storage. Configure MapboxOfflineRouter with offline data MapboxOfflineRouter has a public method MapboxOfflineRouter#configure(String version, OnOfflineTilesConfiguredCallback callback). This method indexes all the data present on a device at the time the method is called. This means it must be called on every MapboxOfflineRouter object before requesting a route. You must wait for the callback to return before requesting a route. Example use Java Kotlin MapboxOfflineRouter offlineRouter = new MapboxOfflineRouter(offlinePath); offlineRouter.configure(versionString, new OnOfflineTilesConfiguredCallback() { @Override public void onConfigured(int numberOfTiles) { // Fetch offline route } @Override public void onConfigurationError(@NonNull OfflineError error) { // Report error } }); Copy Create an offline DirectionsRoute Update your app to use the MapboxOfflineRouter.findRoute method to create a DirectionsRoute. This method takes a OfflineRoute class and a RouteFoundCallback. The callback will be called with either a route or an error. Example use Java Kotlin NavigationRoute.Builder onlineRouteBuilder = NavigationRoute.builder(this) .origin(origin) .destination(destination) .accessToken(accessToken); OfflineRoute offlineRoute = OfflineRoute.builder(onlineRouteBuilder).build(); offlineRouter.findRoute(offlineRoute, new OnOfflineRouteFoundCallback() { @Override public void onRouteFound(@NonNull DirectionsRoute route) { // Start navigation with route } @Override public void onError(@NonNull OfflineError error) { // Handle route error } }); Copy Rerouting When the SDK detects that the user has diverged from the route, the app can use MapboxOfflineRouter to find a new route to the original destination. Having routing data on the client device means new routes are generated without having to go back to the server to calculate and retrieve a route. As long as the user is still within the boundaries of the offline routing data, they can trigger a re-route event or request a new route anywhere within the dataset. Example re-route scenario with MapboxNavigation Java Kotlin navigation.addOffRouteListener(new OffRouteListener() { @Override public void userOffRoute(Location location) { ... OfflineRoute offlineRoute = OfflineRoute.builder(onlineRouteBuilder).build(); offlineRouter.findRoute(offlineRoute, new OnOfflineRouteFoundCallback() { @Override public void onRouteFound(@NonNull DirectionsRoute route) { // Call MapboxNavigation#startNavigation with successful response } @Override public void onError(@NonNull OfflineError error) { // Handle route error } }); } }); Copy Example re-route scenario with NavigationView Java Kotlin @Override public boolean allowRerouteFrom(Point offRoutePoint) { // Fetch new route with MapboxOfflineRouter // Create new options with offline route NavigationViewOptions options = NavigationViewOptions.builder() .directionsRoute(offlineDirectionsRoute) .build(); navigationView.startNavigation(options); // Ignore internal routing, allowing offline route return false; } Copy Estimated local storage and memory benchmarks The device will need to store both the routing data and the map data needed for visual display. For more information on managing offline download size, see the Offline maps troubleshooting guide. Local storage The road network density of given geographic areas varies widely, but we have provided a list of benchmark estimates below, created via a bounding box encompassing the region listed. As the data needs to be uncompressed on disk for faster routing, it shows non-compressed estimates. Download sizes will be smaller after compression. Example region size Routing data Map data (z1-7,12) Washington, DC 41MB 120B San Francisco (city and county) 57MB 20MB California 377MB 400MB New York (state) 475MB 300MB USA (minus HI and AK) 3.8GB 5GB United Kingdom 663MB 290MB Memory For a typical route calculation in a geographic area, the amount of memory needed will vary depending on the complexity of route generation in that area. The following estimates were created using data from some of the largest cities to give a worst-case value. Region size RAM needed San Francisco (city and county) 100MB California 150MB USA (minus HI and AK) 250MB Was this page helpful? Yes No",,Offline routing,Offline maps and offline routing,Integrate offline routing in your app,Kotlin,Retrieve the list of available routing tile versions,Example use,Initialize the offline router and download offline routing tiles,Configure MapboxOfflineRouter with offline data,Create an offline DirectionsRoute,Rerouting,Example re-route scenario with MapboxNavigation,Example re-route scenario with NavigationView,,Estimated local storage and memory benchmarks,Local storage,Memory,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Apply a style designed in Mapbox Studio,Use a style created in Mapbox Studio with the Mapbox Maps SDK for iOS.,https://docs.mapbox.com/ios/maps/examples/custom-style/,example,Swift,,"Apply a style designed in Mapbox Studio Read the Mapbox Studio manual to learn more about creating a custom map style. For raster maps created with legacy Mapbox tools, see the Apply a style designed in Mapbox Studio Classic example. Swift Objective C import Mapbox class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Replace the string in the URL below with your custom style URL from Mapbox Studio. // Read more about style URLs here: https://www.mapbox.com/help/define-style-url/ let styleURL = URL(string: ""mapbox://styles/mapbox/outdoors-v9"") let mapView = MGLMapView(frame: view.bounds, styleURL: styleURL) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] // Set the map’s center coordinate and zoom level. mapView.setCenter(CLLocationCoordinate2D(latitude: 45.52954, longitude: -122.72317), zoomLevel: 14, animated: false) view.addSubview(mapView) } } Copy Was this page helpful? Yes No",,Apply a style designed in Mapbox Studio,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Vector tiles,Mapbox Streets v5,Reference documentation for the Mapbox Streets v5 tileset.,https://docs.mapbox.com/vector-tiles/reference/mapbox-streets-v5/,reference,,,"Mapbox Streets v5 Source id: mapbox.mapbox-streets-v5 Update to Mapbox Streets v8 We recommend moving to Mapbox Streets v8 for additional features and improvements. Mapbox Streets v5 no longer receives data updates from OpenStreetMap. This is an in-depth guide the data inside the Mapbox Streets vector tile source to help with styling. For a complete and documented example of using Mapbox Streets vector tiles to style a Mapbox Studio Classic project, see the OpenStreetMap Bright project for Mapbox Studio Classic. Overview OpenStreetMap Mapbox Streets vector tiles are largely based on data from OpenStreetMap, a free & global source of geographic data built by volunteers. An understanding of the OpenStreetMap data structure and tagging system is not necessary to make use of Mapbox Streets vector tiles, though it's helpful to understand some of the details. When you publicly use styles or software that uses Mapbox Streets vector tiles you must display proper attribution. Name fields There are 5 different name fields for each of the label layers: Field Description name The name (or names) used locally for the place. name The name (or names) used locally for the place. name_en English (if available, otherwise same as name) name_es Spanish (if available, otherwise same as name_en) name_fr French (if available, otherwise same as name_en) name_de German (if available, otherwise same as name_en) OpenStreetMap IDs Most layers in the Mapbox Streets vector tile source have an osm_id field. The values for this field are integers based on the IDs assigned to objects in the main OpenStreetMap database. With raw OpenStreetMap IDs it's possible for two different objects of different types to share the same ID, but the Mapbox osm_id is modified such that a layer containing a mix of object types will not contain any duplicate IDs. The following modification rules are in place, providing non-overlapping IDs to work with while keeping the original IDs simple to deduce at a glance. Original OpenStreetMap object Vector tile geometry ID transform Example node point original + 1015 123 → 1000000000000123 way line none 123 → 123 way polygon, point original + 1012 123 → 1000000000123 relation line original + 2×1012 123 → 2000000000123 relation polygon, point original + 3×1012 123 → 3000000000123 Some objects in the vector tiles are the result of merging multiple OpenStreetMap objects. In these cases, the osm_id will be based on one of the original IDs (and there is no guarantee about which one). Some objects are not from OpenStreetMap at all, or processed in such a way that the original OpenStreetMap IDs are unknown (for example ocean polygons). In these cases, the osm_id will be 0. Boolean fields Some fields represent a boolean condition; the value may be either true or false. To keep the vector tiles compact these fields are stored as integers, where 0 = false and 1 = true. CartoCSS examples: #admin[dispute=1] { /* boundaries that are disputed */ } #road[oneway=0] { /* roads that are not one-way */ } Multiple geometry types Mapnik vector tiles support multiple geometry types in the same layer. The Mapbox Streets source takes advantage of this for some layers. A geometry in the vector tile can be one of 3 types: Point Linestring / multilinestring Polygon / multipolygon In CartoCSS you can select one or two of the 3 types by filtering on the special mapnik::geometry_type property. CartoCSS examples: #layer['mapnik::geometry_type'=1] { /* point styles */ } #layer['mapnik::geometry_type'=2] { /* line styles */ } #layer['mapnik::geometry_type'=3] { /* polygon styles */ } Data updates The current supported version of the Mapbox Streets vector tiles receives regular data updates as new information becomes available and existing information is improved. Layer Source most layers OpenStreetMap replication feed #admin custom OpenStreetMap processing #water (ocean parts) OpenStreetMap Data #marine_label, #country_label, #country_label_line, #state_label custom data Layer Reference #landuse buffer: 4 This layer includes polygons representing both land-use and land-cover. It's common for many different types of landuse/landcover to be overlapping, so the polygons in this layer are ordered by the area of their geometries to make sure smaller objects will not be obscured by larger ones. Pay attention to use of transparency when styling - the overlapping shapes can cause muddied or unexpected colors. Classes The main field used for styling the landuse layer is class. Value Description agriculture Various types of crop and farmland cemetery Cemeteries and graveyards glacier Glaciers or permanent ice/snow grass Grasslands, meadows, fields, lawns, etc hospital Hospital grounds industrial Only includes airport areas park City parks, village greens, playgrounds, national parks, nature reserves, etc pitch Sports fields & courts of all types rock Bare rock, scree, quarries sand Sand, beaches, dunes school Primary, secondary, post-secondary school grounds scrub Bushes, scrub, heaths wood Woods and forestry areas #waterway buffer: 4 The waterway layer contains rivers, streams, canals, etc represented as lines. Waterway classes can represent a wide variety of possible widths. Since larger rivers and canals are usually also represented by polygons in the #water layer, make your line styling biased toward the smaller end of the scales. Classes and types The waterway layer has two fields for styling - class and type - each with similar values. Value Description river Everything from the Amazon down to small creeks a couple meters wide canal Medium to large artificial waterway stream Very small waterway, usually no wider than a meter or two stream_intermittent Class only. A stream that does not always have water flowing through it. drain Medium to small artificial channel for rainwater drainage, often concrete lined. ditch Small artificial channel dug in the ground for rainwater drainage. CartoCSS example: #waterway { [class='stream'], [class='stream_intermittent'] { line-color: #ace; line-width: 2; } [class='stream_intermittent'] { line-dasharray, 4, 2; } } #water buffer: 8 This is a simple polygon layer with no differentiating types or classes. The tileset filters and simplifies water bodies according to scale. It only shows oceans and large lakes at the lowest zoom levels, while smaller and smaller lakes and ponds appear as you zoom in. Water polygons sometimes have overlapping pieces with each other, so avoiding CartoCSS styles such as polygon-opacity and most polygon-comp-op values is recommended. Instead, use the style-level properties opacity and comp-op. Drawing outlines on water can be tricky. Since rivers and lakes are often broken into multiple pieces you can end up with seams in the middle of water bodies. A common CartoCSS pattern to avoid this is this blur method to create an inner-glow effect: #water { ::shadow { polygon-fill: #07f; } ::fill { // a white fill and overlay comp-op lighten the polygon-fill from ::shadow. polygon-fill: #fff; comp-op: soft-light; // blurring reveals the polygon fill from ::shadow around the edges of the water image-filters: agg-stack-blur(2,2); } } #aeroway buffer: 4 The aeroway layer includes both lines and polygons representing runways, helipads, etc. Types The type field separates different types of aeroways for styling. Value Description runway Where planes take off & land taxiway Where planes move between runways, gates, and hangars apron Where planes park, refuel, load helipad Where helicopters take off & land CartoCSS example: #aeroway { ['mapnik::geometry_type'=2] { line-color: #888; [type='runway'] { line-width: 3; } } ['mapnik::geometry_type'=3] { polygon-fill: #888; } } #barrier_line buffer: 4 This layer includes lines and polygons for barriers - things such as walls and fences. Classes Value Description cliff The precipice of a vertical or steep drop fence Include various types of fence and wall barriers gate Only gates that are lines or areas are included hedge land Includes breakwaters and piers Cliff data from OpenStreetMap is designed such that the left-hand side of the line is the top of the cliff, and the right-hand side is the bottom. See the Line patterns with images section of the TileMill Styling Lines guide for how to design an appropriate image pattern for cliffs. CartoCSS example: #barrier_line[class='fence'] { line-color: #864; } #barrier_line[class='hedge'] { line-color: #aec; } #building buffer: 2 This is a simple polygon layer with no differentiating types or classes. Large buildings appear at zoom level 13, and all buildings are included in zoom level 14 and up. CartoCSS example: #building { polygon-fill: #eca; line-color: #864; } #landuse_overlay buffer: 4 This layer is for landuse / landcover polygons that your style should draw above the #water layer. Classes The main field used for styling the landuse_overlay layer is class. Value Description wetland Wetlands that may include vegetation (marsh, swamp, bog) wetland_noveg Wetlands that probably don't contain vegetation (mud, tidal flat) CartoCSS example: #landuse_overlay[class='wetland'] { polygon-pattern-file: url(""./icons/wetland.png""); } #tunnel, #road, #bridge buffer: 4 The roads layers are some of the most complex ones in Mapbox Streets. Starting at zoom level 12, the tileset breaks tunnels and bridges out of the #road layer into either #tunnel or #bridge. Classes The main field used for styling the tunnel, road, and bridge layers is class. Value Description motorway High-speed, grade-separated highways motorway_link Interchanges / on & off ramps main Trunk, primary, secondary, and tertiary roads & links lumped together for simpler styling. street Standard unclassified or residential streets street_limited Streets that may have limited or no access for motor vehicles. Pedestrian streets, roads under construction, private roads, etc. service Access roads, alleys, agricultural tracks, and other services roads. driveway For local access. Includes parking lot aisles, public & private driveways path Foot paths, cycle paths, ski trails. major_rail Railways, including mainline, commuter rail, and rapid transit. minor_rail Yard and service railways. aerialway Ski lifts, gondolas, and other types of aerialway. golf The approximate centerline of a golf course hole One-way roads A oneway field indicates whether the motor traffic on the road is one-way or not. If the road is one-way, traffic travels in the same direction as the linestring. CartoCSS example: #road[oneway=1] { marker-file: url(shape://arrow); marker-fill: red; } Types The type field is the value of the road's ""primary"" OpenStreetMap tag. For most roads this is the highway tag, but for aerialways it will be the aerialway tag, and for golf holes it will be the golf tag. See TagInfo for a list of used tag values. Layers The layer field is used to determine drawing order of overlapping road segments in the tunnel and bridge layers. 95% of values are -1, 1, or 0, and 99.9999% of values are between -5 and 5. If you want to make sure proper ordering of overlapping bridges when dealing with styles that involve road casing, you'll need to manually add some extra code to your project.yml. The layer field is intended to be used by this feature, not in your CartoCSS styles directly. project.yml: _properties: bridge: ""group-by"": layer # ... #admin buffer: 4 Administrative boundary lines. These are constructed from the OpenStreetMap data in such a way that there are no overlapping lines where multiple boundary areas meet. Administrative level The admin_level field separates different levels of boundaries, using the same numbering scheme as OpenStreetMap. See admin_level for details about what the different values translate to in different countries. Value Description 2 countries 3 regions (not commonly used) 4 states, provinces, etc. Disputes The disputed field should be used to apply a dashed or otherwise distinct style to disputed boundaries. No single map of the world will ever keep everybody happy, but acknowledging disputes where they exist is an important aspect of good cartography. CartoCSS example: #admin[admin_level=2] { line-width: 2; [dispute=1] { line-dasharray: 4, 4; } } Maritime boundaries The maritime field can be used as a filter to downplay or hide maritime boundaries, which are often not shown on maps. Note that the practice of tagging maritime boundaries is not entirely consistent or complete within OpenStreetMap, so some boundaries may not have this field set correctly (this mostly affects admin levels 3 & 4). CartoCSS example: #admin { [maritime=0] { line-color: black; } [maritime=1] { line-color: blue; } } #country_label_line buffer: 2 This layer contains lines used as label leader lines for some country labels at low zoom levels. There are no data fields for this layer - only a single, simple line style is needed. CartoCSS example: #country_label_line { line-color: #333; } #country_label buffer: 256 This layer contains points used for labeling countries. The points are placed for minimal overlap with small to medium-sized text. Names See Name fields in the overview for information about names and translations. Scalerank The scalerank field is intended to help assign different label styles based on the size and available room to label different countries. CartoCSS example: #country_label { text-name: [name_en]; text-face-name: 'Open Sans Semibold'; text-size: 10; [scalerank=0] { text-size: 14; } [scalerank=1] { text-size: 13; } [scalerank=2] { text-size: 12; } [scalerank=3] { text-size: 11; } } #marine_label buffer: 256 Points and lines for labeling major marine features such as oceans, seas, large lakes & bays. Names See Name fields in the overview for information about names and translations. Labelrank & placement The labelrank field is intended to help assign different label styles based on the size and available room to label different water bodies. The possible values are whole numbers 1 through 6. The value of the placement field will be either point or line depending on the geometry type of the object. CartoCSS example: #marine_label { text-name: [name_en]; text-face-name: 'Merriweather Italic'; placement: point; [placement='line'] { placement: line; } text-size: 12; [labelrank=0] { text-size: 20; } [labelrank=1] { text-size: 18; } [labelrank=2] { text-size: 16; } [labelrank=3] { text-size: 15; } [labelrank=4] { text-size: 14; } [labelrank=5] { text-size: 13; } } #state_label buffer: 256 Points for labeling states and provinces. Only a small number of countries are included. Names See Name fields in the overview for information about names and translations. Area The area field is the physical area of the entity in square kilometers. Use it to help filter and size your state labels at different zoom levels. CartoCSS example: #state_label { text-name: [name]; text-face-name: 'Open Sans Regular'; text-size: 12; [area>=10000] { text-size: 14; } [area>=500000] { text-size: 16; } [area>=1000000] { text-size: 18; } #place_label buffer: 128 This layer contains points for labeling human settlements. Names See Name fields in the overview for information about names and translations. Types The main field for styling labels for different kinds of places is type. Value Description city Settlement of about 100,000 or more people. town Urban or rural settlement of about 10,000-100,000 people village Usually rural settlement of less than about 10,000 hamlet Rural settlement with a population of about 200 or fewer suburb A distinct section of an urban settlement such as an annexed town, historical district, or large & important neighborhood. neighbourhood A named part of a larger settlement Capitals The capital field allows distinct styling of labels or icons for the capitals of countries, regions, or states & provinces. capital limited integer 2 National capital 3 Regional capital (uncommon) 4 State / provincial capital CartoCSS example: #place_label { [capital=2] { marker-file: url(""./icons/star-national.svg""); } [capital=3] { marker-file: url(""./icons/star-region.svg""); } [capital=4] { marker-file: url(""./icons/star-state.svg""); } } Scalerank The scalerank field can be used to adjust the prominence of label styles for larger and more prominent cities. The value number from 0 through 9, where 0 is the large end of the scale (for example New York City). All places other than large cities will have a scalerank of null. CartoCSS example: #place_label[type='city] { text-name: [name]; text-face-name: 'Open Sans Regular'; text-size: 12; [scalerank>=0][scalerank<=2] { text-size: 18; } [scalerank>=3][scalerank<=4] { text-size: 16; } [scalerank>=5][scalerank<=6] { text-size: 14; } [scalerank>=7][scalerank<=8] { text-size: 13; } } Localrank The localrank field can be used to adjust the label density by showing fewer labels. This method is preferred to CartoCSS's text-min-distance because it leads to far fewer labels clipped across tile boundaries. It is a whole number greater than 0 calculated by grouping places into a 128 pixel grid at each zoom level, then assigning each place a ranking within that grid. The most important place in that 128 pixels will get a localrank of 1, the second most important is 2, and so on. So to reduce the label density to 4 labels per tile, you can add the filter [localrank=1]. CartoCSS example: #place_label[localrank<=1] { text-name: [name]; text-face-name: 'Open Sans Regular'; } Label direction The ldir field can be used as a hint for label offset directions at lower zoom levels. For places with a scalerank value set, the ldir will be a cardinal direction such as N, E, SW. CartoCSS example: #place[type='city'] { text-name: [name]; text-face-name: 'Open Sans Regular'; text-placement-type: simple; text-dx: 3; text-dy: 3; [ldir='N'] { text-placements: 'N'; } [ldir='NE'] { text-placements: 'NE'; } [ldir='E'] { text-placements: 'E'; } [ldir='SE'] { text-placements: 'SE'; } [ldir='S'] { text-placements: 'S'; } [ldir='SW'] { text-placements: 'SW'; } [ldir='W'] { text-placements: 'W'; } [ldir='NW'] { text-placements: 'NW'; } } #water_label buffer: 64 This layer contains points for labeling bodies of water such as lakes and ponds. Names See Name fields in the overview for information about names and translations. Area The area field holds the area of the associated water polygon in square meters (Mercator-projected units rounded to the nearest whole number, not real-world area). You can use it to adjust label size and visibility. CartoCSS example: #water_label { [zoom<=15][area>=200000], [zoom=16][area>=50000], [zoom=17][area>=10000], [zoom>=18][area>0] { text-name: [name]; text-face-name: 'Open Sans Regular'; } } #poi_label buffer: 64 This layer is used to place icons and labels for various points of interest (POIs). Names See Name fields in the overview for information about names and translations. Maki icons The maki field is designed to make it easier to add icons to POIs using the Maki icon project, or with other icons that follow the same naming scheme. CartoCSS example: #poi_label[maki!=null] { marker-file: url(""icons/[maki].svg""); } Not all Maki icons are used, and different types of related POIs will sometimes have the same maki value (for example universities and colleges, or art supply shops and art galleries). The possible values for the maki field are listed below. null 'airport' 'airfield' 'alcohol-shop' 'art-gallery' 'bakery' 'bank' 'bar' 'beer' 'bicycle' 'bus' 'cafe' 'car' 'campsite' 'cemetery' 'cinema' 'clothing-store' 'college' 'dog-park' 'embassy' 'entrance' 'fast-food' 'ferry' 'fire-station' 'fuel' 'garden' 'golf' 'grocery' 'harbor' 'heliport' 'hospital' 'laundry' 'library' 'lodging' 'monument' 'museum' 'music' 'park' 'pharmacy' 'camera' 'place-of-worship' 'rail' 'rail-light' 'rail-metro' 'religious-christian' 'religious-jewish' 'religious-muslim' 'police' 'post' 'prison' 'restaurant' 'school' 'shop' 'swimming' 'theatre' 'town-hall' 'suitcase' 'zoo' Type The type field contains a more specific classification intended for display - for example 'Cafe', 'Hotel', 'Laundry'. These values come from the original OpenStreetMap tags and are not a limited set. Scalerank The scalerank field is intended to help assign different label styles based on the prominence of different features. Value Description 1 The POI has a large area 2 The POI has a medium-large area 3 The POI has a small area, or is of a type that is commonly large and important (for example hospital, university) 4 The POI has no known area Controlling label density The localrank field can be used to adjust the label density by showing fewer labels. This method is preferred to CartoCSS's text-min-distance because it leads to far fewer labels clipped across tile boundaries. It is a whole number >=1 calculated by grouping places into a ~300m projected grid, then assigning each place a ranking within that grid. The most important place in each cell will get a localrank of 1, the second most important is 2, and so on. CartoCSS example: #poi_label { [zoom=15][localrank<=1], [zoom=16][localrank<=2], [zoom=17][localrank<=4] { /* icon styles */ } } Rail station networks The network field is aimed at helping assign icons for rail stations - the value will be null for all other types of POIs. They don't necessarily correspond to a specific network - for example u-bahn applies to any U-Bahn network in Germany. Some stations serve multiple networks; in these cases, multiple network names are joined with a dot (in alphabetical order). Value Description null POI is not a rail station rail Default rail station subway Default subway/metro station light Default light rail station dlr Docklands Light Rail, London, UK dlr.london-overground.london-underground.national-rail London, UK dlr.london-underground London, UK dlr.london-underground.national-rail London, UK dlr.national-rail London, UK london-overground London Overground, UK london-overground.london-underground London, UK london-overground.london-underground.national-rail London, UK london-overground.national-rail London, UK london-underground London Underground, UK london-underground.national-rail London, UK national-rail UK washington-metro Washington DC Metro wiener-linien Vienna, Austria metro Paris Metro, France rer Paris regional commuter rail, France metro.rer Paris, France transilien Paris suburban rail, France rer.transilien Paris, France moscow-metro Moscow Metro, Russia s-bahn Germany u-bahn Germany s-bahn.u-bahn Germany Additional information The ref field is a short reference code that can be used as an alternative name. It is only used for airports. #road_label buffer: 64 Names See Name fields in the overview for information about names and translations. Route numbers Besides the standard name fields, there is also a ref field that holds any reference codes or route numbers a road may have. To aid with shield styling in TileMill and Mapnik, the reflen field conveys the number of characters present in the ref field. If the ref is 'I 95', then the reflen is 4. CartoCSS example: #road_label[reflen>=1] { shield-name: [ref]; shield-face-name: 'Open Sans Regular'; shield-file: url(""./img/shield-[reflen].png""); } Classes The class field for road labels matches the #tunnel, #road, & #bridge layers. Value Description motorway High-speed, grade-separated highways main Trunk, primary, secondary, and tertiary roads & links lumped together for simpler styling. street Standard unclassified or residential streets street_limited Streets that may have limited or no access for motor vehicles. Pedestrian streets, roads under construction, private roads, etc. service Access roads, alleys, agricultural tracks, and other services roads. path Foot paths, cycle paths, ski trails. aerialway Ski lifts, gondolas, and other types of aerialway. golf The approximate centerline of a golf course hole Additional information The len field stores the length of the road segment in projected meters, rounded to the nearest whole number. This can be useful for limiting some label styles to longer roads. #waterway_label buffer: 64 This layer contains line geometries that match those in the #waterway layer but with name fields for label rendering. Label text See Name fields in the overview for information about names and translations. Classes & types The class and type fields match those in the #waterway layer. Value Description river Everything from the Amazon down to small creeks a couple meters wide canal Medium to large artificial waterway stream Very small waterway, usually no wider than a meter or two stream_intermittent Class only. A stream that does not always have water flowing through it. drain Medium to small artificial channel for rainwater drainage, often concrete lined. ditch Small artificial channel dug in the ground for rainwater drainage. #housenum_label buffer: 64 This layer contains points used to label the street number parts of specific addresses. The house_num field contains house and building numbers. These are commonly integers but may include letters or be only letters, for example ""1600"", ""31B"", ""D"". If an address has no number tag but has a house name or building name, the house_num field will be the name instead. CartoCSS example: #housenum_label { text-name: [house_num]; text-face-name: 'Open Sans Regular'; } Changelog A summary of the changes from v4: New class field added in the #waterway layer. You can safely ignore this change when upgrading styles from v4 New maki values in the #poi_label layer: bakery, camera, car, clothing-store, dog-park, entrance, laundry, rail-light, rail-metro, suitcase. If upgrading a v4 style that uses [maki] in a URL expression (for example marker-file), you will need to make sure to add files to match the new values. New network values in the #poi_label layer: wiener-linien, metro, rer, metro.rer, transilien, rer.transilien, moscow-metro, s-bahn, u-bahn, sbahn.u-bahn. If upgrading a v4 style that uses [network] in a URL expression (for example marker-file), you will need to make sure to add files to match the new values. New #housenum_label layer for labeling house and building numbers. You can safely ignore this change when upgrading styles from v4 New localrank field in the #place_label layer. When upgrading styles from v4 it is recommended to remove any text-min-distance styles from you place labels and use localrank to control label density. New class values in the #landuse layer: agriculture, glacier, grass, piste, rock, scrub. When upgrading styles from v4, look for catch-all styles that may have unexpected results for unhandled values (for example dark gray polygon fills, black outlines). In the #road_label layer, the ref field is now available for all road types. Before it was only available for motorways. For most style upgrades from it should be safe to ignore this change, though there may be edge cases where action is needed. The #marine_label layer now contains actual point geometries so you can use ['mapnik::geometry_type'=1] instead of [placement='point']. The tileset keeps placement for backwards-compatibility, but no action is necessary for this change when upgrading styles from v4. New capital field added in the #place_label layer to identify cities that are the capitals of countries, regions, or states/provinces. You can safely ignore this change when upgrading styles from v4. Was this page helpful? Yes No",,Mapbox Streets v5,OpenStreetMap,Name fields,,OpenStreetMap IDs,Boolean fields,Multiple geometry types,Data updates,Layer Reference,#landuse,Classes,#waterway,,Classes and types,#water,#aeroway,Types,#barrier_line,#building,#landuse_overlay,"#tunnel, #road, #bridge",One-way roads,Layers,#admin,Administrative level,Disputes,Maritime boundaries,#country_label_line,#country_label,Names,Scalerank,#marine_label,Labelrank & placement,#state_label,Area,#place_label,Capitals,Localrank,Label direction,#water_label,#poi_label,Maki icons,Type,Controlling label density,Rail station networks,Additional information,#road_label,Route numbers,#waterway_label,Label text,Classes & types,#housenum_label,Changelog,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,RecyclerView interaction,Manipulate the map based on recyclerview interactions.,https://docs.mapbox.com/android/maps/examples/recyclerview-interaction/,example,Java,,"RecyclerView interaction Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""-34.598172"" mapbox:mapbox_cameraTargetLng=""-58.374867"" mapbox:mapbox_cameraZoom=""12"" /> <androidx.recyclerview.widget.RecyclerView android:id=""@+id/rv_on_top_of_map"" android:layout_width=""match_parent"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom"" android:layout_marginBottom=""32dp"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.graphics.BitmapFactory; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.cardview.widget.CardView; import androidx.recyclerview.widget.DefaultItemAnimator; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.LinearSnapHelper; import androidx.recyclerview.widget.RecyclerView; import androidx.recyclerview.widget.SnapHelper; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.List; import java.util.Random; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; /** * Use a recyclerview with a Mapbox map to easily explore content all on one screen */ public class RecyclerViewOnMapActivity extends AppCompatActivity implements OnMapReadyCallback { private static final String SYMBOL_ICON_ID = ""SYMBOL_ICON_ID""; private static final String SOURCE_ID = ""SOURCE_ID""; private static final String LAYER_ID = ""LAYER_ID""; public MapboxMap mapboxMap; private MapView mapView; private FeatureCollection featureCollection; private LatLng[] coordinates = new LatLng[] { new LatLng(-34.6054099, -58.363654800000006), new LatLng(-34.6041508, -58.38555650000001), new LatLng(-34.6114412, -58.37808899999999), new LatLng(-34.6097604, -58.382064000000014), new LatLng(-34.596636, -58.373077999999964), new LatLng(-34.590548, -58.38256609999996), new LatLng(-34.5982127, -58.38110440000003) }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_recycler_view_on_map); // Initialize the map view mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { RecyclerViewOnMapActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { initFeatureCollection(); initMarkerIcons(style); initRecyclerView(); Toast.makeText(RecyclerViewOnMapActivity.this, R.string.toast_instruction, Toast.LENGTH_SHORT).show(); } }); } private void initFeatureCollection() { featureCollection = FeatureCollection.fromFeatures(new Feature[] {}); List<Feature> featureList = new ArrayList<>(); if (featureCollection != null) { for (LatLng latLng : coordinates) { featureList.add(Feature.fromGeometry(Point.fromLngLat(latLng.getLongitude(), latLng.getLatitude()))); } featureCollection = FeatureCollection.fromFeatures(featureList); } } private void initRecyclerView() { RecyclerView recyclerView = findViewById(R.id.rv_on_top_of_map); LocationRecyclerViewAdapter locationAdapter = new LocationRecyclerViewAdapter(createRecyclerViewLocations(), mapboxMap); recyclerView.setLayoutManager(new LinearLayoutManager(getApplicationContext(), LinearLayoutManager.HORIZONTAL, true)); recyclerView.setItemAnimator(new DefaultItemAnimator()); recyclerView.setAdapter(locationAdapter); SnapHelper snapHelper = new LinearSnapHelper(); snapHelper.attachToRecyclerView(recyclerView); } private void initMarkerIcons(@NonNull Style loadedMapStyle) { loadedMapStyle.addImage(SYMBOL_ICON_ID, BitmapFactory.decodeResource( this.getResources(), R.drawable.red_marker)); loadedMapStyle.addSource(new GeoJsonSource(SOURCE_ID, featureCollection)); loadedMapStyle.addLayer(new SymbolLayer(LAYER_ID, SOURCE_ID).withProperties( iconImage(SYMBOL_ICON_ID), iconAllowOverlap(true), iconOffset(new Float[] {0f, -4f}) )); } private List<SingleRecyclerViewLocation> createRecyclerViewLocations() { ArrayList<SingleRecyclerViewLocation> locationList = new ArrayList<>(); for (int x = 0; x < coordinates.length; x++) { SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation(); singleLocation.setName(String.format(getString(R.string.rv_card_name), x)); singleLocation.setBedInfo(String.format(getString(R.string.rv_card_bed_info), new Random().nextInt(coordinates.length))); singleLocation.setLocationCoordinates(coordinates[x]); locationList.add(singleLocation); } return locationList; } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } /** * POJO model class for a single location in the recyclerview */ class SingleRecyclerViewLocation { private String name; private String bedInfo; private LatLng locationCoordinates; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getBedInfo() { return bedInfo; } public void setBedInfo(String bedInfo) { this.bedInfo = bedInfo; } public LatLng getLocationCoordinates() { return locationCoordinates; } public void setLocationCoordinates(LatLng locationCoordinates) { this.locationCoordinates = locationCoordinates; } } static class LocationRecyclerViewAdapter extends RecyclerView.Adapter<LocationRecyclerViewAdapter.MyViewHolder> { private List<SingleRecyclerViewLocation> locationList; private MapboxMap map; public LocationRecyclerViewAdapter(List<SingleRecyclerViewLocation> locationList, MapboxMap mapBoxMap) { this.locationList = locationList; this.map = mapBoxMap; } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View itemView = LayoutInflater.from(parent.getContext()) .inflate(R.layout.rv_on_top_of_map_card, parent, false); return new MyViewHolder(itemView); } @Override public void onBindViewHolder(MyViewHolder holder, int position) { SingleRecyclerViewLocation singleRecyclerViewLocation = locationList.get(position); holder.name.setText(singleRecyclerViewLocation.getName()); holder.numOfBeds.setText(singleRecyclerViewLocation.getBedInfo()); holder.setClickListener(new ItemClickListener() { @Override public void onClick(View view, int position) { LatLng selectedLocationLatLng = locationList.get(position).getLocationCoordinates(); CameraPosition newCameraPosition = new CameraPosition.Builder() .target(selectedLocationLatLng) .build(); map.easeCamera(CameraUpdateFactory.newCameraPosition(newCameraPosition)); } }); } @Override public int getItemCount() { return locationList.size(); } static class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener { TextView name; TextView numOfBeds; CardView singleCard; ItemClickListener clickListener; MyViewHolder(View view) { super(view); name = view.findViewById(R.id.location_title_tv); numOfBeds = view.findViewById(R.id.location_num_of_beds_tv); singleCard = view.findViewById(R.id.single_location_cardview); singleCard.setOnClickListener(this); } public void setClickListener(ItemClickListener itemClickListener) { this.clickListener = itemClickListener; } @Override public void onClick(View view) { clickListener.onClick(view, getLayoutPosition()); } } } public interface ItemClickListener { void onClick(View view, int position); } } Copy Was this page helpful? Yes No",,RecyclerView interaction,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Customize the user location annotation,Override the default user location annotation.,https://docs.mapbox.com/ios/maps/examples/user-location-annotation/,example,Swift,,"Customize the user location annotation This example uses two classes within a single file: CustomUserLocationAnnotationView is a subclass of MGLUserLocationAnnotationView, a descendant of UIView. ViewController uses the custom user location annotation view with MGLMapView. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { let point = MGLPointAnnotation() override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.delegate = self // Enable heading tracking mode so that the arrow will appear. mapView.userTrackingMode = .followWithHeading // Enable the permanent heading indicator, which will appear when the tracking mode is not `.followWithHeading`. mapView.showsUserHeadingIndicator = true view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, viewFor annotation: MGLAnnotation) -> MGLAnnotationView? { // Substitute our custom view for the user location annotation. This custom view is defined below. if annotation is MGLUserLocation && mapView.userLocation != nil { return CustomUserLocationAnnotationView() } return nil } // Optional: tap the user location annotation to toggle heading tracking mode. func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { if mapView.userTrackingMode != .followWithHeading { mapView.userTrackingMode = .followWithHeading } else { mapView.resetNorth() } // We're borrowing this method as a gesture recognizer, so reset selection state. mapView.deselectAnnotation(annotation, animated: false) } } // Create a subclass of MGLUserLocationAnnotationView. class CustomUserLocationAnnotationView: MGLUserLocationAnnotationView { let size: CGFloat = 48 var dot: CALayer! var arrow: CAShapeLayer! // -update is a method inherited from MGLUserLocationAnnotationView. It updates the appearance of the user location annotation when needed. This can be called many times a second, so be careful to keep it lightweight. override func update() { if frame.isNull { frame = CGRect(x: 0, y: 0, width: size, height: size) return setNeedsLayout() } // Check whether we have the user’s location yet. if CLLocationCoordinate2DIsValid(userLocation!.coordinate) { setupLayers() updateHeading() } } private func updateHeading() { // Show the heading arrow, if the heading of the user is available. if let heading = userLocation!.heading?.trueHeading { arrow.isHidden = false // Get the difference between the map’s current direction and the user’s heading, then convert it from degrees to radians. let rotation: CGFloat = -MGLRadiansFromDegrees(mapView!.direction - heading) // If the difference would be perceptible, rotate the arrow. if abs(rotation) > 0.01 { // Disable implicit animations of this rotation, which reduces lag between changes. CATransaction.begin() CATransaction.setDisableActions(true) arrow.setAffineTransform(CGAffineTransform.identity.rotated(by: rotation)) CATransaction.commit() } } else { arrow.isHidden = true } } private func setupLayers() { // This dot forms the base of the annotation. if dot == nil { dot = CALayer() dot.bounds = CGRect(x: 0, y: 0, width: size, height: size) // Use CALayer’s corner radius to turn this layer into a circle. dot.cornerRadius = size / 2 dot.backgroundColor = super.tintColor.cgColor dot.borderWidth = 4 dot.borderColor = UIColor.white.cgColor layer.addSublayer(dot) } // This arrow overlays the dot and is rotated with the user’s heading. if arrow == nil { arrow = CAShapeLayer() arrow.path = arrowPath() arrow.frame = CGRect(x: 0, y: 0, width: size / 2, height: size / 2) arrow.position = CGPoint(x: dot.frame.midX, y: dot.frame.midY) arrow.fillColor = dot.borderColor layer.addSublayer(arrow) } } // Calculate the vector path for an arrow, for use in a shape layer. private func arrowPath() -> CGPath { let max: CGFloat = size / 2 let pad: CGFloat = 3 let top = CGPoint(x: max * 0.5, y: 0) let left = CGPoint(x: 0 + pad, y: max - pad) let right = CGPoint(x: max - pad, y: max - pad) let center = CGPoint(x: max * 0.5, y: max * 0.6) let bezierPath = UIBezierPath() bezierPath.move(to: top) bezierPath.addLine(to: left) bezierPath.addLine(to: center) bezierPath.addLine(to: right) bezierPath.addLine(to: top) bezierPath.close() return bezierPath.cgPath } } Copy Was this page helpful? Yes No",,Customize the user location annotation,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Show polygon information on click,"When a user clicks a polygon, show a Popup containing more information.",https://docs.mapbox.com/mapbox-gl-js/example/polygon-popup-on-click/,example,JavaScript,,"Show polygon information on click When a user clicks a polygon, show a Popup containing more information. Was this example helpful? Yes No",,Show polygon information on click,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Filter symbols by toggling a list,Filter a set of symbols based on a property value in the data.,https://docs.mapbox.com/mapbox-gl-js/example/filter-markers/,example,JavaScript,,Filter symbols by toggling a list Filter a set of symbols based on a property value in the data. Was this example helpful? Yes No,,Filter symbols by toggling a list,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Animate a line,Add an animated polyline from a GeoJSON source.,https://docs.mapbox.com/ios/maps/examples/runtime-animate-line/,example,Swift,,"Animate a line Related examples: drawing a GeoJSON line and dynamically-styled line. Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! var timer: Timer? var polylineSource: MGLShapeSource? var currentIndex = 1 var allCoordinates: [CLLocationCoordinate2D]! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter( CLLocationCoordinate2D(latitude: 45.5076, longitude: -122.6736), zoomLevel: 11, animated: false) view.addSubview(mapView) mapView.delegate = self allCoordinates = coordinates } // Wait until the map is loaded before adding to the map. func mapViewDidFinishLoadingMap(_ mapView: MGLMapView) { addPolyline(to: mapView.style!) animatePolyline() } func addPolyline(to style: MGLStyle) { // Add an empty MGLShapeSource, we’ll keep a reference to this and add points to this later. let source = MGLShapeSource(identifier: ""polyline"", shape: nil, options: nil) style.addSource(source) polylineSource = source // Add a layer to style our polyline. let layer = MGLLineStyleLayer(identifier: ""polyline"", source: source) layer.lineJoin = NSExpression(forConstantValue: ""round"") layer.lineCap = NSExpression(forConstantValue: ""round"") layer.lineColor = NSExpression(forConstantValue: UIColor.red) // The line width should gradually increase based on the zoom level. layer.lineWidth = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [14: 5, 18: 20]) style.addLayer(layer) } func animatePolyline() { currentIndex = 1 // Start a timer that will simulate adding points to our polyline. This could also represent coordinates being added to our polyline from another source, such as a CLLocationManagerDelegate. timer = Timer.scheduledTimer(timeInterval: 0.05, target: self, selector: #selector(tick), userInfo: nil, repeats: true) } @objc func tick() { if currentIndex > allCoordinates.count { timer?.invalidate() timer = nil return } // Create a subarray of locations up to the current index. let coordinates = Array(allCoordinates[0..<currentIndex]) // Update our MGLShapeSource with the current locations. updatePolylineWithCoordinates(coordinates: coordinates) currentIndex += 1 } func updatePolylineWithCoordinates(coordinates: [CLLocationCoordinate2D]) { var mutableCoordinates = coordinates let polyline = MGLPolylineFeature(coordinates: &mutableCoordinates, count: UInt(mutableCoordinates.count)) // Updating the MGLShapeSource’s shape will have the map redraw our polyline with the current coordinates. polylineSource?.shape = polyline } let coordinates = [ (-122.63748, 45.52214), (-122.64855, 45.52218), (-122.6545, 45.52219), (-122.65497, 45.52196), (-122.65631, 45.52104), (-122.6578, 45.51935), (-122.65867, 45.51848), (-122.65872, 45.51293), (-122.66576, 45.51295), (-122.66745, 45.51252), (-122.66813, 45.51244), (-122.67359, 45.51385), (-122.67415, 45.51406), (-122.67481, 45.51484), (-122.676, 45.51532), (-122.68106, 45.51668), (-122.68503, 45.50934), (-122.68546, 45.50858), (-122.6852, 45.50783), (-122.68424, 45.50714), (-122.68433, 45.50585), (-122.68429, 45.50521), (-122.68456, 45.50445), (-122.68538, 45.50371), (-122.68653, 45.50311), (-122.68731, 45.50292), (-122.68742, 45.50253), (-122.6867, 45.50239), (-122.68545, 45.5026), (-122.68407, 45.50294), (-122.68357, 45.50271), (-122.68236, 45.50055), (-122.68233, 45.49994), (-122.68267, 45.49955), (-122.68257, 45.49919), (-122.68376, 45.49842), (-122.68428, 45.49821), (-122.68573, 45.49798), (-122.68923, 45.49805), (-122.68926, 45.49857), (-122.68814, 45.49911), (-122.68865, 45.49921), (-122.6897, 45.49905), (-122.69346, 45.49917), (-122.69404, 45.49902), (-122.69438, 45.49796), (-122.69504, 45.49697), (-122.69624, 45.49661), (-122.69781, 45.4955), (-122.69803, 45.49517), (-122.69711, 45.49508), (-122.69688, 45.4948), (-122.69744, 45.49368), (-122.69702, 45.49311), (-122.69665, 45.49294), (-122.69788, 45.49212), (-122.69771, 45.49264), (-122.69835, 45.49332), (-122.7007, 45.49334), (-122.70167, 45.49358), (-122.70215, 45.49401), (-122.70229, 45.49439), (-122.70185, 45.49566), (-122.70215, 45.49635), (-122.70346, 45.49674), (-122.70517, 45.49758), (-122.70614, 45.49736), (-122.70663, 45.49736), (-122.70807, 45.49767), (-122.70807, 45.49798), (-122.70717, 45.49798), (-122.70713, 45.4984), (-122.70774, 45.49893) ].map({CLLocationCoordinate2D(latitude: $0.1, longitude: $0.0)}) } Copy Was this page helpful? Yes No",,Animate a line,,,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Troubleshooting,Resolve common issues across Mapbox products.,https://docs.mapbox.com/help/troubleshooting/,,,,"Troubleshooting Resolve common issues across Mapbox products. Access tokens How to regain access to your account Learn to troubleshoot common account lockout scenarios. Collaboration best practices Learn best practices for setting up an account and collaborating on projects. How to use Mapbox securely Learn how to use Mapbox securely. Inconsistencies in statistics and invoices Understand what situations might result in inconsistencies between your statistics page and monthly invoices. Data Access elevation data Learn how to access elevation data in Mapbox tilesets. How to regain access to your account Learn to troubleshoot common account lockout scenarios. Adjust the zoom extent of your tileset Learn how to manually adjust the zoom extent of your tilesets. Blank or missing map tiles Learn why you may be seeing blank or missing tiles. Change your map’s label language Learn about available languages and how to change your map’s language. Collaboration best practices Learn best practices for setting up an account and collaborating on projects. CSV file errors Learn how to fix errors when uploading CSV files. How to use Mapbox securely Learn how to use Mapbox securely. Manage large data files for Mapbox Studio with Tippecanoe Learn how to manage big data files and make a scale-independent view of your data. Browser support Learn which browsers support each Mapbox product. Troubleshoot raster image with black background Learn how to fix raster images that display black backgrounds. Source limits in Mapbox Studio styles Read about strategies for reducing the number of tileset sources in Mapbox Studio styles. Report a problem with the map Learn how to report errors on Mapbox maps. Transfer styles between accounts Learn how to transfer Mapbox styles between accounts. Working with large GeoJSON sources in Mapbox GL JS Strategies for handling large GeoJSON sources with GL JS. Geocoding Address geocoding format guide Follow these best practices when formatting addresses for geocoding. Map design How to regain access to your account Learn to troubleshoot common account lockout scenarios. Adjust the zoom extent of your tileset Learn how to manually adjust the zoom extent of your tilesets. Blank or missing map tiles Learn why you may be seeing blank or missing tiles. Change your map’s label language Learn about available languages and how to change your map’s language. Collaboration best practices Learn best practices for setting up an account and collaborating on projects. How to use Mapbox securely Learn how to use Mapbox securely. Manage your fontstacks Learn how to manage fontstacks for optimal rendering. Browser support Learn which browsers support each Mapbox product. Improve the performance of Mapbox GL JS maps Learn how to improve the performance of your Mapbox GL JS maps. Optimize map label placement Optimize label placement on web and mobile maps. Source limits in Mapbox Studio styles Read about strategies for reducing the number of tileset sources in Mapbox Studio styles. Troubleshooting SVG image errors in Mapbox Studio Learn how to fix SVG upload errors in Mapbox Studio. Transfer styles between accounts Learn how to transfer Mapbox styles between accounts. Mobile apps Understanding Android APK size Learn how to measure and optimize your Android app’s size. How to use Mapbox securely Learn how to use Mapbox securely. Understanding iOS framework size Learn how to measure and optimize your iOS app’s size. Troubleshooting Mapbox Maps SDK for iOS installation Learn how to troubleshoot frequently seen issues when installing the Mapbox Maps SDK for iOS. Troubleshooting App Store submission with the Mapbox Maps SDK for iOS Learn how to troubleshoot frequently seen issues when submitting applications built with the Mapbox Maps SDK for iOS to the App Store. Offline maps Learn about how offline maps work. Keep access tokens private in open source iOS and Android apps Learn how to protect your access tokens so that they aren't used by others. Third party integration Integrate the Mapbox Visual with Microsoft Power BI General configuration guidance and tips for using the Mapbox Visual in Microsoft Power BI. Use custom Mapbox styles in Tableau General configuration guidance and tips for using custom Mapbox maps in Tableau. Uploads Adjust the zoom extent of your tileset Learn how to manually adjust the zoom extent of your tilesets. CSV file errors Learn how to fix errors when uploading CSV files. Manage large data files for Mapbox Studio with Tippecanoe Learn how to manage big data files and make a scale-independent view of your data. Improve the performance of Mapbox GL JS maps Learn how to improve the performance of your Mapbox GL JS maps. Get your PostGIS data ready for Mapbox Studio Methods to re-format, query, and export PostGIS data into a Mapbox Studio ready format. Troubleshoot raster image with black background Learn how to fix raster images that display black backgrounds. Tilesets API recipe examples This feature is in beta. Use these example tiling recipes to learn how to transform custom data into tilesets using the Mapbox Tilesets API. Tilesets API recipe reference This feature is in beta. Learn about the correct format and syntax for Tilesets API recipes, or tile transformation documents. Tileset sources and the Tilesets API This feature is in beta. Learn about how to use line-delimited GeoJSON to create tileset sources and how to handle IDs in tileset sources. Troubleshoot Tilesets API errors This feature is in beta. Learn how to debug common errors with the Mapbox Tilesets API. Upload data to Mapbox Learn how to prepare data for upload, interpret error messages, and troubleshoot failed uploads. Web apps Adjust the zoom extent of your tileset Learn how to manually adjust the zoom extent of your tilesets. Blank or missing map tiles Learn why you may be seeing blank or missing tiles. CORS errors Learn how to address CORS errors. Working with firewalls General troubleshooting tips and some configuration guidance for working with Mapbox behind a firewall. How to use Mapbox securely Learn how to use Mapbox securely. Browser support Learn which browsers support each Mapbox product. Improve the performance of Mapbox GL JS maps Learn how to improve the performance of your Mapbox GL JS maps. Transition from Mapbox.js to Mapbox GL JS Learn about transitioning from using Mapbox.js to using Mapbox GL JS in your apps. Working with large GeoJSON sources in Mapbox GL JS Strategies for handling large GeoJSON sources with GL JS.",,Access tokens,Geocoding,Map design,,Mobile apps,Third party integration,Uploads,Web apps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,marker,A marker is a visual representation of a specific coordinate on a map.,https://docs.mapbox.com/help/glossary/marker/,glossary,,,"marker In web mapping generally, a marker is a visual representation of a specific coordinate on a map. Markers can be added and customized for use in Mapbox web maps and mobile applications in a variety of ways. You can read more about options for visualizing point data and find step by step tutorials in our Add custom icons and markers guide. Was this page helpful? Yes No",,marker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Offline manager,"Download, view, navigate to, and delete an offline region.",https://docs.mapbox.com/android/maps/examples/set-up-offline-manager/,example,Java,,"Offline manager Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.offline.OfflineManagerActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""29.720"" mapbox:mapbox_cameraTargetLng=""-95.342"" mapbox:mapbox_cameraZoom=""15.27"" mapbox:mapbox_cameraZoomMin=""10""/> <ProgressBar android:id=""@+id/progress_bar"" style=""?android:attr/progressBarStyleHorizontal"" android:layout_width=""match_parent"" android:layout_height=""25dp"" android:layout_centerHorizontal=""true"" android:layout_centerInParent=""true"" android:paddingLeft=""25dp"" android:paddingRight=""25dp"" android:visibility=""gone""/> <LinearLayout android:id=""@+id/bottom_navigation"" style=""?android:attr/buttonBarStyle"" android:layout_width=""match_parent"" android:layout_height=""56dp"" android:layout_alignParentBottom=""true"" android:background=""@color/colorAccent"" android:elevation=""8dp"" android:orientation=""horizontal"" android:paddingTop=""8dp""> <Button android:id=""@+id/download_button"" style=""?android:attr/buttonBarButtonStyle"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_weight=""1"" android:background=""@android:color/transparent"" android:clickable=""true"" android:drawableTop=""@drawable/ic_get_app_24dp"" android:text=""@string/download_button_text"" android:textAllCaps=""false"" android:textColor=""@color/mapboxWhite"" android:textSize=""12sp""/> <Button android:id=""@+id/list_button"" style=""?android:attr/buttonBarButtonStyle"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_weight=""1"" android:background=""@android:color/transparent"" android:drawableTop=""@drawable/ic_list_24dp"" android:text=""@string/list_button_text"" android:textAllCaps=""false"" android:textColor=""@color/mapboxWhite"" android:textSize=""12sp""/> </LinearLayout> </RelativeLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.offline; import android.app.AlertDialog; import android.content.DialogInterface; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.ProgressBar; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.offline.OfflineManager; import com.mapbox.mapboxsdk.offline.OfflineRegion; import com.mapbox.mapboxsdk.offline.OfflineRegionError; import com.mapbox.mapboxsdk.offline.OfflineRegionStatus; import com.mapbox.mapboxsdk.offline.OfflineTilePyramidRegionDefinition; import org.json.JSONObject; import java.util.ArrayList; import timber.log.Timber; /** * Download, view, navigate to, and delete an offline region. */ public class OfflineManagerActivity extends AppCompatActivity { private static final String TAG = ""OffManActivity""; // JSON encoding/decoding public static final String JSON_CHARSET = ""UTF-8""; public static final String JSON_FIELD_REGION_NAME = ""FIELD_REGION_NAME""; // UI elements private MapView mapView; private MapboxMap map; private ProgressBar progressBar; private Button downloadButton; private Button listButton; private boolean isEndNotified; private int regionSelected; // Offline objects private OfflineManager offlineManager; private OfflineRegion offlineRegion; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_offline_manager); // Set up the MapView mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { map = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Assign progressBar for later use progressBar = findViewById(R.id.progress_bar); // Set up the offlineManager offlineManager = OfflineManager.getInstance(OfflineManagerActivity.this); // Bottom navigation bar button clicks are handled here. // Download offline button downloadButton = findViewById(R.id.download_button); downloadButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { downloadRegionDialog(); } }); // List offline regions listButton = findViewById(R.id.list_button); listButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { downloadedRegionList(); } }); } }); } }); } // Override Activity lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } private void downloadRegionDialog() { // Set up download interaction. Display a dialog // when the user clicks download button and require // a user-provided region name AlertDialog.Builder builder = new AlertDialog.Builder(OfflineManagerActivity.this); final EditText regionNameEdit = new EditText(OfflineManagerActivity.this); regionNameEdit.setHint(getString(R.string.set_region_name_hint)); // Build the dialog box builder.setTitle(getString(R.string.dialog_title)) .setView(regionNameEdit) .setMessage(getString(R.string.dialog_message)) .setPositiveButton(getString(R.string.dialog_positive_button), new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { String regionName = regionNameEdit.getText().toString(); // Require a region name to begin the download. // If the user-provided string is empty, display // a toast message and do not begin download. if (regionName.length() == 0) { Toast.makeText(OfflineManagerActivity.this, getString(R.string.dialog_toast), Toast.LENGTH_SHORT).show(); } else { // Begin download process downloadRegion(regionName); } } }) .setNegativeButton(getString(R.string.dialog_negative_button), new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.cancel(); } }); // Display the dialog builder.show(); } private void downloadRegion(final String regionName) { // Define offline region parameters, including bounds, // min/max zoom, and metadata // Start the progressBar startProgress(); // Create offline definition using the current // style and boundaries of visible map area String styleUrl = map.getStyle().getUrl(); LatLngBounds bounds = map.getProjection().getVisibleRegion().latLngBounds; double minZoom = map.getCameraPosition().zoom; double maxZoom = map.getMaxZoomLevel(); float pixelRatio = this.getResources().getDisplayMetrics().density; OfflineTilePyramidRegionDefinition definition = new OfflineTilePyramidRegionDefinition( styleUrl, bounds, minZoom, maxZoom, pixelRatio); // Build a JSONObject using the user-defined offline region title, // convert it into string, and use it to create a metadata variable. // The metadata variable will later be passed to createOfflineRegion() byte[] metadata; try { JSONObject jsonObject = new JSONObject(); jsonObject.put(JSON_FIELD_REGION_NAME, regionName); String json = jsonObject.toString(); metadata = json.getBytes(JSON_CHARSET); } catch (Exception exception) { Timber.e(""Failed to encode metadata: %s"", exception.getMessage()); metadata = null; } // Create the offline region and launch the download offlineManager.createOfflineRegion(definition, metadata, new OfflineManager.CreateOfflineRegionCallback() { @Override public void onCreate(OfflineRegion offlineRegion) { Timber.d( ""Offline region created: %s"" , regionName); OfflineManagerActivity.this.offlineRegion = offlineRegion; launchDownload(); } @Override public void onError(String error) { Timber.e( ""Error: %s"" , error); } }); } private void launchDownload() { // Set up an observer to handle download progress and // notify the user when the region is finished downloading offlineRegion.setObserver(new OfflineRegion.OfflineRegionObserver() { @Override public void onStatusChanged(OfflineRegionStatus status) { // Compute a percentage double percentage = status.getRequiredResourceCount() >= 0 ? (100.0 * status.getCompletedResourceCount() / status.getRequiredResourceCount()) : 0.0; if (status.isComplete()) { // Download complete endProgress(getString(R.string.end_progress_success)); return; } else if (status.isRequiredResourceCountPrecise()) { // Switch to determinate state setPercentage((int) Math.round(percentage)); } // Log what is being currently downloaded Timber.d(""%s/%s resources; %s bytes downloaded."", String.valueOf(status.getCompletedResourceCount()), String.valueOf(status.getRequiredResourceCount()), String.valueOf(status.getCompletedResourceSize())); } @Override public void onError(OfflineRegionError error) { Timber.e(""onError reason: %s"", error.getReason()); Timber.e(""onError message: %s"", error.getMessage()); } @Override public void mapboxTileCountLimitExceeded(long limit) { Timber.e(""Mapbox tile count limit exceeded: %s"", limit); } }); // Change the region state offlineRegion.setDownloadState(OfflineRegion.STATE_ACTIVE); } private void downloadedRegionList() { // Build a region list when the user clicks the list button // Reset the region selected int to 0 regionSelected = 0; // Query the DB asynchronously offlineManager.listOfflineRegions(new OfflineManager.ListOfflineRegionsCallback() { @Override public void onList(final OfflineRegion[] offlineRegions) { // Check result. If no regions have been // downloaded yet, notify user and return if (offlineRegions == null || offlineRegions.length == 0) { Toast.makeText(getApplicationContext(), getString(R.string.toast_no_regions_yet), Toast.LENGTH_SHORT).show(); return; } // Add all of the region names to a list ArrayList<String> offlineRegionsNames = new ArrayList<>(); for (OfflineRegion offlineRegion : offlineRegions) { offlineRegionsNames.add(getRegionName(offlineRegion)); } final CharSequence[] items = offlineRegionsNames.toArray(new CharSequence[offlineRegionsNames.size()]); // Build a dialog containing the list of regions AlertDialog dialog = new AlertDialog.Builder(OfflineManagerActivity.this) .setTitle(getString(R.string.navigate_title)) .setSingleChoiceItems(items, 0, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // Track which region the user selects regionSelected = which; } }) .setPositiveButton(getString(R.string.navigate_positive_button), new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int id) { Toast.makeText(OfflineManagerActivity.this, items[regionSelected], Toast.LENGTH_LONG).show(); // Get the region bounds and zoom LatLngBounds bounds = ((OfflineTilePyramidRegionDefinition) offlineRegions[regionSelected].getDefinition()).getBounds(); double regionZoom = ((OfflineTilePyramidRegionDefinition) offlineRegions[regionSelected].getDefinition()).getMinZoom(); // Create new camera position CameraPosition cameraPosition = new CameraPosition.Builder() .target(bounds.getCenter()) .zoom(regionZoom) .build(); // Move camera to new position map.moveCamera(CameraUpdateFactory.newCameraPosition(cameraPosition)); } }) .setNeutralButton(getString(R.string.navigate_neutral_button_title), new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int id) { // Make progressBar indeterminate and // set it to visible to signal that // the deletion process has begun progressBar.setIndeterminate(true); progressBar.setVisibility(View.VISIBLE); // Begin the deletion process offlineRegions[regionSelected].delete(new OfflineRegion.OfflineRegionDeleteCallback() { @Override public void onDelete() { // Once the region is deleted, remove the // progressBar and display a toast progressBar.setVisibility(View.INVISIBLE); progressBar.setIndeterminate(false); Toast.makeText(getApplicationContext(), getString(R.string.toast_region_deleted), Toast.LENGTH_LONG).show(); } @Override public void onError(String error) { progressBar.setVisibility(View.INVISIBLE); progressBar.setIndeterminate(false); Timber.e( ""Error: %s"", error); } }); } }) .setNegativeButton(getString(R.string.navigate_negative_button_title), new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int id) { // When the user cancels, don't do anything. // The dialog will automatically close } }).create(); dialog.show(); } @Override public void onError(String error) { Timber.e( ""Error: %s"", error); } }); } private String getRegionName(OfflineRegion offlineRegion) { // Get the region name from the offline region metadata String regionName; try { byte[] metadata = offlineRegion.getMetadata(); String json = new String(metadata, JSON_CHARSET); JSONObject jsonObject = new JSONObject(json); regionName = jsonObject.getString(JSON_FIELD_REGION_NAME); } catch (Exception exception) { Timber.e(""Failed to decode metadata: %s"", exception.getMessage()); regionName = String.format(getString(R.string.region_name), offlineRegion.getID()); } return regionName; } // Progress bar methods private void startProgress() { // Disable buttons downloadButton.setEnabled(false); listButton.setEnabled(false); // Start and show the progress bar isEndNotified = false; progressBar.setIndeterminate(true); progressBar.setVisibility(View.VISIBLE); } private void setPercentage(final int percentage) { progressBar.setIndeterminate(false); progressBar.setProgress(percentage); } private void endProgress(final String message) { // Don't notify more than once if (isEndNotified) { return; } // Enable buttons downloadButton.setEnabled(true); listButton.setEnabled(true); // Stop and hide the progress bar isEndNotified = true; progressBar.setIndeterminate(false); progressBar.setVisibility(View.GONE); // Show a toast Toast.makeText(OfflineManagerActivity.this, message, Toast.LENGTH_LONG).show(); } } Copy Was this page helpful? Yes No",,Offline manager,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Legacy Atlas,Legacy Atlas.,https://docs.mapbox.com/atlas/overview/legacy/,guide,,,"Legacy Atlas Legacy Atlas only supports raster maps using Mapbox.js, while the updated Atlas version supports the latest Mapbox vector map technology, including Mapbox GL JS. The updated Atlas also ships with the latest Mapbox styling software, Mapbox Studio. Still using the legacy version of Atlas? We'd love for you to upgrade! Contact Mapbox support for help in migrating from legacy Atlas to the newest version. Legacy Atlas install and setup Specifications The legacy Atlas product runs on Ubuntu 14.04, CentOS 7, and Red Hat Enterprise Linux 7. A developer version is available for OS X. We recommend the following hardware configuration: 16 CPU cores 32 GB RAM 512 GB SSD Download and install The legacy Atlas software and datasources are available for download at mapbox.com/studio/atlas. Unpack the Atlas zip and run ./install.sh. All dependencies are pre-built and will be installed with Atlas. Then open http://localhost:2999/atlas/setup in the browser and follow the steps below to complete the setup process. License key You can find your Atlas license key at mapbox.com/studio/atlas: Copy the license key, go to http://localhost:2999/atlas/setup, and paste it into the license key field. Server URL By default, legacy Atlas installs on the localhost domain at port 2999, i.e. http://localhost:2999. To set Atlas's URL for production, go to http://localhost:2999/atlas/setup and set the URL to http://your.server.location:2999. In this example, Atlas's URL is http://ec2-54-205-117-140.compute-1.amazonaws.com:2999. To change legacy Atlas's port from the default 2999, you can set the AtlasServerPort environment variable during installation. For example, to set the port to 2555: Run sudo AtlasServerPort=2555 ./install.sh Go to http://localhost:2555/atlas/setup and set the legacy Atlas URL to http://your.server.location:2555 Adding datasources To serve map tiles, the following datasources must be added to /opt/atlas-server-data/sources/: mapbox.mapbox-streets-v5.mbtiles mapbox.mapbox-terrain-v1.mbtiles mapbox.satellite-full.mbtiles mapbox.satellite-watermask.mbtiles If you installed legacy Atlas via AMI, your instance may already include development (lower zoom) datasources. If you did not install via AMI or want to add production (higher zoom) datasources, you must download the datasources from your Mapbox account and add them to /opt/atlas-server-data/sources/, matching the above file names exactly. Download URLs are cycled every 12 hours for security purposes. For larger datasources, especially the production version of mapbox.satellite-full.mbtiles, you may need to use a continuous download: Copy download URL for mapbox.satellite-full.mbtiles from mapbox.com/studio/atlas wget -c ""pasted-download-URL"" -O mapbox.satellite-full.mbtiles If the URL cycles and download stops, copy the new download URL wget -c ""pasted-new-download-URL"" -O mapbox.satellite-full.mbtiles Repeat until download is complete Once the license key, server URL, and datasources have been configured, legacy Atlas is ready to go. Server logs To export and view the legacy Atlas logs on CentOS 7 and Red Hat Enterprise Linux 7, use the following command: sudo journalctl -u atlas-server > /tmp/logs.txt On Ubuntu 14.04, the legacy Atlas logs can be viewed at /var/log/upstart/atlas-server.log. Install legacy Atlas on AWS To install legacy Atlas on AWS, we recommend using an Amazon Machine Image (AMI). There are two ways to install via AMI. Install via AWS console Here are steps to install Atlas via the AWS Console: Login to your desired AWS region and click on the EC2 button. Click Launch Instance. Click My AMIs and check the Shared with me box under Ownership. Choose your instance type (c3.4xlarge is recommended). Confirm that presence of an EBS volume with 512 GB of storage, and add additional storage if desired. Configure your security group. Atlas operates on port 2999, which you must set as open. Add rule: Type: Custom TCP Rule Protocol: TCP Port Range: 2999 Source: Anywhere Review your instance and, if it is properly configured, launch. Before launching, there will be a prompt to add a key-name pair to use to SSH into the instance. If you plan to SSH into the instance (recommended), select or create a new key pair. Your instance is launched. Grab its public DNS record and go to http://your.server.url:2999/atlas/setup to begin the configuration process. Install via CloudFormation template You will need: An AWS account AWS Command Line Tools installed A Mapbox access token Run the following command: aws cloudformation create-stack \ --region us-east-1 \ --stack-name ""Atlas_Server"" \ --parameters ParameterKey=Instance,ParameterValue=c3.4xlarge ParameterKey=KeyName,ParameterValue=your_key_name \ --template-url https://s3.amazonaws.com/mapbox/atlas-server/ami/atlas-server-linux-x64-VERSION.template This command will launch an Atlas instance in the US-East-1 region. Go to your AWS console, find the instance, copy its public DNS record, and navigate to http://your.server.url:2999/atlas/setup/ to configure your instance. Suggested instance types Mapbox recommends deploying legacy Atlas with a c3.4xlarge, though it is also compatible with the following instance types: c3.8xlarge r3.4xlarge r3.8xlarge i2.4xlarge hs1.8xlarge Notes Legacy Atlas AMIs include development data sources. To add full production base map data follow the instructions for adding datasources. The sudo command is not possible on a legacy Atlas instance created via AMI. User data scripts are not allowed when creating a legacy Atlas instance via AMI. You can provide a script, but it will be blocked by the AMI. Upgrading legacy Atlas Upgrade a local instance To upgrade a local instance of Atlas while retaining your source and style files, run rm -rf /opt/atlas-server but leave /opt/atlas-server-data in place. Then download the latest Atlas package from your Mapbox.com account and follow the normal installation instructions. Upgrade on AWS To upgrade your Atlas AMI instance while retaining your source and style files, take a snapshot of your data, create a new instance, and attach the data volume to the new instance using the following steps: From the AWS Console, navigate to your instance. Find the attached data volume at the bottom of the Description tab for your instance under Block Devices. The data volume will always be the /dev/sdg device. Create a snapshot of your data volume by clicking Actions > Create Snapshot. While the snapshot is copying, create a new Atlas instance from the most recent AMI. Follow the Atlas AMI setup instructions, but remove the data volume option on the Storage page. Once the new instance has completed all setup processes, stop the instance. Create a new volume from you data snapshot in the same availability zone as the new Atlas AMI instance. Attach the volume to the stopped instance by clicking Actions > Attach Volume. Paste the instance ID of your stopped Atlas in the Instance field. Under device paste /dev/sdg. This step will not work if the volume and instance availability zones are different. Once your data volume is attached, start your new Atlas instance and stop the old one. Mapbox Studio Classic and legacy Atlas Mapbox Studio Classic is a desktop application for vector tile driven map design. You can use Mapbox Studio Classic to create new sources and styles with your data that can be loaded onto the legacy Atlas product. Mapbox Studio Classic is no longer in development, and we recommend using Mapbox Studio instead. Connect Mapbox Studio Classic Enter your Atlas URL in the Mapbox Studio Classic login screen. Once connected to Atlas, Mapbox Studio Classic will display Offline user. New source Atlas stores source data in .mbtiles files in the /opt/atlas-server-data/sources/ directory. To create a new source from your data, follow the steps in our source quickstart. When your source is ready, follow these steps: Click Save as. Click Settings and select Export to MBTiles. Click Download once the export is complete. Move the downloaded file into your Atlas's /opt/atlas-server-data/sources/ directory. Confirm that the new source and its map ID are visible in Atlas's Sources tab: New style Atlas stores style data in .tm2z files in the /opt/atlas-server-data/styles/ directory. To create a new style from a source file on Atlas: Click Projects in the lower left corner of Mapbox Studio Classic. Click New project. Enter your source’s map ID in the your map ID box, shown below. Multiple sources can be composited by separating their map IDs with commas. Click Create. Use CartoCSS to style your data. (For more information, see the Mapbox style manual.) Click Save as. Click Settings and select Download package. Move the downloaded file into your Atlas's /opt/atlas-server-data/styles/ directory. Confirm that the new style and its map ID are visible in the Styles tab: Naming sources and styles Each source and style file must have a unique filename. Source and style files can be renamed after export from Mapbox Studio Classic and before loading into Atlas with the following formats: Sources: aaaa.bbbb.mbtiles Styles: xxxx.yyyy.tm2zIn these examples, aaaa.bbbb and xxxx.yyyy will be the map IDs corresponding to the source and style files. Was this page helpful? Yes No",,Legacy Atlas,Specifications,Download and install,,License key,Server URL,Adding datasources,Server logs,Install legacy Atlas on AWS,Install via AWS console,Install via CloudFormation template,Suggested instance types,,Notes,Upgrading legacy Atlas,Upgrade a local instance,Upgrade on AWS,Mapbox Studio Classic and legacy Atlas,Connect Mapbox Studio Classic,New source,New style,Naming sources and styles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Traffic and directions,A showcase of Mapbox's traffic and directions data.,https://docs.mapbox.com/unity/maps/examples/traffic-and-directions/,example,No code,,"Traffic and directions The traffic and directions example is a visualization of Mapbox's traffic data and Directions API. Traffic In this example scene, traffic is visualized by leveraging the Mapbox Traffic v1 tileset, which provides constantly updating congestion information. The tileset is specified in the Map Layers settings as a Custom Data Source as shown in the screenshot below. You can specify multiple tilesets as data sources by separating them with a comma. For more information refer to the documentation on using custom data in Unity. Map Features are used to render the congestion data inside of Unity. Navigate to Map Layers > Features > Map Features to see how the visualizers are configured. The Mapbox Traffic v1 tileset gives access to layers and fields that are used for this visualization. The traffic layer of the tileset contains the congestion key which has low, moderate, heavy, and severe as possible values. Each one of these keys are configured with a separate visualizer so that it can be styled and rendered appropriately. To see how the vector features interact with tileset data, inspect the LowTrafficCongestion feature. Select LowTrafficCongestion to view the configuration and you'll see the following settings: Filters View the configured filters by navigating to Filters. Key is set to congestion. Operator is set to Contains. Str Value is set to low. Modeling Primitive Type is set to Custom. Layer Name is set to traffic. Snap to Terrain is checked and Combine Meshes is unchecked. Behavior modifiers Styling of this feature is handled in Behavior Modifiers by the following modifiers: Mesh Modifier: A LoftModifier is specified to achieve a 3D look. Game Object Modifier: A MaterialModifier is specified to color the area with low congestion a specific color. Directions Mapbox Navigation is available inside of Unity, and is configured using the DirectionsFactor.cs script. In this scene there is a Directions game object that has the DirectionsFactory script attached to it. Additionally, it has two waypoints as children that are the markers on the map. Every two seconds the DirectionsFactory will query the Directions API and return the driving route between the two points. If the points have moved within that time, a line will be rendered along the new driving route. The DirectionsFactory script contains the following: Map: This field contains the map game object for this scene. Mesh Modifiers: This is an array of mesh modifiers. It contains a LoftModifier to place a line on top of the traffic mesh. Material: This contains the material to style the line along the directions route. Waypoints: This array contains the waypoints of the route. Update Frequency: This setting controls how often the Directions API is queried and updates the route if the position of the waypoints have changed. To configure directions in your own scene, you can drag the Directions prefab into a new scene or attach the DirectionsFactory script to an empty game object. Was this page helpful? Yes No",,Traffic and directions,Filters,Modeling,,Behavior modifiers,Directions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Adjust a layer's opacity,Drag the range slider to adjust the opacity of a raster layer on top of a map.,https://docs.mapbox.com/mapbox-gl-js/example/adjust-layer-opacity/,example,JavaScript,,Adjust a layer's opacity Drag the range slider to adjust the opacity of a raster layer on top of a map. Was this example helpful? Yes No,,Adjust a layer's opacity,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Navigation SDK,The Mapbox Navigation SDK provides an open source toolset for integrating turn-by-turn navigation within mobile applications.,https://docs.mapbox.com/help/glossary/mapbox-navigation-sdk/,glossary,,,"Mapbox Navigation SDK Built on top of the Mapbox Directions API, the Mapbox Navigation SDKs provide all the logic necessary to implement a navigation experience in your app. The SDKs include critical features like: Drop-in turn-by-turn navigation UI. Automotive, cycling, and walking directions. Traffic avoidance. Maneuver announcements. Text instructions. Text to speech support. Automatic rerouting. Snap to route. To include the Mapbox Navigation SDKs in your application, please visit the respective documentation pages for installation instructions, API reference, and sample code: Mapbox Navigation for iOS Mapbox Navigation for Android Was this page helpful? Yes No",,Mapbox Navigation SDK,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Studio Classic,Mapbox Studio Classic is a desktop application for designing classic styles.,https://docs.mapbox.com/help/glossary/mapbox-studio-classic/,glossary,,,"Mapbox Studio Classic Note Mapbox Studio Classic is no longer in active development. To learn more about our newer mapping tools see Mapbox Studio. Mapbox Studio Classic is a desktop application for designing maps. It allows you to create maps by using vector tiles and CartoCSS. Mapbox Studio Classic allows you to export and upload your map directly to your Mapbox account in MBTiles format to then use with our developer tools. Creating a new map? Mapbox Studio is the modern alternative to Mapbox Studio Classic. If you're creating a new map today, you should use Mapbox Studio rather than Mapbox Studio Classic. Was this page helpful? Yes No",,Mapbox Studio Classic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Maps SDK for Android,The Mapbox Maps SDK for Android is an open source toolset for building mapping applications for Android devices.,https://docs.mapbox.com/help/glossary/mapbox-android-sdk/,glossary,,,Mapbox Maps SDK for Android The Mapbox Maps SDK for Android is an open source toolset for building mapping applications for Android devices with flexibility for visual styling and customizability. Maps SDK for Android documentation Maps SDK for Android on GitHub First steps with the Mapbox Maps SDK for Android Was this page helpful? Yes No,,Mapbox Maps SDK for Android,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,API,"An API, or application programming interface, is a specification for how software libraries should interact with each other.",https://docs.mapbox.com/help/glossary/api/,glossary,,,"API An API, or application programming interface, is a specification for how software libraries should interact with each other. Think of an API as a way to get data from a website or service without having to physically visit that website or service. Explore all the APIs in the Mapbox API documentation. Was this page helpful? Yes No",,API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a geocoder,Use the mapbox-gl-geocoder control to search for places using Mapbox Geocoding API. Check out our Search Playground to explore geocoding query parameters and how they affect the results.,https://docs.mapbox.com/mapbox-gl-js/example/mapbox-gl-geocoder/,example,JavaScript,,Add a geocoder Use the mapbox-gl-geocoder control to search for places using Mapbox Geocoding API. Check out our Search Playground to explore geocoding query parameters and how they affect the results. Was this example helpful? Yes No,,Add a geocoder,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Examples,Code examples for the Mapbox Navigation SDK for Android.,https://docs.mapbox.com/android/navigation/examples/,,,,Getting started Embedded Navigation Navigation in a view which contains other views. Mock navigation Mock a navigation session using a mock location engine. Navigation Map Route Shows different styles using NavigationMapRoute. NavigationView with Fragment NavigationView implemented with Fragment. Navigation views Create a drop-in navigation UI experience. Reroute Test the reroute feature inside the Navigation SDK for Android. Waypoint Navigation Navigation with waypoints between destinations. AR Basic blue-line AR navigation Project a blue route line on the view of the road through your device.,,Getting started,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for Android,Android,Testing and development,An overview of strategies for testing and developing with the Vision SDK.,https://docs.mapbox.com/android/vision/overview/testing-and-development/,guide,,,"Testing and development Testing visual detection and classification You can point your device at a prerecorded video playing on a separate monitor to test some features that rely only on visual detection and classification. Device requirements You must use a physical Android device for all development and testing with Vision-related products. You can use the camera built into the device or an external camera connected to a physical device. You cannot use an Android emulated device with Android Studio. Video requirements You can use prerecorded videos from a dashboard-mounted camera to test some features like detections, segmentations, and sign classifications. You can use any dashboard camera video (for example, from YouTube) or record your own video to be sure to capture local traffic signs and road markings important to your application. For the best results when recording your own videos, you should use the same in-car setup described in the Requirements and Device setup sections of this documentation. Some tips for recording a video: The Vision SDK works best under good lighting conditions. Lighting conditions may impact the reliability of certain behaviors so you should collect video in any lighting conditions you’d like to test. Plan your route ahead of time to include a diversity of driving situations that may be important to your application (roads with different lane configurations, various speed limits, encounters with pedestrians and cyclists, etc). Development environment setup After you have selected or recorded a video, you will need to set up your physical development environment. You will need: A physical device with a built-in camera (or set up an external camera source following the code example) A monitor to play the video on A method for positioning the device to point at the video Position the device so the camera is pointed at the video. The video should fill the entire screen of your device. What to expect This approach to development can help you test some features of the SDK, but will not work for testing all features since some features rely on GPS and other sensors. Examples of features that can be tested using this setup: Road sign classification to determine the signType for road signs that appear in the video. Lane detection. Vehicle, pedestrian, and bicycle detection for the 2D screen location of objects only. Examples of features that cannot be tested using this setup: AR Navigation cannot be tested using this setup because it requires GPS data. Using a simple simulated location is not a workable alternative because the location needs to match the current location featured in the video. Vision Safety cannot be tested using this setup because Vision Safety requires the current vehicle speed and the ability to estimate distance for objects in view. Testing with sensor data Several features of the Vision SDK require GPS and other sensors including Vision AR and Vision Safety. You can test these features in the real world in a vehicle using a device. Or, you can use the session recording and replay mechanisms of the Vision SDK to debug and iterate more rapidly. Record a session To record a session including video, GPS, sensors, and other necessary data, you'll need to: Prepare a Vision application and load it on your device. Use VisionManager.startRecording method to start session recording, then stop it with VisionManager.stopRecording Java Kotlin VisionManager.start(); string path = ""/path/to/recorded/session/""; VisionManager.startRecording(path); // some code during session is running VisionManager.stopRecording(); // record another session to different directory path = ""/path/to/recorded/session2/""; VisionManager.startRecording(path); // some code during session is running VisionManager.stopRecording(); VisionManager.stop(); Copy Set up a device in a vehicle according to the instructions in the requirements and device setup instructions of this documentation. Drive and record. Replay a session After you've recorded a session, you can replay it using VisionReplayManager, which is a replacement of VisionManager for replay scenario. The only method of VisionManager that still must be called is VisionManager.init. Provide path to the recorded session to VisionReplayManager.create(path) method: Java Kotlin string path = ""/path/to/recorded/session/""; VisionReplayManager.create(path); VisionReplayManager.start(); Copy Was this page helpful? Yes No",,Testing and development,Device requirements,Video requirements,,Development environment setup,What to expect,Testing with sensor data,Record a session,Replay a session,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Local style or custom raster style,Load a locally stored map style JSON file or custom raster style via a URL.,https://docs.mapbox.com/android/maps/examples/use-a-local-style-source/,example,Java,,"Local style or custom raster style Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""parent"" mapbox:layout_constraintHorizontal_bias=""0.0"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""8.853067"" mapbox:mapbox_cameraTargetLng=""-73.846880"" mapbox:mapbox_cameraZoom=""3.15"" /> <Button android:id=""@+id/load_custom_raster_button"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginBottom=""8dp"" android:layout_marginEnd=""8dp"" android:background=""@color/mapboxPink"" android:elevation=""2dp"" android:paddingLeft=""8dp"" android:paddingRight=""8dp"" android:text=""@string/load_raster_button_text"" android:textAllCaps=""false"" android:textColor=""@color/mapboxWhite"" mapbox:layout_constraintBottom_toTopOf=""@+id/load_local_style_button"" mapbox:layout_constraintEnd_toEndOf=""parent""/> <Button android:id=""@+id/load_local_style_button"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginBottom=""16dp"" android:background=""@color/mapboxPurple"" android:elevation=""2dp"" android:paddingLeft=""8dp"" android:paddingRight=""8dp"" android:text=""@string/load_local_style_button_text"" android:textAllCaps=""false"" android:textColor=""@color/mapboxWhite"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintEnd_toEndOf=""@+id/load_custom_raster_button""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; /** * Example loads the map style via a locally stored style JSON file or custom raster style */ public class LocalStyleSourceActivity extends AppCompatActivity { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_style_local_style_source); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.LIGHT); findViewById(R.id.load_custom_raster_button).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // Reference the custom raster file URL and pass through as the string parameter mapboxMap.setStyle(new Style.Builder().fromUri(""https://www.mapbox.com/android-docs/files/mapbox-raster-v8.json"")); } }); findViewById(R.id.load_local_style_button).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // Reference the local JSON style file in the assets folder and pass through as the string parameter mapboxMap.setStyle(new Style.Builder().fromUri(""asset://local_style_file.json"")); } }); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Local style or custom raster style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Georeference imagery,Take your non-georeferenced aerial image or historical map and get it onto a Mapbox map with the help of QGIS.,https://docs.mapbox.com/help/tutorials/georeferencing-imagery/,tutorial,No code,,"advanced No code Georeference imagery Prerequisite Familiarity with QGIS. Georeferencing is the process of assigning geographic coordinates to a raster image to define its location in the world based on a map coordinate system. If you've ever used Mapbox Satellite you've already worked with georeferenced images. This is because each raster tile in Mapbox Satellite is an image that's been assigned a particular location in the world. There are lots of reasons why you may want to georeference your own custom raster images. For example, you might receive satellite imagery in a non-spatial image format, you may need to compare historic maps to current maps, or you might be building an interactive map of a fictional place for a gaming app. For this tutorial, you'll be georeferencing a JPEG image of historical downtown Portland, Oregon using QGIS, a free open-source Geospatial Information System (GIS). Once you've exported your image to GeoTIFF format in QGIS, you'll upload it to your Mapbox account as a tileset. Mapbox does not provide built-in tools to georeference your imagery because there are free, open-source tools that do this, such as QGIS. Getting started For this tutorial you'll need: QGIS. Follow the download instructions for more information and be sure you've installed the latest version. An image to georeference. This tutorial uses a historical map of downtown Portland, Oregon in JP2 (a type of high resolution JPEG) format, which you'll need to download. This image is clipped from a larger map of Multnomah County, Oregon provided by the Library of Congress.1 Download image Georeference your image in QGIS First you'll need to follow the instructions in the Georeferencing Topo Sheets and Scanned Maps tutorial for QGIS. This introduction to georeferencing will guide you through the process using the most recent version of QGIS. Make sure you use the image you downloaded at the beginning of this tutorial rather than the image provided in the QGIS tutorial and EPSG:900913 or EPSG: 3857 (Web Mercator) as your coordinate reference system (CRS). Once you've finished georeferencing your image, make sure to save your GeoTIFF file as downtown-pdx.tif in a convenient location for when you upload it to Mapbox. Upload to Mapbox as a tileset You successfully transformed a JP2 image into a GeoTIFF and are ready to upload it to Mapbox as a tileset. You can upload your GeoTIFF in Mapbox Studio or programmatically using the Mapbox Uploads API. For more information on uploading using Mapbox Studio, read the Uploads section of the Mapbox Studio Manual. For more information on using the Uploads API, read the Uploads API documentation. Finished product You georeferenced your custom imagery and uploaded it to your Mapbox account. Now that your imagery is in raster tile format, you can add it to any of your Mapbox projects as a raster tile source. Here's an example of adding your imagery to a map using Mapbox GL JS. Next steps To learn more about georeferencing, read QGIS's advanced Georeferencing Aerial Imagery guide to extend your georeferencing skills. 1 Habersham, Robert A, and Julius Bien & Co. Map of Multnomah County, Oregon: compiled from county records, railroad surveys, and other official data. [New York: Julius Bien & Co Photo. Lith, 1889] Map. Retrieved from the Library of Congress, https://www.loc.gov/item/2012586242/. (Accessed April 18, 2017.) Was this page helpful? Yes No",,Georeference imagery,Georeference your image in QGIS,Upload to Mapbox as a tileset,,Finished product,Next steps,,,,,,,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Use Atlas with other Mapbox products,Use Atlas with other Mapbox products.,https://docs.mapbox.com/atlas/overview/products/,guide,,,"Use Atlas with other Mapbox products To build with Mapbox GL JS and other Mapbox products and to serve your Atlas maps, you will need the Atlas token that you created as part of the installation process. This Atlas public token is unique to your Atlas instance, and will not work on Mapbox.com. Available Mapbox APIs With Mapbox Atlas, you can use the following Mapbox APIs offline: Vector Tiles API Raster Tiles API Legacy Maps API Styles API Static Images API Static Tiles API Tilequery API Geocoding API Right now, Atlas only supports calls to these APIs that require public access (pk) tokens. For example, it's not possible to programmatically create, edit, or delete map styles using the Styles API since these calls require a secret access (sk) token, but you can do all these functions with the Atlas instance of Mapbox Studio. Use Mapbox GL JS with Atlas Note: Atlas supports Mapbox GL JS versions 0.40 through 0.54. To use a Mapbox GL JS application with Atlas, make the following changes to the relevant files: Update mapboxgl.accessToken to a public access token created on your Atlas Studio Account page. Set mapboxgl.config.API_URL = '<your-atlas-url>'; within your application. Update the mapbox-gl-js library URLs in your HTML: <script src='<your-atlas-url>/mapbox-gl-js/v0.46.0/mapbox-gl.js'></script> <link href='<your-atlas-url>/mapbox-gl-js/v0.46.0/mapbox-gl.css' rel='stylesheet' /> If you use additional APIs in your application, you need to make sure that all APIs have been updated to the appropriate Atlas URL instead of the default api.mapbox.com. Looking for inspiration? You can use Mapbox GL JS examples as a baseline to build off of, then make the above changes for working with Atlas. Use Mapbox.js with Atlas Note: Atlas supports Mapbox.js versions 2.0 through 3.1. While Mapbox.js is stable, it is not in active development. We recommend you to use Mapbox GL JS instead if possible. Mapbox Studio styles with L.mapbox.styleLayer are supported when you use Mapbox.js with Atlas. Mapbox Studio Classic styles are not supported. To use a Mapbox.js application with Atlas, make the following changes to your file: Update L.mapbox.accessToken to a public access token created on your Atlas Studio Account page. Update L.mapbox.config.HTTPS_URL to set the appropriate hostname and port for your Atlas installation. Use L.mapbox.styleLayer to set the style. For example: L.mapbox.styleLayer('mapbox://styles/mapbox/streets-v10').addTo(map); Update the mapbox.js library URLs in your HTML: <script src='https://<your-atlas-url>/mapbox.js/v3.1.1/mapbox.js'></script> <link href='https://<your-atlas-url>/mapbox.js/v3.1.1/mapbox.css' rel='stylesheet' /> If you use additional APIs in your application, you need to make sure that all APIs have been updated to the appropriate Atlas URL instead of the default api.mapbox.com. Use mobile and AR SDKs with Atlas Atlas maps can also be used in mobile apps that use the Mapbox Android Maps SDK or the iOS Maps SDK, or in AR apps that use the Mapbox Unity SDK. You can make all apps that work on Mapbox.com also work with Atlas using the proper app configuration. Static examples Your Atlas installation comes with two static map examples that you can use for reference as you create your own Atlas maps. There is a vector map example used in a webpage powered by Mapbox GL JS, and a raster map example in a page powered by Mapbox.js. The HTML for both of these files is in the /static directory. To view these examples: Open the example HTML file in a text editor like Atom or Sublime. For Mapbox GL JS: /atlas-server/static/index.html For Mapbox.js: /atlas-server/static/mapbox-js.html In the JavaScript and CSS scripts in the header of the HTML file, update http://localhost:2999 to match your Atlas configuration. Remove the token placeholder text (your-atlas-studio-token) and replace it with your public pk access token. (Your public token is located on your Atlas account dashboard.) The token should be in quotation marks. Open the sample file in a browser to view the static map example. Was this page helpful? Yes No",,Use Atlas with other Mapbox products,Use Mapbox GL JS with Atlas,Use Mapbox.js with Atlas,,Use mobile and AR SDKs with Atlas,Static examples,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Inconsistencies in statistics and invoices,Understand what situations might result in inconsistencies between your statistics page and monthly invoices.,https://docs.mapbox.com/help/troubleshooting/statistics-invoices/,troubleshooting,,,"Inconsistencies in statistics and invoices This guide covers what situations might result in inconsistencies between your account statistics and your invoices. If you'd like to read more about either of these products in depth, jump to the Statistics and usage guide or the Invoices and billing guide. Timezones If you've set the custom date on your Statistics page to match your billing cycle and notice a discrepancy in the values of services you were billed for, it's most likely an issue with timezones. Requests attributed to your billing period that were not invoiced during that month will roll over to the next invoice. Deleted access tokens When you filter by All tokens, you will see all your account statistics, including usage from deleted access tokens. Deleted tokens do not show up in the drop-down filter list. Filtering MAUs by token For mobile applications that are billed on Monthly Active Users, statistics in your dashboard vary based on whether or not you are filtering by access token: When viewing stats for All tokens and connected apps your statistics page will not show any tile requests or Static Images API requests from that application. When filtered by access token your statistics page will include these tile requests or Static Images API requests for dates before April 4, 2019. This discrepancy only relates to dates before April 4, 2019, and does not affect your bill, which is based on Monthly Active User counts. Other inconsistencies If none of the situations above apply to your account, please contact support. Was this page helpful? Yes No",,Inconsistencies in statistics and invoices,Deleted access tokens,Filtering MAUs by token,,Other inconsistencies,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,CORS errors,Learn how to address CORS errors.,https://docs.mapbox.com/help/troubleshooting/cors-errors/,troubleshooting,,,"CORS errors CORS (cross origin request sharing) errors can be identified by checking for error messages in the console: XMLHttpRequest cannot load file:///mapbox.js/assets/data/states.geojson. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource. When you receive a CORS (cross origin request sharing) error, it means that the file you have opened is attempting to load external data, either from a relative or absolute URL: var statesLayer = L.mapbox.featureLayer() // Grab some GeoJSON data from a relative URL .loadURL('https://www.mapbox.com/mapbox.js/assets/data/states.geojson') .on('click', handleClick) .on('ready', resetStyles) .addTo(map); The code above, copied from a Mapbox.js example, points to a GeoJSON file in a different directory. Your browser interprets this as a cross origin HTTP request. As with any AJAX request, this technique is subject to the Same Origin Policy. To avoid this error, you can either put the file on the same domain (or, for local testing, in the same directory) as the JavaScript, or open the file via a server delivering that supports CORS. Python's SimpleHTTPServer supports CORS and is relatively straightforward to set up. Was this page helpful? Yes No",,CORS errors,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Customize label text for a single label,Use expressions in Mapbox Studio to alter a single label.,https://docs.mapbox.com/help/tutorials/customize-label-text/,tutorial,No code,,"beginner No code Customize label text for a single label This tutorial will walk you through how to use expressions in the Mapbox Studio style editor to customize the label text for a single label. Getting started Before getting started, you will need to create a Mapbox account to use the Mapbox Studio style editor. You can create an account at mapbox.com/account. Create a new style Log into your Mapbox account and navigate to your Styles page. This is where all your styles are listed. A style is a set of rules for how Mapbox will draw your map on the page. It defines how all your data should be styled and includes references to your data and map images (icons, markers, patterns), fonts. For more about styles, see the Styles section of the Mapbox Studio Manual. Go to your Styles page. Click the New style button. Find the Basic Template style and click Customize Basic Template. The style editor will automatically open with the Basic template style ready for editing. Use the style editor The Mapbox Studio style editor is a visual tool for creating custom map styles to your exact specifications. Take a look at the layers on the left side of the style editor screen. Each layer can be customized in a variety of ways including (but not limited to) changing labels. Use expressions to edit specific labels within a layer Click on the country-label layer to see all the options available to style this layer. To customize the country labels based on conditions and properties within the data, select Style with data conditions and choose name_en to style the label based on the English name for the country. In the new panel, you are prompted to fill in the details of your data condition. In the first text field, enter France since this is the label you will be customizing. In the Text field, add ""Land in: "" and click on & to combine your two strings. As you do this, you will see the France label change to Land in: France on your map. To edit another data condition, click Done in the bottom right hand corner and then Add another condition. This time, continue the travel journey by choosing the first stop on the trip. In the first text field, enter Spain and then ""First stop: "" in the Text field box. Repeat the previous step to continue to add more data conditions and stops on the trip. Once you are finished your map will look something like the one below. Final product You've updated your map using expressions to display custom labels for specific labels. To learn more about using the Mapbox Studio style editor, read the Mapbox Studio Manual. Was this page helpful? Yes No",,Customize label text for a single label,Create a new style,Use the style editor,,Use expressions to edit specific labels within a layer,Final product,,,,,,,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Examples,Code examples for the Mapbox Maps SDK for Android.,https://docs.mapbox.com/android/maps/examples/,,,,"Getting started Create a simple map view Learn how to quickly display a Mapbox Street map in your app. Dynamically build a map view Add a mapview in a dynamically created layout. Support map fragment Include a map fragment within your app using Android support library. Dynamic styling Hillshading Use elevation data to show and customize hills and mountains. Add a vector tile source Add a vector source to a map and display it as a layer. Add a new layer below labels Using the second argument of addLayer, you can be more precise. Add a WMS source Adding an external Web Map Service layer to the map. Show time lapse Use an image source and a runnable to show data changes over time. Adjust a layer's opacity Drag the seek bar to adjust the opacity of a raster layer on top of a map. Animate marker position Animate the marker to a new position on the map. Icon update based on API response See the International Space Station location in real time. Change a layer's color Using layer set to change a layer's fill color. Change a map's language Switch the maps language dynamically. Color dependent on zoom level Make a property depend on the map zoom level, in this case, the water layers fill color. Click to add photo Select a photo on the device and add it on the map tap location. Indoor Map Display an indoor map of a building with toggles to switch between floor levels. Marker following route Using a map matched GeoJSON route, the marker travels along the route at consistent speed. Style with missing icon Provide an icon when a Style failed to load one. Symbol layer icons Use a SymbolLayer to display icons on the map. Picture in picture Use the Android O release of picture-in-picture to maintain a map in a separate window. Pulsing layer opacity Use the style API to highlight parks, hotels, and attractions. A pulsing animation is also added to the colors. Text anchor position Adjust the anchor position of SymbolLayer text fields. Button interaction styling Change various properties of a map based on user interaction and other runtime situations. Opacity fade Adjust the opacity of a satellite raster layer based on zoom level. Show and hide layers Create a custom layer switcher to display different datasets. SymbolLayer icons Add markers via SymbolLayer and manipulate the data in real time. A Mapillary integration is also showcased in this example. Adjust text labels Adjust the color, size, and fonts of SymbolLayer text fields. Multiple text formats Use a format expression to style labels with multiple languages, fonts, sizes, and colors. Transparent render surface Create a transparent background and fill it with something such as moving water. Use an image source Use an image source to easily display images on the map. Variable label placement To increase the chance of high-priority labels staying visible, provide the map renderer a list of preferred text anchor positions. Animated icon movement Use Android system interpolators to animate SymbolLayer icons movement. Data visualization Styling heatmaps Gain minute control over heatmap coloring. Display water depth Use data-driven styling to show bathymetry (water depth) data. Calendar integration Show calendar event locations on the map. CircleLayer clusters Use GeoJSON and circle layers to visualize point data in clusters. Circle radius Set the radii of a circle layer\'s circles based on a data property. Create a line layer Create a GeoJSON line source, style it using properties, and add the layer to the map. Show heatmap data Add and customize a heatmap to visualize data. Draw a GeoJSON line Draw a polyline by parsing a GeoJSON file with the Mapbox Maps SDK. Draw a polygon with holes Draw a vector polygon with holes on a map using the Mapbox Maps SDK. Draw a polygon Draw a vector polygon on a map with the Mapbox Maps SDK. Draw multiple geometries Filter and draw multiple geometries from a single GeoJSON file. Join local JSON data with vector tile geometries Style a choropleth map by merging local JSON data with vector tile geometries. Line gradient Style a line with colored gradient. Line behind moving icon Draw a line behind a moving SymbolLayer icon which moves along a Mapbox Directions API route. Multiple expressions Use multiple expressions to convert and visualize data. Outlined polygon hole Outline a polygon hole to highlight a revealed region. Satellite land select View satellite photos and click to outline an area of land. Style circles categorically Using a categorical circle-color property function for a visualization. Style lines using an identity property function Using an identity line-color property function for a visualization. Toggle collision detection Allow or deny text and icons to overlap and collide. SymbolLayer clustering Use GeoJSON and SymbolLayer icons to view clustered images. Symbol layer info window Use SymbolLayer and icons to show data in a BubbleLayout ""info window"". Zoom-based icon switch Change SymbolLayer icons based on the camera\'s zoom level. Update a choropleth layer by zoom level Style a choropleth map with data-driven styling, local JSON data, and vector tile geometries. Create hotspots from points Use the Mapbox Maps SDK to visualize point data as hotspots. Data time lapse Use data-driven styling to visualize point data with a time lapse effect; rainfall in China in this example. Extrusions Adjust light location and color Change the location and color of the light shined on extrusions. Display 3D building height based on vector data Use extrusions to display 3D building height based on imported vector data. Extrude polygons for 3D indoor mapping Create a 3D indoor map with the fill-extrude-height paint property. Rotate and tilt with 3D buildings Rotate and tilt device to change camera and see all around 3D buildings. Use GeoJSON data to set extrusion height Use data-driven styling and GeoJSON data to set extrusion heights. Camera Animate the map camera Animate the map's camera position, tilt, bearing, and zoom. Fit camera in bounding box Position the camera so that all the given markers are in view. Restrict map panning Prevent a map from being panned to a different place. Rotating camera Slowly have the camera circle around a single point. Querying the map Building outline Query the building layer and show a building\'s outline. Query a map feature Click the map to add a marker at the location and display the maps property information for that feature. Select a building Use the query feature to select a building, get its geometry and draw a polygon highlighting it. User interaction Click on single layer Click on and highlight a selected GeoJSON polygon. Feature count Get the feature count inside a bounding box and highlight all the buildings. Drawing search area Drag a finger on the map to draw a search area. Highlighted line Tap on a line and add a highlight effect behind it. Symbol layer icon size change Query the map and animate the change in a SymbolLayer icon's size if clicked on. Inset map Show a smaller inset map fragment and link it to a larger map for two map interaction. Great for gaming. Location picker Drop a marker at a specific location and then perform reverse geocoding. Background fog Add a gradient on top of a MapView to show a background fog effect. RecyclerView Directions Quickly show the directions route associated with a RecyclerView item. RecyclerView interaction Manipulate the map based on recyclerview interactions. Search again in an area Search for certain features once the map is moved. This example finds parks. Snaking directions Rather than showing the directions route all at once, have it ""snake"" from the origin to destination. Offline A simple offline map Download and view an offline map using the Mapbox Maps SDK. Offline manager Download, view, navigate to, and delete an offline region. Image generation Snapshot Notification Show a snapshotted image in a notification. Share snapshot image Send and share a map snapshot image. Device location Location camera options Use LocationComponent camera options to customize map camera behavior. Track device location Receive updates when the device changes location. Customized location icon Use LocationComponent options to customize the user location information. Show a user's location on a map fragment Use the LocationComponent to display a user's location on a map fragment. Show a user's location Use the LocationComponent to show the user's current location on the map. Map style Local style or custom raster style Load a locally stored map style JSON file or custom raster style via a URL. Mapbox Studio style Use a custom Mapbox-hosted style. Default styles Use a variety of professionally designed styles with the Mapbox Maps SDK.",,Getting started,Data visualization,Extrusions,,Camera,Querying the map,User interaction,Offline,Image generation,Device location,Map style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Style with missing icon,Provide an icon when a Style failed to load one.,https://docs.mapbox.com/android/maps/examples/missing-icon/,example,Java,,"Style with missing icon Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.styles.MissingIconActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""39.6226149"" mapbox:mapbox_cameraTargetLng=""-8.4155273"" mapbox:mapbox_cameraZoom=""6""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textField; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.textOffset; /** * Use the {@link MapView#addOnStyleImageMissingListener(MapView.OnStyleImageMissingListener)} * to handle the situation where a SymbolLayer tries using a missing image as an icon. If an icon-image * cannot be found in a map style, a custom image can be provided to the map via * the listener. */ public class MissingIconActivity extends AppCompatActivity { private static final String ICON_SOURCE_ID = ""ICON_SOURCE_ID""; private static final String ICON_LAYER_ID = ""ICON_LAYER_ID""; private static final String PROFILE_NAME = ""PROFILE_NAME""; private static final String CARLOS = ""Carlos""; private static final String ANTONY = ""Antony""; private static final String MARIA = ""Maria""; private static final String LUCIANA = ""Luciana""; private MapView mapView; private MapboxMap mapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_styles_missing_icon); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { // Add Features which represent the location of each profile photo SymbolLayer icon Feature carlosFeature = Feature.fromGeometry(Point.fromLngLat(-7.9760742, 41.2778064)); carlosFeature.addStringProperty(PROFILE_NAME, CARLOS); Feature antonyFeature = Feature.fromGeometry(Point.fromLngLat(-8.0639648, 37.5445773)); antonyFeature.addStringProperty(PROFILE_NAME, ANTONY); Feature mariaFeature = Feature.fromGeometry(Point.fromLngLat(-9.1845703, 38.9764924)); mariaFeature.addStringProperty(PROFILE_NAME, MARIA); Feature lucianaFeature = Feature.fromGeometry(Point.fromLngLat(-7.5146484, 40.2459915)); lucianaFeature.addStringProperty(PROFILE_NAME, LUCIANA); // Use a URL to build and add a Style object to the map. Then add a source to the Style. mapboxMap.setStyle( new Style.Builder().fromUri(Style.LIGHT) .withSource(new GeoJsonSource(ICON_SOURCE_ID, FeatureCollection.fromFeatures(new Feature[] { carlosFeature, antonyFeature, mariaFeature, lucianaFeature}))), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { MissingIconActivity.this.mapboxMap = mapboxMap; // Add a SymbolLayer to the style. iconImage is set to a value that will // be used later in the addOnStyleImageMissingListener below style.addLayer(new SymbolLayer(ICON_LAYER_ID, ICON_SOURCE_ID).withProperties( iconImage(get(PROFILE_NAME)), iconIgnorePlacement(true), iconAllowOverlap(true), textField(get(PROFILE_NAME)), textIgnorePlacement(true), textAllowOverlap(true), textOffset(new Float[] {0f, 2f}) )); } }); } }); // Use the listener to match the id with the appropriate person. The correct profile photo is // given to the map during ""runtime"". mapView.addOnStyleImageMissingListener(new MapView.OnStyleImageMissingListener() { @Override public void onStyleImageMissing(@NonNull String id) { switch (id) { case CARLOS: addImage(id, R.drawable.carlos); break; case ANTONY: addImage(id, R.drawable.antony); break; case MARIA: addImage(id, R.drawable.maria); break; case LUCIANA: addImage(id, R.drawable.luciana); break; default: addImage(id, R.drawable.carlos); break; } } }); } private void addImage(String id, int drawableImage) { Style style = mapboxMap.getStyle(); if (style != null) { style.addImageAsync(id, BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(drawableImage))); } } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",,Style with missing icon,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Processing satellite imagery,"Learn how to find satellite raster data, process it using the Rasterio command-line tool, and publish it on a webpage.",https://docs.mapbox.com/help/tutorials/processing-satellite-imagery/,tutorial,JavaScript,,"advanced JavaScript Processing satellite imagery Prerequisite Familiarity with front-end development concepts. Some advanced JavaScript required. In this tutorial, you will learn how to find satellite raster imagery, then use command line tools to process these images. Finally, you will use Mapbox GL JS to create a map that demonstrates how Dubai's landscape has changed from the early 2000s to the present. To do this, you will use imagery from the USGS Landsat satellites to create georeferenced composite images using the red, green, and blue bands to prioritize the natural look of land and water. Landsat imagery is free to use, and is typical of what you often see in other resources. Getting started If you are new to working with satellite imagery, or are unfamiliar with bands or the raster data type, read the How satellite imagery works guide before getting started. There are a few tools you will need to complete this tutorial: GDAL. GDAL is a low-level GIS toolkit that Rasterio depends on. Install GDAL using the method recommended for your operating system. Rasterio. Rasterio is a tool for reading and writing geospatial raster data. Install Rasterio on the command line with the command pip install rasterio. NASA Earthdata account. A free NASA Earthdata account will let you use EarthExplorer, where the data for this tutorial comes from. Your Mapbox access token. You can find your access token on your Mapbox Account page. A text editor. Use the text editor of your choice for writing HTML, CSS, and JavaScript. You will also need to be familiar with how to use the command line to complete this tutorial. Download scenes from EarthExplorer Landsat image data is cut into scenes, which are roughly square images, for distribution. You can think of a scene as a single frame from a camera. A Landsat scene covers about 170 × 185 kilometers (105 × 115 miles). Landsat's imaging process For a more detailed understanding of Landsat's imaging process, see the Landsat Data Continuity Mission documentation. In this tutorial, you will compare historical and present-day scenes of Dubai in the United Arab Emirates that show the landscape before and after Dubai's period of economic growth in the early 2000s. To make this comparison, the scenes in this tutorial come from two different satellites in the Landsat series. The ""before"" image is from Landsat 5, which was decommissioned in 2013, and the ""after"" image is from Landsat 8, the latest satellite. Some features change between these satellites, but in general the Landsat program maintains as much consistency as possible, which makes this kind of comparison possible. Before you begin, create a new folder to keep your project files in. The instructions below reference specific Landsat scenes, but you can choose any scenes that you prefer. Download the Landsat 5 scene Log in to EarthExplorer with your Earthdata account. In the Search Criteria tab, type ""Dubai"" in the Address/Place search bar. Click the Show button, then select the result. Click on the Data Sets tab. Drill down to the Landsat 4-5 TM C1 Level-1 data set by clicking on Landsat, then Landsat Collection 1 Level-1. Click the checkbox next to Landsat 4-5 TM C1 Level-1 to select it. Click on the Additional Criteria tab. Paste the following ID into the Landsat Product Identifier: LT05_L1TP_160043_20011208_20180930_01_T1. Click the Results button. Click the download icon under the resulting data product (the green arrow pointing down), then click the Download button next to the Level-1 GeoTIFF Data Product option. Save the file to your project folder. Download the Landsat 8 scene Go back to the Data Sets tab and click on the checkbox next to the Landsat 4-5 TM C1 Level-1 data set to deselect it. Click the checkbox next to Landsat 8 OLI/TIRS C1 Level-1 to select it. Click on the Additional Criteria tab. Paste the following ID into the Landsat Product Identifier: LC08_L1TP_160043_20181207_20181211_01_T1. Click the Results button. Click the download icon under the resulting data product (the green arrow pointing down), then click the Download button next to the Level-1 GeoTIFF Data Product option. Save the file to your project folder. Examine the bundle contents The Landsat Level 1 products that you downloaded are compressed .tar.gz files called bundles. Unpack both bundles. The method you use to unpack them will vary depending your computer's operating system, or your web browser may unzip or fully unpack them automatically. As long as the unpacked bundles are directories in your project folder, you will be able to follow the processing instructions exactly. Each bundle will unpack into a directory that contains 14 items, mostly TIFF images. Each item's name starts with the Landsat product ID and ends with the band number. For example, LT05_L1TP_160043_20011208_20180930_01_T1_B1.TIF is the Band 1 readout for the Landsat 5 LT05_L1TP_160043_20011208_20180930_01_T1 scene. Open LT05_L1TP_160043_20011208_20180930_01_T1_B1.TIF to see what Band 1 for the Landsat 5 scene looks like. Process Landsat 5 imagery Now that you have the images you want, you will process them so that you can use them in a live map. You will work entirely from the command line for this section, starting with the Landsat 5 bundle you downloaded earlier. In the following steps, you will composite the bands into a single image, reproject these bands into the Web Mercator (EPSG:3857) projection, then color-correct the image. Composite the bands The aim of this tutorial is to make a visible image, and the natural choice would be to use the red, green, and blue bands to make a red, green, blue image. But Landsat 5 doesn’t have a blue band, so instead you will make a slightly false-color image with green for blue, red for green, and near-infrared for red. This wouldn’t work for scientific analysis, but it’s fine for visualization purposes. The numbers of the Landsat 5 bands you’ll use, which will map respectively to red, green, and blue, are 3, 2, and 1. To stack those bands into an RGB image, you will use rio stack to composite the TIFF files for Bands 1-3 and export them as a new file. Copy and paste the following command into the command line: rio stack --rgb LT05_L1TP_160043_20011208_20180930_01_T1/LT05_L1TP_160043_20011208_20180930_01_T1_B { 3,2,1 } .TIF landsat5_stack.tif The --rgb option tells viewing software (for example Photoshop) that the bands should be interpreted as red, green, and blue. The last argument in this command is the new output file (landsat5_stack.tif). The LT05_L1TP_160043_20011208_20180930_01_T1_B { 3,2,1 } .TIF argument specifies the files that get combined. This command uses a shell expansion to specify bands 3, 2, and 1 instead of separately naming each band file. After the command runs, check your project folder. You will see the new landsat5_stack.tif file. Open this file to see what the new composite image looks like. Reproject the image Next, you will reproject the composite image into the Web Mercator (EPSG:3857) projection with rio warp. You will tell rio warp to reproject with bilinear sampling, a method that does not leave pixelation. Copy and paste the following command into the command line: rio warp --resampling bilinear --dst-crs EPSG:3857 landsat5_stack.tif landsat5_mercator.tif The --dst-crs EPSG:3857 option sets the projection to Web Mercator. The last argument in this command is the new output file (landsat5_mercator.tif). After the command runs, open the new file with the reprojected image, landsat5_mercator.tif. It will look like the image in landsat5_stack.tif because the original projection is fairly close to Web Mercator. Color-correct the image Next, you will change the color, saturation, and contrast of the image using rio color, a color-correction plugin for Rasterio. Remember that rio color will create a useful visualization, but not one that is suitable for analysis. For analysis, you would need a separate workflow that included top-of-atmospheric calibration and atmospheric correction. Copy and paste the following command into the command line: rio color landsat5_mercator.tif landsat5_color.tif gamma g 1.7 gamma r 1.4 sigmoidal rgb 10 0.4 This command applies a gamma of 1.7 to the green band and a gamma of 1.4 to the red band, as well as sigmoidal contrast to all bands. (If you’re curious, you can change the numbers (and operations) in the rio color command to see if you can make the image clearer or more attractive.) Open the newly created landsat5_color.tif file. You have successfully processed the Landsat 5 image. Process Landsat 8 imagery Next, you will process the Landsat 8 image. The processing steps are much the same as the ones that you performed for the Landsat 5 image, with one important addition. Landsat 8 data is collected by a sensor that has a higher radiometric resolution than the sensor on Landsat 5. This means that Landsat 8 data comes in a 16 bit format, while Landsat 5 comes as 8 bit. Because Mapbox only accepts 8 bit resolution images, you need to convert your 16 bit Landsat 8 bands into 8 bit. Run the following commands in the command line: Composite the bands: rio stack --rgb LC08_L1TP_160043_20181207_20181211_01_T1/LC08_L1TP_160043_20181207_20181211_01_T1_B { 3,2,1 } .TIF landsat8_stack.tif Reproject the image: rio warp --resampling bilinear --dst-crs EPSG:3857 landsat8_stack.tif landsat8_mercator.tif Next, you will use rio color to convert the image to 8 bit format. You will also color-correct the image in the same step. Copy and paste the following command into the command line: rio color --co photometric=rgb --out-dtype uint8 landsat8_mercator.tif landsat8_color.tif sigmoidal rgb 20 0.2 Open the newly created landsat8_color.tif file. You have successfully processed the Landsat 8 image. Build a map using Mapbox GL JS Now that your images are processed and ready to upload, you will upload them to your Mapbox account as tilesets so you can use them in your project. Upload to Mapbox Studio The following steps show how to upload your GeoTIFFs to Mapbox using the Mapbox tilesets page. You can also upload using the Mapbox Uploads API if desired. Navigate to the Tilesets page. Click the New tileset button. A new window will open. Select the final Landsat 5 file (landsat5_color.tif), then click Confirm. The page will let you know when the file has been uploaded successfully. Repeat these steps with the final Landsat 8 file (landsat8_color.tif). The uploaded tilesets are listed on your tilesets page. Each tileset has its own tileset ID, which you can find by clicking the Menu option to the right of the listed tileset. The tileset ID allows you to reference a tileset when you use developer tools, such as Mapbox GL JS or the Mapbox iOS or Android SDKs. Compare tilesets with Mapbox GL JS Next, you will use the tileset IDs from your Landsat 5 and Landsat 8 tilesets to build a map with Mapbox GL JS. This project uses the Mapbox GL Compare plugin to compare the Landsat 5 and Landsat 8 images. Open your text editor and create a new file named index.html. Copy and paste the code below into your text editor to initialize a Mapbox GL JS map. Replace the ACCESS_TOKEN placeholder with your own Mapbox access token, which is on your Account page. Replace the BEFORE_STYLE placeholder with the tileset ID of your Landsat 5 tileset, which you can find on the Tilesets page by clicking the Menu option to the right of the tileset. Replace the AFTER_STYLE placeholder with the tileset ID of your Landsat 8 tileset, which you can find on the Tilesets page by clicking the Menu option to the right of the tileset. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title></title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <style> body { overflow: hidden; } body * { -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-compare/v0.1.0/mapbox-gl-compare.js'></script> <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-compare/v0.1.0/mapbox-gl-compare.css' type='text/css' /> <div id='before' class='map'></div> <div id='after' class='map'></div> <script> mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var beforeTileset = 'BEFORE_STYLE'; var afterTileset = 'AFTER_STYLE'; var beforeMap = new mapboxgl.Map( { container: 'before', style: { version: 8, sources: { 'raster-tiles': { type: 'raster', url: 'mapbox://' + beforeTileset, tileSize: 256 } } , layers: [ { id: 'simple-tiles', type: 'raster', source: 'raster-tiles', minzoom: 0, maxzoom: 22 } ] } , center: [55.1720, 25.0859], zoom: 11 } ); var afterMap = new mapboxgl.Map( { container: 'after', style: { version: 8, sources: { 'raster-tiles': { type: 'raster', url: 'mapbox://' + afterTileset, tileSize: 256 } } , layers: [ { id: 'simple-tiles', type: 'raster', source: 'raster-tiles', minzoom: 0, maxzoom: 22 } ] } , center: [55.1720, 25.0859], zoom: 11 } ); var map = new mapboxgl.Compare(beforeMap, afterMap, { } ); </script> </body> </html> Open the file in your browser. You will see your initialized Mapbox GL JS map displayed in the browser window. Drag the slider left and right to compare the difference in Dubai's landscape. Finished product You found your own satellite imagery, processed it for the best visual impact, and created a display to visualize landscape change over time. You also learned how to use command-line analysis tools to process any kind of raster imagery you might want to use with Mapbox. Next steps To learn more, complete the Georeferencing imagery tutorial, which walks you through a manual process for georeferencing imagery or raster data that doesn't already come with a geospatial reference system. You can also explore out the Mapbox GL JS examples page for ideas about how to extend your web applications even further. Was this page helpful? Yes No",,Processing satellite imagery,Download scenes from EarthExplorer,Download the Landsat 5 scene,,Download the Landsat 8 scene,Examine the bundle contents,Process Landsat 5 imagery,Composite the bands,Reproject the image,Color-correct the image,Process Landsat 8 imagery,Build a map using Mapbox GL JS,3,Upload to Mapbox Studio,Compare tilesets with Mapbox GL JS,Finished product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Isochrone API,The Mapbox Isochrone API allows you to request polygon or line features that show areas that are reachable within a specified amount of time from a location.,https://docs.mapbox.com/help/glossary/isochrone-api/,glossary,,,"Isochrone API The Mapbox Isochrone API allows you to request polygon or line features that show areas that are reachable within a specified amount of time from a location. A sample Isochrone API request looks like: https://api.mapbox.com/isochrone/v1/mapbox/driving/-118.22258,33.99038?contours_minutes=5,10,15&access_token= YOUR_MAPBOX_ACCESS_TOKEN The Isochrone API has optional parameters that can be used to refine the results of a request. Related resources: Isochrone API documentation Get started with the Isochrone API tutorial Was this page helpful? Yes No",,Isochrone API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Runtime styling,"Use Mapbox's runtime styling features to create dynamic maps and visualizations that respond to user interaction, context, and more.",https://docs.mapbox.com/ios/maps/overview/runtime-styling/,guide,,,"Runtime styling Mapbox’s runtime styling features allow you direct control over every layer in your maps with code. It’s now possible to create dynamic maps and visualizations that aren’t possible with other mobile maps SDKs. What is runtime styling? The Mapbox Studio style editor can be used to create completely custom map styles. Runtime styling expands upon the design power of Mapbox Studio and exposes all the same properties and attributes directly to mobile developers in our Maps SDK. Change the look and feel of your map dynamically by updating its visual appearance based on user interaction or context. Leverage the power of OpenGL for highly performant and complex data visualizations. With the Mapbox Maps SDK, it’s possible to mix in your own data and bring your map to life. Example use cases As an example of what’s possible with runtime styling, consider some of the following use cases: Styling maps dynamically At runtime, you can tailor the map specifically to your user interface. Adjust colors, text, and icons to match the style to your brand. For maps that aren’t going to change in response to custom data or user interaction, consider creating a custom map style with Mapbox Studio. Map interactivity You can customize the map to respond dynamically to the actions your users take. Increase the text size of streets while a user is driving, emphasize points of interest tailored to a user’s preferences, or change the UI if users are at parks, trails, landmarks, or rivers. Powerful data visualization Mapbox maps are built on top of OpenGL and can support rendering data without the traditional overhead of UIView-based map annotations. Mapbox can support data visualizations that were slow or impossible with traditional map SDKs. Render heatmaps, visualize population density, or even go so far as updating the snow levels in the mountains to match recent snowfall. Powerful annotations The Mapbox Maps SDK gives you access to all the same tools we use to render our default map styles. Instead of using generic pin markers, enrich your place data or custom polygons with icons and labels that make your maps stand out. Custom shapes Draw custom shapes on the map the same way you would a custom UIView or CALayer. These shapes keep their geographic scale and can visualize everything from indoor floor plans to metro systems to hurricane tracks. Next steps Explore the iOS code examples to learn more about how to use runtime styling in your own apps. Learn more about map styles and runtime styling in the following resources: Information for style authors Mapbox Streets source reference Mapbox Studio iOS code examples Step-by-step tutorials Was this page helpful? Yes No",,Runtime styling,Example use cases,Styling maps dynamically,,Map interactivity,Powerful data visualization,Powerful annotations,Custom shapes,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,View a fullscreen map,Toggle between current view and fullscreen mode.,https://docs.mapbox.com/mapbox-gl-js/example/fullscreen/,example,JavaScript,,View a fullscreen map Toggle between current view and fullscreen mode. Was this example helpful? Yes No,,View a fullscreen map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Overview,Learn about the building blocks that Mapbox provides so you can create custom mapping applications.,https://docs.mapbox.com/help/how-mapbox-works/,guide,,,"How Mapbox works Learn about the building blocks that Mapbox provides so you can create custom mapping applications. Overview Welcome to Mapbox! Mapbox is a developer platform used across industries to create custom applications that solve problems with maps, data, and spatial analysis. Mapbox's tools are building blocks that support every part of the web and mobile map-making process. Whether your goal is to build a beautiful map to match your website or to build a full-featured geoprocessing application, we have you covered. These guides will introduce you to the building blocks of Mapbox and how you can: Work with in Mapbox's robust data. Style your map down to the smallest details. Upload or create custom data. Develop full-featured web and mobile applications. Extend your app's functionality with web services for geocoding, directions, spatial analysis, and more. Create static maps programmatically. Use Mapbox map data Our core tilesets: Mapbox Streets, Mapbox Terrain, Mapbox Traffic, and Mapbox Satellite. Each tileset contains a unique set of data from a variety of sources. Mapbox Streets includes streets, buildings, administrative areas, water, and land data based on OpenStreetMap, updated as often as every five minutes. Mapbox Terrain includes landcover data and a worldwide elevation data set complete with contours, hillshade, and elevation data. Mapbox Satellite includes global satellite imagery from a range of sources, processed and seamed together by Mapbox. Mapbox Traffic includes regularly updated vehicle congestion information on top of Mapbox Streets. You can find a full list of layers available in the Mapbox Streets, Terrain, and Traffic sources in our Vector Tiles overview. You can read more about our data sources on our Maps page. Learn about our data Design a map Custom map design is one of the core functions of Mapbox Studio. We provide an advanced application for putting this customization at your fingertips with the Mapbox Studio style editor. In Mapbox Studio, you can start with one of our template styles or designer styles and style each individual layer to your exact specification. On the left you can see the Basic style, a template style made up of a limited set of layers. On the right you can see a custom style that uses all the same underlying data, but that has been customized by changing colors and fonts in Mapbox Studio style editor. The Mapbox Studio style editor is a full-featured map editor that gives you total control over the style of your map directly in your browser. Whether you start with a Mapbox template style or start from scratch, the styling possibilities are virtually endless. With the Mapbox Studio style editor, you can: Create styles that change dynamically based on zoom level. Use custom fonts. Set custom alignment, pitch, offset, and more for your labels. Set colors, weights, and opacity for your map layers. Filter tilesets based on attributes. Learn about map design Add custom data Mapbox provides robust geospatial data with our Streets, Terrain, Traffic, and Satellite tilesets, but mapping applications often require custom data. To add custom data to your map, you can upload your own data as tilesets or create datasets. Tilesets and datasets are two different types of data: tilesets are styleable and datasets are editable. Styling includes changing things like color, opacity, font, or icon. Editing includes changing the placement of features (points, lines, polygons), their geometries, and adding or deleting features from a feature collection. If you have created or imported a dataset, you can export your dataset to a tileset right in Mapbox Studio and use it in the Mapbox Studio style editor like you would any other tileset. Upload tilesets Tilesets are lightweight collections of vector data that are optimized for rendering and are not editable. When you upload custom data, your files are converted to vector tilesets, which can be styled in the Mapbox Studio style editor, added to interactive web maps with Mapbox GL JS, and used in mobile applications created with the Mapbox Maps SDKs for iOS and Android. For more details about accepted file types and methods for uploading data, see the Uploading data guide. Learn about uploads Create datasets A dataset is an editable collection of GeoJSON features. A feature stored with Mapbox has both geometries and properties (attributes), both of which can be edited in the Mapbox Studio dataset editor or through the Mapbox Datasets API. You can use the dataset editor in Mapbox Studio to import, create, and edit GeoJSON point, line, and polygon features and their properties. Once you've finished working with your dataset, you can export it to a tileset for use with the Mapbox Studio style editor. There are limits to how much data you can load into the Mapbox Studio dataset editor at a time, but you can use the Mapbox Datasets API to add more features and manage them programmatically. For more details about accepted file types and methods for creating datasets, see the Creating new data guide. Learn about creating data Build applications Once you've created, styled, and added data to your map, Mapbox provides multiple tools for integrating your maps into a website or custom application. Web applications You can use one of our JavaScript libraries to publish your map to the web. This web application uses a combination of HTML, CSS, JavaScript, and Mapbox GL JS, our WebGL-based JavaScript library. If you are interested in learning more about how to build an application like this one, read our step-by-step Build a store locator tutorial. Mapbox GL JS is a JavaScript library for creating interactive, customizable maps from Mapbox styles and vector tiles. Mapbox GL JS uses WebGL, a technology used to create video games in the browser, which enables you to build advanced interactions into your maps, including smooth zooming, map bearing and pitch, querying underlying map data, and dynamically filtering the data you choose to display. You can use the custom styles you've created in the Mapbox Studio style editor or any of the template styles we provide, plus add any additional data you want programmatically -- including GeoJSON, images, and even video! Be sure to explore the Mapbox GL JS examples for dozens of other interactive examples. Mapbox.js is our older JavaScript web mapping library that extends the popular Leaflet.js library. Mapbox.js can be used to create interactive maps with classic styles. Learn about web apps Mobile applications Mapbox provides a Maps SDK for iOS and Android for publishing your maps in native applications. The Maps SDKs for iOS and Android are designed to be drop-in replacements for Apple's MapKit and the Google Maps SDKs. The Maps SDKs should be familiar to mobile developers who have experience with either. Often, your maps can be swapped for Mapbox by changing a single line of code. Each SDK comes bundled with five Mapbox-designed map styles and can handle any custom design created with the Mapbox Studio style editor. If you use one of Mapbox's mobile SDKs, you'll also get access to the mobile usage dashboard, which provides a continuously updated view of monthly active users, map usage, and region-by-region metrics. Learn about mobile apps Unity applications Mapbox makes real world simulations possible by giving you the tools to put real world maps in your Unity applications. The Mapbox Maps SDK for Unity is a set of tools to build Unity applications from real map data. It consists of a robust API for interfacing with Mapbox web services and converting map resources into game objects as well as a robust graphical user interface built on top of the Unity platform. Learn about Unity apps Extend your application Besides designing maps and publishing mapping applications, Mapbox also has tools for interacting with data, locating addresses, conducting spatial analysis, and routing. Our web services APIs are building blocks you can use to make your maps interactive and dynamic. Mapbox Geocoding API Add global place search to your app with the Mapbox Geocoding API. Turn latitude and longitude values into addresses with reverse geocoding or you turn addresses into latitude and longitude values with forward geocoding. You can use the Geocoding API right in your web or mobile application or as a standalone service. Learn about geocoding Mapbox Directions API The Mapbox Directions API provides point-to-point directions for walking, cycling, or driving based on the wide network of roads and paths in OpenStreetMap. The Directions API returns text instructions, alternative routes, geometry (for drawing routes), and maneuvers. The Directions API also powers our Map matching, Matrix, and Optimization APIs. See the Directions API documentation for more information. Learn about directions Analyze with Turf.js Turf.js is an open source JavaScript library for spatial analysis. Turf includes traditional spatial analysis operations, helper functions for creating GeoJSON data, and data classification and statistics tools. You can add Turf to your website as a client-side plugin, or you can run Turf server-side with Node.js. Learn about analysis Use satellite imagery Mapbox Satellite is a global basemap of continuous satellite and aerial imagery that you can use as a blank canvas or an overlay for your own data. Comprised of multiple imagery sources, we color correct it and update it as new imagery becomes available. Mapbox Satellite uses global satellite and aerial imagery from commercial providers, NASA, and USGS. As cities grow and landscapes change, we add newer, clearer, and more attractive imagery. The current zoom level offerings include: 0–8: MODIS 2012–2013. 9–12: Landsat 5 & 7, 2010–2011. 13–19: a combination of open and proprietary sources, including DigitalGlobe’s GBM 2011+ for much of the world, USDA’s NAIP 2011–2013 in the contiguous United States, and open aerial imagery from Denmark, Finland, and parts of Germany. Learn about satellite imagery Create static maps The Mapbox Static Images API can generate static images from your map styles. Provide your style ID, access token, and a few more parameters — such as zoom, bearing, pitch, and overlay — and you can display static images directly by making requests in your application. Learn about static maps Add attribution Whether you're creating a custom style with Mapbox Studio or building a mobile app with the Android SDK, all Mapbox tools require attribution according to our terms of service. Learn about attribution Was this page helpful? Yes No",,Overview,Design a map,Add custom data,,Upload tilesets,Create datasets,Build applications,Web applications,Mobile applications,Unity applications,Extend your application,Mapbox Geocoding API,,Mapbox Directions API,Analyze with Turf.js,Use satellite imagery,Create static maps,Add attribution,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Get started with Mapbox Boundaries v1,Get started with v1 of the Mapbox Boundaries tileset.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,No code,,"intermediate No code Get started with Mapbox Boundaries v1 Prerequisite Familiarity with front-end development and access to Mapbox Boundaries. Note Boundaries v1 is no longer in active development. To learn more about our newer mapping tools see Get started with Mapbox Boundaries. Access to Mapbox Boundaries Access to the Boundaries tilesets are controlled by Mapbox account access token. If you do not have access on your account, contact a Mapbox sales representative to request access to Boundaries tilesets. Mapbox Enterprise users can add global administrative and postal boundaries to their maps and data visualizations. This guide covers how to use Mapbox Boundaries in a web application, feature lookup tables, data-joins, and the Tilequery API. Getting started Mapbox Boundaries are available as a part of an Enterprise plan. If you do not have an Enterprise plan or if you do have an Enterprise plan and would like to add access to Mapbox Boundaries, contact a Mapbox sales representative to request access. Access to the Boundaries tilesets are controlled by your Mapbox account access token. Add to an application Once you have access to Mapbox Boundaries, you can use them in an application as you would use any other tileset. About Mapbox Boundaries Below you'll find a few pieces of key information that you'll need to navigate the Mapbox Boundaries tileset. Tileset IDs Mapbox Boundaries are stored as vector tiles and distributed via the Mapbox Vector Tiles API, with a unique tileset for each admin and postal level. Tileset IDs for Boundaries tilesets are in the form mapbox.enterprise-boundaries-adminOrPostalLevel-version. For example, admin level 0 boundaries (which contain countries) are at the tileset ID mapbox.enterprise-boundaries-a0-v1. Feature IDs Each feature also has a unique ID that is used to identify a feature polygon. Once Mapbox Boundaries are added to your account, you will be able to access the technical documentation containing the feature IDs and all identifying metadata. Minimum zoom levels and bounding boxes z_min: The z_min value for each feature indicates the minimum zoom level at which a feature is available in a tileset. Use this to set the camera to a minimum zoom level to see the feature. centroid point: Centroid point features are guaranteed to appear at zoom level z_min + 1. Centroid point features can be used to display a marker, symbol, or label at the center of a Boundaries feature. bounds: Feature bounds are the smallest rectangular envelope that a feature fits into denoted as an array of [min_long, min_lat, max_long, max_lat]. Example To use a Mapbox Boundaries tileset in your application, make a request from the Mapbox Vector Tiles API for the relevant tileset. For example, in Mapbox GL JS, load the tileset using the code below: // Be sure to use an access token from an account // that has access to Boundaries mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', style: 'mapbox://styles/mapbox/light-v 10 ', center: [-99.9, 41.5], zoom: 1 } ); map.on('load', function() { // Add source for admin-0 Boundaries map.addSource('admin-0', { type: 'vector', url: 'mapbox://mapbox.enterprise-boundaries-a0-v1' } ); // Add a layer with boundary lines map.addLayer( { id: 'admin-0-line', type: 'line', source: 'admin-0', 'source-layer': 'boundaries_admin_0', paint: { 'line-color': 'red', 'line-width': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 10] } } , 'waterway-label'); // Add a layer with points map.addLayer( { id: 'admin-0-circle', type: 'circle', source: 'admin-0', 'source-layer': 'points_admin_0', paint: { 'circle-color': 'white', 'circle-stroke-color': 'black', 'circle-stroke-width': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 6], 'circle-radius': ['interpolate', ['linear'], ['zoom'], 0, 2, 20, 20] } } , 'waterway-label'); } ); The code above will yield a map with all country boundaries in red with a circle at the center of each country. Feature lookup tables Each boundary feature is indexed in a lookup table. Lookup tables are designed to be used locally in your application. User data can be joined to Mapbox Boundaries in your application to create a visualization, such as a choropleth map of unemployment by state. About feature lookup tables The Mapbox Boundaries lookup tables include this metadata about each polygon feature: id: globally unique identifier for the feature level: admin level; admin-0, admin-1....post-3, post-4 country_code: 2-digit ISO code name: local feature name name_ascii: local feature name converted to ascii characters admin_code: feature admin or postal code bounds: an array of the features bounding box as [minlong, minlat, maxlong, maxlat] z_min: minimum zoom level at which a polygon feature appears in a tileset parent_0: the level-0 parent of a feature, if it exists parent_1: the level-1 parent of a feature, if it exists parent_2: the level-2 parent of a feature, if it exists parent_3: the level-3 parent of a feature, if it exists parent_4: the level-4 parent of a feature, if it exists tileset_name: tileset ID for the tileset containing the feature point_layername: name of the source-layer within the tileset containing feature centroid poly_layername: name of the source-layer within the tileset containing feature polygon geometry Lookup tables are available in two formats: tsv and json. Sample workflow The feature lookup tables are designed to be used alongside the Boundaries tilesets. A typical workflow for a business intelligence application is: A user identifies geographic dimensions in a data source, such as state, zip, country, or longitude & latitude. A user makes a query from application data store. Data store joins geographic dimension query results to metadata in the feature lookup table, such as name or admin_code. Data store groups and aggregates results by geographic dimension and sends to the client visualization tool. Generate a Mapbox GL layer from the Mapbox Style Specification to create a visual from query results. The visual style definition works the same across all Mapbox GL products, including Mapbox GL JS on the web, and Mapbox GL Native on iOS, Android, macOS, and Qt. Example Read Visualize the USA’s economic recovery with client-side data joins, which illustrates how the steps in the sample workflow can work in your application. Data-joins About data-joins The data-join technique are inner joins between local data, such as the unemployment rate by US state, to vector tile features using data-driven style notation. Sample workflow To create a data-join, use the following approach: Initialize a Mapbox Style Specification property function object. This will be the data-driven style for a fill layer's color. var color_dds = { ""property"": ""id"", ""type"": ""categorical"", ""default"": ""rgba(0, 0, 0, 0)"", //Set the default color to opacity zero ""stops"": [] } Set the stops value of the object to a list of arrays containing the [id, style value] of features needed in the visual. color_dds.stops = [['US', 'red'], ['UK', 'green']] Only features with a matching id in color_dds.stops will appear in the visual. Set the paint property of the layer to show the visual. map.setPaintProperty('my-layer-name', 'fill-color', color_dds) Example Explore this code example to apply the data-join technique to create a choropleth map from user data joined to Boundaries. Point-in-polygon query About Tilequery Use the Mapbox Tilequery API to match points to polygons. Example request: https://api.mapbox.com/v4/mapbox.enterprise-boundaries-a0-v1/tilequery/ { longitude,latitude } .json?access_token= YOUR_MAPBOX_ACCESS_TOKEN If the point is within a polygon, the Tilequery API response will return a GeoJSON-format body. The id property value of the first feature returned is the ID of the Boundaries feature that contains the queried point. Since the feature lookup table contains all Mapbox Boundaries parent features, only one API request is required per point to find all matching parent boundaries. For example, you can query the admin-3 boundary of a point in Italy, and use the lookup table to find the parent features at admin-2, admin-1, and admin-0. Example Below is an example API response from a sample query to admin-3 in Italy. The query URL is: https://api.mapbox.com/v4/mapbox.enterprise-boundaries-a3-v1/tilequery/12.87,43.100.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN The id returned is the identifier of the Boundaries feature containing the point at admin-3. { ""type"": ""FeatureCollection"", ""features"": [ { ""type"": ""Feature"", ""geometry"": { ""type"": ""Point"", ""coordinates"": [ 12.87, 43.1 ] } , ""properties"": { ""id"": ""ITA3054034"", ""tilequery"": { ""distance"": 0, ""layer"": ""boundaries_admin_3"" } } } ] } You can query multiple admin levels in one API call using tile compositing. The query below will return the admin_ids at a location for admin-1, admin-2, and admin-3: https://api.mapbox.com/v4/mapbox.enterprise-boundaries-a3-v1,mapbox.enterprise-boundaries-a2-v1,mapbox.enterprise-boundaries-a1-v1/tilequery/12.87,43.100.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN This technique allows for aggregating and visualizing points at any admin level or multiple admin levels, down to individual points, as an API service. Example You can also explore this end to end example using both the data-join technique and Tilequery API. Next steps You can extend Mapbox Boundaries with any custom data you need for your application. This could mean adding school district, city, market, or property boundaries to your application — all with the same performance and API features of the native product. For more details, read the Extend Mapbox Boundaries tutorial. Was this page helpful? Yes No",Get started with Mapbox Boundaries v1,,,,,,,,,,,,,Getting started,Add to an application,About Mapbox Boundaries,Tileset IDs,Feature IDs,Minimum zoom levels and bounding boxes,Example,Feature lookup tables,About feature lookup tables,Sample workflow,Data-joins,About data-joins,Point-in-polygon query,About Tilequery,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Dependencies,Install Atlas dependencies.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Dependencies To download and set up Atlas, you need to download several dependencies first: wget OpenSSL (optional) Docker Docker Compose unzip (Atlas Search) pv Wget, pv, OpenSSL, and unzip are all dependencies of the Atlas installer. wget is used as the download manager for the installer's download command. OpenSSL is used by the installer's setup command to create a self-signed certificate, and is optional. pv provides user feedback during file operations. If you have purchased Atlas Search, you will need unzip installed to unpack the geocoding dataset. Docker and Docker Compose are used as the primary distribution and containerization strategy for Atlas. The installation process for these dependencies will vary depending on which operating system you are using. You may need to reboot after installing the dependencies. Configuring Docker Important Please check disk space & context storage configuration! The Atlas deployment will require about 25 GB of disk space within your Docker context. Depending on how your Docker storage is configured you may have increase the disk space available to Docker. Get details about your configuration with docker info and visit the Docker storage driver documentation. We recommend configuring overlay2 and explicitly setting your data-root to reside on NVMe SSD storage: { ""data-root"": ""/nvme/docker"", ""storage-driver"": ""overlay2"" } macOS Download and install Docker and Docker Compose for macOS from the Docker website. Use Homebrew to install Wget and, optionally, OpenSSL: $ brew update $ brew install wget openssl unzip pv Docker needs at least 4 GB of RAM to run on macOS. Open the Docker control panel. Click Preferences > Advanced. Adjust the memory by sliding the tab to 4 GB. CentOS 7 # Most of these commands need to be run by the root user $ sudo su $ yum check-update $ yum install -y epel-release $ yum install -y wget openssl python-pip unzip pv # Install Docker $ curl -fsSL https://get.docker.com/ | sh # Add your user to the Docker group. i.e. centos $ usermod -aG docker centos # Enable the Docker daemon to start at system boot $ systemctl enable docker.service # Start the Docker daemon $ systemctl start docker.service # Install Docker Compose $ pip install docker-compose Ubuntu 14.04 # Update the package database $ sudo apt-get update # Install Docker and Atlas dependencies $ sudo apt-get install \ linux-image-extra-$(uname -r) \ linux-image-extra-virtual \ apt-transport-https \ ca-certificates \ curl \ software-properties-common \ wget \ openssl \ unzip \ pv # Add the Docker repository to APT sources $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \ ""deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"" # Update the package database with the Docker packages $ sudo apt-get update # Install Docker $ sudo apt-get install -y docker-ce # Add your user to the Docker group $ sudo usermod -aG docker ubuntu # Check the current release and, if necessary, update it in the command below $ sudo curl -L \ ""https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)"" \ -o /usr/local/bin/docker-compose # Set execute permissions on docker-compose $ sudo chmod +x /usr/local/bin/docker-compose Ubuntu 16.04 # Update the package database $ sudo apt-get update # Install Docker and Atlas dependencies $ sudo apt-get install -y wget openssl unzip pv # Add the Docker repository to APT sources $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \ ""deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"" # Update the package database with the Docker packages $ sudo apt-get update # Make sure you are about to install from the Docker repo $ sudo apt-cache policy docker-ce # Install Docker $ sudo apt-get install -y docker-ce # Add your user to the docker group $ sudo usermod -aG docker ubuntu # Check the current release and, if necessary, update it in the command below $ sudo curl -L \ ""https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)"" \ -o /usr/local/bin/docker-compose # Set execute permissions on docker-compose $ sudo chmod +x /usr/local/bin/docker-compose Ubuntu 18.04 # Update the package database $ sudo apt-get update # Install Docker and Atlas dependencies $ sudo apt-get install -y wget openssl unzip pv # Add the Docker repository to APT sources $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \ ""deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"" # Update the package database with the Docker packages $ sudo apt-get update # Make sure you are about to install from the Docker repo $ sudo apt-cache policy docker-ce # Install Docker $ sudo apt-get install -y docker-ce # Add your user to the docker group $ sudo usermod -aG docker ubuntu # Check the current release and, if necessary, update it in the command below $ sudo curl -L \ ""https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)"" \ -o /usr/local/bin/docker-compose # Set execute permissions on docker-compose $ sudo chmod +x /usr/local/bin/docker-compose # Link an available version of python $ sudo ln -s /usr/bin/python3 /usr/local/bin/python Red Hat Enterprise Linux 7 This guidance was tested with RHEL 7.6 3.10.0-957; per Docker documentation the OverlayFS driver requires a kernel version of at least 3.10.0-514. The OverlayFS storage driver must sit on top of an XFS file system. The following guidance assumes a storage disk is accessible at /dev/xvdf. # Red Hat Labs Registration # SKIP IF: You have already registered your instance with Red Hat $ subscription-manager register --username <username> --password <password> --auto-attach # Initialize a disk w/ the XFS file system for OverlayFS & Docker $ parted -a optimal /dev/xvdf mklabel gpt $ parted -a optimal /dev/xvdf mkpart primary xfs 0% 100% $ mkfs.xfs -n ftype=1 /dev/xvdf1 $ mkdir /docker $ mount /dev/xvdf1 /docker # Setup Docker users & groups: $ useradd -M -r docker $ usermod -aG docker ec2-user # Enable Red Hat Subscription based repositories $ subscription-manager repos --enable=rhel-7-server-rpms \ && subscription-manager repos --enable=rhel-7-server-extras-rpms \ && subscription-manager repos --enable=rhel-7-server-optional-rpms # Update System $ yum update -y # Enable EPEL yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm # Install Docker & Atlas dependencies $ yum install -y docker device-mapper-libs device-mapper-event-libs \ wget openssl python-pip unzip pv # Link shasum for the atlas-installer $ ln /bin/sha1sum /bin/shasum # Configure Docker to use disk space $ echo '{""graph"":""/docker""}' > /etc/docker/daemon.json # Deactivate selinux immediately setenforce 0 # Deactivate selinux permanently sed -i s/^SELINUX=.*$/SELINUX=disabled/ /etc/selinux/config # Enable the Docker daemon to start at system boot $ systemctl enable docker.service # Start the Docker daemon $ systemctl start docker.service # Install Docker Compose $ pip install docker-compose Was this page helpful? Yes No",Dependencies,,,,,,,,,,,,,Configuring Docker,macOS,CentOS 7,Ubuntu 14.04,Ubuntu 16.04,Ubuntu 18.04,Red Hat Enterprise Linux 7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Tilesets API,"The Mapbox Tilesets API allows you to list, delete, and retrieve TileJSON metadata for raster and vector tilesets.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"Tilesets API The Mapbox Tilesets API allows you to list, delete, and retrieve TileJSON metadata for raster and vector tilesets that belong to your account. A sample Tilesets API request to list tilesets looks like: https://api.mapbox.com/tilesets/v1/ { username } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN Tilesets API beta endpoints The Tilesets API also has beta endpoints that can be used to create and interact with tileset sources, vector tilesets, and tileset recipes. Since these endpoints are in beta, they are subject to potential changes. For more information about these endpoints, see the Tilesets API documentation. Related resources: Tilesets API documentation Was this page helpful? Yes No",Tilesets API,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Snaking directions,"Rather than showing the directions route all at once, have it ""snake"" from the origin to destination.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Snaking directions Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.javaservices.DirectionsActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""47.097562"" mapbox:mapbox_cameraTargetLng=""3.709416"" mapbox:mapbox_cameraZoom=""5.991072""/> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.graphics.BitmapFactory; import android.graphics.Color; import android.os.Bundle; import android.os.Handler; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.api.directions.v5.DirectionsCriteria; import com.mapbox.api.directions.v5.MapboxDirections; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.api.directions.v5.models.LegStep; import com.mapbox.core.constants.Constants; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import timber.log.Timber; import static com.mapbox.api.directions.v5.DirectionsCriteria.GEOMETRY_POLYLINE; import static com.mapbox.mapboxsdk.style.layers.Property.LINE_CAP_ROUND; import static com.mapbox.mapboxsdk.style.layers.Property.LINE_JOIN_ROUND; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineCap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineJoin; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Rather than showing the directions route all at once, have it ""snake"" from the origin to destination by showing the * route one {@link LegStep} section at a time. */ public class SnakingDirectionsRouteActivity extends AppCompatActivity implements OnMapReadyCallback { private static final float NAVIGATION_LINE_WIDTH = 6; private static final float NAVIGATION_LINE_OPACITY = .8f; private static final String DRIVING_ROUTE_POLYLINE_LINE_LAYER_ID = ""DRIVING_ROUTE_POLYLINE_LINE_LAYER_ID""; private static final String DRIVING_ROUTE_POLYLINE_SOURCE_ID = ""DRIVING_ROUTE_POLYLINE_SOURCE_ID""; private static final int DRAW_SPEED_MILLISECONDS = 500; // Origin point in Paris, France private static final Point PARIS_ORIGIN_POINT = Point.fromLngLat(2.35222, 48.856614); // Destination point in Lyon, France private static final Point LYON_DESTINATION_POINT = Point.fromLngLat(4.83565, 45.76404); private MapView mapView; private MapboxMap mapboxMap; private MapboxDirections mapboxDirectionsClient; private Handler handler = new Handler(); private Runnable runnable; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_javaservices_snaking_directions_route); // Setup the MapView mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; this.mapboxMap.setStyle(new Style.Builder().fromUri(Style.LIGHT) // Add origin and destination SymbolLayer marker icons to the map .withImage(""icon-id"", BitmapFactory.decodeResource( getResources(), R.drawable.red_marker)) .withSource(new GeoJsonSource(""source-id"", FeatureCollection.fromFeatures(new Feature[] { Feature.fromGeometry(Point.fromLngLat(PARIS_ORIGIN_POINT.longitude(), PARIS_ORIGIN_POINT.latitude())), Feature.fromGeometry(Point.fromLngLat(LYON_DESTINATION_POINT.longitude(), LYON_DESTINATION_POINT.latitude())), }))) .withLayer(new SymbolLayer(""layer-id"", ""source-id"").withProperties( iconImage(""icon-id""), iconOffset(new Float[] {0f, -8f}) )) // Add a source and LineLayer for the snaking directions route line .withSource(new GeoJsonSource(DRIVING_ROUTE_POLYLINE_SOURCE_ID)) .withLayerBelow(new LineLayer(DRIVING_ROUTE_POLYLINE_LINE_LAYER_ID, DRIVING_ROUTE_POLYLINE_SOURCE_ID) .withProperties( lineWidth(NAVIGATION_LINE_WIDTH), lineOpacity(NAVIGATION_LINE_OPACITY), lineCap(LINE_CAP_ROUND), lineJoin(LINE_JOIN_ROUND), lineColor(Color.parseColor(""#d742f4"")) ), ""layer-id""), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { getDirectionsRoute(PARIS_ORIGIN_POINT, LYON_DESTINATION_POINT); } }); } /** * Build the Mapbox Directions API request * * @param origin The starting point for the directions route * @param destination The final point for the directions route */ private void getDirectionsRoute(Point origin, Point destination) { mapboxDirectionsClient = MapboxDirections.builder() .origin(origin) .destination(destination) .overview(DirectionsCriteria.OVERVIEW_FULL) .profile(DirectionsCriteria.PROFILE_DRIVING) .geometries(GEOMETRY_POLYLINE) .alternatives(true) .steps(true) .accessToken(getString(R.string.access_token)) .build(); mapboxDirectionsClient.enqueueCall(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { // Create log messages in case no response or routes are present if (response.body() == null) { Timber.d(""No routes found, make sure you set the right user and access token.""); return; } else if (response.body().routes().size() < 1) { Timber.d(""No routes found""); return; } // Get the route from the Mapbox Directions API response DirectionsRoute currentRoute = response.body().routes().get(0); // Start the step-by-step process of drawing the route runnable = new DrawRouteRunnable(mapboxMap, currentRoute.legs().get(0).steps(), handler); handler.postDelayed(runnable, DRAW_SPEED_MILLISECONDS); } @Override public void onFailure(Call<DirectionsResponse> call, Throwable throwable) { Toast.makeText(SnakingDirectionsRouteActivity.this, R.string.snaking_directions_activity_error, Toast.LENGTH_SHORT).show(); } }); } /** * Runnable class which goes through the route and draws each {@link LegStep} of the Directions API route */ private static class DrawRouteRunnable implements Runnable { private MapboxMap mapboxMap; private List<LegStep> steps; private List<Feature> drivingRoutePolyLineFeatureList; private Handler handler; private int counterIndex; DrawRouteRunnable(MapboxMap mapboxMap, List<LegStep> steps, Handler handler) { this.mapboxMap = mapboxMap; this.steps = steps; this.handler = handler; this.counterIndex = 0; drivingRoutePolyLineFeatureList = new ArrayList<>(); } @Override public void run() { if (counterIndex < steps.size()) { LegStep singleStep = steps.get(counterIndex); if (singleStep != null && singleStep.geometry() != null) { LineString lineStringRepresentingSingleStep = LineString.fromPolyline( singleStep.geometry(), Constants.PRECISION_5); Feature featureLineString = Feature.fromGeometry(lineStringRepresentingSingleStep); drivingRoutePolyLineFeatureList.add(featureLineString); } if (mapboxMap.getStyle() != null) { GeoJsonSource source = mapboxMap.getStyle().getSourceAs(DRIVING_ROUTE_POLYLINE_SOURCE_ID); if (source != null) { source.setGeoJson(FeatureCollection.fromFeatures(drivingRoutePolyLineFeatureList)); } } counterIndex++; handler.postDelayed(this, DRAW_SPEED_MILLISECONDS); } } } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); if (handler != null) { handler.removeCallbacks(runnable); } } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override protected void onDestroy() { super.onDestroy(); // Cancel the directions API request if (mapboxDirectionsClient != null) { mapboxDirectionsClient.cancelCall(); } mapView.onDestroy(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } } Copy Was this page helpful? Yes No",Snaking directions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Get coordinates of the mouse pointer,Showing mouse position on hover with pixel and latitude and longitude coordinates.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Get coordinates of the mouse pointer Showing mouse position on hover with pixel and latitude and longitude coordinates. Was this example helpful? Yes No,Get coordinates of the mouse pointer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Map design for iOS,An overivew of best practices for designing maps for use on iOS.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Map design for iOS Mapbox Studio allows you to create completely custom map styles. When designing your style, consider the context in which your application shows the style. There are many considerations related to the mobile experience and iOS specifically that may not be obvious when designing your style in Mapbox Studio on the Web. A map is essentially a graphical user interface element, so many of same issues in user interface design also apply when designing a map style. Color Make sure there is enough contrast in your application’s user interface when your map style is present. Standard user interface elements such as toolbars, sidebars, and sheets often overlap the map view with a translucent, blurred background, so make sure the contents of these elements stay legible with the map view underneath. The user location annotation view, the attribution button, any buttons in callout views, and any items in the navigation bar are influenced by your application’s tint color, so choose a tint color that contrasts well with your map style. If you intend your style to be used in the dark, consider the impact that Night Shift may have on your style’s colors. Typography and graphics Choose font and icon sizes appropriate to iOS devices. iPhones and iPads have smaller screens than the typical browser window in which you would use Mapbox Studio, especially when multitasking is enabled. Your user’s viewing distance may be shorter than on a desktop computer. Some of your users may use the Larger Dynamic Type and Accessibility Text features to increase the size of all text on the device. You can use the runtime styling API to adjust your style’s font and icon sizes as needed. Design sprite images and choose font weights that look crisp on both standard-resolution displays and Retina displays. This SDK supports the same resolutions as iOS. Standard-resolution displays are limited to older devices that your application may or may not support, depending on its minimum deployment target. Icon and text labels should be legible regardless of the map’s orientation. By default, this SDK keeps the map legible as your users rotate or tilt the map using multitouch gestures. If you do not intend your design to accommodate rotation and tilting, disable these gestures using the MGLMapView.rotateEnabled and MGLMapView.pitchEnabled properties, respectively, or the corresponding inspectables in Interface Builder. Interactivity Pay attention to whether elements of your style appear to be interactive. A text label may look like a tappable button merely due to matching your application’s tint color or the default blue tint color. You can make an icon or text label interactive by installing a gesture recognizer and performing feature querying (e.g., -[MGLMapView visibleFeaturesAtPoint:]) to get details about the selected feature. Make sure your users can easily distinguish any interactive elements from the surrounding map, such as pins, the user location annotation view, or a route line. Avoid relying on hover effects to highlight or emphasize interactive elements. Leave enough room between interactive elements to accommodate imprecise tapping gestures. Next steps For more information about user interface design, consult Apple’s iOS Human Interface Guidelines. To learn more about designing maps for mobile devices, see the Maps for mobile section of Mapbox's Guide to map design. Was this page helpful? Yes No",Map design for iOS,,,,,,,,,,,,,Color,Typography and graphics,Interactivity,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Use Mapbox with OpenLayers,Learn how to use Mapbox with OpenLayers.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,JavaScript,,"intermediate JavaScript Use Mapbox with OpenLayers Prerequisite Familiarity with front-end development concepts. You can use Mapbox styles withOpenLayers. Choose the version of OpenLayers and Mapbox tool that you're working with to get started. View fullscreen demo Getting started There are a few things you'll need to gather before you can start working with your Mapbox maps in OpenLayers: Your Mapbox access token. You can find your access tokens on your Mapbox Account page. A style URL. You can find a style URL in your Mapbox account's styles page. OpenLayers 3.x You can load a Mapbox Studio style or Mapbox style URL or a Mapbox tileset ID with OpenLayers 3.x. View fullscreen demo Mapbox Studio style or Mapbox style URL To use a Mapbox Studio style or a Mapbox style URL with OpenLayers 3.x, you'll need to reference the Mapbox Static Tiles API. You can replace the style URL mapbox/streets-v 11 with your own. var map = new ol.Map( { layers: [ new ol.layer.Tile( { source: new ol.source.XYZ( { url: 'https://api.mapbox.com/styles/v1/mapbox/streets-v 11 /tiles/256/ { z } / { x } / { y } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN ' } ) } ) ], target: 'map', view: new ol.View( { center: [0, 0], zoom: 2 } ) } ); Mapbox tileset ID To use a Mapbox tileset ID with OpenLayers 3.x, you'll need to reference the Mapbox Raster Tiles API. You can replace the tileset ID mapbox.satellite with your own. var map = new ol.Map( { layers: [ new ol.layer.Tile( { source: new ol.source.XYZ( { url: 'https://api.mapbox.com/v4/mapbox.satellite/ { z } / { x } / { y } .png?access_token= YOUR_MAPBOX_ACCESS_TOKEN ' } ) } ) ], target: 'map', view: new ol.View( { center: [0, 0], zoom: 2 } ) } ); OpenLayers 2.x For OpenLayers 2.x, use the OpenLayers.Layer.XYZ class. You can load a Mapbox Studio style or Mapbox style URL or a Mapbox tileset ID with OpenLayers 2.x. View fullscreen demo Mapbox Studio style or Mapbox style URL To use a Mapbox Studio style or a Mapbox style URL with OpenLayers 2.x, you'll need to reference the Mapbox Static Tiles API. You can replace the style URL mapbox/streets-v 11 with your own. var myLayer = new OpenLayers.Layer.XYZ( 'My Map Layer', ['https://api.mapbox.com/styles/v1/mapbox/streets-v 11 /tiles/256/$ { z } /$ { x } /$ { y } ?access_token= YOUR_MAPBOX_ACCESS_TOKEN '], { sphericalMercator: true, wrapDateLine: true } ); var map = new OpenLayers.Map( { div: 'map', layers: [myLayer], center: [0, 0], zoom: 1 } ); Mapbox tileset ID To use a Mapbox tileset ID with OpenLayers 2.x, you'll need to reference the Mapbox Raster Tiles API. You can replace the mapbox.satellite with your own. var myLayer = new OpenLayers.Layer.XYZ( 'My Map Layer', ['https://a.tiles.mapbox.com/v4/mapbox.satellite/$ { z } /$ { x } /$ { y } .png?access_token= YOUR_MAPBOX_ACCESS_TOKEN '], { sphericalMercator: true, tileSize: new OpenLayers.Size([512, 512]), wrapDateLine: true } ); var map = new OpenLayers.Map( { div: 'map', layers: [myLayer], center: [0, 0], zoom: 1 } ); Was this page helpful? Yes No",Use Mapbox with OpenLayers,,,,,,,,,,,,,Getting started,OpenLayers 3.x,Mapbox Studio style or Mapbox style URL,Mapbox tileset ID,OpenLayers 2.x,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Isochrone,Official documentation on the Mapbox Java SDK Isochrone API.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,Java,,"Isochrone The Mapbox Isochrone API computes areas that are reachable within a specified amount of time from a location and returns the reachable regions as contours of polygons and/or lines. If you're using this Java SDK wrapper with the Mapbox Maps SDK for Android, you can then display these areas/lines on a map. For more extensive information about this API, see the Mapbox Isochrone API documentation. Along with the API documentation, you can also view the Isochrone API example in the Mapbox Android demo app to see a complete example of how to use the API. Criteria Use the IsochroneCriteria class to conveniently reference a particular directions profile as you build the MapboxIsochrone.builder() object. Using the IsochroneCriteria class helps make sure that you pass correctly formatted parameters. Driving: For automotive routing. This profile shows the fastest routes by preferring high-speed roads like highways. Walking: For pedestrian and hiking routing. This profile shows the shortest path by using sidewalks and trails. Cycling: For bicycle routing. This profile shows routes that are short and safer for cyclists by avoiding highways and preferring streets with bike lanes. Building the URL Start by creating a new instance of the MapboxIsochrone object and use its builder to customize your API request. The options offered in the builder include choosing whether the API returns polygon areas and the colors of those polygon areas. If you're using this API with the Mapbox Maps SDK for Android, setting true for .polygons(boolean) will return polygon coordinates that you can then use for FillLayer. Isochrone lines can be used with LineLayers. Java Kotlin MapboxIsochrone mapboxIsochroneRequest = MapboxIsochrone.builder() .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .profile(IsochroneCriteria.PROFILE_DRIVING) .addContoursMinutes(listOfIntegers) .polygons(usePolygon) .addContoursColors(listOfHexColorValueStrings) .generalize(2f) .denoise(.4f) .coordinates(Point.fromLngLat(queryPoint.longitude, queryPoint.latitude)) .build(); Copy API response In the response to a request to the Mapbox Isochrone API, the isochrone contours are returned as a GeoJSON Feature Collection. More information about the response. The API will return a FeatureCollection: Java Kotlin mapboxIsochroneRequest.enqueueCall(new Callback<FeatureCollection>() { @Override public void onResponse(Call<FeatureCollection> call, Response<FeatureCollection> response) { if (response.body() != null && response.body().features() != null && response.body().features().size() > 0) { FeatureCollection featureCollection = response.body(); List<Feature> responseFeatureList = response.body().features(); } } @Override public void onFailure(Call<FeatureCollection> call, Throwable t) { Timber.d(""Request failed: %s"", t.getMessage()); } }); Copy Was this page helpful? Yes No",Isochrone,Kotlin,,,,,,,,,,,,Criteria,Building the URL,API response,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Studio manual,Style a heatmap layer,Add and style a heatmap layer.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,No code,,"Style a heatmap layer About this style Tileset from custom data: The data that is used as the source for the meteorites layer comes from a custom tileset that was created by uploading a CSV file to Mapbox Studio. The original data comes from NASA's open data portal. The tileset itself contains the locations of various meteorite strikes and several properties including mass (g) (a number). Read more about uploading data to Mapbox Studio in the Overview section. Styling heatmap layers: Open the meteorites layer to see how the color, opacity, radius, weight, and intensity style properties have been specified to style the heatmap layer. Related resources Looking for more guidance? Read our Make a heatmap with Mapbox Studio tutorial. Was this page helpful? Yes No",Style a heatmap layer,,,,,,,,,,,,,About this style,Related resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display a popup on hover,"When a user hovers over a symbol, show a Popup containing more information.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,"Display a popup on hover When a user hovers over a symbol, show a Popup containing more information. Was this example helpful? Yes No",Display a popup on hover,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,API,Search service,Overview of the Mapbox Search service APIs.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,API,,,"Search service The Mapbox Search service is composed of the following APIs: Geocoding The Mapbox Geocoding API does two things: forward geocoding and reverse geocoding. Forward geocoding converts location text into geographic coordinates, turning 2 Lincoln Memorial Circle NW into -77.050,38.889. Reverse geocoding turns geographic coordinates into place names, turning -77.050, 38.889 into 2 Lincoln Memorial Circle NW. These location names can vary in specificity, from individual addresses to states and countries that contain the given coordinates. For information on how the Geocoding API is billed, visit the Pricing by product guide. For more background information on the Mapbox Geocoding API and how it works, see the How geocoding works guide. Endpoints The geocoding API includes two different endpoints: mapbox.places and mapbox.places-permanent. mapbox.places The mapbox.places endpoint is accessible to all geocoding customers. Requests to this endpoint must be triggered by user activity. Any results must be displayed on a Mapbox map and cannot be stored permanently, as described in Mapbox’s terms of service. mapbox.places-permanent The mapbox.places-permanent endpoint is accessible to Enterprise customers with a license for permanent geocodes. This endpoint allows for permanent storage of results and for batch geocoding. Note that the mapbox.places-permanent endpoint does not include POI (point-of-interest) features. The data available for other feature types may vary slightly compared to the data available in the mapbox.places endpoint. Data types Various types of geographic features are available in the Mapbox geocoder. Any type might appear as a top-level response, as context in a top-level response, or as a filtering option using the types parameter. Not all features are available or relevant in all parts of the world. New types are occasionally added as necessary to correctly capture global administrative hierarchies. The data types available in the geocoder, listed from the largest to the most granular, are: Data type Description country Generally recognized countries or, in some cases like Hong Kong, an area of quasi-national administrative status that has been given a designated country code under ISO 3166-1. region Top-level sub-national administrative features, such as states in the United States or provinces in Canada or China. postcode Postal codes used in country-specific national addressing systems. district Features that are smaller than top-level administrative features but typically larger than cities, in countries that use such an additional layer in postal addressing (for example, prefectures in China). place Typically these are cities, villages, municipalities, etc. They’re usually features used in postal addressing, and are suitable for display in ambient end-user applications where current-location context is needed (for example, in weather displays). locality Official sub-city features present in countries where such an additional administrative layer is used in postal addressing, or where such features are commonly referred to in local parlance. Examples include city districts in Brazil and Chile and arrondissements in France. neighborhood Colloquial sub-city features often referred to in local parlance. Unlike locality features, these typically lack official status and may lack universally agreed-upon boundaries. address Individual residential or business addresses. poi Points of interest. These include restaurants, stores, concert venues, parks, museums, etc. Forward geocoding get /geocoding/v5/{endpoint}/{search_text}.json The forward geocoding query type allows you to look up a single location by name and returns its geographic coordinates. Try forward geocoding in the Search Playground. Required parameters Description endpoint One of mapbox.places or mapbox.places-permanent, as described in the Endpoints section. search_text The feature you’re trying to look up. This could be an address, a point of interest name, a city name, etc. When searching for points if interest, it can also be a category name (for example, “coffee shop”). For information on categories, see the Point of interest category coverage section. The search text should be expressed as a URL-encoded UTF-8 string, and must not contain the semicolon character (either raw or URL-encoded). Your search text, once decoded, must consist of at most 20 words and numbers separated by spacing and punctuation, and at most 256 characters. The accuracy of coordinates returned by a forward geocoding request can be impacted by how the addresses in the query are formatted. Learn more about address formatting best practices in the Address geocoding format guide. You can further refine the results of a forward geocoding query with the following optional parameters: Optional parameters Description autocomplete Specify whether to return autocomplete results (true, default) or not (false). When autocomplete is enabled, results will be included that start with the requested string, rather than just responses that match it exactly. For example, a query for India might return both India and Indiana with autocomplete enabled, but only India if it’s disabled. When autocomplete is enabled, each user keystroke counts as one request to the Geocoding API. For example, a search for ""coff"" would be reflected as four separate Geocoding API requests. To reduce the total requests sent, you can configure your application to only call the Geocoding API after a specific number of characters are typed. bbox Limit results to only those contained within the supplied bounding box. Bounding boxes should be supplied as four numbers separated by commas, in minLon,minLat,maxLon,maxLat order. The bounding box cannot cross the 180th meridian. country Limit results to one or more countries. Permitted values are ISO 3166 alpha 2 country codes separated by commas. fuzzyMatch Specify whether the Geocoding API should attempt approximate, as well as exact, matching when performing searches (true, default), or whether it should opt out of this behavior and only attempt exact matching (false). For example, the default setting might return Washington, DC for a query of wahsington, even though the query was misspelled. language Specify the user’s language. This parameter controls the language of the text supplied in responses, and also affects result scoring, with results matching the user’s query in the requested language being preferred over results that match in another language. For example, an autocomplete query for things that start with Frank might return Frankfurt as the first result with an English (en) language parameter, but Frankreich (“France”) with a German (de) language parameter. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and, optionally, one or more IETF subtags for country or script. More than one value can also be specified, separated by commas, for applications that need to display labels in multiple languages. For more information on which specific languages are supported, see the language coverage section. limit Specify the maximum number of results to return. The default is 5 and the maximum supported is 10. proximity Bias the response to favor results that are closer to this location, provided as two comma-separated coordinates in longitude,latitude order. routing Specify whether to request additional metadata about the recommended navigation destination corresponding to the feature (true) or not (false, default). Only applicable for address features. For example, if routing=true the response could include data about a point on the road the feature fronts. Response features may include an array containing one or more routable points. Routable points cannot always be determined. Consuming applications should fall back to using the feature’s normal geometry for routing if a separate routable point is not returned. types Filter results to include only a subset (one or more) of the available feature types. Options are country, region, postcode, district, place, locality, neighborhood, address, and poi. Multiple options can be comma-separated. Note that poi.landmark is a deprecated type that, while still supported, returns the same data as is returned using the poi type. For more information on the available types, see the data types section. Example request: Forward geocoding # A basic forward geocoding request # Find Los Angeles $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places/Los%20Angeles.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN "" # Find a town called 'Chester' in a specific region # Add the proximity parameter with local coordinates # This ensures the town of Chester, New Jersey is in the results $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places/chester.json?proximity=-74.70850,40.78375&access_token= YOUR_MAPBOX_ACCESS_TOKEN "" # Specify types=country to search only for countries named Georgia # Results will exclude the American state of Georgia $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places/georgia.json?types=country&access_token= YOUR_MAPBOX_ACCESS_TOKEN "" # Search for ""Starbucks"" in Washington, D.C. # Use a bounding box to limit results to within the district $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places/starbucks.json?bbox=-77.083056,38.908611,-76.997778,38.959167&access_token= YOUR_MAPBOX_ACCESS_TOKEN "" # Limit the results to two results using the limit option # Even though there are many possible matches # for ""Washington"", this query will only return two results. $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places/Washington.json?limit=2&access_token= YOUR_MAPBOX_ACCESS_TOKEN "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDKs support this endpoint: Mapbox CLI SDK MapboxDirections.swift (Objective-C and Swift) Mapbox Java SDK Mapbox JavaScript SDK Mapbox Python SDK Mapbox Ruby SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Forward geocoding The API response for a forward geocoding query returns a GeoJSON feature collection in Mapbox Geocoding Response format. For more details on how a response from the Geocoding API is formatted, see the Geocoding API response object section. Reverse geocoding get /geocoding/v5/{endpoint}/{longitude},{latitude}.json The reverse geocoding query type allows you to look up a single pair of coordinates and returns the geographic feature or features that exist at that location. Batch geocoding is only available with an Enterprise plan. For other plan levels, one geocode is permitted per request. Try reverse geocoding in the Search Playground. Required parameters Description endpoint One of mapbox.places or mapbox.places-permanent, as described in the Endpoints section. longitude,latitude A longitude,latitude pair that specifies the location being queried. You can further refine the results of a reverse geocoding query with the following optional parameters: Optional parameters Description country Limit results to one or more countries. Permitted values are ISO 3166 alpha 2 country codes separated by commas. language Specify the user’s language. This parameter controls the language of the text supplied in responses. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and, optionally, one or more IETF subtags for country or script. More than one value can also be specified, separated by commas, for applications that need to display labels in multiple languages. For more information on which specific languages are supported, see the language coverage section. limit Specify the maximum number of results to return. The default is 1 and the maximum supported is 10. The default behavior in reverse geocoding is to return at most one feature at each of the multiple levels of the administrative hierarchy (for example, one address, one region, one country). Increasing the limit allows returning multiple features of the same type, but only for one type (for example, multiple address results). Consequently, setting limit to a higher-than-default value requires specifying exactly one types parameter. reverseMode Decides how results are sorted in a reverse geocoding query if multiple results are requested using a limit other than 1. Options are distance (default), which causes the closest feature to always be returned first, and score, which allows high-prominence features to be sorted higher than nearer, lower-prominence features. routing Specify whether to request additional metadata about the recommended navigation destination corresponding to the feature (true) or not (false, default). Only applicable for address features. For example, if routing=true the response could include data about a point on the road the feature fronts. Response features may include an array containing one or more routable points. Routable points cannot always be determined. Consuming applications should fall back to using the feature’s normal geometry for routing if a separate routable point is not returned. types Filter results to include only a subset (one or more) of the available feature types. Options are country, region, postcode, district, place, locality, neighborhood, address, and poi. Multiple options can be comma-separated. Note that poi.landmark is a deprecated type that, while still supported, returns the same data as is returned using the poi type. For more information on the available types, see the data types section. Example request: Reverse geocoding # A basic reverse geocoding request # Retrieve places near a specific location $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places/-73.989,40.733.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN "" # Filter results to only include points of interest $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places/-73.989,40.733.json?types=poi&access_token= YOUR_MAPBOX_ACCESS_TOKEN "" Endpoint support Mapbox wrapper libraries help you integrate Mapbox APIs into your existing application. The following SDKs support this endpoint: Mapbox CLI SDK MapboxDirections.swift (Objective-C and Swift) Mapbox Java SDK Mapbox JavaScript SDK Mapbox Python SDK Mapbox Ruby SDK See the SDK documentation for details and examples of how to use the relevant methods to query this endpoint. Response: Reverse geocoding The API response for a reverse geocoding query returns a GeoJSON feature collection in Mapbox Geocoding Response format. For more details on how a response from the Geocoding API is formatted, see the Geocoding API response object section. Batch geocoding get /geocoding/v5/{endpoint}/{search_text_1};{search_text_2};{search_text_N}.json The batch geocoding query type allows you to have multiple forward or reverse geocoding queries in a single request. You must have an Enterprise plan to use batch geocoding, and it is only available using the mapbox.places-permanent endpoint. On all other plan levels, one geocode is permitted per request. Batch geocoding requests are formatted similarly to ordinary forward or reverse geocoding requests, but with multiple search queries one after another, separated by semicolons. Each query should be URL encoded, but the ; character should not be encoded and should be included verbatim. Rate limits and billing for batch geocoding requests Each individual semicolon-separated search in a batch geocoding request counts as one request. A batch forward geocoding request with three search strings, for example Juneau,Alaska;Fresno,CA;Phoenix,Arizona, would count as three requests. These three requests would count against your rate limit. They would also be billed as three individual requests, which would be reflected on your statistics graph and your bill. For more information, see the Pricing by product guide. A batch forward geocoding request can be made using an HTTP GET request: https://api.mapbox.com/geocoding/ v5 /mapbox.places-permanent/{search_text_1};{search_text_2}[;{search_text_N};...].json?parameters A batch reverse geocoding request can be made using an HTTP GET request: https://api.mapbox.com/geocoding/ v5 /mapbox.places-permanent/{lon_1},{lat_1};{lon_2},{lat_2}[;{lon_N},{lat_N};...].json?parameters Required parameters Description search_text_N For batch forward queries. The features to look up (addresses, point of interest names, city names, etc.). They should be expressed as URL-encoded UTF-8 strings, and must not contain the semicolon character (either raw or URL-encoded), as this is the delimiter between search items. Each search text, once decoded, must consist of at most 20 words and numbers separated by spacing and punctuation, and at most 256 characters. You may supply at most 50 search texts within one request. { lon_N } , { lat_N } For batch reverse queries. The longitude and latitude, respectively, of the locations being queried. You may supply at most 50 longitude-latitude coordinate pairs within one request. access_token All geocoding requests must include an access token. For batch forward queries, you may use any optional parameters that are available for single forward queries, and they will apply to all search texts. Likewise, for reverse queries, you may use any optional parameters that apply to single reverse queries. Example request: Batch geocoding $ curl ""https://api.mapbox.com/geocoding/ v5 /mapbox.places-permanent/20001;20009;22209.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN "" Response: Batch geocoding The response from a batch geocoding query is an array of results in GeoJSON feature collection format. The order of the semi-colon separated list of queries in the request determines the order of corresponding objects in the returned array. If there are no results returned for a particular query within the batch, the features array for that query is empty ( ""features"": [] ). Here's an example request in which the list of three queries is fairbanks,alaska;aslkdjf;juno,alaska. https://api.mapbox.com/geocoding/v5/mapbox.places-permanent/fairbanks,alaska;aslkdjf;juno,alaska.json?access_token= YOUR_MAPBOX_ACCESS_TOKEN &limit=1 The parameter limit=1 was set in the request, so each query returns a maximum of one result in the response. Notice that in the response, the results are in same the order as the queries in the request, where the second query aslkdjf doesn't return a result but still exists in the second position of the array: [ { ""type"": ""FeatureCollection"", ""query"": [ ""fairbanks"", ""alaska"" ], ""features"": [ { ""id"": ""place.16619084287168120"", ""type"": ""Feature"", ""place_type"": [ ""place"" ], ""relevance"": 1, ""properties"": { ""wikidata"": ""Q79638"" }, ""text"": ""Fairbanks"", ""place_name"": ""Fairbanks, Alaska, United States"", ""bbox"": [ -152.082261679596, 63.9388459884296, -143.884791986593, 68.0041310199992 ], ""center"": [ -147.7164, 64.8378 ], ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -147.7164, 64.8378 ] }, ""context"": [ { ""id"": ""region.9053016009778630"", ""short_code"": ""US-AK"", ""wikidata"": ""Q797"", ""text"": ""Alaska"" }, { ""id"": ""country.9053006287256050"", ""short_code"": ""us"", ""wikidata"": ""Q30"", ""text"": ""United States"" } ] } ], ""attribution"": ""© 2018 Mapbox and its suppliers. All rights reserved. Use of this data is subject to the Mapbox Terms of Service. (https://www.mapbox.com/about/maps/)"" }, { ""type"": ""FeatureCollection"", ""query"": [ ""aslkdjf"" ], ""features"": [], ""attribution"": ""© 2018 Mapbox and its suppliers. All rights reserved. Use of this data is subject to the Mapbox Terms of Service. (https://www.mapbox.com/about/maps/)"" }, { ""type"": ""FeatureCollection"", ""query"": [ ""juno"", ""alaska"" ], ""features"": [ { ""id"": ""region.9053016009778630"", ""type"": ""Feature"", ""place_type"": [ ""region"" ], ""relevance"": 0.5, ""properties"": { ""short_code"": ""US-AK"", ""wikidata"": ""Q797"" }, ""text"": ""Alaska"", ""place_name"": ""Alaska, United States"", ""bbox"": [ -179.9, 51.075286, -129.974167, 71.540724 ], ""center"": [ -150, 64 ], ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -150, 64 ] }, ""context"": [ { ""id"": ""country.9053006287256050"", ""short_code"": ""us"", ""wikidata"": ""Q30"", ""text"": ""United States"" } ] } ], ""attribution"": ""© 2018 Mapbox and its suppliers. All rights reserved. Use of this data is subject to the Mapbox Terms of Service. (https://www.mapbox.com/about/maps/)"" } ] Geocoding response object The response to a Geocoding API request is an object that contains the following properties: Property Description type ""FeatureCollection"", a GeoJSON type from the GeoJSON specification. query Forward geocodes: An array of space and punctuation-separated strings from the original query. Reverse geocodes: An array containing the coordinates being queried. features An array of feature objects. Forward geocodes: Returned features are ordered by relevance. Reverse geocodes: Returned features are ordered by index hierarchy, from most specific features to least specific features that overlap the queried coordinates. Read the Search result prioritization guide to learn more about how returned features are organized in the Geocoding API response. attribution A string that attributes the results of the Mapbox Geocoding API to Mapbox. Mapbox's geocoding data is constantly being updated and improved. This means that the values of properties in the response object are not guaranteed and may change within the same version of the API. Properties may be added to, but will not be removed from, the response within the same API version. Each feature object in the features array may have the properties described below: Property Description id A feature ID in the format { type } . { id } where { type } is the lowest hierarchy feature in the place_type field. The { id } suffix of the feature ID is unstable and may change within versions. type ""Feature"", a GeoJSON type from the GeoJSON specification. place_type An array of feature types describing the feature. Options are country, region, postcode, district, place, locality, neighborhood, address, and poi. Most features have only one type, but if the feature has multiple types, all applicable types will be listed in the array. (For example, Vatican City is a country, region, and place.) relevance Indicates how well the returned feature matches the user's query on a scale from 0 to 1. 0 means the result does not match the query text at all, while 1 means the result fully matches the query text. You can use the relevance property to remove results that don’t fully match the query. Learn more about textual relevance in the Search result prioritization guide. address (optional) A string of the house number for the returned address feature. Note that unlike the address property for poi features, this property is outside the properties object. properties An object describing the feature. The properties object may change with data improvements. Your implementation should check for the presence of these values in a response before it attempts to use them. properties.accuracy (optional) A point accuracy metric for the returned address feature. Can be one of rooftop, parcel, point, interpolated, intersection, street. Note that this list is subject to change. See below for details properties.address (optional) A string of the full street address for the returned poi feature. Note that unlike the address property for address features, this property is inside the properties object. properties.category (optional) A string of comma-separated categories for the returned poi feature. properties.maki (optional) The name of a suggested Maki icon to visualize a poi feature based on its category. properties.landmark (optional) Describes whether or not the feature is in the poi.landmark data type. This data type is deprecated, and this property will be present on all poi features for backwards compatibility reasons but will always be true. properties.wikidata (optional) The Wikidata identifier for the returned feature. properties.short_code (optional) The ISO 3166-1 country and ISO 3166-2 region code for the returned feature. properties.tel (deprecated) A formatted string of the telephone number for the returned poi feature. text A string representing the feature in the requested language, if specified. place_name A string representing the feature in the requested language, if specified, and its full result hierarchy. matching_text (optional) A string analogous to the text field that more closely matches the query than results in the specified language. For example, querying Köln, Germany with language set to English (en) might return a feature with the text Cologne and the matching_text Köln. Category matches will not appear as matching_text. For example, a query for coffee, Köln with language set to English (en) would return a poi Café Reichard, but this feature will not include a matching_text field. matching_place_name (optional) A string analogous to the place_name field that more closely matches the query than results in the specified language. For example, querying Köln, Germany with language set to English (en) might return a feature with the place_name Cologne, Germany and a matching_place_name of Köln, North Rhine-Westphalia, Germany. Category matches will not appear in the matching_place_name field. For example, a query for coffee, Köln with language set to English (en) would return a matching_place_name of Café Reichard, Unter Fettenhennen 11, Köln, North Rhine-Westphalia 50667, Germany instead of a matching_place_name of coffee, Unter Fettenhennen 11, Köln, North Rhine-Westphalia 50667, Germany. text_ { language } (optional) A string analogous to the text field that matches the query in the requested language. This field is only returned when multiple languages are requested using the language parameter, and will be present for each requested language. place_name_ { language } (optional) A string analogous to the place_name field that matches the query in the requested language. This field is only returned when multiple languages are requested using the language parameter, and will be present for each requested language. language (optional) A string of the IETF language tag of the query’s primary language. language_ { language } (optional) A string of the IETF language tag of the query’s fallback language. This field is only returned when multiple languages are requested using the language parameter, and will be present for each requested language. bbox A bounding box array in the form [minX,minY,maxX,maxY]. center The coordinates of the feature’s center in the form [longitude,latitude]. This may be the literal centroid of the feature’s geometry, or the center of human activity within the feature (for example, the downtown area of a city). geometry An object describing the spatial geometry of the returned feature. geometry.type ""Point"", a GeoJSON type from the GeoJSON specification. geometry.coordinates An array in the format [longitude,latitude] at the center of the specified bbox. geometry.interpolated (optional) If present, indicates that an address is interpolated along a road network. The geocoder can usually return exact address points, but if an address is not present the geocoder can use interpolated data as a fallback. In edge cases, interpolation may not be possible if surrounding address data is not present, in which case the next fallback will be the center point of the street feature itself. geometry.omitted (optional) If present, indicates an out-of-parity match. This occurs when an interpolated address is not in the expected range for the indicated side of the street. context An array representing the hierarchy of encompassing parent features. Each parent feature may include any of the above properties. routable_points (optional) An object with the routable points for the feature. routable_points.points (optional) An array of points in the form of [ { coordinates: [lon, lat] } ], or null if no points were found. properties.accuracy Accuracy Description rooftop Result is for a specific building/entrance parcel Result is derived from a parcel centroid point (default) Result is a known address point but has no specific accuracy interpolated Result has been interpolated from an address range intersection Result is for a block or intersection approximate Result is an approximate location street Result is a street centroid Example response: Forward geocoding { ""type"": ""FeatureCollection"", ""query"": [ ""825"", ""s"", ""milwaukee"", ""ave"", ""deerfield"", ""il"", ""60015"" ], ""features"": [{ ""id"": ""address.4356035406756260"", ""type"": ""Feature"", ""place_type"": [ ""address"" ], ""relevance"": 1, ""properties"": {}, ""text"": ""Milwaukee Ave"", ""place_name"": ""825 Milwaukee Ave, Deerfield, Illinois 60015, United States"", ""matching_text"": ""South Milwaukee Avenue"", ""matching_place_name"": ""825 South Milwaukee Avenue, Deerfield, Illinois 60015, United States"", ""center"": [ -87.921434, 42.166602 ], ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -87.921434, 42.166602 ], ""interpolated"": true, ""omitted"": true }, ""address"": ""825"", ""context"": [{ ""id"": ""neighborhood.287187"", ""text"": ""Lake Cook Road"" }, { ""id"": ""postcode.13903677306297990"", ""text"": ""60015"" }, { ""id"": ""place.5958304312090910"", ""wikidata"": ""Q287895"", ""text"": ""Deerfield"" }, { ""id"": ""region.3290978600358810"", ""short_code"": ""US-IL"", ""wikidata"": ""Q1204"", ""text"": ""Illinois"" }, { ""id"": ""country.9053006287256050"", ""short_code"": ""us"", ""wikidata"": ""Q30"", ""text"": ""United States"" } ] }, { ""id"": ""address.7464624790403620"", ""type"": ""Feature"", ""place_type"": [ ""address"" ], ""relevance"": 0.5, ""properties"": {}, ""text"": ""Milwaukee Ave"", ""place_name"": ""825 Milwaukee Ave, Wheeling, Illinois 60090, United States"", ""matching_text"": ""South Milwaukee Avenue"", ""matching_place_name"": ""825 South Milwaukee Avenue, Wheeling, Illinois 60090, United States"", ""center"": [ -87.910299, 42.144504 ], ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -87.910299, 42.144504 ], ""interpolated"": true }, ""address"": ""825"", ""context"": [{ ""id"": ""neighborhood.287187"", ""text"": ""Lake Cook Road"" }, { ""id"": ""postcode.9418633295906190"", ""text"": ""60090"" }, { ""id"": ""place.9902190947082220"", ""wikidata"": ""Q935043"", ""text"": ""Wheeling"" }, { ""id"": ""region.3290978600358810"", ""short_code"": ""US-IL"", ""wikidata"": ""Q1204"", ""text"": ""Illinois"" }, { ""id"": ""country.9053006287256050"", ""short_code"": ""us"", ""wikidata"": ""Q30"", ""text"": ""United States"" } ] }, { ""id"": ""address.6472754353404224"", ""type"": ""Feature"", ""place_type"": [ ""address"" ], ""relevance"": 0.5, ""properties"": {}, ""text"": ""Milwaukee Avenue"", ""place_name"": ""825 Milwaukee Avenue, Glenview, Illinois 60025, United States"", ""matching_text"": ""South Milwaukee Avenue"", ""matching_place_name"": ""825 South Milwaukee Avenue, Glenview, Illinois 60025, United States"", ""center"": [ -87.852677, 42.071152 ], ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -87.852677, 42.071152 ] }, ""address"": ""825"", ""context"": [{ ""id"": ""neighborhood.275266"", ""text"": ""Northfield Woods"" }, { ""id"": ""postcode.3787740186211610"", ""text"": ""60025"" }, { ""id"": ""place.10211845459386970"", ""wikidata"": null, ""text"": ""Glenview"" }, { ""id"": ""region.3290978600358810"", ""short_code"": ""US-IL"", ""wikidata"": ""Q1204"", ""text"": ""Illinois"" }, { ""id"": ""country.9053006287256050"", ""short_code"": ""us"", ""wikidata"": ""Q30"", ""text"": ""United States"" } ] }, { ""id"": ""address.1225436500189372"", ""type"": ""Feature"", ""place_type"": [ ""address"" ], ""relevance"": 0.5, ""properties"": {}, ""text"": ""Milwaukee Ave"", ""place_name"": ""825 Milwaukee Ave, Buffalo Grove, Illinois 60089, United States"", ""matching_text"": ""South Milwaukee Avenue"", ""matching_place_name"": ""825 South Milwaukee Avenue, Buffalo Grove, Illinois 60089, United States"", ""center"": [ -87.917484, 42.158084 ], ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -87.917484, 42.158084 ], ""interpolated"": true }, ""address"": ""825"", ""context"": [{ ""id"": ""neighborhood.287187"", ""text"": ""Lake Cook Road"" }, { ""id"": ""postcode.11727721238210580"", ""text"": ""60089"" }, { ""id"": ""place.8589721255665070"", ""wikidata"": ""Q967086"", ""text"": ""Buffalo Grove"" }, { ""id"": ""region.3290978600358810"", ""short_code"": ""US-IL"", ""wikidata"": ""Q1204"", ""text"": ""Illinois"" }, { ""id"": ""country.9053006287256050"", ""short_code"": ""us"", ""wikidata"": ""Q30"", ""text"": ""United States"" } ] }, { ""id"": ""address.240107872738130"", ""type"": ""Feature"", ""place_type"": [ ""address"" ], ""relevance"": 0.5, ""properties"": {}, ""text"": ""Milwaukee Avenue"", ""place_name"": ""825 Milwaukee Avenue, Wheeling, Illinois 60090, United States"", ""matching_text"": ""South Milwaukee Avenue"", ""matching_place_name"": ""825 South Milwaukee Avenue, Wheeling, Illinois 60090, United States"", ""center"": [ -87.898319, 42.126289 ], ""geometry"": { ""type"": ""Point"", ""coordinates"": [ -87.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Search service,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Simplify a polyline,"Using the polylines utility, simplify a polyline which reduces the amount of coordinates making up the polyline depending on tolerance.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Simplify a polyline Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical"" tools:context="".examples.javaservices.SimplifyPolylineActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.692465"" mapbox:mapbox_cameraTargetLng=""-122.410413"" mapbox:mapbox_cameraTilt=""45"" mapbox:mapbox_cameraZoom=""10.5""/> </LinearLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.graphics.Color; import android.os.AsyncTask; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.geojson.utils.PolylineUtils; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.ColorUtils; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.List; import java.util.Objects; import java.util.Scanner; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Using the polylines utility, simplify a polyline at a * given tolerance to reduce the number of coordinates in that polyline. */ public class SimplifyPolylineActivity extends AppCompatActivity { private static final String TAG = ""SimplifyLineActivity""; private MapView mapView; private MapboxMap map; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_simplify_polyline); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { map = mapboxMap; mapboxMap.setStyle(Style.LIGHT, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { new DrawGeoJson(SimplifyPolylineActivity.this).execute(); } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private static class DrawGeoJson extends AsyncTask<Void, Void, FeatureCollection> { private WeakReference<SimplifyPolylineActivity> weakReference; DrawGeoJson(SimplifyPolylineActivity activity) { this.weakReference = new WeakReference<>(activity); } @Override protected FeatureCollection doInBackground(Void... voids) { try { SimplifyPolylineActivity activity = weakReference.get(); if (activity != null) { InputStream inputStream = activity.getAssets().open(""matched_route.geojson""); return FeatureCollection.fromJson(convertStreamToString(inputStream)); } } catch (Exception exception) { Timber.e(""Exception loading GeoJSON: %s"", exception.toString()); } return null; } static String convertStreamToString(InputStream is) { Scanner scanner = new Scanner(is).useDelimiter(""\\A""); return scanner.hasNext() ? scanner.next() : """"; } @Override protected void onPostExecute(@Nullable FeatureCollection featureCollection) { super.onPostExecute(featureCollection); SimplifyPolylineActivity activity = weakReference.get(); if (activity != null && featureCollection != null) { activity.drawLines(featureCollection); } } } private void drawLines(@NonNull FeatureCollection featureCollection) { List<Feature> features = featureCollection.features(); if (features != null && features.size() > 0) { Feature feature = features.get(0); drawBeforeSimplify(feature); drawSimplify(feature); } } private void drawBeforeSimplify(@NonNull Feature lineStringFeature) { addLine(""rawLine"", lineStringFeature, ""#8a8acb""); } private void drawSimplify(@NonNull Feature feature) { List<Point> points = ((LineString) Objects.requireNonNull(feature.geometry())).coordinates(); List<Point> after = PolylineUtils.simplify(points, 0.001); addLine(""simplifiedLine"", Feature.fromGeometry(LineString.fromLngLats(after)), ""#3bb2d0""); } private void addLine(String layerId, Feature feature, String lineColorHex) { map.getStyle(style -> { style.addSource(new GeoJsonSource(layerId, feature)); style.addLayer(new LineLayer(layerId, layerId).withProperties( lineColor(ColorUtils.colorToRgbaString(Color.parseColor(lineColorHex))), lineWidth(4f) )); }); } } Copy Was this page helpful? Yes No",Simplify a polyline,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,data-driven styling,Data-driven styling allows you to style your spatial data based on its properties.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"data-driven styling Data-driven styling allows you to style your spatial data based on its properties. For example, with data-driven styling you can change the radius of a circle at an intersection based on the number of pedestrians crossing the intersection, change the color of a state polygon based on the population of each state, or use conditional logic to create bilingual labels. Data-driven styling is available in Mapbox Studio, Mapbox GL JS, the Mapbox Maps SDK for iOS, and the Mapbox Maps SDK for Android. Property functions versus property expressions We recently changed the way data-driven styling works — from property functions to property expressions. Property expressions help you achieve similar effects as property functions, with much more flexibility and functionality. Property expressions were introduced in Mapbox GL JS v0.41.0. While property functions are available, they will ultimately be deprecated and replaced by property expressions. Expressions are compatible with: Mapbox GL JS 0.41.0 and above. Mapbox Android SDK 6.0.0 and above. Mapbox iOS SDK 4.0.0 and above. Was this page helpful? Yes No",data-driven styling,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Symbol listener,Listen for SymbolLayer icon interaction using the Annotation plugin and its built-in listeners.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Symbol listener Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLng=""24.939876"" mapbox:mapbox_cameraTargetLat=""60.169091"" mapbox:mapbox_cameraZoom=""12"" /> </androidx.coordinatorlayout.widget.CoordinatorLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.annotation.OnSymbolDragListener; import com.mapbox.mapboxsdk.plugins.annotation.OnSymbolLongClickListener; import com.mapbox.mapboxsdk.plugins.annotation.SymbolManager; import com.mapbox.mapboxsdk.plugins.annotation.SymbolOptions; import com.mapbox.mapboxsdk.plugins.annotation.Symbol; import com.mapbox.mapboxsdk.plugins.annotation.OnSymbolClickListener; /** * Change symbol icon by pressing on icon */ public class SymbolListenerActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private static final String MAKI_ICON_CAFE = ""cafe-15""; private static final String MAKI_ICON_HARBOR = ""harbor-15""; private static final String MAKI_ICON_AIRPORT = ""airport-15""; private SymbolManager symbolManager; private Symbol symbol; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_annotation_plugin_symbol_activity); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Set up a SymbolManager instance symbolManager = new SymbolManager(mapView, mapboxMap, style); symbolManager.setIconAllowOverlap(true); symbolManager.setTextAllowOverlap(true); // Add symbol at specified lat/lon symbol = symbolManager.create(new SymbolOptions() .withLatLng(new LatLng(60.169091, 24.939876)) .withIconImage(MAKI_ICON_HARBOR) .withIconSize(2.0f) .withDraggable(true)); // Add click listener and change the symbol to a cafe icon on click symbolManager.addClickListener(new OnSymbolClickListener() { @Override public void onAnnotationClick(Symbol symbol) { Toast.makeText(SymbolListenerActivity.this, String.format(""Symbol clicked""), Toast.LENGTH_SHORT).show(); symbol.setIconImage(MAKI_ICON_CAFE); symbolManager.update(symbol); } }); // Add long click listener and change the symbol to an airport icon on long click symbolManager.addLongClickListener((new OnSymbolLongClickListener() { @Override public void onAnnotationLongClick(Symbol symbol) { Toast.makeText(SymbolListenerActivity.this, String.format(""Symbol long clicked""), Toast.LENGTH_SHORT).show(); symbol.setIconImage(MAKI_ICON_AIRPORT); symbolManager.update(symbol); } })); symbolManager.addDragListener(new OnSymbolDragListener() { @Override // Left empty on purpose public void onAnnotationDragStarted(Symbol annotation) { } @Override // Left empty on purpose public void onAnnotationDrag(Symbol symbol) { } @Override // Left empty on purpose public void onAnnotationDragFinished(Symbol annotation) { } }); } }); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Symbol listener,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,CSV file errors,Learn how to fix errors when uploading CSV files.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"CSV file errors You can upload a CSV file to Mapbox Studio from the tilesets page, the Mapbox Studio dataset editor page, or by using the Mapbox Uploads API. Tilesets vs. datasets If you upload your CSV via the Mapbox Studio tilesets page or via the Uploads API, the geometries and data attributes of the resulting features will not be editable. Use the Mapbox Studio dataset editor if you'd like to edit your data before you add it to your map. For more information on the difference between datasets and tilesets, see the Mapbox Studio Manual. File format When uploading CSV files, keep the following in mind: CSV files can be no larger than 5 MB for datasets, and 1 GB for tilesets. CSV files must be in UTF-8 encoding. CSV files must contain coordinates (latitude and longitude) and can only represent point features, not lines or polygons. CSV files must be comma (,) separated. Data imported via CSV will be encoded as a string type in the Mapbox Studio dataset editor. If you want to code any of your imported data as numbers, you can edit the fields individually in the dataset editor or upload your data in GeoJSON format. If a row of data is invalid, that row will not be included in the resulting tileset. The first line of your CSV file must contain column headers, and column headers must include latitude and longitude fields at a minimum. The following are acceptable column headers for columns that contain latitude and longitude values. Note that x and y are valid column headers when you are uploading data as a tileset, but they are not valid column headers when you are uploading data as a dataset. Latitude: latitude lat y Longitude: longitude lon long lng x If your coordinates are GeoJSON or WKT encoded, you can name that field geojson or wkt respectively. See the Mapnik documentation on CSVs for more information. If a column has an empty header, a column label will be generated automatically. Example Here's an example of how to format a CSV file to upload in Mapbox Studio: title,latitude,longitude University at Albany,42.686744,-73.822852 Siena College,42.718588,-73.755328 Union College,42.814403,-73.930967 The College of St. Rose,42.664351,-73.786562 Was this page helpful? Yes No",CSV file errors,,,,,,,,,,,,,Tilesets vs. datasets,File format,Example,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,tileset,A tileset is a collection of raster or vector data broken up into a uniform grid of square tiles at 22 preset zoom levels.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"tileset A tileset is a collection of raster or vector data broken up into a uniform grid of square tiles at 22 preset zoom levels. Tilesets are used in Mapbox libraries and SDKs as a core piece of making maps visible on mobile devices or in the browser. Tilesets are highly cacheable and load quickly. Mapbox relies heavily on both raster and vector tilesets to keep our maps performant. For more information on working with tilesets, read the Mapbox Studio manual. Tilesets can be raster or vector. The differences are outlined below: Raster tilesets Raster tilesets are created when uploading raster images to Mapbox Studio as TIFFs/GeoTIFFs. They are used in both modern and classic Mapbox tools to display maps as a grid of images that can be loaded when necessary on the map. You can use raster tilesets in Mapbox Studio, Mapbox GL JS, and within the Mapbox Mobile SDKs. Traditional web mapping libraries, like Mapbox.js and Leaflet, also use raster tiles to display your map on a webpage. All classic styles created in Mapbox Studio Classic consist of raster tilesets as well. Vector tilesets Vector tilesets are the vector data equivalent of raster tilesets -- instead of storing raster data in the form of pixels, vector tilesets store vector data in the form of points, lines, and polygons as vector tiles. Vector tiles can be manipulated and queried. They can be used as sources for styles or queried directly to create interactive experiences with Mapbox Mobile SDKs and Mapbox GL JS. When uploading vector data (GeoJSON, Shapefile, KML, or GPX) to your Mapbox account, your data is automatically converted to a vector tileset. Was this page helpful? Yes No",tileset,,,,,,,,,,,,,Raster tilesets,Vector tilesets,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,routing profile,A routing profile is a set of rules that a routing engine uses to find the optimal route between two points.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,routing profile A Mapbox routing profile is a set of rules that a Mapbox routing engine uses to find the optimal route between two points. Routing profiles are generally optimized for the mode of transportation being used to get between locations. The Mapbox Navigation service APIs have access to the following routing profiles: Profile Description mapbox/driving-traffic For automotive routing. This profile factors in current and historic traffic conditions to avoid slowdowns. Traffic information is available for the supported geographies listed in the Traffic Data page. mapbox/driving For automotive routing. This profile shows the fastest routes by preferring high-speed roads like highways. mapbox/walking For pedestrian and hiking routing. This profile shows the shortest path by using sidewalks and trails. mapbox/cycling For bicycle routing. This profile shows routes that are short and safer for cyclists by avoiding highways and preferring streets with bike lanes. Note that the Isochrone API and the Optimization API do not support the mapbox/driving-traffic profile. Related resources: Directions API documentation Isochrone API documentation Map Matching API documentation Matrix API documentation Optimization API documentation Was this page helpful? Yes No,routing profile,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Localization,Mapbox Android Localization Plugin.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,Java,,"Localization The Mapbox Localization Plugin is an excellent option for adjusting your Android project's map experience according to the individual user's preferences. The plugin: Automatically detects the set language on the Android device and changes map text to that language. The plugin can change map text based on the Android device's language preference, but it also provides methods to programmatically change the text to a language independent of what the user set their device's language to. For example, if a user sets their phone to French but, they meet a Spanish-only speaking person, your app could provide a way for the French speaker to switch the map to Spanish temporarily. The map can then be switched back to French once their interaction is over. Adjusts the map camera to an area of the world that is associated with the device's set language. For example, say that the user set their device to German. The plugin can detect this so that when the map begins, the map camera's target is focused on Germany. Install the Localization Plugin To start developing an application using the Localization Plugin, you'll need to add the appropriate dependencies inside of your build.gradle. The Localization Plugin dependency includes the Mapbox Maps SDK for Android. You can find all dependencies given below on MavenCentral. If your application is close or exceeds the 65k method count limit, you can mitigate this problem by enabling ProGuard inside your application. ProGuard directives are included in the Android dependencies to preserve the required classes. Add the dependency Start Android Studio. Open up your application's build.gradle. Make sure that your project's minSdkVersion is API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-plugin-localization- v8. Click the Sync Project with Gradle Files near the toolbar in Studio. repositories { mavenCentral() } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-plugin-localization- v8 : 0.11.0 ' } Initialize the plugin The plugin's constructor requires a MapView and MapboxMap object. You should initialize the plugin within the onMapReady() method to be sure that the plugin is receiving a mapboxMap that's completely ready. Java Kotlin mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { LocalizationPlugin localizationPlugin = new LocalizationPlugin(mapView, mapboxMap, style); } }); } }); Copy Use MapLocale The MapLocale class powers much of the Localization Plugin and increases its flexibility. The class doesn't extend the Android system's Locale class, but rather, interacts with the Locale class in the form of a key/value HashMap. The plugin supports all the same default locales found inside the Locale class. More generally, the MapLocale class handles the retrieval of map languages and bounding boxes for regions that your app might interact with. The MapLocale object can be used to get the matching Locale's map language. This is useful for translating the map language into one found in the Languages interface. A handful of MapLocale objects are already constructed and offered through this class as static variables. If a country is missing and you'd like to add it, you can use one of the MapLocale constructors to build a valid map locale. Once this is done, you need to add it to the Locale cache using MapLocale.addMapLocale(Locale, MapLocale) where the first parameter is the Locale object which matches up with your newly created MapLocale. Match map with device language As described above, the plugin's main benefit is its ability to detect the device's language and change the map text to use that language. The quickest way to do this is using the matchMapLanguageWithDeviceDefault() method. Calling this method should happen within a try/catch statement because matchMapLanguageWithDeviceDefault() can throw a NullPointerException. This NullPointerException is thrown when the device's Locale has no matching MapLocale object. You need to create an instance of MapLocale and add it to the MapLocale cache (LOCAL_SET) using the addMapLocale() method. Java Kotlin mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { LocalizationPlugin localizationPlugin = new LocalizationPlugin(mapView, mapboxMap, style); try { localizationPlugin.matchMapLanguageWithDeviceDefault(); } catch (RuntimeException exception) { Log.d(TAG, exception.toString()); } } }); } }); Copy Set map language The plugin overloads the setMapLanguage() method with three different parameter options. Method Description setMapLanguage(String language) A string that is the language tag for the Mapbox-support language that you want to change the map too. You can find a list of supported language tags  in the MapLocale class. setMapLanguage(@NonNull Locale locale) The Locale object that is part of the Android platform. If you'd like to set the map language to a specific locale, you can pass it in as a parameter and MapLocale will try matching the information with one of the MapLocales found in its map. A null point exception will be thrown if one isn't found. To prevent this, make sure that the locale you are trying to use, has a complementary MapLocale for it. setMapLanguage(@NonNull MapLocale mapLocale) The MapLocale object that is part of the plugin. For example, localizationPlugin.setMapLanguage(MapLocale.GERMAN). Adjust the map camera A LatLngBounds bounding box isn't required to create a MapLocale instance. But, the plugin's setCameraToLocaleCountry() method can be used if the MapLocale has a LatLngBounds bounding box. For example, here is the plugin's bounding box for Germany: Java Kotlin private static final LatLngBounds GERMANY_BBOX = new LatLngBounds.Builder() .include(new LatLng(55.055637, 5.865639)) .include(new LatLng(47.275776, 15.039889)).build(); Copy It is used in creating the Germany MapLocale: Java Kotlin public static final MapLocale GERMANY = new MapLocale(""name_de"", GERMANY_BBOX); Copy Setting the camera: Java Kotlin try { localizationPlugin.setCameraToLocaleCountry(GERMANY); } catch (RuntimeException exception) { Log.d(TAG, exception.toString()); } Copy Calling the setCameraToLocaleCountry() method should happen within a try/catch statement because setCameraToLocaleCountry() can throw a NullPointerException. This NullPointerException is thrown when the MapLocale object was expecting to have a LatLngBounds bounding box but received null instead. Was this page helpful? Yes No",Localization,Kotlin,,,,,,,,,,,,Install the Localization Plugin,Add the dependency,Initialize the plugin,Use MapLocale,Match map with device language,Set map language,Adjust the map camera,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Waypoint arrival screen,Display a message when a user arrives at a waypoint.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Swift,,"Waypoint arrival screen import Foundation import UIKit import MapboxCoreNavigation import MapboxNavigation import MapboxDirections class WaypointArrivalScreenViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let waypointOne = Waypoint(coordinate: CLLocationCoordinate2DMake(37.777655950348475, -122.43199467658997)) let waypointTwo = Waypoint(coordinate: CLLocationCoordinate2DMake(37.776087132342745, -122.4329173564911)) let waypointThree = Waypoint(coordinate: CLLocationCoordinate2DMake(37.775357832637184, -122.43493974208832)) let options = NavigationRouteOptions(waypoints: [waypointOne, waypointTwo, waypointThree]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } // For demonstration purposes, simulate locations if the Simulate Navigation option is on. let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .always : .onPoorGPS) let navigationOptions = NavigationOptions(navigationService: navigationService) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) navigationViewController.delegate = self self.present(navigationViewController, animated: true, completion: nil) } } } extension WaypointArrivalScreenViewController: NavigationViewControllerDelegate { // Show an alert when arriving at the waypoint and wait until the user to start next leg. func navigationViewController(_ navigationViewController: NavigationViewController, didArriveAt waypoint: Waypoint) -> Bool { let alert = UIAlertController(title: ""Arrived at \(String(describing: waypoint.name))"", message: ""Would you like to continue?"", preferredStyle: .alert) alert.addAction(UIAlertAction(title: ""Ok"", style: .default, handler: { action in // Begin the next leg once the driver confirms navigationViewController.navigationService.routeProgress.legIndex += 1 })) navigationViewController.present(alert, animated: true, completion: nil) return false } } Copy Was this page helpful? Yes No",Waypoint arrival screen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Access elevation data,Learn how to access elevation data in Mapbox tilesets.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Access elevation data There are two different Mapbox tilesets that contain elevation data: Mapbox Terrain-RGB, a raster tileset. Mapbox Terrain, a vector tileset. This guide explains what each is used for and how to access the data. Mapbox Terrain-RGB Mapbox Terrain-RGB contains global elevation data encoded in raster PNG tiles as color values that can be decoded to raw heights in meters. You can use Terrain-RGB for a wide variety of applications both visual and analytical, from styling terrain slope and hillshades to generating 3D terrain meshes for video games. Some specifics about Terrain-RGB: Data up to zoom 15. The data is encoded to the equivalent of zoom 15 at 256 tile resolution (and zoom 14 for 512 tiles). Any higher zoom levels will not increase the resolution of the data loaded by your application. 0.1 meter height increments. Data is mapped to 0.1 meter height increments, which gives it the vertical precision necessary for cartographic and 3D applications. Request data You can use the following endpoint to get Terrain-RGB tiles. https://api.mapbox.com/v4/mapbox.terrain-rgb/ { z } / { x } / { y } .pngraw?access_token= YOUR_MAPBOX_ACCESS_TOKEN Two things to note about this request: Be sure you are requesting pngraw tiles. By default, 256x256 tiles are returned. You can use @2x to request 512x512 tiles. Requesting 512x512 tiles is sometimes preferable as it means fewer total requests over a given area. Decode data Terrain-RGB uses each color channel as a position in a base-256 numbering system, allowing for 16,777,216 unique values. Once you receive the tiles, you will need to get the red (R), green (G), and blue (B) values for individual pixels. You can do this using a canvas layer in your browser (example) or using a tool like get-pixel. The following equation will decode pixel values to height values. The height will be returned in meters. height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1) Identify tiles to request While working with Terrain-RGB, you may need to develop your own workflow to identify which tiles you will need. We recommend checking out the tools below to identify and request the tiles you require: mercantile: a module of utilities for working with XYZ-style spherical mercator tiles and includes a set of command line programs built on these utilities. supermercado: extends the functionality of Mercantile with additional commands. tilebelt: a set of JavaScript utilities for requesting and working with tiles. tile-cover: a JavaScript library that generates the minimum number of tiles required to cover a GeoJSON Geometry. xt: allows you to automatically convert a stream of tile coordinates to another format. Mapbox Terrain vector tileset The Mapbox Terrain vector tileset includes features like topography, hillshades, and landcover. The features in the contour source layer contain a property called ele, which is an elevation value in meters. Some specifics about Mapbox Terrain: Data is mapped to 10 meter height increments. Index field can be used to highlight index contour lines or control the density of contours on the map. Request data To work directly with the elevation data in the Mapbox Terrain tileset, you can retrieve features from vector tiles at a given point using the Mapbox Tilequery API. https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/ { lon } , { lat } .json?&access_token= YOUR_MAPBOX_ACCESS_TOKEN Query elevation along a line The Mapbox Tilequery API allows you to query features at a single point. To find elevation along a line, you will have to turn your line into a series of points. You can do this using turf.js. var points = turf.explode(line); // where line is a GeoJSON LineString Get elevation The above request will return a GeoJSON FeatureCollection of all the features that exist at the given point, some of which have elevation data (ele). When working with the returned data, there are a couple of considerations: Because the elevation data you want is included in the contour layer, you will need to parse the returned GeoJSON to isolate the features from the contour layer. In the Mapbox Terrain tileset, contours are comprised of stacked polygons, which means most of your requests will return multiple features from the contour layer. You will likely need to parse the returned GeoJSON to find the highest elevation value. Was this page helpful? Yes No",Access elevation data,,,,,,,,,,,,,Mapbox Terrain-RGB,Request data,Decode data,Identify tiles to request,Mapbox Terrain vector tileset,Get elevation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,API Playground,API Playground,Fill in the parameters to see how the Mapbox Search and Navigation APIs work.,,playground,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Geographic Analytics,Configure the extension,Configure the extension.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Configure the extension As with all Tableau extensions, the configuration menu is available in the top right corner of the extension pane. The configuration menu is broken down into two sections: the data source and visualization options, and the styling options.         Set data source bindings The Select Your Data Source menu allows you to specify the source worksheet and the initial data. In the Pick Your Source Worksheet dropdown menu, choose the Sheet you want the Geographic Analytics Extension to listen to. Note that interaction is only one-way, so the extension will only respond to clicks and selections from a single dashboard object. Interactions with the Geographic Analytics Extension will not affect the selected sheet or the dashboard. In the Pick Your Initial Data dropdown menu, choose the data you want to visualize. The selected column must be numeric to be valid.         Set map appearance options The Configure Map Appearance menu allows you to specify which map style you want to overlay your data onto, and how you want that data do be visualized.         Choose a map style Choose a map style in the Pick Your Map Style dropdown menu. The options are: light: Mapbox Light dark: Mapbox Dark satellite_streets: Mapbox Satellite Streets satellite: Mapbox Satellite streets: Mapbox Streets basic: Mapbox Basic The Geographic Analytics Extension does not support custom Mapbox styles yet. Specify a visualization type Use the Pick your Visualization Type dropdown menu to choose how your data will be rendered. Each visualization type is described in detail in the Data flow and processing section of this documentation. Each option has some sub-options that affect the visualization process. These include: Sub-option Parent option Description Tile Borders All options Turn the borders of all markers on or off. Circle Range Cluster Set the minimum and maximum size of clusters. Grid Size Square, Hex, Data Elevation Specify how large of a grid to bin the selected data into. Set the marker styling options You can control how the markers in the visualization are styled using the options in the Configure Marker Appearance menu: Pick your Color Range: The Min Color and Max Color represent the beginning and end of your color ranges. Values will then be interpolated between both ends, bucketed into as many groups as you select with the next option. Pick your Classification Method: The classification method and class count is the number and method for binning your data range: Equidistant: N buckets that are equally separated. Quantile: N buckets broken by appropriate percentages (100/N). Logarithmic: N buckets broken down to the appropriate log scale. Natural: N buckets broken down so as to minimize the average deviation from the bucket's mean. Also known as Jenks breaking. Select your Metric: With the exception of Voronoi, all the Geographic Analytics Extension's visualization techniques work on the basis of aggregating points together. To represent the data under each cell/band/cluster, math is applied to those points, which are then styled. All these aggregations are performed, and you are selecting which one to visualize. You have the following aggregation options: Sum Min Max Mean Median Count Extrusion Height The extension allows you to extrude the grids, Voronoi, and data elevations into 3D. The extrusion serves as a ""bar chart on a map"", permitting your audience to better visualize the differences in metrics. But, because the variance in data can be small, this control allows you to stack a minimum height to better visualize the inter-point variance. Opacity: This setting lets you control the opacity of the visualizations.         Was this page helpful? Yes No",Configure the extension,,,,,,,,,,,,,Set data source bindings,Set map appearance options,Choose a map style,Specify a visualization type,Set the marker styling options,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Inset map,Show a smaller inset map fragment and link it to a larger map for two map interaction. Great for gaming.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Inset map Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:maps=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:orientation=""vertical""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""11.302318"" mapbox:mapbox_cameraTargetLng=""106.025839"" mapbox:mapbox_cameraZoom=""5.11"" mapbox:mapbox_cameraZoomMin=""3"" maps:mapbox_enableZMediaOverlay=""true"" /> <androidx.cardview.widget.CardView android:id=""@+id/cardview"" android:layout_width=""150dp"" android:layout_height=""150dp"" android:layout_gravity=""bottom|end"" android:layout_marginBottom=""16dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" app:cardCornerRadius=""2dp"" app:cardElevation=""@dimen/cardview_default_elevation""> <FrameLayout android:id=""@+id/mini_map_fragment_container"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> </androidx.cardview.widget.CardView> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.labs; import android.os.Bundle; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.MapboxMapOptions; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.maps.SupportMapFragment; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.fragment.app.FragmentTransaction; public class InsetMapActivity extends AppCompatActivity { private static final String STYLE_URL = ""mapbox://styles/mapbox/cj5l80zrp29942rmtg0zctjto""; private static final String INSET_FRAGMENT_TAG = ""com.mapbox.insetMapFragment""; private static final int ZOOM_DISTANCE_BETWEEN_MAIN_AND_INSET_MAPS = 3; private MapView mainMapView; private MapboxMap mainMapboxMap; private MapboxMap insetMapboxMap; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_inset_map); mainMapView = findViewById(R.id.mapView); mainMapView.onCreate(savedInstanceState); mainMapView.getMapAsync(mainLargeMapReadyCallback); SupportMapFragment insetMapFragment = (SupportMapFragment) getSupportFragmentManager().findFragmentByTag(INSET_FRAGMENT_TAG); if (insetMapFragment == null) { // Create fragment transaction for the inset fragment final FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Build map fragment options MapboxMapOptions options = MapboxMapOptions.createFromAttributes(this, null); options.attributionEnabled(false); options.logoEnabled(false); options.compassEnabled(false); options.scrollGesturesEnabled(false); options.tiltGesturesEnabled(false); options.rotateGesturesEnabled(false); options.camera(new CameraPosition.Builder() .target(new LatLng(11.302318, 106.025839)) .zoom(2) .build()); // Create map fragment and pass through map options insetMapFragment = SupportMapFragment.newInstance(options); // Add fragmentMap fragment to parent container transaction.add(R.id.mini_map_fragment_container, insetMapFragment, INSET_FRAGMENT_TAG); transaction.commit(); } insetMapFragment.getMapAsync(insetMapReadyCallback); } private OnMapReadyCallback mainLargeMapReadyCallback = new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { InsetMapActivity.this.mainMapboxMap = mapboxMap; mapboxMap.setStyle(new Style.Builder().fromUri(STYLE_URL), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { mainMapboxMap.addOnCameraMoveListener(mainCameraMoveListener); } }); } }; private OnMapReadyCallback insetMapReadyCallback = new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { insetMapboxMap = mapboxMap; mapboxMap.setStyle(new Style.Builder().fromUri(STYLE_URL)); } }; private MapboxMap.OnCameraMoveListener mainCameraMoveListener = new MapboxMap.OnCameraMoveListener() { @Override public void onCameraMove() { CameraPosition mainCameraPosition = mainMapboxMap.getCameraPosition(); CameraPosition insetCameraPosition = new CameraPosition.Builder(mainCameraPosition) .zoom(mainCameraPosition.zoom - ZOOM_DISTANCE_BETWEEN_MAIN_AND_INSET_MAPS).build(); if (insetMapboxMap != null) { insetMapboxMap.moveCamera(CameraUpdateFactory.newCameraPosition(insetCameraPosition)); } } }; // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mainMapView.onResume(); } @Override protected void onStart() { super.onStart(); mainMapView.onStart(); } @Override protected void onStop() { super.onStop(); mainMapView.onStop(); } @Override public void onPause() { super.onPause(); mainMapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mainMapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mainMapboxMap != null) { mainMapboxMap.removeOnCameraMoveListener(mainCameraMoveListener); } mainMapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mainMapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Inset map,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Add a polygon annotation,Draw a vector polygon on a map with the Mapbox Maps SDK for iOS.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Swift,,"Add a polygon annotation Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 45.520486, longitude: -122.673541), zoomLevel: 11, animated: false) view.addSubview(mapView) mapView.delegate = self } override func viewDidAppear(_ animated: Bool) { // Draw the polygon after the map has initialized drawShape() } func drawShape() { // Create a coordinates array to hold all of the coordinates for our shape. var coordinates = [ CLLocationCoordinate2D(latitude: 45.522585, longitude: -122.685699), CLLocationCoordinate2D(latitude: 45.534611, longitude: -122.708873), CLLocationCoordinate2D(latitude: 45.530883, longitude: -122.678833), CLLocationCoordinate2D(latitude: 45.547115, longitude: -122.667503), CLLocationCoordinate2D(latitude: 45.530643, longitude: -122.660121), CLLocationCoordinate2D(latitude: 45.533529, longitude: -122.636260), CLLocationCoordinate2D(latitude: 45.521743, longitude: -122.659091), CLLocationCoordinate2D(latitude: 45.510677, longitude: -122.648792), CLLocationCoordinate2D(latitude: 45.515008, longitude: -122.664070), CLLocationCoordinate2D(latitude: 45.502496, longitude: -122.669048), CLLocationCoordinate2D(latitude: 45.515369, longitude: -122.678489), CLLocationCoordinate2D(latitude: 45.506346, longitude: -122.702007), CLLocationCoordinate2D(latitude: 45.522585, longitude: -122.685699) ] let shape = MGLPolygon(coordinates: &coordinates, count: UInt(coordinates.count)) mapView.addAnnotation(shape) } func mapView(_ mapView: MGLMapView, alphaForShapeAnnotation annotation: MGLShape) -> CGFloat { return 0.5 } func mapView(_ mapView: MGLMapView, strokeColorForShapeAnnotation annotation: MGLShape) -> UIColor { return .white } func mapView(_ mapView: MGLMapView, fillColorForPolygonAnnotation annotation: MGLPolygon) -> UIColor { return UIColor(red: 59/255, green: 178/255, blue: 208/255, alpha: 1) } } Copy Was this page helpful? Yes No",Add a polygon annotation,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,raster data,Rasters are a pixel-based data format that efficiently represent continuous surfaces.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"raster data Raster data is a pixel-based data format that efficiently represent continuous surfaces. Information in a raster is stored in a grid structure with each unit of information, or pixel, having the same size and shape, but varying in value. All digital photographs are stored in this format, which is also referred to as a bitmap. This includes satellite images and orthophotography. You can upload raster data to Mapbox Studio to add custom data to your maps. For more information on uploading raster data, read the Mapbox Studio Manual uploads page. Was this page helpful? Yes No",raster data,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for iOS,iOS,Route generation,Learn how to generate routes for use in the Mapbox Navigation SDK for iOS.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Route generation The routes used in the Navigation SDK are generated by the Mapbox Directions API. When you install the Navigation SDK, it also includes MapboxDirections.swift, which provides a convenient way to access the Mapbox Directions API in iOS applications. To generate a route, you'll create a new Route object using MapboxDirections.swift. In most cases, you'll also use the NavigationRouteOptions class (a subclass of MapboxDirections.swift's RouteOptions class) to set a few options. You can specify any of the same options you could using the RouteOptions class found in MapboxDirections.swift, but the defaults in NavigationRouteOptions are better suited to how the Navigation SDK uses the resulting route. Below are examples of how you can use specific options to generate routes for a few scenarios. Request a route in a specific direction With the Navigation SDK, you can consider the direction a user’s device is facing and request a route starting in a specific direction. To receive a route in a specific direction (for example, the direction a user is traveling or the direction a device is facing), pass in the user’s location heading value. This property corresponds to the angles in the bearings query parameter in the Mapbox Directions and Map Matching APIs. Waypoint: In the adjacent diagram, the blue dot with white stroke is the device location. Imagine this is the first (origin) Waypoint in a Directions API request. Heading: The Waypoint.heading can be used to influence the direction in which a route leg should begin. The heading value is the angle clockwise from true north between 0 and 359. For example, when the heading value is 0, the heading direction is due north. In the adjacent diagram, the pink arrow is the direction that the device is the heading (which is due west or 270°). Read about Waypoint.heading in more detail. Heading accuracy: The Waypoint.headingAccuracy is the range of degrees by which a route can deviate from the Waypoint.heading angle and still be recommended. The semi-transparent blue area illustrates headingAccuracy. In this example headingAccuracy is 90° (45° in either direction from the heading angle). Read about Waypoint.headingAccuracy in more detail. Default heading The default value for heading is −1°, which means that the heading will not be taken into account when calculating a route. Consider the direction a device is facing To request a route that starts in the direction that the device is facing, set Waypoint.heading to use CLHeading.trueHeading. This may be appropriate when requesting a route with the user's location as the origin before the user has started moving or for walking directions. You can also set a Waypoint.headingAccuracy to specify the range of degrees by which a route can deviate from the Waypoint.heading angle. Though Waypoint.headingAccuracy and CLHeading.headingAccuracy have similar names, it is not appropriate to pass in the current CLHeading.headingAccuracy. CLHeading.headingAccuracy tends to result in too-strict route requests. This can also be applied to any waypoint including the origin and any stops along the route. let userWaypoint = Waypoint(location: mapView?.userLocation!.location, heading: CLHeading.trueHeading, headingAccuracy: 90) Consider the direction a user is already traveling If you need to request a route that's continuing along the path that the user is traveling, set the Waypoint.heading to use CLLocation.course. This may be appropriate for driving directions. Consider that the phone may be in a center cup holder, facing the driver rather than the rear-view mirror, as the car moves in a forward direction. You can also set a custom Waypoint.headingAccuracy. This can be applied to any waypoint including the origin, stops along the route, and the destination. let userWaypoint = Waypoint(location: mapView?.userLocation!.location, heading: CLLocation.course, headingAccuracy: 90) Specify a side of the road to approach By default, routes generated will approach waypoints on either side of road. You can override the default by setting Waypoint.allowsArrivingOnOppositeSide to false. This will require that the route has the driver approach the waypoint on the same side of the road the waypoint is on. allowsArrivingOnOppositeSide corresponds to the approaches query parameter in the Mapbox Directions and Map Matching APIs. let userWaypoint = Waypoint(location: mapView?.userLocation!.location, allowsArrivingOnOppositeSide: false) Include multiple stops The Mapbox Directions API requires at least two waypoints to generate a route. If your route involves several pick-up and drop-off points, you can add up to 25 coordinates (including the origin and destination) using the driving profile or three coordinates using the driving-traffic profile. These coordinates are treated as stops in between the origin and destination in the order that you add them — the first waypoint is the origin and the second waypoint is the first stop: let waypointOne = Waypoint(coordinate: CLLocationCoordinate2DMake(37.77766, -122.43199)) let waypointTwo = Waypoint(coordinate: CLLocationCoordinate2DMake(37.77609, -122.43292)) let waypointThree = Waypoint(coordinate: CLLocationCoordinate2DMake(37.77536, -122.43494)) let options = NavigationRouteOptions(waypoints: [waypointOne, waypointTwo, waypointThree]) Directions.shared.calculate(options) { (waypoints, routes, error) in guard let route = routes?.first, error == nil else { print(error!.localizedDescription) return } let navigationService = MapboxNavigationService(route: route, simulating: simulationIsEnabled ? .onPoorGPS) let navigationOptions = NavigationOptions(navigationService: navigationService) let navigationViewController = NavigationViewController(for: route, options: navigationOptions) navigationViewController.delegate = self self.present(navigationViewController, animated: true, completion: nil) } Silent waypoints The Waypoint.separatesLegs property determines if a waypoint will be treated as a stop between legs or influence the route without specifically mentioning it in maneuver instructions. By default Waypoint.separatesLegs is equal to true meaning the waypoint will appear in the resulting routes as a waypoint separating two legs, along with corresponding guidance instructions. If you want to make sure that the route you request passes through the waypoint without specifically mentioning it, set Waypoint.separatesLegs equal to false. Optimized routes If you want to generate a route that will arrive at the waypoints in the fastest order (not necessarily in a specific order), see the Optimization API documentation. More about route generation Localization: Customize the language and units of measurement returned for both text and voice instructions or use the language preferences set on the device. Offline routing: Provide routing functionality from the Navigation SDK in non-connected environments. Was this page helpful? Yes No",Route generation,,,,,,,,,,,,,Request a route in a specific direction,Consider the direction a device is facing,Consider the direction a user is already traveling,Specify a side of the road to approach,Include multiple stops,Silent waypoints,Optimized routes,More about route generation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Style a single country,Find and upload open source data to style in Mapbox Studio.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,No code,,"beginner No code Style a single country With the Mapbox Studio style editor, you can style a single country or region. In this example, you will be styling Australia. Getting started Before getting started, you will need a few things: Mapbox account. You will need an account to log in and use the Mapbox Studio style editor. You can create an account at mapbox.com/account. Natural Earth data. Download the Admin 0 - Countries Shapefile from Natural Earth. Create a new style Log into your Mapbox account and navigate to your Styles page. This is where all your styles are listed. A style is a set of rules for how Mapbox will draw the map on a page – it includes references to your data, map images (icons, markers, patterns), fonts, and defines how all your data should be styled on your map. For more about styles, see the Styles section of the Mapbox Studio Manual. To create a new style from your Styles page, click New style, scroll down, select Blank, and click Customize Blank. The style editor will automatically open. Your browser doesn't support embedded videos. Use the style editor Use the style editor to add the data you downloaded to the map and adjust the style of the country. Add a tileset source You can add Australia to the empty map canvas by uploading the Natural Earth data as a tileset: Click + Layer. In the list of Data sources, click + Upload, and select the Natural Earth data. A popover will appear in the bottom right showing the progress of your upload. Once the upload has ""Succeeded"", the tileset will be ready to use! Search for your tileset in the Data sources list and click the source and then the source layer you'd like to use. The tileset you created includes all countries. To filter to use only Australia: Click the Filter option and click + Create filter. Choose NAME from the list of data fields. Type Australia into the search bar. Click + Use Australia and then click Done. In the original panel, flip back to the Style tab. You'll see a black outline of Australia in your map canvas. Style data Next, click the Style tab to customize the look and feel of the layer. Change both the Color and 1px stroke fields to #11b1f0. Publish When you have finished editing your map style, publish your changes by clicking Publish in the upper right of the style editor. When you click the publish button, a window will display the difference between the previous and current version of this style. If you're happy with the changes, click Publish. Your style will now be available to share from a variety of tools and applications. Final product You've styled a single country with the help of an outside data source. Mapbox Studio provides a wide variety of ways to use your new map style. You can use this map directly on your website or in a web or mobile application. Take a look at the Publish style section of the Mapbox Studio Manual to see all the ways you can use your style! Next steps Learn more about what you can do with the Mapbox Studio style editor in the Mapbox Studio Manual. Was this page helpful? Yes No",Style a single country,,,,,,,,,,,,,Getting started,Create a new style,Use the style editor,Add a tileset source,Style data,Publish,Final product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,How to regain access to your account,Learn to troubleshoot common account lockout scenarios.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"How to regain access to your account This guide outlines common account lockout scenarios and highlights the processes for confirming ownership, regaining access to an account, and updating the credentials of an account. Mapbox serves as critical infrastructure for our customers and we work hard to protect the security of your accounts, data, and end users. If you’re still experiencing difficulties after working through this guide, contact support. If you have more general questions about your Mapbox account, see our Account documentation. Account lockout scenarios Maintaining access to an account starts by setting up your account with the recommendations listed in our best practices guide for collaboration. That said, here are some of the most common account lockout scenarios, how to fix them, and how to avoid them in the future. I don’t know the username or password for our Mapbox account If you've inherited a project that uses Mapbox location services, but you don't have access to the login credentials, the information below will help you work with support team to confirm ownership of the account. How to regain access:Please verify ownership of your account by contacting support. In your request, include as many of these details as possible: Full URL of an API request Link to a live map Invoice number Mapbox username Registered email address Prevention:Save the username & password for your Mapbox account in a shared vault like a 1Password vault and/or Okta and use an email address that is accessible for all your stakeholders. My colleague left the company with their email address still registered on our account How to regain access:If a former colleague's email address is tied to your company's Mapbox account, try contacting your IT department requesting the email address be reactivated or forwarded automatically to an email of your choosing. Once you have access to that email address or forwarding rules are in place, you can reset your password to regain access to that account. Once you’ve regained access to your account, you can change the email to any of your choosing. If you need our Security team to change the registered email on your account, we’ll need to verify that you are the owner of the account first. Send us a note and we will be happy to look into it for you. We try and respond to all account verification and lockout troubleshooting requests within 1-2 business days of submission. Prevention:Once you have access to your account, change the email to one that multiple people have access to and store your credentials in a shared-secure location, like a 1Password vault and/or Okta. This will help keep your password safe and available when you or your teammates need it. Make sure the stakeholders (anyone who might need to access your account) know where to find the credentials. I’m not receiving the password reset email Have you tried sending yourself the password reset instructions and still aren’t receiving the email? Emails can be temporarily undeliverable for various reasons. Sometimes the receiving email server cannot be found, gets overloaded, or becomes unavailable. First, check that the emails haven’t landed in your Spam folder, then contact support to let us know you’re having trouble. We can help. I lost my two-factor authentication (2FA) backup codes 2FA provides an additional layer of security on your account. When enabled, logging in requires entering the password and a string of numbers generated by an authentication app like Google Authenticator—it’s free for iOS and Android. Backup codes are vital to regain access to your account. If you do not have the 2FA backup codes though, we might be able to help. How to regain access:If you do not have your 2FA backup codes, we’ll need to verify that you’re the owner of the account, which requires having a payment method on file. Please contact support to begin the verification process. If your account doesn’t have a payment method on file and we’re unable to verify ownership, consider creating a new account. Prevention: When you enable 2FA, a single-use recovery code is generated. Write down this code and keep it in a safe place, like a password manager: You can find your recovery codes when you enable 2FA. This code can be found above the purple Enable two-factor authentication button. Not able to resolve your issue with this guide? Contact support. Was this page helpful? Yes No",How to regain access to your account,,,,,,,,,,,,,Account lockout scenarios,I don’t know the username or password for our Mapbox account,My colleague left the company with their email address still registered on our account,I’m not receiving the password reset email,I lost my two-factor authentication (2FA) backup codes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Keep access tokens private in open source iOS and Android apps,Learn how to protect your access tokens so that they aren't used by others.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Keep access tokens private in open source iOS and Android apps An app using the Mapbox Maps SDK for iOS or the Mapbox Maps SDK for Android, must provide an access token to display Mapbox-hosted maps and use other Mapbox services. If the app’s source code is public, for example on GitHub, you should rotate your access token regularly to prevent abuse by other developers. You can go one step further by keeping your access token out of the project’s repository entirely. iOS Create a new plain text file containing your access token, named either .mapbox or mapbox. To avoid accidentally committing this file to an open-source project, either you can save it to a location outside your project's version-controlled directory, or you can add this file to your project’s .gitignore file. Open your project in Xcode. In the project editor, go to the Build Phases tab, then click the + button to add a new Run Script phase to the end. Customize the Run Script build phase to run the following code (replacing ~/.mapbox or ~/mapbox with the path to the file you added in step 1): # Look for a global file named 'mapbox' or '.mapbox' within the home directory token_file=~/.mapbox token_file2=~/mapbox token=""$(cat $token_file 2>/dev/null || cat $token_file2 2>/dev/null)"" if [ ""$token"" ]; then plutil -replace MGLMapboxAccessToken -string $token ""$TARGET_BUILD_DIR/$INFOPLIST_PATH"" else echo 'warning: Missing Mapbox access token' open 'https://www.mapbox.com/account/access-tokens/' echo ""warning: Get an access token from <https://www.mapbox.com/account/access-tokens/>, then create a new file at $token_file or $token_file2 that contains the access token."" fi Add $(TARGET_BUILD_DIR)/$(INFOPLIST_PATH) to the build phase’s Input Files section. Otherwise, the access token may be overridden during incremental builds. Optionally, you can also add ~/.mapbox or ~/mapbox to this section, so that Xcode will automatically update Info.plist after you change your access token. When building the project in Xcode, the access token will be inserted into the Info.plist inside your built app, but not into the Info.plist that you’d commit. Android Git-based option Please be aware that to enable continuous integration builds with the following approach, you can take advantage of a Gradle script that the Mapbox Android team uses itself. Create a local .gitignore file in your repository folder. If the folder already has a .gitignore file, locate and open it. Add the following line to the .gitignore file : YOUR_APP_MODULE_NAME/src/main/res/values/developer-config.xml. This will tell the Git system to ignore the XML values file that you will create in the next step. Navigate to your project's src/main/res/values folder and make a new file titled developer-config.xml. Create an access_token String resource and paste your access token into it: <string name=""access_token"">PASTE_YOUR_TOKEN_HERE</string> At this point, the R.string.access_token string resource should be discoverable wherever you deliver the access token to the Mapbox class such as: Mapbox.getInstance(context, getString(R.string.access_token)); Because of step #3 above, the Git system shouldn't be tracking the developer-config.xml file at all. You're all set! You can use and change the Mapbox access token locally on your machine without the chance of committing and pushing it to a public platform such as GitHub! Non-Git option Find or create a gradle.properties file in your Gradle user home folder. The folder can be found at «USER_HOME»/.gradle. Once the file is created, its path should be «USER_HOME»/.gradle/gradle.properties. More information about Gradle properties. Add a key-value pair to the gradle.properties file: MAPBOX_ACCESS_TOKEN=""PASTE_YOUR_TOKEN_HERE""; Open your app-level build.gradle file. This file is usually the one where you define specific dependencies for your app, such as the Mapbox Maps SDK for Android. Add MAPBOX_ACCESS_TOKEN as a buildConfigField entry to whichever buildTypes your app has: android { buildTypes { debug { ... buildConfigField 'String', ""MapboxAccessToken"", MAPBOX_ACCESS_TOKEN ... } release { ... buildConfigField 'String', ""MapboxAccessToken"", MAPBOX_ACCESS_TOKEN ... } } } Because your Gradle files have changed, make sure to sync the project with the latest Gradle files. Now you can access your Mapbox access token in your app to initialize the Mapbox Maps SDK for Android: Mapbox.getInstance(context, BuildConfig.MapboxAccessToken); Was this page helpful? Yes No",Keep access tokens private in open source iOS and Android apps,,,,,,,,,,,,,iOS,Android,Git-based option,Non-Git option,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Help,Help and troubleshooting articles for the Mapbox Maps SDK for iOS.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,,,,"Our Help page contains tutorials, troubleshooting guides, and other resources to help you get started. Tutorials First steps with the Mapbox Maps SDK for iOS Walk through installing the Mapbox Maps SDK for iOS, getting a map on the screen, and placing a pin on it. Create a map for iOS using data-driven styling Create a map for iOS that styles a circle based on a data attribute. Build a store locator for iOS Build a store locator that can be integrated into any iOS application. Troubleshooting App Store submission with the Mapbox Maps SDK for iOS Learn how to troubleshoot frequently seen issues when submitting applications built with the Mapbox Maps SDK for iOS to the App Store. Understanding iOS framework size Learn how to measure and optimize your iOS app’s size. Keep access tokens private in open source iOS apps Learn how to keep access tokens private in private open source iOS apps. Troubleshooting Mapbox Maps SDK for iOS installation Learn how to troubleshoot frequently seen issues when installing the Mapbox Maps SDK for iOS. Offline maps Learn about how offline maps work. Change your map’s label language Learn about available languages and how to change your map’s language. Interactive tools Mapbox offline tile count estimator Estimate the number of tiles required to download an offline region using the Mapbox Maps SDK for Android and iOS. Marker playground Add a marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, React Native, or web application.",Tutorials,,,,,,,,,,,,,Troubleshooting,Interactive tools,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Install Atlas,"Download, install, and set up Atlas.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Install Atlas You'll need four parts to install Atlas on your machine. This guide will walk you through each of the following pieces: Make sure your machine meets all prerequisites. The installer, which can be downloaded from studio.mapbox.com/atlas. A Mapbox access token with an atlas:read scope. An installation method for downloading, installing, and configuring Atlas. Documentation conventions In this guide, we used atlas-installer as the installer name. Depending on which target OS you selected the installer will be named differently. To simplify the documentation, we will use atlas-installer for the rest of the documentation. Some examples use <angle-brackets> as a convention to show places where you will need to specify your own details. The examples in this guide also use atlas-server-files for the download destination and atlas-server as an install target. Change the destination and target directory name with the ones you choose to use. Check prerequisites To download Atlas, your system must have at least enough disk space for the Docker images and tilesets. The disk space requirements will be different depending on whether you download the development or production tilesets: Data Development tilesets Production tilesets Maps 2 GB 410 GB Geocoding 245 MB 70 GB Tileset size Below are approximate sizes for each tileset. Exact tileset file sizes are subject to change with new data from weekly updates. Tileset Dev Production mapbox.mapbox-terrain-v2 450 MB 40 GB mapbox.mapbox-streets-v7 300 MB 100 GB mapbox.satellite-full 850 MB 260 GB mapbox.satellite-watermark 140 MB 7 GB Total 1.75 GB 407 GB Docker images In total, Docker images are about 10 GB. Total disk space recommendations Because installation maintains two copies of your data, we recommend hosting Atlas on a server with double the disk space that the data will require. If you are downloading full production tilesets and geocoding data, our recommendation is to host Atlas on a server with at least 1000 GB of disk space. Check dependencies Before proceeding, make sure your machine has all of the necessary dependencies: wget OpenSSL (optional) Docker Docker Compose unzip (Atlas Search) pv Download the installer Go to studio.mapbox.com/atlas. Click the Download button for your operating system, either Linux or macOS. Unzip the downloaded zip file: unzip atlas-installer.zip. Give execute permission on the installer executable: chmod +x ./atlas-installer. Create a Mapbox access token Once you have downloaded the Atlas installer, the next step is to create a Mapbox token with atlas:read scope. This token will be required by the download command. You will create this token using the Mapbox account with which your Atlas license is associated. Go to the Mapbox access token page. Click on + Create a token. Give the new token a name like ""Atlas Server"". Uncheck all the default public scopes. Under Secret scopes, check the Atlas:Read scope. Click Create token. Save your new Atlas token in a secure place. Once you leave the Access Tokens page, you will not have access to this token again. Do not commit the Atlas token to GitHub or share it with anyone outside of your organization. Recommended installation method The Atlas installer is a command line interface (CLI) utility used to download and setup Atlas. The installer has been specifically designed for air-gapped environments where the host computer does not have access to the internet. Note This documentation refers to version 1.3.0 of the Atlas installer. If you have an older version of the installer, you need to download the latest version before continuing. We recommend using the install command. This command will prompt you through a series of questions to configure your setup, execute download to download your Atlas data, then run setup if you've specified that you're installing Atlas on the same machine. To start the installation process run: $ ./atlas-installer install Before starting the installation process, be prepared with the following information: Whether or not you plan to run Atlas on the same machine you are running the install command on. Which version of Atlas you want to download (defaults to the most recent version). What data you would like to download including development data. For a full reference of the prompts you will see when running install, see Installer prompts reference Install Atlas on the same machine If you are running this command on the machine you will be installing Atlas on, you should also be prepared with the following information: If you are upgrading an existing Atlas installation. If you plan to run Atlas on HTTPS. If you have an SSL certificate. If yes, where it is located. The path where you would like to install Atlas. Your Atlas server hostname, port, and a password. After you have answered all the prompts, the installer will download all the Atlas dependencies (Docker images, tilesets, geocoding data) you specified, and put them in a directory named atlas-server-files. If you are installing Atlas on the same machine (answered yes to the first prompt), the installer will run the setup command and configure your installation based on the information passed in to the wizard. Once complete, you can skip to the run Atlas section. Install Atlas on a different machine If you are planning to install Atlas on a different machine (for example, a machine without internet connection), you should only run install to download Atlas. You will then need to run setup on the machine you plan to use Atlas on. To do this, answer no to the first prompt if you plan to run Atlas on a different machine, or if you are running Atlas in an air-gapped environment. If answered no to the first prompt, the installer wizard will only ask you the questions needed to downloaded data. Once the installer has finished downloading data, you will need to copy the downloaded files along with the installer and run the setup command. Manual installation method The following outlines the steps to manually install Atlas using the download and setup commands. We recommend using the installer wizard for a better install experience. If you ran the install command but are installing Atlas on a different machine (for example, an offline server), you should copy the atlas-installer along with the downloaded files in your atlas-server-files directory to the new location and proceed with the setup command. Download Docker images, tilesets, and data If you do not want to use the installer wizard, you can download Atlas data manually using the download command. You will need to be connected to the internet to run this command. Usage $ ./atlas-installer download <destination> --token <your-atlas-token> [options] Arguments <destination> (required): The directory where the downloaded files will be saved. Must be on the same computer as the Atlas installer. Options --token, -t <token> (required): A Mapbox access token with atlas:read scope. --dev (optional): Download only development tilesets. Recommended if you are testing or evaluating Atlas. --version, -v (optional): Version of Atlas to download. Default is the latest version. --tilesets <streets | terrain | satellite | all | none> (optional): Specify which production tilesets to download. Defaults to all. --dev-tilesets <streets | terrain | satellite | all | none> (optional): Specify which development tilesets to download. Defaults to none. --no-geocoding (optional): Do not download geocoding data. --dev-geocoding (optional): Download development geocoding data (includes country-level data). --enterprise-boundaries <all | admin | postal | stats | none> (optional): Download enterprise boundaries tilesets. Defaults to all. --no-progress (optional): Disable progress bar indicator. Deprecated: --data, -d <tilesets | docker | geocoding | all> (optional): Choose to download only tilesets, only Docker images, only geocoding data, or all data. Defaults to all. You will only be able to download geocoding data if you purchased Atlas Search. If no flags are passed in to the Installer, the latest Atlas version along with production tilesets, production geocoding data (if purchased), and Enterprise Boundaries data (if purchased) will be downloaded. This command will take a while to complete. You will see the message ""Tilesets downloads completed"" once the download is finished. You will not be able to move on to the setup step until the download command is finished. Downloading development data If you are testing or evaluating Atlas, we recommend that you download the development tilesets using --dev to test your Atlas configuration without committing to downloading the full set of production tilesets. These are low-zoom (z0-8) versions of the Mapbox Streets, Satellites, and Terrain tilesets that you can use for testing. Once you have confirmed that the development tilesets work on your system, you can download the full set of production tilesets. $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --dev Downloading a specific version of Atlas By default, the download command will download the latest release of Atlas. You can use the list command to see the list of Atlas versions that are available to download. For more information on the list command, see the List available Atlas versions section. For example, to download v2.4.2 of Atlas, you would run: $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --version v2.4.2 Downloading specific tilesets Version 1.3.0 of the Installer allows you to specify which tilesets to download. For example, if you would like to download production streets data, but development terrain and satellite, you would do: $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --dev-tilesets satellite,terrain Downloading only Docker images To only download Docker images (e.g., to upgrade Atlas without replacing data), you would run: $ ./atlas-installer download atlas-server-files/ --token <your-atlas-token> --tilesets none --no-geocoding --enterprise-boundaries none Setup Atlas Once the download command has completed, you will run the setup command. When the setup command runs, all the files from the source directory are moved into the target directory, then the source directory will be deleted. The setup command also loads each downloaded Docker image tarball and unzips geocoding data, if applicable. You can run the setup command offline and you must run it from the Docker host where Atlas will be installed. If you ran the download command from another computer than the host you will need to copy over the download command destination directory in its entirety. The directory should contain two subdirectories, /docker and /tilesets, as well as a license.json file. If you have Atlas Search, you will have an additional directory called /search. Usage $ ./atlas-installer setup <source> <target> [options] Arguments <source> (required): The directory that contains all the files downloaded with the download command. <target> (required): The directory where Atlas will be installed on the host. Options Note If neither --self-signed or --ssl is specified, Atlas will be configured to run on HTTP. --config (optional): Pass in a JSON configuration file to configure the Atlas password, port, and hostname. If a configuration file isn't passed, Atlas will be configured with the defaults shown below. You can also configure the Atlas password, port, and hostname by using the command line options rather than passing in a config. --ssl, -s <path> (optional): The path to a directory that contains SSL certificate files, cert.pem (a certificate file) and key.pem (a private key for the certificate). These will be copied into your Atlas installation. Use this option if you need to use your own certificate. Cannot be used with --self-signed. --self-signed, -l (optional): This will tell the installer to create self-signed SSL certificates and configure Atlas to run over HTTPS. Cannot be used with --ssl. --hostname, -t (optional): Public hostname of the server running Atlas. Should match the host the end users will use in their browsers. --password, -p (optional): Password administrators will use to access Atlas account dashboard & Studio. If no password is passed in, a secure password will be generated for you. --port, -r (optional): Port the Atlas Server will listen on. --upgrade (optional): Used to indicate that you are upgrading Atlas versions. If passed, setup will skip re-configuring settings. --config format Here is an example config.json showing defaults that will be applied if no config is passed. We highly recommend changing the default password at the minimum. { ""AtlasServerPassword"": ""password"", ""AtlasServerPort"": 2999, ""AtlasServerHostName"": ""localhost"" } Examples # Configure to run on HTTP $ ./atlas-installer setup atlas-server-files/ atlas-server/ # Configure to run on HTTPS with self-signed certificates $ ./atlas-installer setup atlas-server-files/ atlas-server/ --self-signed # Configure to run on HTTPS with custom certificates $ ./atlas-installer setup atlas-server-files/ atlas-server/ --ssl ~/sslcert-directory Change configuration (post-setup) If you want to change the config file or the Atlas protocol (HTTP/HTTPS) after you set up Atlas, use the settings command. Usage $ ./atlas-installer settings <target> --config <path to JSON file> Options --config (optional): Pass in a JSON configuration file to configure the Atlas password, port, and hostname. The config.json file takes the same format as for the --config option in the setup command. The config file will automatically be backed up to a config.json file in the Atlas target directory. --http (optional): Configure Atlas to use HTTP. Cannot be used with --ssl or --self-signed. --self-signed, -l (optional) : This will tell the installer to create self-signed SSL certificates and configure Atlas to run over HTTPS. Cannot be used with --ssl or --http. --ssl, -s <path> (optional): The path to a directory that contains SSL certificate files, cert.pem (a certificate file) and key.pem (a private key for the certificate). These will be copied into your Atlas target directory. Use this option if you need to use your own certificate. Cannot be used with --http or --self-signed. Examples # Stop Atlas $ (cd atlas-server && ./atlas.sh stop) # Update the atlas config $ ./atlas-installer settings atlas-server/ --config path/to/config.json # Switch to HTTP $ ./atlas-installer settings atlas-server/ --http # Switch to HTTPS (custom certificate) $ ./atlas-installer setup atlas-server-files/ atlas-server/ --ssl path/to/certs # Switch to HTTPS (self-signed certificate) $ ./atlas-installer setup atlas-server-files/ atlas-server/ --self-signed # Start Atlas $ (cd atlas-server && ./atlas.sh start) List available Atlas versions The list command lists of all downloadable Atlas versions. You can determine the version of Atlas you have installed by listing the files in <install-target>/docker directory. You will find the version of Atlas in the docker tarballs. This will help you know if you should upgrade. api-accounts-e06eaabc6c743f6d4d2810342eccef1c097f6a2d-v2.4.0.tar.gz --> Atlas version 2.4.0 Usage $ ./atlas-installer list --token <your-atlas-token> Options --token <token> (required): A Mapbox access token with atlas:read scope. Once you have found the version of Atlas you would like to install, run the download command and specify the --version. $ ./atlas-installer download atlas-server-files/ --version <your-atlas-version> --token <your-atlas-token> --dev Reference Installer command reference The recommended installation method above uses the following commands. If you used the recommended method, you do not need to use any of these commands directly, they are provided only for reference. Command Requires Internet Description install Yes Configure your installation through a series of prompts. download Yes Downloads Atlas. setup No Install Atlas. settings No Change Atlas settings. list Yes List downloadable Atlas versions. remove No Uninstall Atlas or parts of Atlas. Installer prompts reference Do you plan to run Atlas on this machine? Defaults to yes. Select no if you only want to download dependencies. Enter your sk token with atlas:read scope Copy and paste your secret token you created on mapbox.com with atlas:read scope. Which Atlas version would you like to download? You will be presented with a drop down menu of available versions to download. The first version listed is the latest stable version. Use your arrow keys to select a different version, and press <enter> to continue. What data would you like to download? By default, Docker images, mapbox-streets-v7, and geocoding data are selected as options. Use your arrow keys to navigate the options. You can press <space> to select, <a> to toggle all, or <i> to invert selection. Would you like to download development data for any of the following? Select which development data you would like to download. For testing out or evaluating Atlas, we recommend downloading all development data. Use your arrow keys to navigate the options and <space> to make selections. Press <enter> to continue. Are you upgrading an existing Atlas installation? Only asked if installing Atlas on the same machine. Defaults to no. Type in yes if you already have a previous version of Atlas v2 installed. This will skip re-configuring settings. Do you plan to run Atlas on HTTPS? Only asked if installing Atlas on the same machine. Defaults to no (HTTP). If you plan to run Atlas on HTTPS, type yes and press <enter>. Do you have an SSL certificate? Only asked if running Atlas on HTTPS. Defaults to yes. Type no if you do not have an SSL certificate, and the installer will generate one for you with OpenSSL. Where is your cert located? Only asked if answered yes to having an SSL certificate. Enter the full path of the location of your SSL certificate. Where do you plan to install Atlas? Only asked if installing Atlas on the same machine. Defaults to atlas-server. Enter the name of the directory you wish to install Atlas. The installer will create this directory for you. What is your Atlas server hostname? Only asked if installing Atlas on the same machine. Enter the public hostname of the server running Atlas. This should match the hostname your end users will use in their browsers. Defaults to localhost. What port will you be running Atlas on? Only asked if installing Atlas on the same machine. Enter the port that Atlas will listen on. Defaults to 2999. Enter a password for your Atlas server instance Only asked if installing Atlas on the same machine. Enter a password for administrators to use to access the Atlas account dashboard and Studio. Alternatively, you can press <enter> without entering a password, and the installer will generate a secure password for you. Your password must be at least 8 characters. Was this page helpful? Yes No",Install Atlas,,Downloading specific tilesets,Downloading only Docker images,Setup Atlas,#NAME?,Examples,Change configuration (post-setup),List available Atlas versions,Reference,Installer command reference,Installer prompts reference,,Check prerequisites,Total disk space recommendations,Check dependencies,Download the installer,Create a Mapbox access token,Recommended installation method,Install Atlas on the same machine,Install Atlas on a different machine,Manual installation method,"Download Docker images, tilesets, and data",Usage,Arguments,Options,Downloading development data,Downloading a specific version of Atlas,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Add a Mapbox Studio style as a basemap in ArcGIS Online,Add your map as a basemap to ArcGIS Online.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,No code,,"intermediate No code Add a Mapbox Studio style as a basemap in ArcGIS Online Prerequisite Familiarity with and access to ArcGIS Online. Mapbox allows you to integrate your Mapbox Studio styles with ArcGIS Online. In this tutorial, you'll learn how to add a style from your Mapbox account to your ArcGIS Online project as a tile layer. Getting Started There are a few resources you will need to follow along with this tutorial: ArcGIS Online account. You can sign up for a free account on the ArcGIS website. Integration URL. You can find the integration URL in the Share & use modal for your style. Finding this will be covered in a later step. Create a new project in ArcGIS Navigate to your ArcGIS Online projects page and create a new project: Log into ArcGIS Online. Navigate to the Make a Map page. This will automatically create a new project. Click Add > Add Layer from Web. A new window will open. Choose A Tile Layer from the dropdown list. Find your ArcGIS integration URL In another tab in your browser, open Mapbox Studio and find your ArcGIS integration URL: Log into Mapbox Studio. Navigate to your Styles page. Click on the Share & use button next to the style you want to add to your map. When the Share & use modal opens, switch to the Use tab. Click the Third party option. Toggle to ArcGIS. Copy the URL by clicking the clipboard icon. Add your Mapbox style as a tile layer Let's return to ArcGIS Online to finish adding our tile layer: Navigate back to your ArcGIS Online project. In the open Add Layer from Web window, paste your ArcGIS integration URL in the URL field. Check the Use as Basemap box. Add a Title to your layer. Add ""© OpenStreetMap contributors Design © Mapbox"" to the Credits field. Click Add Layer. Finished product You've successfully added your Mapbox style as the basemap in your ArcGIS Online project. Next steps If you're interested in creating a custom or branded style in Mapbox Studio to be used in ArcGIS Online, take a look at our Create a custom style tutorial. Was this page helpful? Yes No",Add a Mapbox Studio style as a basemap in ArcGIS Online,,,,,,,,,,,,,Getting Started,Create a new project in ArcGIS,Find your ArcGIS integration URL,Add your Mapbox style as a tile layer,Finished product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vision SDK for iOS,iOS,Speeding alerts,Display an alert when the vehicle is speeding.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Swift,,"Speeding alerts Swift Objective C import Foundation import UIKit import MapboxVision import MapboxVisionSafety /** * ""Over speeding"" example demonstrates how to utilize events from MapboxVisionSafetyManager to alert a user about exceeding allowed speed limit. */ class OverSpeedingViewController: UIViewController { private var videoSource: CameraVideoSource! private var visionManager: VisionManager! private var visionSafetyManager: VisionSafetyManager! private let visionViewController = VisionPresentationViewController() private var alertView: UIView! private var vehicleState: VehicleState? private var restrictions: RoadRestrictions? override func viewDidLoad() { super.viewDidLoad() addVisionView() addAlertView() // create a video source obtaining buffers from camera module videoSource = CameraVideoSource() videoSource.add(observer: self) // create VisionManager with video source visionManager = VisionManager.create(videoSource: videoSource) // create VisionSafetyManager and register as its delegate to receive safety related events visionSafetyManager = VisionSafetyManager.create(visionManager: visionManager, delegate: self) } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) visionManager.start(delegate: self) videoSource.start() } override func viewDidDisappear(_ animated: Bool) { super.viewDidDisappear(animated) videoSource.stop() visionManager.stop() // free up resources by destroying modules when they're not longer used visionSafetyManager.destroy() } private func addVisionView() { addChild(visionViewController) view.addSubview(visionViewController.view) visionViewController.didMove(toParent: self) } private func addAlertView() { alertView = UIImageView(image: UIImage(named: ""alert"")) alertView.isHidden = true alertView.translatesAutoresizingMaskIntoConstraints = false view.addSubview(alertView) NSLayoutConstraint.activate([ alertView.topAnchor.constraint(equalToSystemSpacingBelow: view.topAnchor, multiplier: 1), view.trailingAnchor.constraint(equalToSystemSpacingAfter: alertView.trailingAnchor, multiplier: 1) ]) } } extension OverSpeedingViewController: VisionManagerDelegate, VisionSafetyManagerDelegate { func visionManager(_ visionManager: VisionManager, didUpdateVehicleState vehicleState: VehicleState) { DispatchQueue.main.async { [weak self] in // save the latest state of the vehicle self?.vehicleState = vehicleState } } func visionSafetyManager(_ visionSafetyManager: VisionSafetyManager, didUpdateRoadRestrictions roadRestrictions: RoadRestrictions) { DispatchQueue.main.async { [weak self] in // save currenly applied road restrictions self?.restrictions = roadRestrictions } } func visionManagerDidCompleteUpdate(_ visionManager: VisionManager) { DispatchQueue.main.async { [weak self] in // when update is completed all the data has the most current state guard let state = self?.vehicleState, let restrictions = self?.restrictions else { return } // decide whether speed limit is exceeded by comparing it with the current speed let isOverSpeeding = state.speed > restrictions.speedLimits.speedLimitRange.max self?.alertView.isHidden = !isOverSpeeding } } } extension OverSpeedingViewController: VideoSourceObserver { public func videoSource(_ videoSource: VideoSource, didOutput videoSample: VideoSample) { DispatchQueue.main.async { [weak self] in // display received sample buffer by passing it to presentation controller self?.visionViewController.present(sampleBuffer: videoSample.buffer) } } } Copy Was this page helpful? Yes No",Speeding alerts,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,font stack,A font stack is a collection of fonts that belong to an individual layer within a style.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"font stack A font stack is an ordered list of fonts containing a primary font and optional fallback font(s), as defined within a layer. Within a font stack is a combination of primary and fallback fonts that defines the order in which the renderer should try to find the characters used within the layer. If the renderer cannot find a character within the first font stack, then it will try to use the next one until it can find a font with that character. A style object itself does not have a main font stack. Rather, individual layers have their own font stacks that are defined within the text-font property of a symbol layer, as detailed in the Mapbox Style Specification. You can manage the font stacks used within a style to improve rendering time and reduce the size of an offline map. Was this page helpful? Yes No",font stack,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,MBTiles,MBTiles is a file format for storing tilesets.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"MBTiles MBTiles is a file format for storing tilesets. It's designed so that you can package the potentially thousands of files that make up a tileset and move them around, eventually uploading to Mapbox or using in a web or mobile application. MBTiles is an open specification and is based on the SQLite database. MBTiles can contain raster or vector tilesets. You can export Mapbox Studio Classic sources in MBTiles format to upload directly to Mapbox Studio. See the Mapbox Studio manual uploads page for details. Below is a sample MBTiles file for reference. Download sample MBTiles Was this page helpful? Yes No",MBTiles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Troubleshoot raster image with black background,Learn how to fix raster images that display black backgrounds.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Troubleshoot raster image with black background Sometimes raster image uploads appear with a black background where you would expect there to be transparency. These black pixels often exist around the edges of the image as shown below. Drought Shrinks Australia's Lake Eucumbene. NASA Visible Earth. May 2007. www.earthobservatory.nasa.gov/ Why black backgrounds appear The black background that appears is the part of the raster image that does not contain any data. Generally a raster image is a rectangular grid of pixels. When you are working with data that is not rectangular, there are pixels within the grid that don't contain any data. These pixels are expressed as NoData values and represent the absence of data. GeoTIFFs that are uploaded to Mapbox Studio are displayed as JPEG to save space and make maps load quickly. Since JPEG cannot display transparency, NoData values appear black. It's not possible to change the appearance of NoData values within Mapbox Studio, but there are two strategies you can use to resolve the issue outside of Mapbox Studio. First, you can use Mapbox GL JS to retrieve a PNG instead of a JPEG. If that doesn't work, you can edit the original image using Rasterio. Note If you do not see a black background on Chrome, but do see one on other browsers (Firefox, IE, Opera, etc.), this is because Chrome supports the WebP image format. Our services will use this more efficient format if browser support is detected at runtime. Change the way you retrieve the image When you use your style in a Mapbox GL JS application, you can dynamically add the tiles to the style as a raster source and specify that it be encoded as PNG instead of JPEG. Since the PNG format supports transparency, if your GeoTIFF was exported with the correct NoData values they should appear transparent. Once you have initialized your map, add the following code to add the raster source to your map: map.on('load', function() { map.addLayer( { id: 'raster-layer', type: 'raster', source: { type: 'raster', tiles: ['https://api.mapbox.com/v4/ { tileset_id } / { z } / { x } / { y } .png?access_token= YOUR_MAPBOX_ACCESS_TOKEN '], } , minzoom: 0, maxzoom: 22 } ); } ); After adding the above code, view your map in the browser and check if those changes resolved the transparency issue. If you are still seeing the black background, make sure that your GeoTIFF was initially exported with the correct NoData values by following the process outlined below. Edit the original image You can edit the original GeoTIFF using a tool called Rasterio. Rasterio is used to read and write raster datasets. First, run the following command, and compress the image using a lossless data compression method called LZW: rio calc ""(asarray (take a 1) (take a 2) (take a 3))"" --co compress=lzw --co tiled=true --co blockxsize=256 --co blockysize=256 --name a=filename.tif filename255.tif Next, run this command to set NoData values to zero: rio edit-info --nodata 0 filename255.tif Note For more information on Rasterio, read the Rasterio documentation on GitHub Once you do this, upload your new filename255.tif file. See the image below for an example of the expected result. If you continue to see a black background after following the above steps, please contact support and attach your original GeoTIFF for further troubleshooting. Was this page helpful? Yes No",Troubleshoot raster image with black background,,,,,,,,,,,,,Why black backgrounds appear,Change the way you retrieve the image,Edit the original image,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,First steps with the Mapbox Maps SDK for iOS,"Walk through installing the Mapbox Maps SDK for iOS, getting a map on the screen, and placing a pin on it.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,Swift,,"beginner Swift, Objective-C First steps with the Mapbox Maps SDK for iOS Prerequisite Familiarity with Xcode and either Swift or Objective-C, and completion of the Mapbox Maps SDK for iOS installation guide. The Mapbox Maps SDK for iOS is our vector maps library for iOS. This guide will show you how to work with the Maps SDK for iOS, including how to customize your map, add markers with callouts, and display your user’s location on a map. Getting started Before you begin, install the Mapbox Maps SDK for iOS by following our installation guide. You can integrate the Mapbox Maps SDK for iOS using a dependency manager such as Carthage or CocoaPods, or you can install the SDK manually. After you complete the installation flow, your view controller should look like the one below if you chose the “Add with code” option. If you selected the “Add with Storyboard” option during the installation process, you will need to connect your MGLMapView to an IBOutlet so it is accessible within your view controller to continue with this guide. swift objective-c import UIKit import Mapbox class FirstStepsTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 40.74699, longitude: -73.98742), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.styleURL = MGLStyle.satelliteStyleURL // Add a point annotation let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 40.77014, longitude: -73.97480) annotation.title = ""Central Park"" annotation.subtitle = ""The biggest park in New York City!"" mapView.addAnnotation(annotation) // Set the map view's delegate mapView.delegate = self // Allow the map view to display the user's location mapView.showsUserLocation = true } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { let camera = MGLMapCamera(lookingAtCenter: annotation.coordinate, fromDistance: 4500, pitch: 15, heading: 180) mapView.fly(to: camera, withDuration: 4, peakAltitude: 3000, completionHandler: nil) } } Copy Change the map style To change your map style, set the MGLMapView.styleURL property to a style URL. This style URL can be any one of our beautiful template or designer styles, or you can create your own completely custom style in Mapbox Studio. The MGLStyle class also provides a set of convenience methods that return the style URLs of default Mapbox styles. For this guide, you will be using the Mapbox Satellite Streets style. Set the MGLMapView.styleURL property to the URL for this style using the provided convenience method, satelliteStreetsStyleURL. swift objective-c import UIKit import Mapbox class FirstStepsTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 40.74699, longitude: -73.98742), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.styleURL = MGLStyle.satelliteStyleURL // Add a point annotation let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 40.77014, longitude: -73.97480) annotation.title = ""Central Park"" annotation.subtitle = ""The biggest park in New York City!"" mapView.addAnnotation(annotation) // Set the map view's delegate mapView.delegate = self // Allow the map view to display the user's location mapView.showsUserLocation = true } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { let camera = MGLMapCamera(lookingAtCenter: annotation.coordinate, fromDistance: 4500, pitch: 15, heading: 180) mapView.fly(to: camera, withDuration: 4, peakAltitude: 3000, completionHandler: nil) } } Copy Then run your application to see the map's new style. Add a marker to the map There are many ways to add a marker, also called an annotation, to your map. MGLPointAnnotation provides the simplest way to add a predefined point style to your map. Your viewDidLoad method should look like the code below to place a point annotation on Central Park within New York City. swift objective-c import UIKit import Mapbox class FirstStepsTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 40.74699, longitude: -73.98742), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.styleURL = MGLStyle.satelliteStyleURL // Add a point annotation let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 40.77014, longitude: -73.97480) annotation.title = ""Central Park"" annotation.subtitle = ""The biggest park in New York City!"" mapView.addAnnotation(annotation) // Set the map view's delegate mapView.delegate = self // Allow the map view to display the user's location mapView.showsUserLocation = true } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { let camera = MGLMapCamera(lookingAtCenter: annotation.coordinate, fromDistance: 4500, pitch: 15, heading: 180) mapView.fly(to: camera, withDuration: 4, peakAltitude: 3000, completionHandler: nil) } } Copy Run your application and notice the new point annotation added. MGLPointAnnotation is the base class of all point annotations and can be additionally configured to use views or static images in place of the default annotation style. Read the documentation for MGLAnnotationView and MGLAnnotationImage for more information about working with these types of annotations. If you want to add a large number of points to a map, consider using runtime styling, which is another feature of the Mapbox Maps SDK for iOS geared towards creating rich data visualizations. For more information about the different ways to add points to a map and the differences between each approach, read our Markers and annotations guide. Add a callout To get the annotation to display a callout when a user taps on it, the view controller will need to conform to the MGLMapViewDelegate protocol to use the delegate methods MGLMapViewDelegate provides. Once the view controller conforms to the MGLMapViewDelegate protocol and the map view's delegate is set to the view controller itself, you can then implement the -mapView:annotationCanShowCallout: delegate method. This makes sure that the map view knows that an annotation should display a callout when tapped. The full implementation of this is shown below: swift objective-c import UIKit import Mapbox class FirstStepsTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 40.74699, longitude: -73.98742), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.styleURL = MGLStyle.satelliteStyleURL // Add a point annotation let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 40.77014, longitude: -73.97480) annotation.title = ""Central Park"" annotation.subtitle = ""The biggest park in New York City!"" mapView.addAnnotation(annotation) // Set the map view's delegate mapView.delegate = self // Allow the map view to display the user's location mapView.showsUserLocation = true } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { let camera = MGLMapCamera(lookingAtCenter: annotation.coordinate, fromDistance: 4500, pitch: 15, heading: 180) mapView.fly(to: camera, withDuration: 4, peakAltitude: 3000, completionHandler: nil) } } Copy Copy Run the application, and then try to tap the annotation — it now displays a callout with your annotation's title and subtitle when tapped! Zoom to a marker To center the map on the tapped marker, start by implementing the -mapView:didSelectAnnotation: delegate method. When the delegate method is called, initialize a new MGLMapCamera, which is the map's field of view. After creating the MGLMapCamera, call the -setCamera:animated: method on the MGLMapView to set the map's viewport to the new camera, which will be centered on the annotation's coordinate at a specified distance above ground level. swift objective-c import UIKit import Mapbox class FirstStepsTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 40.74699, longitude: -73.98742), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.styleURL = MGLStyle.satelliteStyleURL // Add a point annotation let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 40.77014, longitude: -73.97480) annotation.title = ""Central Park"" annotation.subtitle = ""The biggest park in New York City!"" mapView.addAnnotation(annotation) // Set the map view's delegate mapView.delegate = self // Allow the map view to display the user's location mapView.showsUserLocation = true } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { let camera = MGLMapCamera(lookingAtCenter: annotation.coordinate, fromDistance: 4500, pitch: 15, heading: 180) mapView.fly(to: camera, withDuration: 4, peakAltitude: 3000, completionHandler: nil) } } Display the user’s location If you haven't configured location permissions already, you will need to do so to use the device's location services. Before you can draw a user’s location on the map, you must ask for their permission and give a brief explanation of how your application will use their location data. Configure location permissions by setting the NSLocationWhenInUseUsageDescription key in the Info.plist file. We recommend setting the value to the following string which is the application's location usage description: Shows your location on the map and helps improve OpenStreetMap. Additionally, you may also choose to include the NSLocationAlwaysAndWhenInUseUsageDescription within your Info.plist file. We recommend providing a different string when using this key to help your users decide which level of permission they wish to grant to your application. When a user opens your application for the first time, they will be presented with an alert that asks them if they would like to allow your application to access their location. Note If your application targets iOS 10 or below, you may also include the `NSLocationAlwaysUsageDescription` key your application. Note that this key is ignored in iOS 11. Once you have configured your application's location permissions, display the device's current location on the map by setting the showsUserLocation property on the map view to true. swift objective-c import UIKit import Mapbox class FirstStepsTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 40.74699, longitude: -73.98742), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.styleURL = MGLStyle.satelliteStyleURL // Add a point annotation let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 40.77014, longitude: -73.97480) annotation.title = ""Central Park"" annotation.subtitle = ""The biggest park in New York City!"" mapView.addAnnotation(annotation) // Set the map view's delegate mapView.delegate = self // Allow the map view to display the user's location mapView.showsUserLocation = true } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { let camera = MGLMapCamera(lookingAtCenter: annotation.coordinate, fromDistance: 4500, pitch: 15, heading: 180) mapView.fly(to: camera, withDuration: 4, peakAltitude: 3000, completionHandler: nil) } } Copy Simulating a location When you run your app in Simulator, you’ll be presented with a dialog box asking for permission to use Location Services. Click Allow. You won’t see your location on the map until you go to Simulator’s menu bar and select Debug ‣ Location ‣ Custom Location. Enter 40.74699 for latitude, -73.98742 for longitude, and you’re right outside Central Park in New York City! Finished product swift objective-c import UIKit import Mapbox class FirstStepsTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 40.74699, longitude: -73.98742), zoomLevel: 9, animated: false) view.addSubview(mapView) mapView.styleURL = MGLStyle.satelliteStyleURL // Add a point annotation let annotation = MGLPointAnnotation() annotation.coordinate = CLLocationCoordinate2D(latitude: 40.77014, longitude: -73.97480) annotation.title = ""Central Park"" annotation.subtitle = ""The biggest park in New York City!"" mapView.addAnnotation(annotation) // Set the map view's delegate mapView.delegate = self // Allow the map view to display the user's location mapView.showsUserLocation = true } func mapView(_ mapView: MGLMapView, annotationCanShowCallout annotation: MGLAnnotation) -> Bool { // Always allow callouts to popup when annotations are tapped. return true } func mapView(_ mapView: MGLMapView, didSelect annotation: MGLAnnotation) { let camera = MGLMapCamera(lookingAtCenter: annotation.coordinate, fromDistance: 4500, pitch: 15, heading: 180) mapView.fly(to: camera, withDuration: 4, peakAltitude: 3000, completionHandler: nil) } } Copy Next steps You built a small app with the Mapbox Maps SDK for iOS! You added a Mapbox map to an iOS application, changed the map style, placed an annotation on your map, and displayed the user’s location on it. Way to go! As you continue to develop your Mapbox app, we recommend that you read the following: Mapbox Maps SDK for iOS homepage for general information about working with the Mapbox Maps SDK for iOS. Mapbox Maps SDK for iOS documentation for a complete reference of all classes and methods available. Mapbox Maps SDK for iOS code examples to see classes and methods in action. Mapbox GL Native on GitHub to read about the open source project behind the Mapbox Maps SDK for iOS. Was this page helpful? Yes No",First steps with the Mapbox Maps SDK for iOS,Objective-C,,,,,,,,,,,,Getting started,Change the map style,Add a marker to the map,Add a callout,Zoom to a marker,Display the user’s location,Simulating a location,Finished product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Mapbox GL JS usage playground,"Interact with a Mapbox GL JS map to understand the relationship between billing units including map loads, map views, and tile requests.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,playground,,,"Mapbox GL JS usage playground Interact with the map below to understand these three different usage units: Map loads Mapbox GL JS v1.0.0+ A map load occurs whenever a Mapbox GL JS Map object is initialized on a webpage and you request a Mapbox-hosted map tile. Additional user interactions, such as panning and zooming, do not incur additional map loads. This means that people who are using your web map can toggle additional sources on and off, interact with the map, and toggle between styles without affecting your usage. The maximum session length for a map load is 12 hours, meaning a user can have a browser open with continuous map interactions that all count towards the same map load during a consecutive 12 hour window. After 12 hours of continuous map interactions, a new map load is triggered. Vector Tiles API requests Mapbox GL JS < v1.0.0 The Mapbox Vector Tiles API serves vector tiles. Each API request results in a single tile from a vector tileset. Vector Tiles API requests are typically made as a series of requests used to render a map using a Mapbox GL map library. Map views Deprecated Map views are a deprecated usage unit that used to be used to track map usage for Mapbox products. For maps using Mapbox GL JS, a map view was equal to four Vector Tiles API tile requests.",Mapbox GL JS usage playground,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Unity,Unity,Attribution,Learn how to add attribution to Unity applications that use the Mapbox Maps SDK for Unity.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Attribution You must include the Mapbox wordmark and attribution notice on any map that uses the Mapbox Maps SDK for Unity. We provide an Attribution prefab that includes all required information and can be customized via uGUI. You may adjust the position of the Mapbox wordmark and attribution notice, but they must stay visible on the map. You may also change the background and text color of the attribution notice to match your design aesthetics, but all information must be legible. You may not otherwise alter the Mapbox wordmark or text attribution notice. If you wish to otherwise move or remove the Mapbox wordmark, please contact our sales team to discuss options available under our Enterprise plans. Read more about how attribution works. Was this page helpful? Yes No",Attribution,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Mapbox offline tile count estimator,Estimate the number of tiles required to download an offline region using the Mapbox Maps SDK for Android and iOS.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,playground,,,"Mapbox offline tile count estimator Use this tool to estimate the number of tiles required to download an offline region using the Mapbox Maps SDK for Android and iOS. Note that default Mapbox vector sources extend to z16. At higher zoom levels, existing vector data can be scaled up or “overzoomed” efficiently with minimal loss of detail.",Mapbox offline tile count estimator,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Change map text to device language,Use the plugin to automatically change map label text to the language set on the device.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Change map text to device language Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" app:mapbox_cameraTargetLat=""35.830744"" app:mapbox_cameraTargetLng=""136.711369"" app:mapbox_cameraZoom=""4.5257"" /> <androidx.constraintlayout.widget.ConstraintLayout android:layout_width=""match_parent"" android:layout_height=""wrap_content""> <androidx.cardview.widget.CardView android:id=""@+id/language_one_cardview"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginTop=""8dp"" android:backgroundTint=""@color/mapboxOrangeDark"" app:layout_constraintEnd_toStartOf=""@+id/language_two_cardview"" app:layout_constraintHorizontal_bias=""0.5"" app:layout_constraintStart_toStartOf=""parent"" app:layout_constraintTop_toBottomOf=""parent""> <TextView android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_margin=""16dp"" android:text=""@string/arabic"" android:textColor=""@color/mapboxWhite"" /> </androidx.cardview.widget.CardView> <androidx.cardview.widget.CardView android:id=""@+id/language_two_cardview"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:backgroundTint=""@color/mapboxPurpleDark"" app:layout_constraintEnd_toStartOf=""@+id/language_three_cardview"" app:layout_constraintHorizontal_bias=""0.5"" app:layout_constraintStart_toEndOf=""@+id/language_one_cardview"" app:layout_constraintTop_toTopOf=""@id/language_one_cardview""> <TextView android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_margin=""16dp"" android:text=""@string/russian"" android:textColor=""@color/mapboxWhite"" /> </androidx.cardview.widget.CardView> <androidx.cardview.widget.CardView android:id=""@+id/language_three_cardview"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:backgroundTint=""@color/mapboxGreenDark"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintHorizontal_bias=""0.5"" app:layout_constraintStart_toEndOf=""@+id/language_two_cardview"" app:layout_constraintTop_toTopOf=""@id/language_two_cardview""> <TextView android:layout_width=""match_parent"" android:layout_height=""match_parent"" android:layout_margin=""16dp"" android:text=""@string/chinese"" android:textColor=""@color/mapboxWhite"" /> </androidx.cardview.widget.CardView> </androidx.constraintlayout.widget.ConstraintLayout> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/match_map_to_device_language"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom|right"" android:layout_marginBottom=""16dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" app:layout_constraintBottom_toBottomOf=""parent"" app:layout_constraintEnd_toEndOf=""parent"" app:srcCompat=""@drawable/ic_swap_horiz_white_24dp"" mapbox:fabSize=""small"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.os.Bundle; import androidx.annotation.NonNull; import com.google.android.material.snackbar.Snackbar; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.plugins.localization.LocalizationPlugin; import com.mapbox.mapboxsdk.plugins.localization.MapLocale; /** * Use the localization plugin to retrieve the device's language and set all map text labels to that language. */ public class LocalizationPluginActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private LocalizationPlugin localizationPlugin; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_localization_plugin); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { localizationPlugin = new LocalizationPlugin(mapView, mapboxMap, style); findViewById(R.id.language_one_cardview).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { localizationPlugin.setMapLanguage(MapLocale.ARABIC); } }); findViewById(R.id.language_two_cardview).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { localizationPlugin.setMapLanguage(MapLocale.RUSSIAN); } }); findViewById(R.id.language_three_cardview).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { localizationPlugin.setMapLanguage(MapLocale.SIMPLIFIED_CHINESE); } }); findViewById(R.id.match_map_to_device_language).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Snackbar.make(view, R.string.change_device_language_instruction, Snackbar.LENGTH_LONG).show(); try { localizationPlugin.matchMapLanguageWithDeviceDefault(); mapboxMap.animateCamera(CameraUpdateFactory .newCameraPosition(new CameraPosition.Builder() .target(new LatLng(34.032666, -80.363160)) .zoom(2.038777) .build()), 1000); } catch (RuntimeException exception) { Snackbar.make(view, exception.toString(), Snackbar.LENGTH_LONG).show(); } } }); Toast.makeText(LocalizationPluginActivity.this, R.string.instruction_description, Toast.LENGTH_LONG).show(); } }); } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Change map text to device language,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,source,A source supplies data to be shown on maps that use Mapbox GL.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"source A source supplies data that Mapbox GL displays on a map. Sources are defined by the Mapbox Style Specification, and are used with style layers to visually represent the source data on to a map. Specific source types may not be supported depending on which platform you're developing on, so refer to platform-specific documentation when adding sources to your map. Was this page helpful? Yes No",source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display driving directions,Use the mapbox-gl-directions plugin to show results from the Mapbox Directions API. Click the map to add an origin and destination.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Display driving directions Use the mapbox-gl-directions plugin to show results from the Mapbox Directions API. Click the map to add an origin and destination. Was this example helpful? Yes No,Display driving directions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Leaflet,Leaflet is an open source web mapping library that forms the basis of Mapbox.js.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"Leaflet Leaflet is an open source web mapping library that forms the basis of Mapbox.js. It's software that works on webpages and makes interactive maps possible. Leaflet requests tiles from servers like Mapbox, displays and animates them, and supports other overlays. Was this page helpful? Yes No",Leaflet,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,NavigationView with Fragment,NavigationView implemented with Fragment.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"NavigationView with Fragment Activity View on GitHub package com.mapbox.services.android.navigation.testapp.activity.navigationui.fragment; import android.content.Context; import android.content.SharedPreferences; import android.location.Location; import android.os.Bundle; import android.preference.PreferenceManager; import android.support.annotation.NonNull; import android.support.annotation.Nullable; import android.support.v4.app.Fragment; import android.support.v4.app.FragmentActivity; import android.support.v7.app.AppCompatDelegate; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.geojson.Point; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.services.android.navigation.testapp.R; import com.mapbox.services.android.navigation.testapp.activity.navigationui.SimplifiedCallback; import com.mapbox.services.android.navigation.ui.v5.NavigationView; import com.mapbox.services.android.navigation.ui.v5.NavigationViewOptions; import com.mapbox.services.android.navigation.ui.v5.OnNavigationReadyCallback; import com.mapbox.services.android.navigation.ui.v5.listeners.NavigationListener; import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute; import com.mapbox.services.android.navigation.v5.routeprogress.ProgressChangeListener; import com.mapbox.services.android.navigation.v5.routeprogress.RouteProgress; import retrofit2.Call; import retrofit2.Response; public class NavigationFragment extends Fragment implements OnNavigationReadyCallback, NavigationListener, ProgressChangeListener { private static final double ORIGIN_LONGITUDE = -3.714873; private static final double ORIGIN_LATITUDE = 40.397389; private static final double DESTINATION_LONGITUDE = -3.712331; private static final double DESTINATION_LATITUDE = 40.401686; private NavigationView navigationView; private DirectionsRoute directionsRoute; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.navigation_view_fragment_layout, container, false); } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); updateNightMode(); navigationView = view.findViewById(R.id.navigation_view_fragment); navigationView.onCreate(savedInstanceState); navigationView.initialize(this); } @Override public void onStart() { super.onStart(); navigationView.onStart(); } @Override public void onResume() { super.onResume(); navigationView.onResume(); } @Override public void onSaveInstanceState(@NonNull Bundle outState) { navigationView.onSaveInstanceState(outState); super.onSaveInstanceState(outState); } @Override public void onViewStateRestored(@Nullable Bundle savedInstanceState) { super.onViewStateRestored(savedInstanceState); if (savedInstanceState != null) { navigationView.onRestoreInstanceState(savedInstanceState); } } @Override public void onPause() { super.onPause(); navigationView.onPause(); } @Override public void onStop() { super.onStop(); navigationView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); navigationView.onLowMemory(); } @Override public void onDestroyView() { super.onDestroyView(); navigationView.onDestroy(); } @Override public void onNavigationReady(boolean isRunning) { Point origin = Point.fromLngLat(ORIGIN_LONGITUDE, ORIGIN_LATITUDE); Point destination = Point.fromLngLat(DESTINATION_LONGITUDE, DESTINATION_LATITUDE); fetchRoute(origin, destination); } @Override public void onCancelNavigation() { navigationView.stopNavigation(); stopNavigation(); } @Override public void onNavigationFinished() { // no-op } @Override public void onNavigationRunning() { // no-op } @Override public void onProgressChange(Location location, RouteProgress routeProgress) { boolean isInTunnel = routeProgress.inTunnel(); boolean wasInTunnel = wasInTunnel(); if (isInTunnel) { if (!wasInTunnel) { updateWasInTunnel(true); updateCurrentNightMode(AppCompatDelegate.MODE_NIGHT_YES); } } else { if (wasInTunnel) { updateWasInTunnel(false); updateCurrentNightMode(AppCompatDelegate.MODE_NIGHT_AUTO); } } } private void updateNightMode() { if (wasNavigationStopped()) { updateWasNavigationStopped(false); AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_AUTO); getActivity().recreate(); } } private void fetchRoute(Point origin, Point destination) { NavigationRoute.builder(getContext()) .accessToken(Mapbox.getAccessToken()) .origin(origin) .destination(destination) .build() .getRoute(new SimplifiedCallback() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { directionsRoute = response.body().routes().get(0); startNavigation(); } }); } private void startNavigation() { if (directionsRoute == null) { return; } NavigationViewOptions options = NavigationViewOptions.builder() .directionsRoute(directionsRoute) .shouldSimulateRoute(true) .navigationListener(NavigationFragment.this) .progressChangeListener(this) .build(); navigationView.startNavigation(options); } private void stopNavigation() { FragmentActivity activity = getActivity(); if (activity != null && activity instanceof FragmentNavigationActivity) { FragmentNavigationActivity fragmentNavigationActivity = (FragmentNavigationActivity) activity; fragmentNavigationActivity.showPlaceholderFragment(); fragmentNavigationActivity.showNavigationFab(); updateWasNavigationStopped(true); updateWasInTunnel(false); } } private boolean wasInTunnel() { Context context = getActivity(); SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context); return preferences.getBoolean(context.getString(R.string.was_in_tunnel), false); } private void updateWasInTunnel(boolean wasInTunnel) { Context context = getActivity(); SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context); SharedPreferences.Editor editor = preferences.edit(); editor.putBoolean(context.getString(R.string.was_in_tunnel), wasInTunnel); editor.apply(); } private void updateCurrentNightMode(int nightMode) { AppCompatDelegate.setDefaultNightMode(nightMode); getActivity().recreate(); } private boolean wasNavigationStopped() { Context context = getActivity(); SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context); return preferences.getBoolean(getString(R.string.was_navigation_stopped), false); } public void updateWasNavigationStopped(boolean wasNavigationStopped) { Context context = getActivity(); SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context); SharedPreferences.Editor editor = preferences.edit(); editor.putBoolean(getString(R.string.was_navigation_stopped), wasNavigationStopped); editor.apply(); } } Copy Was this page helpful? Yes No",NavigationView with Fragment,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Upload data to Mapbox,"Learn how to prepare data for upload, interpret error messages, and troubleshoot failed uploads.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Upload data to Mapbox Beta feature: Upload vector tilesets with the Tilesets API The Mapbox Tilesets API has several beta endpoints that allow you to create custom vector tilesets. You can use these endpoints as an alternative to the Uploads API for tiling vector data using custom configuration rules. While these endpoints are in beta, they are subject to potential changes. If you want to upload your data to Mapbox, you've come to the right place! From GeoTIFFs to Shapefiles, whether you want to edit your data or style it on a map, this guide outlines the different types of data you can upload, techniques for uploading, and common pitfalls and how to troubleshoot them. Datasets vs. tilesets Datasets and tilesets are two different types of files that you can create when uploading data to your Mapbox account. Datasets provide access to feature geometries (points, lines, and polygons) and properties (attributes), both of which can be edited in the Mapbox Studio dataset editor or through the Mapbox Datasets API. Tilesets are lightweight collections of vector data that are optimized for rendering and are not editable but can be styled in the Mapbox Studio style editor. Uploads Techniques for uploading datasets and tilesets are listed below. The size of your data file will affect how much can be transferred at one time. See the section on transfer limits to know which method is right for you. Datasets To add your data to a dataset, you can create a new, blank dataset through Mapbox Studio or through the Mapbox Datasets API and then add data to it. Note that the Mapbox Datasets API does not date GeoJSON files as uploads, but rather as the body of a POST request. See the Mapbox Datasets API documentation for more information. Tilesets You can upload your data as a tileset through: The Mapbox Studio style editor Your tilesets page in Mapbox Studio The Mapbox Uploads API Accepted file types and transfer limits The accepted file types and transfer limits for dataset and tileset uploads include: File type Datasets Tilesets Transfer limits CSV 5 Mb for datasets, 1 GB for tilesets GeoJSON 5 Mb for datasets, 1 GB for tilesets MBTiles 25 GB KML 260 Mb with 15 layers or fewer GPX 260 Mb Shapefile 260 Mb (combined uncompressed size of .shp and .dbf files). You must upload shapefiles as a compressed (.zip) file. GeoTIFF 10 GB If your file size exceeds these limits, see the Troubleshooting section below. Dataset and dataset editor limits An extra note on dataset uploads: Multiple files can be uploaded to the same dataset without limit — they need to be loaded 5 MB at a time in the Mapbox Studio dataset editor. The size of a dataset is unlimited, but the Mapbox Studio dataset editor can only display datasets of 20 MB or smaller. Datasets that exceed 20 MB can still be downloaded from Mapbox Studio and accessed through the Mapbox Datasets API. Raster tilesets in Mapbox Studio When uploading raster MBTiles to Mapbox Studio, be sure to use 512x512 tiles. TIFF uploads There are a couple requirements for TIFFs: Only 8-bit GeoTIFFs are supported. Run gdalinfo to find your GeoTIFF's resolution. Mapbox only accepts TIFFs with georeferencing information (GeoTIFFs). Make sure your TIFF is georeferenced before trying to upload. If you are attempting to upload large TIFFs (multi GBs), here are some ways you can optimize your TIFF before uploading: Reproject to Web Mercator EPSG:3857. Set blocksize to 256x256. If compression is needed, use LZW. Remove Alpha band, if applicable. Errors Upload failures directly in Mapbox Studio typically occur for two reasons: There's an explicit issue with your data. The data didn't process within one hour (two hours for MBTiles files). If there is an explicit issue with your data, you will receive a descriptive error message when the upload fails. Each message includes an error code that is described in full below. If your upload times out, read through the troubleshooting recommendations below. Tileset upload errors Message Description Solution Failed to find a shapefile in your zip You tried to upload a zipfile that did not include one of the files that make up a shapefile: .shp, .shx, .dbf, .prj. Make sure your zipfile contains each of these files. vector_layers must be an array of layer objects Your data source may not have any layers. Check your data source in QGIS or use ogr2ogr to make sure it is correct. Metadata exceeds limit of 60kb The TileJSON file in your MBTiles upload contains too much information. Remove extra or unneeded content from the TileJSON file (inside the MBTiles file). KML does not contain any layers. Your KML file is empty. Make sure you have some layers in your data that are readable. Here's an example of a valid KML file. X layers found. Maximum of X layers allowed. Your KML file has more than 15 layers. This can happen when combining many files into one. Make sure to split up your layers into different files before uploading to Mapbox Studio. If you must use KML and require all the layers, use kml-split, which breaks a KML into multiple files with fewer layers. Otherwise you can merge your layers into one and upload as either GeoJSON or a Shapefile. Tileset exceeds processing limit. Your MBTiles file has more items than the limit allows. Try adjusting & limiting your zoom levels. Dataset not found. It may have been deleted during processing into a tileset. The uploaded dataset was deleted during processing into a tileset. Try uploading the dataset again, and do not delete the dataset until the tileset processing has successfully completed. Tile exceeds maximum size of 500k at z { zoom level } . Reduce the detail of data at this zoom level or omit it by adjusting your minzoom. The size of a specific tile in the MBTiles file is too large. Reduce the detail of data at this zoom level or omit it by adjusting your minzoom. Grid exceeds maximum size of 500k at z { zoom level } . Reduce the detail of data at this zoom level or omit it by adjusting your minzoom. The size of the grid tile in the MBTiles file is too large. Reduce the detail of data at this zoom level or omit it by adjusting your minzoom. Failed to parse geojson feature Your GeoJSON file has invalid syntax. Make sure your GeoJSON is compliant with the GeoJSON specification. You can validate your GeoJSON with GeoJSON Lint. Error creating Mapnik Datasource: Invalid geojson Mapnik is unable to process the GeoJSON file, likely due to invalid syntax. Make sure your GeoJSON is compliant with the GeoJSON specification. You can validate your GeoJSON with the geojsonhint package. Coordinates beyond web mercator range. Please check projection and lat/lon values. The coordinates in your file are beyond the extend of Web Mercator. Check to see that your coordinates are in the correct order ([longitude, latitude]). Try visualizing your GeoJSON in geojson.net to see if geometries appear where you expect. If they do, try reprojecting to Web Mercator prior to uploading. Unknown filetype You have one of the following: - Bad TIFF files that are missing necessary information. - Invalid MBTiles where the MBTiles is not recognized as an SQLite database. - Invalid MBTiles table data where the MBTiles has data in the tile_data field of the tiles that does not represent a valid tile format (png, jpeg, or gzip compressed mapbox vector tile). - tmz2 files have been double zipped meaning the .zip process has been applied twice on the same file. - Try running gdalinfo to get more information. - Make sure your MBtiles file conforms the MBtiles specification. - Check that the file has only been zipped once. Tile size exceeds limit. At least one vector tile is larger than 5MB. While generating tiles from your upload, at least one tile was larger than 5MB, which is too large. Try simplifying your data where it is most dense. This typically happens with CSV point datasets where there are many millions of points in a single tile. Try using Tippecanoe to simplify and cluster points before uploading. Invalid tile based on the Mapbox Vector Tile spec: ClosePath command count is not 1 or Invalid tile based on the Mapbox Vector Tile spec: Max count too large One of the tiles in your MBTiles file is invalid according to the Mapbox Vector Tile Specification We need to make sure all vector tiles conform to the specification, so this makes sure any encoders are doing their job correctly. If you see this, please reach out to help@mapbox.com with the error message and we'll help you move forward. Dataset upload errors Most dataset upload errors are related to syntax. Be sure to check your data for syntax errors before uploading. If you are working with GeoJSON data, consider using a tool like geojsonhint to lint your data before uploading. If your error is specifically related to a CSV upload, you can view our CSV file errors troubleshooting guide or investigate further by checking out the library we use to convert CSV files to GeoJSON. Message Description Solution Input failed old-style crs member is not recommended Your dataset contains a crs attribute. Remove the crs attribute from your data before uploading. Input failed. Datasets don't support GeometryCollections or null geometries. Your dataset contains one or more GeometryCollections and/or a geometry that is set to null. GeometryCollections and null geometries are not supported and must be removed from your dataset. Troubleshooting If you receive a Processing timed out. message after a lengthy ""processing"" status, it is likely because your file has taken more than one hour (two hours for MBTiles files) to process and has timed out. To keep our upload queue fresh, we limit the time it takes for particularly large uploads. The following techniques can be used to update your data to improve processing time. Note: the troubleshooting advice here mostly relates to tilesets, although some may be applicable to datasets as well. If you are having trouble uploading datasets and your issue is not listed here, please contact support. Reproject to Web Mercator During upload processing, we reproject all geometries to Web Mercator (EPSG:3857) before encoding into vector tiles. During the vector tile encoding process, if your data isn't Web Mercator, each vertex must be reprojected during encoding, which can take a long time. We suggest reprojecting your data before uploading to skip this process and speed up your upload. Here's how you can reproject your data with open source tools: GDAL's ogr2ogr command line utility. The following example is how to convert a Shapefile to Web Mercator. ogr2ogr output.shp -t_srs ""EPSG:3857"" input.shp QGIS allows for reprojection - Right-click your layer -> Save As -> Select ""Web Mercator EPSG:3857"" as the output projection. Multipart to singlepart Multipart geometries can be complex – a single feature can be comprised of hundreds of thousands of polygons. These complex multipart geometries increase processing time and lead to timeouts. To improve processing speeds, you can break each polygon into its own unique feature (singlepart) using QGIS. This will reduce the complexity per feature and allow the data to process faster. Note that each individual singlepart feature will share the attributes of the original feature. Note that population: 100 is duplicated. If you plan on styling based on attributes such as this, be wary of splitting into singleparts! There are a couple of helpful tools for doing this: In QGIS you can use either the Vector -> Geometry Tools -> Multipart to singleparts or the Multipart Split plugin. If you are using GeoJSON and Node.js, you can use the geojson-flatten module. Simplification Simplifying your data means removing complexity in the vertices of your geometry. Each vertex must be translated to vector tile coordinates. The fewer vertices to translate, the faster processing becomes. Often you can simplify your data without any visual change. It's important to watch out for oversimplification, though! Oversimplifying could remove important granularity in your data as well as potentially create invalid geometries if lines begin overlapping. Simplification tools typically take a tolerance parameter to specify how much to simplify. Some tools to use for simplifying data: Tippecanoe QGIS vector simplification - Vector -> Geometry Tools -> Simplify geometries Mapshaper.org Turf.js simplify Limit large features Large features that span the entire dataset can slow down processing. For example, consider this dataset of Hawaii. It contains a handful of smaller polygons that represent the islands. It also contains a large polygon that represents the surrounding water. Since the bounding box of the water polygon will intersect with nearly all the tile boundaries (gray lines), the water polygon will need to be processed for nearly every tile within this tileset. There is no exact solution for this, since it largely depends on the dataset and how you plan to style and use the data. Some possible solutions include: Remove the large polygon if it's not necessary for your use case. Split the large polygon into smaller polygons: After creating a digitized layer of smaller polygons, use that digitized layer to intersect with the large polygon and split it into pieces. Then add the newly split feature into your original dataset. QGIS geometry intersection - Vector -> Geoprocessing Tools -> Intersection Caution: This could create unwanted polygon borders, depending on how you plan to style the dataset. Slice large contour datasets Large contour datasets can be particularly complex. Often they will have long, single feature linestrings wrapping across the entire dataset. Like the large polygons above, these can take a long time to process. We recommend using GRASS's v.split function via QGIS to break lines into shorter, equal segments. Smaller geometries will improve processing speed. If the contour data is highly detailed (as in, requires zoom 22) we recommend breaking lines every 5 kilometers. Generate tilestats for MBTiles We generate summary documents, known as tilestats, for uploads so Mapbox Studio can see what types of data and properties are in your spatial data. This takes quite a long time for large MBTiles files and can lead to timeouts. If you are using Tippecanoe to generate your MBTiles file you can bypass this step by using version 1.21.0 or later of Tippecanoe, which pre-generates a tilestats object. This can cut upload times in half. If you aren't using Tippecanoe, you can still use the tile-join operation provided by Tippecanoe to generate the tilestats document. Make sure to at least use version 1.22.0. tile-join -o with-tilestats.mbtiles original.mbtiles Was this page helpful? Yes No",Upload data to Mapbox,,Generate tilestats for MBTiles,,,,,,,,,,,Datasets vs. tilesets,Uploads,Datasets,Tilesets,Accepted file types and transfer limits,TIFF uploads,Errors,Tileset upload errors,Dataset upload errors,Troubleshooting,Reproject to Web Mercator,Multipart to singlepart,Simplification,Limit large features,Slice large contour datasets,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Integrate the Mapbox Visual with Microsoft Power BI,General configuration guidance and tips for using the Mapbox Visual in Microsoft Power BI.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Integrate the Mapbox Visual with Microsoft Power BI Supported Power BI environments and tools The Mapbox Visual for Microsoft Power BI is on version 1.2.4. This version works with the following Power BI environments and tools: PBI Report Server PBI Mobile (iOS/Android) PBI Embedded PBI Publish to Web PBI Desktop Chrome Firefox Safari Edge IE11 Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes Link your Mapbox access token in Power BI To use the Mapbox Visual in Microsoft Power BI, you need to link your Mapbox access token in Power BI: To get started with the Mapbox Visual in Microsoft Power BI, you need a Mapbox account and a Mapbox access token. You can find your Mapbox access tokens on your Account page. In Power BI, under the Mapbox Custom Visual Format panel, open the Viz Settings dropdown. Paste your Mapbox access token in the Access Token field. Use a custom Mapbox style in Power BI The Mapbox Visual for Power BI gives you access to several default Mapbox styles. You can also use a custom Mapbox that you have created in Mapbox Studio: In Mapbox Studio, find the style that you want to use. Click the Menu button. Click the icon next to the Style URL to copy it to your clipboard. You will need this URL to link to your custom map style in Power BI. Go to Power BI. Under the Mapbox Custom Visual Format panel, open the Viz Settings dropdown. In the Map Style field, select the Custom option. In the Style URL field, paste the style URL that you copied earlier. Format your location data to use in Power BI choropleth visualizations The Mapbox Visual for Power BI provides default support for creating choropleth visualizations at different administrative levels: Global countries US states US postal codes. When you add your own data to Power BI, the data must contain fields that match these administrative levels names and data types to create the data join. Data dropped into the Location field in the Mapbox Visual must match a row in the Name matches file exactly to be included visually on your map. The following data are supported in the Mapbox Visual for Power BI: Administrative level Data type Capitalization Examples Notes Exceptions Global countries text Capitalize the first letter of each word; all other letters must be lowercase. South Africa • Use United Kingdom rather than the individual country names England, Scotland, Wales, or Northern Ireland. • Use a country's name rather than its abbreviation (for example, United Arab Emirates, not UAE), except for USA, as noted in this table's Exceptions column. Use USA rather than United States or United States of America. US states text Capitalize the first letter of each word; all other letters must be lowercase. New Jersey, New Hampshire — — US postal codes ZCTA 5-digit text string Not applicable 94110 When you import data as a CSV file, Power BI will automatically cut the leading ""0"" off any zip codes beginning with ""0"". To fix this, change the zip code field type to ""Text"" before the data is imported. Changing it to text after the data is imported will not fix the issue. — Style dimensional values with the Data Colors feature If you format your data so that the values in categorical (dimension) field are text, you can style these dimensional values using the Data Colors feature. The Power BI interface hides this feature until you have met the following data and format conditions. To access the Data Colors feature: Format your data and import it into Power BI. The values in the dimensional field you want to use must be formatted as text. Begin creating your Power BI report as usual, and add the Mapbox Visual. Drag your dimensional field from the Fields panel into the Color shelf. The Data Colors dropdown menu will appear in the Format panel. Select your desired colors for each text value. You can also use the Data Colors field to style your choropleth visualizations in Power BI: Format your data and import it into Power BI. The values in the dimensional field you want to use must be formatted as text. Begin creating your Power BI report as usual, and add the Mapbox Visual. Make sure that the data you drop into the Location field in the Mapbox Visual exactly matches the data in a default Mapbox Visual dataset (see the Format your location data to use in Power BI section). Drag your dimensional field from the Fields panel into the Color shelf. Go back to the Format tab. Switch the Circle option off and turn the Choropleth option on. The Data Colors dropdown menu will appear. Select your desired colors for each text value. Resolve blank map issues in Power BI If a map that you created with the Mapbox Visual for Power BI does not display, this can likely be traced to one of the following issues: No GPU. If your map does not display and you are using Power BI Desktop, this likely means that the machine does not have a graphics processing unit (GPU). The Mapbox custom visual for Power BI uses Mapbox GL, which requires a GPU to do client-side rendering, This is a common case when Power BI Desktop is running on a virtual machine. Mapbox GL needs access to the GPU, and virtual machines don't generally have access to the GPU without hardware acceleration enabled. Check to see if you have hardware acceleration enabled on the virtual machine — if not, you will need to enable it. Cache needs to be cleared. If your map does not display in Power BI Web or Power BI Desktop, either the browser cache or the Power BI Desktop cache may need to be cleared. This can happen due to occasional problems with the Power BI marketplace. To clear the Power BI Desktop cache, delete the contents of the following folders: C:\Users\%username%\AppData\Local\Microsoft\Power BI Desktop C:\Users\%username%\Microsoft\Power BI Desktop Store App No access to Mapbox API endpoints. If your map does not display in Power BI Web or Power BI Desktop, the machine running Power BI Web or Power BI Desktop may not have access to the Mapbox API endpoints. While no customer data is ever sent to Mapbox, the Mapbox API endpoints must be accessible for rendering Mapbox tiles and styles: https://*.tiles.mapbox.com https://api.mapbox.com Was this page helpful? Yes No",Integrate the Mapbox Visual with Microsoft Power BI,,,,,,,,,,,,,Supported Power BI environments and tools,Link your Mapbox access token in Power BI,Use a custom Mapbox style in Power BI,Format your location data to use in Power BI choropleth visualizations,Style dimensional values with the Data Colors feature,Resolve blank map issues in Power BI,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Display and style rich text labels,Uses the format expression to display country labels in both English and in the local language.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Display and style rich text labels Uses the format expression to display country labels in both English and in the local language. Was this example helpful? Yes No,Display and style rich text labels,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Create a hover effect,Using events and feature states to create a per feature hover effect.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Create a hover effect Using events and feature states to create a per feature hover effect. Was this example helpful? Yes No,Create a hover effect,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Marker playground,"Add a marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, React Native, or web application.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,playground,,,"Marker playground Use the marker playground below to add an image marker to the map and view the platform-specific code to recreate this map in your own iOS, Android, or web application.",Marker playground,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Create a heatmap layer,Visualize earthquake data using a heatmap layer.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Swift,,"Create a heatmap layer Swift Objective C import Mapbox class HeatmapExample: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() // Create and add a map view. let mapView = MGLMapView(frame: view.bounds, styleURL: MGLStyle.lightStyleURL) mapView.autoresizingMask = [.flexibleHeight, .flexibleWidth] mapView.delegate = self mapView.tintColor = .lightGray view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { // Parse GeoJSON data. This example uses all M1.0+ earthquakes from 12/22/15 to 1/21/16 as logged by USGS' Earthquake hazards program. guard let url = URL(string: ""https://www.mapbox.com/mapbox-gl-js/assets/earthquakes.geojson"") else { return } let source = MGLShapeSource(identifier: ""earthquakes"", url: url, options: nil) style.addSource(source) // Create a heatmap layer. let heatmapLayer = MGLHeatmapStyleLayer(identifier: ""earthquakes"", source: source) // Adjust the color of the heatmap based on the point density. let colorDictionary: [NSNumber: UIColor] = [ 0.0: .clear, 0.01: .white, 0.15: UIColor(red: 0.19, green: 0.30, blue: 0.80, alpha: 1.0), 0.5: UIColor(red: 0.73, green: 0.23, blue: 0.25, alpha: 1.0), 1: .yellow ] heatmapLayer.heatmapColor = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($heatmapDensity, 'linear', nil, %@)"", colorDictionary) // Heatmap weight measures how much a single data point impacts the layer's appearance. heatmapLayer.heatmapWeight = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:(mag, 'linear', nil, %@)"", [0: 0, 6: 1]) // Heatmap intensity multiplies the heatmap weight based on zoom level. heatmapLayer.heatmapIntensity = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [0: 1, 9: 3]) heatmapLayer.heatmapRadius = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", [0: 4, 9: 30]) // The heatmap layer should be visible up to zoom level 9. heatmapLayer.heatmapOpacity = NSExpression(format: ""mgl_step:from:stops:($zoomLevel, 0.75, %@)"", [0: 0.75, 9: 0]) style.addLayer(heatmapLayer) // Add a circle layer to represent the earthquakes at higher zoom levels. let circleLayer = MGLCircleStyleLayer(identifier: ""circle-layer"", source: source) let magnitudeDictionary: [NSNumber: UIColor] = [ 0: .white, 0.5: .yellow, 2.5: UIColor(red: 0.73, green: 0.23, blue: 0.25, alpha: 1.0), 5: UIColor(red: 0.19, green: 0.30, blue: 0.80, alpha: 1.0) ] circleLayer.circleColor = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:(mag, 'linear', nil, %@)"", magnitudeDictionary) // The heatmap layer will have an opacity of 0.75 up to zoom level 9, when the opacity becomes 0. circleLayer.circleOpacity = NSExpression(format: ""mgl_step:from:stops:($zoomLevel, 0, %@)"", [0: 0, 9: 0.75]) circleLayer.circleRadius = NSExpression(forConstantValue: 20) style.addLayer(circleLayer) } } Copy Was this page helpful? Yes No",Create a heatmap layer,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Create and style clusters,Use Mapbox GL JS' built-in functions to visualize points as clusters.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Create and style clusters Use Mapbox GL JS' built-in functions to visualize points as clusters. Was this example helpful? Yes No,Create and style clusters,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Show time lapse,Use an image source and a runnable to show data changes over time.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Show time lapse Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""40.879"" mapbox:mapbox_cameraTargetLng=""-76.476"" mapbox:mapbox_cameraZoom=""4.3""/> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.styles; import android.os.Bundle; import android.os.Handler; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngQuad; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.RasterLayer; import com.mapbox.mapboxsdk.style.sources.ImageSource; /** * Use a series of images to create an animation with an ImageSource */ public class ImageSourceTimeLapseActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private Handler handler; private Runnable runnable; private static final String ID_IMAGE_SOURCE = ""animated_image_source""; private static final String ID_IMAGE_LAYER = ""animated_image_layer""; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_image_source_time_lapse); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.DARK, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { style.addSource(new ImageSource(ID_IMAGE_SOURCE, new LatLngQuad( new LatLng(46.437, -80.425), new LatLng(46.437, -71.516), new LatLng(37.936, -71.516), new LatLng(37.936, -80.425)), R.drawable.southeast_radar_0)); // Add layer style.addLayer(new RasterLayer(ID_IMAGE_LAYER, ID_IMAGE_SOURCE)); // Loop the GeoJSON refreshing handler = new Handler(); runnable = new RefreshImageRunnable(handler, style); handler.postDelayed(runnable, 100); } }); } private static class RefreshImageRunnable implements Runnable { private final Style loadedMapStyle; private final Handler handler; private int[] drawables; private int drawableIndex; RefreshImageRunnable(Handler handler,Style loadedMapStyle) { this.handler = handler; this.loadedMapStyle = loadedMapStyle; drawables = new int[4]; drawables[0] = R.drawable.southeast_radar_0; drawables[1] = R.drawable.southeast_radar_1; drawables[2] = R.drawable.southeast_radar_2; drawables[3] = R.drawable.southeast_radar_3; drawableIndex = 1; } @Override public void run() { ((ImageSource) loadedMapStyle.getSource(ID_IMAGE_SOURCE)).setImage(drawables[drawableIndex++]); if (drawableIndex > 3) { drawableIndex = 0; } handler.postDelayed(this, 1000); } } // Add the mapView lifecycle to the activity's lifecycle methods @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (handler != null && runnable != null) { handler.removeCallbacks(runnable); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Show time lapse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Use GeoJSON data to set extrusion height,Use data-driven styling and GeoJSON data to set extrusion heights.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Use GeoJSON data to set extrusion height Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context=""com.mapbox.mapboxandroiddemo.examples.extrusions.MarathonExtrusionActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" android:layout_marginBottom=""0dp"" android:layout_marginLeft=""0dp"" android:layout_marginRight=""0dp"" android:layout_marginTop=""0dp"" mapbox:layout_constraintBottom_toBottomOf=""parent"" mapbox:layout_constraintHorizontal_bias=""0.0"" mapbox:layout_constraintLeft_toLeftOf=""parent"" mapbox:layout_constraintRight_toRightOf=""parent"" mapbox:layout_constraintTop_toTopOf=""parent"" mapbox:layout_constraintVertical_bias=""1.0"" mapbox:mapbox_cameraTargetLat=""33.334915"" mapbox:mapbox_cameraZoomMin=""11"" mapbox:mapbox_cameraTargetLng=""-118.335074"" mapbox:mapbox_cameraTilt=""55.8873"" mapbox:mapbox_cameraZoom=""12.692151"" /> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.extrusions; import android.graphics.Color; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillExtrusionLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.io.IOException; import java.io.InputStream; import static com.mapbox.mapboxsdk.style.expressions.Expression.get; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionHeight; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillExtrusionOpacity; /** * Use data-driven styling and GeoJSON data to set extrusions' heights */ public class MarathonExtrusionActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_marathon_extrusion); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(Style.SATELLITE, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Add the marathon route source to the map // Create a GeoJsonSource and use the Mapbox Datasets API to retrieve the GeoJSON data // More info about the Datasets API at https://www.mapbox.com/api-documentation/#retrieve-a-dataset GeoJsonSource courseRouteGeoJson = new GeoJsonSource( ""coursedata"", loadJsonFromAsset(""marathon_route.geojson"")); style.addSource(courseRouteGeoJson); addExtrusionsLayerToMap(style); } }); } private void addExtrusionsLayerToMap(@NonNull Style loadedMapStyle) { // Add FillExtrusion layer to map using GeoJSON data loadedMapStyle.addLayer(new FillExtrusionLayer(""course"", ""coursedata"").withProperties( fillExtrusionColor(Color.YELLOW), fillExtrusionOpacity(0.7f), fillExtrusionHeight(get(""e"")))); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } private String loadJsonFromAsset(String filename) { // Using this method to load in GeoJSON files from the assets folder. try { InputStream is = getAssets().open(filename); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); return new String(buffer, ""UTF-8""); } catch (IOException ex) { ex.printStackTrace(); return null; } } } Copy Was this page helpful? Yes No",Use GeoJSON data to set extrusion height,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,style URL,A style URL allows you to reference a style created with Mapbox Studio.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"style URL Any time you create a style with Mapbox Studio it generates a style URL. The style URL allows you to reference that specific style with the Mapbox GL JS API or native SDKs. A complete style URL, for example mapbox://styles/mapbox/streets-v 11, is comprised of three components: mapbox://styles: points to the Mapbox Styles API /mapbox: your Mapbox username /streets-v 11: your style's unique ID For each custom style you create in Mapbox Studio, there is a draft and a production style URL available. If you are using the draft version of your style, /draft will also be appended to the end of the style URL. You can find the style URL on your Styles page in Mapbox Studio. Click on the menu next to a style to reveal its style URL. Click the icon to copy the style URL. Note Looking for Classic styles or Mapbox Editor map IDs? See our documentation on tileset IDs. Was this page helpful? Yes No",style URL,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,offline regions and offline packs,An offline region is a defined region of a map that is available for use in conditions with limited or no network connection.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"offline regions and offline packs An offline region (also known as an offline pack in the Mapbox Maps SDK for iOS) is a defined region of a map that is available for use in conditions with limited or no network connection, created with either the Mapbox Maps SDK for iOS or the Mapbox Maps SDK for Android. For more information, read the offline maps guide. Was this page helpful? Yes No",offline regions and offline packs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Maki,Maki is an icon set developed by Mapbox for map designers.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"Maki Maki is an icon set developed by Mapbox for map designers. It includes common point of interest icons such as parks, restaurants, campgrounds, and more. Each Mapbox template style found in Mapbox Studio includes a uniquely styled set of Maki icons. Was this page helpful? Yes No",Maki,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java SDK,Android,Define a circle in physical units,"Use Turf to generate a circle with a radius expressed in physical units (e.g. miles, kilometers, etc).",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Define a circle in physical units Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.javaservices.TurfPhysicalCircleActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""0dp"" android:layout_height=""0dp"" app:layout_constraintBottom_toTopOf=""@+id/guideline9"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintStart_toStartOf=""parent"" app:layout_constraintTop_toTopOf=""parent"" mapbox:mapbox_cameraTargetLat=""27.7014884022"" mapbox:mapbox_cameraTargetLng=""85.323283875"" mapbox:mapbox_cameraZoom=""4"" /> <androidx.constraintlayout.widget.Guideline android:id=""@+id/guideline9"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:orientation=""horizontal"" app:layout_constraintGuide_begin=""422dp"" /> <TextView android:id=""@+id/circle_steps_textview"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:gravity=""center"" android:text=""@string/polygon_circle_transformation_circle_steps"" android:textSize=""20sp"" android:textStyle=""bold"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintStart_toStartOf=""parent"" app:layout_constraintTop_toBottomOf=""@+id/mapView"" /> <TextView android:id=""@+id/circle_radius_textview"" android:layout_width=""0dp"" android:layout_height=""27dp"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""32dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" android:gravity=""center"" android:text=""@string/polygon_circle_transformation_circle_radius"" android:textSize=""20sp"" android:textStyle=""bold"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintStart_toStartOf=""parent"" app:layout_constraintTop_toBottomOf=""@+id/circle_steps_seekbar"" /> <TextView android:id=""@+id/distance_units_textview"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""16dp"" android:gravity=""center"" android:text=""@string/polygon_circle_transformation_circle_distance_units"" android:textSize=""20sp"" android:textStyle=""bold"" mapbox:layout_constraintStart_toStartOf=""parent"" mapbox:layout_constraintTop_toBottomOf=""@+id/circle_radius_seekbar"" /> <SeekBar android:id=""@+id/circle_steps_seekbar"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_marginTop=""8dp"" app:layout_constraintEnd_toEndOf=""@+id/circle_steps_textview"" app:layout_constraintStart_toStartOf=""@+id/circle_steps_textview"" app:layout_constraintTop_toBottomOf=""@+id/circle_steps_textview"" /> <SeekBar android:id=""@+id/circle_radius_seekbar"" android:layout_width=""395dp"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginTop=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintStart_toStartOf=""parent"" app:layout_constraintTop_toBottomOf=""@+id/circle_radius_textview"" /> <Spinner android:id=""@+id/circle_units_spinner"" android:layout_width=""0dp"" android:layout_height=""wrap_content"" android:layout_marginStart=""8dp"" android:layout_marginLeft=""8dp"" android:layout_marginEnd=""8dp"" android:layout_marginRight=""8dp"" app:layout_constraintBottom_toBottomOf=""@+id/distance_units_textview"" app:layout_constraintEnd_toEndOf=""parent"" app:layout_constraintStart_toEndOf=""@+id/distance_units_textview"" app:layout_constraintTop_toTopOf=""@+id/distance_units_textview""> </Spinner> </androidx.constraintlayout.widget.ConstraintLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.javaservices; import android.graphics.Color; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.ArrayAdapter; import android.widget.SeekBar; import android.widget.Spinner; import android.widget.TextView; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.geojson.Polygon; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.SymbolLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.mapboxsdk.utils.BitmapUtils; import com.mapbox.turf.TurfMeta; import com.mapbox.turf.TurfTransformation; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconAllowOverlap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconIgnorePlacement; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconImage; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.iconOffset; import static com.mapbox.turf.TurfConstants.UNIT_DEGREES; import static com.mapbox.turf.TurfConstants.UNIT_KILOMETERS; import static com.mapbox.turf.TurfConstants.UNIT_MILES; import static com.mapbox.turf.TurfConstants.UNIT_RADIANS; /** * Use {@link TurfTransformation#circle(Point, double, int, String)} to draw a circle * at a center coordinate with it's radius specified in physical units (i.e. ""miles""). * Default number of steps is 64 and default unit of distance is kilometers. * More information can be found at https://github.com/mapbox/mapbox-java/blob/ * master/services-turf/src/main/java/com/mapbox/turf/TurfTransformation.java and * at http://turfjs.org/docs/#circle. */ public class TurfPhysicalCircleActivity extends AppCompatActivity implements MapboxMap.OnMapClickListener, AdapterView.OnItemSelectedListener { private static final String TURF_CALCULATION_FILL_LAYER_GEOJSON_SOURCE_ID = ""TURF_CALCULATION_FILL_LAYER_GEOJSON_SOURCE_ID""; private static final String TURF_CALCULATION_FILL_LAYER_ID = ""TURF_CALCULATION_FILL_LAYER_ID""; private static final String CIRCLE_CENTER_SOURCE_ID = ""CIRCLE_CENTER_SOURCE_ID""; private static final String CIRCLE_CENTER_ICON_ID = ""CIRCLE_CENTER_ICON_ID""; private static final String CIRCLE_CENTER_LAYER_ID = ""CIRCLE_CENTER_LAYER_ID""; private static final Point DOWNTOWN_KATHMANDU = Point.fromLngLat(85.323283875, 27.7014884022); private static final int RADIUS_SEEKBAR_DIFFERENCE = 1; private static final int STEPS_SEEKBAR_DIFFERENCE = 1; private static final int STEPS_SEEKBAR_MAX = 360; private static final int RADIUS_SEEKBAR_MAX = 500; // Min is 4 because LinearRings need to be made up of 4 or more coordinates. private static final int MINIMUM_CIRCLE_STEPS = 4; private Point lastClickPoint = DOWNTOWN_KATHMANDU; private MapView mapView; private MapboxMap mapboxMap; // Not static final because they will be adjusted by the seekbars and spinner menu private String circleUnit = UNIT_KILOMETERS; private int circleSteps = 180; private int circleRadius = 100; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_lab_turf_circle_physical_units); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(new OnMapReadyCallback() { @Override public void onMapReady(@NonNull MapboxMap mapboxMap) { mapboxMap.setStyle(new Style.Builder().fromUri(Style.MAPBOX_STREETS) .withImage(CIRCLE_CENTER_ICON_ID, BitmapUtils.getBitmapFromDrawable( getResources().getDrawable(R.drawable.red_marker))) .withSource(new GeoJsonSource(CIRCLE_CENTER_SOURCE_ID, Feature.fromGeometry(DOWNTOWN_KATHMANDU))) .withSource(new GeoJsonSource(TURF_CALCULATION_FILL_LAYER_GEOJSON_SOURCE_ID)) .withLayer(new SymbolLayer(CIRCLE_CENTER_LAYER_ID, CIRCLE_CENTER_SOURCE_ID).withProperties( iconImage(CIRCLE_CENTER_ICON_ID), iconIgnorePlacement(true), iconAllowOverlap(true), iconOffset(new Float[] {0f, -4f}) )), new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { TurfPhysicalCircleActivity.this.mapboxMap = mapboxMap; initPolygonCircleFillLayer(); final SeekBar circleStepsSeekbar = findViewById(R.id.circle_steps_seekbar); circleStepsSeekbar.setMax(STEPS_SEEKBAR_MAX); circleStepsSeekbar.incrementProgressBy(STEPS_SEEKBAR_DIFFERENCE); circleStepsSeekbar.setProgress(STEPS_SEEKBAR_MAX / 2); final SeekBar circleRadiusSeekbar = findViewById(R.id.circle_radius_seekbar); circleRadiusSeekbar.setMax(RADIUS_SEEKBAR_MAX + RADIUS_SEEKBAR_DIFFERENCE); circleRadiusSeekbar.incrementProgressBy(RADIUS_SEEKBAR_DIFFERENCE); circleRadiusSeekbar.setProgress(RADIUS_SEEKBAR_MAX / 2); final TextView circleStepsTextview = findViewById(R.id.circle_steps_textview); circleStepsTextview.setText(String.format(getString( R.string.polygon_circle_transformation_circle_steps), circleStepsSeekbar.getProgress())); final TextView circleRadiusTextView = findViewById(R.id.circle_radius_textview); circleRadiusTextView.setText(String.format(getString( R.string.polygon_circle_transformation_circle_radius), circleRadiusSeekbar.getProgress())); drawPolygonCircle(lastClickPoint); circleStepsSeekbar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { if (progress < MINIMUM_CIRCLE_STEPS) { seekBar.setProgress(MINIMUM_CIRCLE_STEPS); } adjustSteps(R.string.polygon_circle_transformation_circle_steps, circleStepsTextview, progress < MINIMUM_CIRCLE_STEPS ? MINIMUM_CIRCLE_STEPS : progress, STEPS_SEEKBAR_DIFFERENCE); } @Override public void onStartTrackingTouch(SeekBar seekBar) { // Not needed in this example. } @Override public void onStopTrackingTouch(SeekBar seekBar) { if (seekBar.getProgress() < MINIMUM_CIRCLE_STEPS) { seekBar.setProgress(MINIMUM_CIRCLE_STEPS); } adjustSteps(R.string.polygon_circle_transformation_circle_steps, circleStepsTextview, seekBar.getProgress(), STEPS_SEEKBAR_DIFFERENCE); } }); circleRadiusSeekbar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { adjustRadius(R.string.polygon_circle_transformation_circle_radius, circleRadiusTextView, seekBar.getProgress(), STEPS_SEEKBAR_DIFFERENCE); } @Override public void onStartTrackingTouch(SeekBar seekBar) { // Not needed in this example. } @Override public void onStopTrackingTouch(SeekBar seekBar) { adjustRadius(R.string.polygon_circle_transformation_circle_radius, circleRadiusTextView, seekBar.getProgress(), STEPS_SEEKBAR_DIFFERENCE); } }); mapboxMap.addOnMapClickListener(TurfPhysicalCircleActivity.this); initDistanceUnitSpinner(); Toast.makeText(TurfPhysicalCircleActivity.this, getString(R.string.polygon_circle_transformation_click_map_instruction), Toast.LENGTH_SHORT).show(); } }); } }); } private void adjustRadius(int string, TextView textView, int progress, int difference) { adjustTextView(string, textView, progress, difference); circleRadius = progress; drawPolygonCircle(lastClickPoint); } private void adjustSteps(int string, TextView textView, int progress, int difference) { adjustTextView(string, textView, progress, difference); circleSteps = progress; drawPolygonCircle(lastClickPoint); } private void initDistanceUnitSpinner() { Spinner spinner = findViewById(R.id.circle_units_spinner); spinner.setOnItemSelectedListener(this); ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(this, R.array.polygon_circle_transformation_circle_distance_units_array, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); spinner.setAdapter(adapter); } @Override public void onItemSelected(AdapterView<?> parentAdapterView, View view, int position, long id) { String selectedUnitInSpinnerMenu = String.valueOf(parentAdapterView.getItemAtPosition(position)); switch (selectedUnitInSpinnerMenu) { case ""Kilometers"": circleUnit = UNIT_KILOMETERS; break; case ""Miles"": circleUnit = UNIT_MILES; break; case ""Degrees"": circleUnit = UNIT_DEGREES; break; case ""Radians"": circleUnit = UNIT_RADIANS; break; default: circleUnit = UNIT_KILOMETERS; } drawPolygonCircle(lastClickPoint); } @Override public void onNothingSelected(AdapterView<?> adapterView) { // Empty on purpose. Not used in this example. } private void adjustTextView(int string, TextView textView, int progress, int difference) { progress = progress / difference; progress = progress * difference; textView.setText(String.format(getString(string), progress)); } @Override public boolean onMapClick(@NonNull LatLng mapClickLatLng) { mapboxMap.easeCamera(CameraUpdateFactory.newLatLng(mapClickLatLng)); lastClickPoint = Point.fromLngLat(mapClickLatLng.getLongitude(), mapClickLatLng.getLatitude()); moveCircleCenterMarker(lastClickPoint); drawPolygonCircle(lastClickPoint); return true; } /** * Move the red marker icon to wherever the map was tapped on. * * @param circleCenter where the red marker icon will be moved to. */ private void moveCircleCenterMarker(Point circleCenter) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Use Turf to calculate the Polygon's coordinates GeoJsonSource markerSource = style.getSourceAs(CIRCLE_CENTER_SOURCE_ID); if (markerSource != null) { markerSource.setGeoJson(circleCenter); } } }); } /** * Update the {@link FillLayer} based on the GeoJSON retrieved via * {@link #getTurfPolygon(Point, double, int, String)}. * * @param circleCenter the center coordinate to be used in the Turf calculation. */ private void drawPolygonCircle(Point circleCenter) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Use Turf to calculate the Polygon's coordinates Polygon polygonArea = getTurfPolygon(circleCenter, circleRadius, circleSteps, circleUnit); GeoJsonSource polygonCircleSource = style.getSourceAs(TURF_CALCULATION_FILL_LAYER_GEOJSON_SOURCE_ID); if (polygonCircleSource != null) { polygonCircleSource.setGeoJson(Polygon.fromOuterInner( LineString.fromLngLats(TurfMeta.coordAll(polygonArea, false)))); } } }); } /** * Use the Turf library {@link TurfTransformation#circle(Point, double, int, String)} method to * retrieve a {@link Polygon} . * * @param centerPoint a {@link Point} which the circle will center around * @param radius the radius of the circle * @param steps number of steps which make up the circle parameter * @param units one of the units found inside {@link com.mapbox.turf.TurfConstants} * @return a {@link Polygon} which represents the newly created circle */ private Polygon getTurfPolygon(@NonNull Point centerPoint, @NonNull double radius, @NonNull int steps, @NonNull String units) { return TurfTransformation.circle(centerPoint, radius, steps, units); } /** * Add a {@link FillLayer} to display a {@link Polygon} in a the shape of a circle. */ private void initPolygonCircleFillLayer() { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Create and style a FillLayer based on information that will come from the Turf calculation FillLayer fillLayer = new FillLayer(TURF_CALCULATION_FILL_LAYER_ID, TURF_CALCULATION_FILL_LAYER_GEOJSON_SOURCE_ID); fillLayer.setProperties( fillColor(Color.parseColor(""#f5425d"")), fillOpacity(.7f)); style.addLayerBelow(fillLayer, CIRCLE_CENTER_LAYER_ID); } }); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Define a circle in physical units,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a GeoJSON line,Add a GeoJSON line to a map.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Add a GeoJSON line Add a GeoJSON line to a map. Was this example helpful? Yes No,Add a GeoJSON line,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Outlined polygon hole,Outline a polygon hole to highlight a revealed region.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Outlined polygon hole Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" tools:context="".examples.dds.DrawPolygonActivity""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""37.331383"" mapbox:mapbox_cameraTargetLng=""-121.888902"" mapbox:mapbox_cameraZoom=""12"" mapbox:mapbox_cameraZoomMin=""11.6"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.dds; import android.graphics.Color; import android.os.AsyncTask; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import com.mapbox.geojson.Feature; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.geojson.Polygon; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.FillLayer; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.layers.Property; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import com.mapbox.turf.TurfMeta; import java.io.InputStream; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; import java.util.Scanner; import timber.log.Timber; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.fillOpacity; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineCap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineJoin; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; public class RevealedPolygonHoleOutlineActivity extends AppCompatActivity implements OnMapReadyCallback { private static final String FILL_SOURCE_ID = ""SOURCE-ID""; private static final String LINE_SOURCE_ID = ""LINE_SOURCE_ID""; private static final String FILL_LAYER_ID = ""FILL-LAYER-ID""; private static final String LINE_LAYER_ID = ""LINE-LAYER-ID""; private static final float FILL_OPACITY = .7f; private static final float LINE_WIDTH = 5f; private static final int GREY_COLOR = Color.parseColor(""#c2c2c2""); private static final int RED_COLOR = Color.parseColor(""#BF544C""); private MapView mapView; private MapboxMap mapboxMap; private static final List<Point> OUTER_POLYGON_COORDINATES = new ArrayList<Point>() { { add(Point.fromLngLat(-121.9921875, 37.27787748952485)); add(Point.fromLngLat(-121.79580688476562, 37.27787748952485)); add(Point.fromLngLat(-121.79580688476562, 37.40452830389465)); add(Point.fromLngLat(-121.9921875, 37.40452830389465)); add(Point.fromLngLat(-121.9921875, 37.27787748952485)); } }; private static final LatLngBounds RESTRICTED_BOUNDS_AREA = new LatLngBounds.Builder() .include(new LatLng(37.27787748952485, -121.9921875)) .include(new LatLng(37.40452830389465, -121.79580688476562)) .build(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_polygon_holes_outline_revealed); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(final MapboxMap map) { this.mapboxMap = map; // Set the boundary area for the map camera mapboxMap.setLatLngBoundsForCameraTarget(RESTRICTED_BOUNDS_AREA); map.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { new LoadGeoJson(RevealedPolygonHoleOutlineActivity.this).execute(); } }); } private void addStyling(@NonNull List<Point> pointList) { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style loadedStyle) { List<LineString> innerList = new ArrayList<>(); LineString innerLineString = LineString.fromLngLats(pointList); innerList.add(innerLineString); loadedStyle.addSource(new GeoJsonSource(FILL_SOURCE_ID, Polygon.fromOuterInner(LineString.fromLngLats(OUTER_POLYGON_COORDINATES), innerList))); loadedStyle.addSource(new GeoJsonSource(LINE_SOURCE_ID, innerLineString)); loadedStyle.addLayerBelow(new FillLayer(FILL_LAYER_ID, FILL_SOURCE_ID).withProperties( fillColor(GREY_COLOR), fillOpacity(FILL_OPACITY)), ""road-street""); loadedStyle.addLayer(new LineLayer(LINE_LAYER_ID, LINE_SOURCE_ID).withProperties( lineColor(RED_COLOR), lineWidth(LINE_WIDTH), lineCap(Property.LINE_CAP_ROUND), lineJoin(Property.LINE_JOIN_ROUND) )); } }); } private static class LoadGeoJson extends AsyncTask<Void, Void, List<Point>> { private WeakReference<RevealedPolygonHoleOutlineActivity> weakReference; LoadGeoJson(RevealedPolygonHoleOutlineActivity activity) { this.weakReference = new WeakReference<>(activity); } @Override protected List<Point> doInBackground(Void... voids) { try { RevealedPolygonHoleOutlineActivity activity = weakReference.get(); if (activity != null) { InputStream inputStream = activity.getAssets().open(""downtown_san_jose_hole.geojson""); Feature holePolygonFeature = Feature.fromJson(convertStreamToString(inputStream)); return TurfMeta.coordAll((Polygon) holePolygonFeature.geometry(), false); } } catch (Exception exception) { Timber.e(""Exception Loading GeoJSON: %s"", exception.toString()); } return null; } static String convertStreamToString(InputStream is) { Scanner scanner = new Scanner(is).useDelimiter(""\\A""); return scanner.hasNext() ? scanner.next() : """"; } @Override protected void onPostExecute(@Nullable List<Point> pointList) { super.onPostExecute(pointList); RevealedPolygonHoleOutlineActivity activity = weakReference.get(); if (activity != null && pointList != null) { activity.addStyling(pointList); } } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } } Copy Was this page helpful? Yes No",Outlined polygon hole,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Build a navigation app for Android,Integrate navigation into any Android application.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,Java,,,Build a navigation app for Android,,,,,,,,,,,,,Getting started,Install the Navigation SDK,Initialize a map,Display user location,Add a marker on click,Calculate and draw route,Add a button to start navigation,Customize the style,Style the navigation view,Style the route overview,Final product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for iOS,iOS,Point conversion,Convert between screen location and geographic coordinates.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Swift,,"Point conversion Swift Objective C import Mapbox class ViewController: UIViewController, MGLMapViewDelegate { var mapView: MGLMapView! override func viewDidLoad() { super.viewDidLoad() mapView = MGLMapView(frame: view.bounds) mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] view.addSubview(mapView) // Add a single tap gesture recognizer. This gesture requires the built-in MGLMapView tap gestures (such as those for zoom and annotation selection) to fail. let singleTap = UITapGestureRecognizer(target: self, action: #selector(handleMapTap(sender:))) for recognizer in mapView.gestureRecognizers! where recognizer is UITapGestureRecognizer { singleTap.require(toFail: recognizer) } mapView.addGestureRecognizer(singleTap) // Convert `mapView.centerCoordinate` (CLLocationCoordinate2D) to screen location (CGPoint). let centerScreenPoint: CGPoint = mapView.convert(mapView.centerCoordinate, toPointTo: nil) print(""Screen center: \(centerScreenPoint) = \(mapView.center)"") } @objc @IBAction func handleMapTap(sender: UITapGestureRecognizer) { // Convert tap location (CGPoint) to geographic coordinate (CLLocationCoordinate2D). let tapPoint: CGPoint = sender.location(in: mapView) let tapCoordinate: CLLocationCoordinate2D = mapView.convert(tapPoint, toCoordinateFrom: nil) print(""You tapped at: \(tapCoordinate.latitude), \(tapCoordinate.longitude)"") // Create an array of coordinates for our polyline, starting at the center of the map and ending at the tap coordinate. var coordinates: [CLLocationCoordinate2D] = [mapView.centerCoordinate, tapCoordinate] // Remove any existing polyline(s) from the map. if mapView.annotations?.count != nil, let existingAnnotations = mapView.annotations { mapView.removeAnnotations(existingAnnotations) } // Add a polyline with the new coordinates. let polyline = MGLPolyline(coordinates: &coordinates, count: UInt(coordinates.count)) mapView.addAnnotation(polyline) } } Copy Was this page helpful? Yes No",Point conversion,Objective-C,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Navigate the map with game-like controls,Move around the map with game-like controls.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Navigate the map with game-like controls Move around the map with game-like controls. Was this example helpful? Yes No,Navigate the map with game-like controls,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
How Mapbox works,Help,Unity applications,"Learn how the Mapbox Maps SDK for Unity works, how to use it, and how to get started building applications.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Unity applications The Mapbox Maps SDK for Unity is a set of tools to build Unity applications from real map data. It consists of a robust API for interfacing with Mapbox web services and converting map resources into game objects as well as a robust graphical user interface built on top of the Unity platform. This guide provides an overview of how the Mapbox Maps SDK for Unity works, how to use it, and how to get started building applications. How the Mapbox Maps SDK for Unity works The Mapbox Maps SDK for Unity is designed to help Unity developers add dynamic map data to their games and applications by providing a straightforward programmatic and graphical interface to Mapbox's web services APIs, including: Vector Tiles API Raster Tiles API Static Images API Geocoding API Directions API Map Matching API Dynamic data While some map-focused Unity plugins are designed to help developers build static game environments from map data, the Mapbox Maps SDK for Unity is designed to request and render map data at runtime. This means that applications built with the Maps SDK for Unity will always display the most recent version of spatial data. It also means that games and applications only ever request the subset of data that corresponds with the area the user is viewing, keeping games and applications lightweight. Mesh generation The Mapbox Maps SDK for Unity provides the ability to generate meshes to create 2D or 3D maps, with satellite imagery, custom map styles, terrain data, and points of interest. See the mesh generation tutorial to get started. AR support The Mapbox Maps SDK for Unity provides support for augmented reality, whether you're making a tabletop AR app or the next PokemonGo. Using the Mapbox Maps SDK for Unity The Mapbox Maps SDK for Unity is used with the Unity desktop application. Installing the Mapbox Maps SDK for Unity The Mapbox Maps SDK for Unity is available via direct download. See the Mapbox Maps SDK for Unity documentation for complete installation instructions. Creating game objects The Mapbox Maps SDK for Unity can be used to build rich environments from a variety of different types of data, including terrain data, raster map tiles, and vector map tiles, among others. Terrain The Mapbox terrain-rgb tileset is designed for high resolution elevation visualizations and it is especially well-suited to creating 3D meshes with Unity. See the Mesh generation basics example for more information. Features from vector tiles Whether you're using a Mapbox tileset or a custom tileset you created via the Mapbox Uploads API, the Mapbox Maps SDK for Unity can request vector tiles, convert them into game objects or meshes, and render them alongside the rest of your game data. See the Slippy map example for more information. Accessing Mapbox web services The Mapbox Maps SDK for Unity can connect your game or application to many of Mapbox's web services APIs, including the Mapbox Vector Tiles API Raster Tiles API, Static Images API, Geocoding API, Directions API, and Map Matching API. See the various Playground examples for more information on interacting with Mapbox APIs. Publishing The Mapbox Maps SDK for Unity works anywhere Unity works, including, desktop, and mobile and coming soon to the web. Pricing Mobile applications built with our Maps SDK for Unity track usage with monthly active users (MAU). This means each device using your app within a month counts as a single MAU. All other apps built with Unity are charged by tile requests. All types of applications are metered for usage of the Mapbox APIs, like Geocoding and Directions, when they surpass what’s included with the free plan. Was this page helpful? Yes No",Unity applications,,,,,,,,,,,,,How the Mapbox Maps SDK for Unity works,Dynamic data,Mesh generation,AR support,Using the Mapbox Maps SDK for Unity,Installing the Mapbox Maps SDK for Unity,Creating game objects,Terrain,Features from vector tiles,Accessing Mapbox web services,Publishing,Pricing,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Troubleshoot Tilesets API errors,This feature is in beta. Learn how to debug common errors with the Mapbox Tilesets API.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Troubleshoot Tilesets API errors Public beta The Mapbox Tilesets API functionalities documented in this guide are in public beta. All features and workflows are subject to potential changes. This guide outlines possible errors that you might see when creating, modifying, or deleting tileset sources, tilesets, and tileset recipes using the Tilesets API. There are gaps of missing data in my tiles If you notice that your tileset is missing points, lines, or polygons, it’s likely that the Tilesets API dropped some features because the tile size was approaching the maximum allowed size of 500 KB. If you view the job_id of this tileset, you will see warnings about how many tiles dropped features and a list of example tiles so you can diagnose the problem. To avoid hitting the 500 KB limit, you should reduce the number and size of features. You can do this by: Increasing the recipe simplification level. Only allowing certain attributes to exist in the final tileset. Unioning adjoining features, such as LineStrings, which reduces the number of overall features in the tiles. My minzoom is different than expected The Tilesets API tries to generate tiles for every requested zoom level. If the zoom levels in a tileset do not match the zoom levels in the corresponding recipe, this is due to features being filtered out based on the rules you have provided, which led to empty tiles at these zooms. For example, if you specify a zoom level of 6 but your filtering syntax only starts accepting features at zoom 8, once processing is complete the Tilesets API will dynamically set the tileset's minzoom to 8 since there are no tiles to be requested at zoom 6 or 7. There are ""notches"" in my LineStrings at high zooms Notches in LineStrings happen when high zoom tiles do not have buffers that are large enough. To avoid possible buffer-edge artifacts, set your buffer_size to something larger than the default of 0.5. The recommended value is 6. The features in my vector tiles have different IDs than the features in my source data Vector tiles only support integer-based identifiers. If you provide an ID in the tileset source in any format other than integers, the Tilesets API will generate an integer hash of this value to use as the feature ID. If you need to keep the original source IDs, you can do either of the following: Use integer IDs in the source data. Save the original ID of the feature as an attribute in the vector tiles using the add_to_attributes option in your recipe. A feature I expected to be in my new tileset isn't there If a feature that you expected to see is not in the new tileset, it might have been dropped for one of the following reasons: The tileset source data was not valid GeoJSON. You can diagnose the problem by using the Tilesets CLI's validate-source command to validate your source data. The feature was filtered out by your recipe. For more information on how and why a recipe might filter out a feature, see the Tilesets API recipe reference. The feature has been simplified away at certain zoom levels. For more information on feature simplification, see the Tilesets API recipe reference. I'm not able to use GeometryCollection features in my tileset source Tileset sources do not support GeoJSON GeometryCollection features. If you have GeometryCollection features in your source data, you should split each of its sub-features into a unique, individual feature. There are no features in my tileset when I click ""zoom to data"" in Mapbox Studio Depending on how your data is distributed or the zoom range you choose, knowing where your data is can be a challenge. Mapbox Studio tries to help you visualize your data at the right location, but due to how it makes this calculation, you may not see any features if there are not any at the mathematical center of the tileset source used to create the tileset. If this occurs, you will need to manually click and drag the map to your feature locations, rather than being able to click ""zoom to data"". Tilesets CLI error messages The following is a list of common errors that you may see when using the Tilesets CLI, which allows you to interact with and prepare data for the Mapbox Tilesets API. No features in source data. You may see this error after you run the Tilesets CLI command to publish a tileset. The problem could be that your tileset source is an empty file, or that it does not contain any line-delimited GeoJSON features. Check the tileset source to confirm that it contains valid features. No GeoJSON features processed. Make sure your GeoJSON is line-delimited. You may see this error after you run the Tilesets CLI command to publish a tileset. This error is most common when a tileset source is a GeoJSON file, but is not line-delimited GeoJSON. The Tilesets API requires all tileset sources to be line-delimited to process correctly. You can learn more about the line-delimited GeoJSON format and some conversion tools in the Tileset sources guide. No GeoJSON features to process. You may see this error after you run the Tilesets CLI command to create a tileset. The problem may be that your data was not uploaded. Check that the data was indeed uploaded. You may also see this error if the filter in your recipe is failing for some reason. If you have a filter condition like [ ""<="", [ ""get"", ""minzoom"" ], 5 ], and one or more of your features has a null value for minzoom, you could run into this error. You can use the coalesce operation in an expression to provide a default value to replace missing data. For instance, if you want a missing minzoom attribute to be treated as 0, you could write this expression as [ ""<="", [ ""coalesce"", [ ""get"", ""minzoom"" ], 0 ], 5 ]. For more information on recipe filters, see the Recipe reference Was this page helpful? Yes No",Troubleshoot Tilesets API errors,,,,,,,,,,,,,There are gaps of missing data in my tiles,My minzoom is different than expected,"There are ""notches"" in my LineStrings at high zooms",The features in my vector tiles have different IDs than the features in my source data,A feature I expected to be in my new tileset isn't there,I'm not able to use GeometryCollection features in my tileset source,"There are no features in my tileset when I click ""zoom to data"" in Mapbox Studio",Tilesets CLI error messages,No features in source data.,No GeoJSON features processed. Make sure your GeoJSON is line-delimited.,No GeoJSON features to process.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Android Plugins,Android,Scale bar,Add a scale bar to determine distance based on zoom level.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Scale bar Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" xmlns:app=""http://schemas.android.com/apk/res-auto"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto"" android:layout_width=""match_parent"" android:layout_height=""match_parent""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" mapbox:mapbox_cameraTargetLat=""23.585781"" mapbox:mapbox_cameraTargetLng=""58.545909"" mapbox:mapbox_cameraZoom=""13.674097"" /> <com.google.android.material.floatingactionbutton.FloatingActionButton android:id=""@+id/switch_scalebar_style_fab"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:layout_gravity=""bottom|right"" android:layout_marginBottom=""16dp"" android:layout_marginEnd=""16dp"" android:layout_marginRight=""16dp"" app:layout_constraintBottom_toBottomOf=""parent"" app:layout_constraintEnd_toEndOf=""parent"" app:srcCompat=""@drawable/ic_swap_horiz_white_24dp"" mapbox:fabSize=""normal"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.plugins; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.View; import android.widget.Toast; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.pluginscalebar.ScaleBarOptions; import com.mapbox.pluginscalebar.ScaleBarPlugin; /** * Use the Scale Bar Plugin to provide a visual indication of how far various map features are from * one another at a certain zoom level. The scalebar can be customized with options such as the * text color/size, referesh interval, margins, and border width. */ public class ScalebarPluginActivity extends AppCompatActivity implements OnMapReadyCallback { private MapView mapView; private ScaleBarPlugin scaleBarPlugin; private ScaleBarOptions[] listOfScalebarStyleVariations; private String[] listOfStyles = new String[] {Style.LIGHT, Style.DARK, Style.SATELLITE_STREETS, Style.OUTDOORS}; private int index = 0; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); setContentView(R.layout.activity_scalebar_plugin); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { mapboxMap.setStyle(listOfStyles[index], new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull final Style style) { initStyling(); // Create a new ScaleBarPlugin object scaleBarPlugin = new ScaleBarPlugin(mapView, mapboxMap); scaleBarPlugin.create(listOfScalebarStyleVariations[index]); findViewById(R.id.switch_scalebar_style_fab).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (index == listOfScalebarStyleVariations.length - 1) { index = 0; } mapboxMap.setStyle(listOfStyles[index], new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { scaleBarPlugin.create(listOfScalebarStyleVariations[index]); } }); index++; } }); Toast.makeText(ScalebarPluginActivity.this, getString(R.string.zoom_map_fab_instruction), Toast.LENGTH_LONG).show(); } }); } private void initStyling() { listOfScalebarStyleVariations = new ScaleBarOptions[] { // Using the plugin's default styling to start new ScaleBarOptions(this), // Random styling option #2 new ScaleBarOptions(this) .setTextColor(R.color.mapboxRed) .setTextSize(40f) .setBarHeight(15f) .setBorderWidth(5f) .setMetricUnit(true) .setRefreshInterval(15) .setMarginTop(30f) .setMarginLeft(16f) .setTextBarMargin(15f), // Random styling option #3 new ScaleBarOptions(this) .setTextColor(R.color.mapbox_blue) .setTextSize(60f) .setBarHeight(15f) .setBorderWidth(5f) .setMetricUnit(true) .setRefreshInterval(15) .setMarginTop(30f) .setMarginLeft(30f) .setTextBarMargin(25f), // Random styling option #4 new ScaleBarOptions(this) .setTextColor(R.color.mapboxYellow) .setTextSize(30f) .setBarHeight(15f) .setBorderWidth(5f) .setMetricUnit(false) .setRefreshInterval(15) .setMarginTop(30f) .setMarginLeft(30f) .setTextBarMargin(25f), }; } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onPause() { super.onPause(); mapView.onPause(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override public void onDestroy() { super.onDestroy(); mapView.onDestroy(); } } Copy Was this page helpful? Yes No",Scale bar,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Transfer styles between accounts,Learn how to transfer Mapbox styles between accounts.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Transfer styles between accounts There are two approaches to transferring styles between accounts. The first approach is a true transfer of a Mapbox style from one account to another. The second approach involves referencing a public style from another Mapbox account within your own application. Approach 1: Download and re-upload a style Transferring styles between accounts allows you to own a style and make changes to it from a single Mapbox account. You can transfer Mapbox assets between accounts if you have access to the account you're transferring from or if you're given the necessary files. How you transfer styles from one account to another depends on whether you are using Mapbox Studio or Mapbox Studio Classic, as well as the data that's included with your style. Styles made with Mapbox Studio Styles made with Mapbox Studio may be downloaded in JSON format and re-uploaded as a new style. To download a style, open the style in the Mapbox Studio style editor, click the Share button, and click the link next to the Download option. You can download draft or production versions of your styles. You can then upload the JSON file to another Mapbox account: Unzip the folder you downloaded. Log into the second account. Click the Upload style link next to the New style button. Select the style.json file inside the unzipped folder and upload. If you added any custom icons or fonts to your style, you'll need to add them back manually. Open your newly uploaded style in Mapbox Studio, then: To add fonts, click Fonts and then Upload new font. Drag and drop the contents of the fonts folder from your downloaded style into the appropriate area. To add icons (images), click Images and then Upload SVG Image. Drag and drop the contents of the icons folder from your downloaded style into the appropriate area. Projects made with Mapbox Studio Classic Note that Mapbox Studio Classic has been deprecated. When possible, consider moving your styles to Mapbox Studio instead. Mapbox Studio Classic styles (CartoCSS in .tm2 files) are converted to code on Mapbox servers, so it's assumed you already have the styles on your local machine. You can re-upload these to your new account if they reference sources available as a tileset in your account. GeoJSON or KML can be downloaded and re-uploaded to your new account as a tileset and imported to a new Mapbox Studio or Mapbox Studio Classic project. Approach 2: Reference a public style By referencing public styles, you can use Mapbox styles created on other Mapbox accounts in your own application. This approach can be particularly useful if your organization has multiple Mapbox accounts each with their own custom styles, fonts, and sprites. In this scenario, you have a style from Account A and you’d like Account B to use that style in an application. By default, Mapbox styles are Private. Navigate to your Styles page and open the menu for the style you want to share. Select Make public. Once you set the style to Public, you can reference the style within any application by copying the Style URL within the Styles page. Special note: A Public URL can be referenced by any application using any access token. Here’s a quick example of how this might look using our Mapbox GL JS library: mapboxgl.accessToken = '<ACCESS TOKEN FROM ACCOUNT B>'; var map = new mapboxgl.Map( { container: 'map', // container id style: '<PUBLIC STYLE URL FROM ACCOUNT A>', // stylesheet location center: [-74.50, 40], // starting position [lng, lat] zoom: 9 // starting zoom } ); Was this page helpful? Yes No",Transfer styles between accounts,,,,,,,,,,,,,Approach 1: Download and re-upload a style,Styles made with Mapbox Studio,Projects made with Mapbox Studio Classic,Approach 2: Reference a public style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,style,A style is a document that defines the visual appearance of a map.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"style A style is a JSON document that defines the visual appearance of a map. Styles are created with the Mapbox Studio style editor or written independently and uploaded to your account. They adhere to the Mapbox Style Specification and include information about data sources, style layers, sprites, glyphs, and metadata. Styles are rendered by Mapbox GL JS, the Mapbox Maps SDK for Android, the Mapbox Maps SDK for iOS, or the Mapbox Static Images API. For more information about styles, explore the Mapbox Studio manual. Looking for classic style? Was this page helpful? Yes No",style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Get started with the Isochrone API,"Create a web app using the Mapbox Isochrone API that allows users to visualize how far they could walk, bike, or drive within a given amount of time.",https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,JavaScript,,"intermediate JavaScript Get started with the Isochrone API Prerequisite Familiarity with front-end development concepts. This tutorial demonstrates how you can use the Mapbox Isochrone API, which uses Mapbox routing profiles and travel times, to create a web app that allows users to estimate how far they could travel by foot, bicycle, or car within a set amount of time. Getting started To complete this tutorial, you will need: A Mapbox access token. Your Mapbox access tokens are on your Account page. Mapbox GL JS. Mapbox GL JS is a JavaScript API for building web maps. Mapbox Isochrone API. The Isochrone API computes areas that are reachable within a specified amount of time from a location, and returns the reachable regions as contours of polygons or lines that you can display on a map. Mapbox Assembly. Assembly is an open source CSS framework you will use to style the user interface for your app. jQuery. jQuery is a JavaScript library you will use to add your API request to your application. A text editor. Use the text editor of your choice for writing HTML, CSS, and JavaScript. Using the Isochrone API An Isochrone API request requires three parameters: profile: The Mapbox routing profile that the query should use. This can be walking for pedestrian and hiking travel times, cycling for travel times by bicycle, or driving for travel times by car. coordinates: A { longitude,latitude } coordinate pair around which to center the isochrone lines. contours_minutes: Times that describe the duration in minutes of the trip. This can be a comma-separated list of up to four times. The maximum duration is 60 minutes. https://api.mapbox.com/isochrone/v1/mapbox/ { profile } / { coordinates } .json? { contours_minutes } &access_token=YOUR_MAPBOX_ACCESS_TOKEN The Isochrone API also accepts several optional parameters that can be used to customize the query. For this app, you will be using one optional parameter: polygons: This parameter specifies whether to return the contours as GeoJSON polygons or linestrings. When polygons=true, any contour that forms a ring is returned as a polygon. To learn more about the Isochrone API and its other optional parameters, explore the Isochrone API documentation. This example query uses the driving routing profile, has a contours_minutes of 15, and has the polygons parameter set to true: https://api.mapbox.com/isochrone/v1/mapbox/driving/-117.17282,32.71204?contours_minutes=15&polygons=true&access_token= YOUR_MAPBOX_ACCESS_TOKEN To see the JSON response to this query, you can paste it into your browser. The response's geometry object contains an array of coordinates that describe the outlines of the isochrone contour. The response also contains a features object that describes how the isochrone should be drawn, including its fill color and fill opacity. You will use the information returned by the Isochrone API to draw and style the contours of the returned isochrone to the app's map. Create a map To start the app, you will create a map using Mapbox GL JS. Open your text editor. Create a new file named index.html. Set up this new HTML file by pasting the following code into your text editor. <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Get started with the Isochrone API</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <!-- Import Mapbox GL JS --> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <!-- Import Assembly --> <link href='https://api.mapbox.com/mapbox-assembly/ v0.23.2 /assembly.min.css' rel='stylesheet'> <script src='https://api.mapbox.com/mapbox-assembly/ v0.23.2 /assembly.js'></script> <!-- Import jQuery --> <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <!-- Create a container for the map --> <div id='map'></div> <script> // Add your Mapbox access token mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Specify the container ID style: 'mapbox://styles/mapbox/streets-v 11 ', // Specify which map style to use center: [-77.0369,38.895], // Specify the starting position zoom: 11.5, // Specify the starting zoom } ); </script> </body> </html> This code creates the structure of the page. It also imports Mapbox GL JS, Assembly, and jQuery in the <head> of the page. The Mapbox GL JS JavaScript and CSS files allow you to use Mapbox GL JS functionality and map style, and the Assembly CSS framework allows you to further refine the style of the non-map elements on the page. jQuery allows you to use Ajax to parse your Isochrone API call. There is a <div> element with the ID map in the <body> of the page. This <div> is the container in which the map will be displayed on the page. Save your changes. Open the HTML file in your browser to see the rendered map, which is centered on the Mapbox headquarters in Washington D.C. Add the sidebar Next, add a sidebar to the web app that will allow users to select a transportation profile and time duration. In the <body> of your HTML, add a new <div>. This <div> holds the app's options and uses Assembly classes for styling. Using Assembly to style your app The code for the form uses Assembly classes that provide CSS styling for the specified elements. For example, applying the classes absolute fl my24 mx24 py24 px24 bg-gray-faint round to the parent div sets its position to absolute and floats it to the left, gives it margin and padding of 24 pixels, sets the background to a light gray, and adds a border radius to round the corners. In your own app, you could also use plain CSS or the CSS framework of your choice to style the sidebar and the buttons instead of using Assembly. <div class='absolute fl my24 mx24 py24 px24 bg-gray-faint round'> <form id='params'> <h4 class='txt-m txt-bold mb6'>Chose a travel mode:</h4> <div class='mb12 mr12 toggle-group align-center'> <label class='toggle-container'> <input name='profile' type='radio' value='walking'> <div class='toggle toggle--active-null toggle--null'>Walking</div> </label> <label class='toggle-container'> <input name='profile' type='radio' value='cycling' checked> <div class='toggle toggle--active-null toggle--null'>Cycling</div> </label> <label class='toggle-container'> <input name='profile' type='radio' value='driving'> <div class='toggle toggle--active-null toggle--null'>Driving</div> </label> </div> <h4 class='txt-m txt-bold mb6'>Chose a maximum duration:</h4> <div class='mb12 mr12 toggle-group align-center'> <label class='toggle-container'> <input name='duration' type='radio' value='10' checked> <div class='toggle toggle--active-null toggle--null'>10 min</div> </label> <label class='toggle-container'> <input name='duration' type='radio' value='20'> <div class='toggle toggle--active-null toggle--null'>20 min</div> </label> <label class='toggle-container'> <input name='duration' type='radio' value='30'> <div class='toggle toggle--active-null toggle--null'>30 min</div> </label> </form> </div> This code and the Assembly classes applied to it create a sidebar that contains toggle buttons that users will be able to select their desired mode of transportation (walking, cycling, or driving) and the amount of time to spend (10, 20, or 30 minutes). Save your work and refresh the page. The sidebar will display on the left side of the page. While it looks good, clicking the buttons doesn't do anything — yet. In the next step, you will add a call to the Isochrone API, which you will be able to hook up to the user interface to create an interactive app. Add the Isochrone API To integrate the Isochrone API into your app, you will write a new function, getIso, that will construct the query string and will use Ajax to make the Isochrone API call. Add the following code to your JavaScript, after the map variable that you used to initialize the map: // // Create variables to use in getIso() var urlBase = 'https://api.mapbox.com/isochrone/v1/mapbox/'; var lon = -77.034; var lat = 38.899; var profile = 'cycling'; var minutes = 10; // Create a function that sets up the Isochrone API query then makes an Ajax call function getIso() { var query = urlBase + profile + '/' + lon + ',' + lat + '?contours_minutes=' + minutes + '&polygons=true&access_token=' + mapboxgl.accessToken; $.ajax( { method: 'GET', url: query } ).done(function(data) { console.log(data); } ) } ; // Call the getIso function // You will remove this later - it's just here so you can see the console.log results in this step getIso(); Since you have not set up the layers yet that will draw the isochrone contour described in the response to the map, this code prints the results of the query to the console. Save your work and refresh the page, and open your browser's developer tools panel. You will see the Isochrone API response object printed out to the console. Draw the isochrone contour In the last step, you created a console.log statment to view the API response. But for this app, you want to show the isochrone contours on the map! To do this in Mapbox GL JS, you need to set up a new source and a new layer. Learn more about the addSource and addLayer methods in the Mapbox GL JS documentation. Remove the getIso(); call from the bottom of your JavaScript. Replace it with the following code: map.on('load', function() { // When the map loads, add the source and layer map.addSource('iso', { type: 'geojson', data: { 'type': 'FeatureCollection', 'features': [] } } ); map.addLayer( { 'id': 'isoLayer', 'type': 'fill', // Use ""iso"" as the data source for this layer 'source': 'iso', 'layout': { } , 'paint': { // The fill color for the layer is set to a light purple 'fill-color': '#5a3fc0', 'fill-opacity': 0.3 } } , ""poi-label""); // Make the API call getIso(); } ); Next, swap the console.log(data) statement in the getIso function with the following code, which will set the iso source to the data returned by the API call: // Set the 'iso' source's data to what's returned by the API query map.getSource('iso').setData(data); Save your changes and refresh the page in your browser. An isochrone contour for the hardcoded parameters (the cycling routing profile and a trip duration of 10 minutes) will be drawn to the map. Make the app interactive Now, you need to hook the buttons that you created earlier up to your JavaScript so that users can change the routing profile and the trip duration and see the results displayed on the map. Add the following code to the bottom of your JavaScript, before the closing </script> tag: // Target the ""params"" form in the HTML portion of your code var params = document.getElementById('params'); // When a user changes the value of profile or duration by clicking a button, change the parameter's value and make the API query again params.addEventListener('change', function(e) { if (e.target.name === 'profile') { profile = e.target.value; getIso(); } else if (e.target.name === 'duration') { minutes = e.target.value; getIso(); } } ); Now, when you click the buttons to change the routing profile or the trip duration, the event listener sets the parameter in the query to the new value and runs the getIso function again. This in turn redraws the new isochrone contours to the map. Save your changes and refresh the page in your browser. Click on different combinations of routing profiles and trip durations to see the isochrone contour change. Add a marker As the last step, you will add a marker to your map at the coordinates of the query to make the center of the isochrone contour more distinct. In this case, the coordinates are set to the Mapbox office in Washington D.C. Add the following code to your JavaScript, before the map.on('load') function: var marker = new mapboxgl.Marker( { 'color': '#314ccd' } ); // Create a LngLat object to use in the marker initialization // https://docs.mapbox.com/mapbox-gl-js/api/#lnglat var lngLat = { lon: lon, lat: lat } ; To draw the marker on the map when the map loads, add the following code inside of your map.on('load') function: // Initialize the marker at the query coordinates marker.setLngLat(lngLat).addTo(map); Now, when you save your work and refresh the page, you will see a blue marker at the specified coordinates. Final product You have created an app that uses the Mapbox Isochrone API to visualize how far a person could walk, bike, or drive within a given amount of time. The final HTML file will look like the following: <!DOCTYPE html> <html> <head> <meta charset='utf-8' /> <title>Get started with the Isochrone API</title> <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' /> <!-- Import Mapbox GL JS --> <script src='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.js'></script> <link href='https://api.tiles.mapbox.com/mapbox-gl-js/ v1.2.0 /mapbox-gl.css' rel='stylesheet' /> <!-- Import Assembly --> <link href='https://api.mapbox.com/mapbox-assembly/ v0.23.2 /assembly.min.css' rel='stylesheet'> <script src='https://api.mapbox.com/mapbox-assembly/ v0.23.2 /assembly.js'> </script> <!-- Import jQuery --> <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script> <style> body { margin: 0; padding: 0; } #map { position: absolute; top: 0; bottom: 0; width: 100%; } </style> </head> <body> <!-- Create a container for the map --> <div id='map'></div> <!-- Create a sidebar with buttons for each option --> <div class='absolute fl my24 mx24 py24 px24 bg-gray-faint round'> <form id='params'> <h4 class='txt-m txt-bold mb6'>Chose a travel mode:</h4> <div class='mb12 mr12 toggle-group align-center'> <label class='toggle-container'> <input name='profile' type='radio' value='walking'> <div class='toggle toggle--active-null toggle--null'>Walking</div> </label> <label class='toggle-container'> <input name='profile' type='radio' value='cycling' checked> <div class='toggle toggle--active-null toggle--null'>Cycling</div> </label> <label class='toggle-container'> <input name='profile' type='radio' value='driving'> <div class='toggle toggle--active-null toggle--null'>Driving</div> </label> </div> <h4 class='txt-m txt-bold mb6'>Chose a maximum duration:</h4> <div class='mb12 mr12 toggle-group align-center'> <label class='toggle-container'> <input name='duration' type='radio' value='10' checked> <div class='toggle toggle--active-null toggle--null'>10 min</div> </label> <label class='toggle-container'> <input name='duration' type='radio' value='20'> <div class='toggle toggle--active-null toggle--null'>20 min</div> </label> <label class='toggle-container'> <input name='duration' type='radio' value='30'> <div class='toggle toggle--active-null toggle--null'>30 min</div> </label> </form> </div> <script> // Add your Mapbox access token mapboxgl.accessToken = ' YOUR_MAPBOX_ACCESS_TOKEN '; var map = new mapboxgl.Map( { container: 'map', // Specify the container ID style: 'mapbox://styles/mapbox/streets-v 11 ', // Specify which map style to use center: [-77.0369, 38.895], // Specify the starting position zoom: 11.5, // Specify the starting zoom } ); // Create variables to use in getIso() var urlBase = 'https://api.mapbox.com/isochrone/v1/mapbox/'; var lon = -77.034; var lat = 38.899; var profile = 'cycling'; var minutes = 10; // Create a function that sets up the Isochrone API query then makes an Ajax call function getIso() { var query = urlBase + profile + '/' + lon + ',' + lat + '?contours_minutes=' + minutes + '&polygons=true&access_token=' + mapboxgl.accessToken; $.ajax( { method: 'GET', url: query } ).done(function(data) { // Set the 'iso' source's data to what's returned by the API query map.getSource('iso').setData(data); } ) } ; var marker = new mapboxgl.Marker( { 'color': '#314ccd' } ); // Create a LngLat object to use in the marker initialization // https://docs.mapbox.com/mapbox-gl-js/api/#lnglat var lngLat = { lon: lon, lat: lat } ; map.on('load', function() { // When the map loads, add the source and layer map.addSource('iso', { type: 'geojson', data: { ""type"": 'FeatureCollection', ""features"": [] } } ); map.addLayer( { 'id': 'isoLayer', 'type': 'fill', // Use ""iso"" as the data source for this layer 'source': 'iso', 'layout': { } , 'paint': { // The fill color for the layer is set to a light purple 'fill-color': '#5a3fc0', 'fill-opacity': 0.3 } } , ""poi-label""); // Initialize the marker at the query coordinates marker.setLngLat(lngLat).addTo(map); // Make the API call getIso(); } ); // Target the ""params"" form in the HTML portion of your code var params = document.getElementById('params'); // When a user changes the value of profile or duration by clicking a button, change the parameter's value and make the API query again params.addEventListener('change', function(e) { if (e.target.name === 'profile') { profile = e.target.value; getIso(); } else if (e.target.name === 'duration') { minutes = e.target.value; getIso(); } } ); </script> </body> </html> Next steps To build on top of the tools and techniques you used in this tutorial, explore the following resources: Learn more about how you can use the Isochrone API's optional parameters to influence what gets returned in the response object in the Isochrone API documentation. Learn more about adding layers to a map using Mapbox GL JS in the Add a GeoJSON line example and in the addLayer documentation. Was this page helpful? Yes No",Get started with the Isochrone API,,,,,,,,,,,,,Getting started,Using the Isochrone API,Create a map,Add the sidebar,Add the Isochrone API,Draw the isochrone contour,Make the app interactive,Add a marker,Final product,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Add a WMS source,Adding an external Web Map Service layer to the map.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Add a WMS source Adding an external Web Map Service layer to the map. Was this example helpful? Yes No,Add a WMS source,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Optimize map label placement,Optimize label placement on web and mobile maps.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,troubleshooting,,,"Optimize map label placement Map labels are applied to Mapbox GL maps as features in symbol layers. Symbol layers are the most complex layer type in the Mapbox Style Specification. The symbol layer type offers detailed typographic styling options for your labels and map data. This guide will walk through a subset of layout properties that are relevant to label placement. You can see the complete list of layout and paint properties for symbol layers, including those responsible for label language, style, and more, in the Mapbox Style Specification. Label collision Collision detection is the process of preventing labels on a map from overlapping each other. Styles use four properties to prevent label collision: By default icon-allow-overlap and text-allow-overlap are set to false. If set to true, the icon or text will be visible even if it collides with other symbols drawn before. By default icon-ignore-placement and text-ignore-placement are set to false. If set to true, other symbols can be visible even if they collide with the text or icon. Use the toggles below to understand the impact of various properties on the visibility of points of interest. All properties are false by default. icon-allow-overlap text-allow-overlap icon-ignore-placement text-ignore-placement For reliable collision detection across layers that come from different data sources, use source compositing. Source compositing happens by default for new styles created in Mapbox Studio. If you are adding sources on the client, they will not be composited. While detecting and preventing label collision helps improve map legibility, it can result in many hidden labels. Use collision detection and variable label placement to keep labels legible while increasing the density of labels displayed on the map. Label density Variable label placement is a map design concept in which more than one placement option is attempted for each label. This maximizes the chances that the map will show each label. Variable label placement is powered by three layout properties in the Mapbox Style Specification: text-variable-anchor, text-radial-offset, and text-justify. The digaram below illustrates each possible position relative to the data point: anchor: bottom-right justify: right anchor: bottom justify: center anchor: bottom-left justify: left anchor: right justify: right anchor: center justify: center anchor: left justify: left anchor: top-right justify: right anchor: top justify: center anchor: top-left justify: left text-variable-anchor text-variable-anchor accepts an array of text-anchor positions as the input value. The map renderer tries to place the label at the positions in this list in the provided order of the array at collision detection time. For example, in a layer with text-variable-anchor set to [""top"", ""bottom"", ""left""], the map renderer would first try to place each label anchored at the top. Then, if there wasn't room for the label at that position, it would try to place the label anchored at the bottom. And finally, if the label could not fit on the map anchored at the top or bottom, it would try anchoring on the left side. If none of these anchor positions can be used, the map will not display the label. If a user changes the map zoom after a label has been placed, the map renderer will try to place the label in its original position first before moving on to the rest of the positions specified in the text-variable-anchor array. This exception makes map rendering more efficient, but can sometimes be surprising. The order in which each label in a layer will go through this process is described in detail below in Label hierarchy. text-radial-offset text-radial-offset accepts a scalar value that represents the offset distance of text from its anchor and is applied to the text-variable-anchor. Positive values specify right and down, while negative values specify left and up. text-justify text-justify specifies the justification of the label. It can be set to one of auto, left, center, or right. Specifying auto will automatically set the justification towards the anchor position. Platform-specific examples The exact syntax used to implement variable label placement varies by platform. View examples for web and mobile using variable label placement to improve label density: Mapbox GL JS example Maps SDK for Android example Label hierarchy Some labels on your map may be more relevant to a wider audience or more important to a particular audience. When two labels collide, the draw order of features determines which label to display and which to hide. There are several factors that contribute to draw order. Order of layers Map styles contain a collection of style layers. Layers are specified in your style JSON and are drawn in order. This means that the first layer defined in the style JSON will be drawn first and will appear below all layers that follow. The last layer defined in the style JSON will be drawn last, on top of all other layers. You can increase the chances that a layer's labels will be visible by placing that layer further down in your style JSON. Order of features inside layers For each layer in your style, you must specify a source. For vector sources, you must also specify a source layer for each style layer. The draw order of features inside a single vector tileset source layer can be specified in two ways: At the time of tileset creation: If you are using the Mapbox Tilesets API, you can specify the order of features inside a single source layer using the order option. See the Tilesets API recipe reference. At runtime with symbol-sort-key: If you don't have control over the data at the time of tileset creation, you can influence the draw order of features at runtime using symbol-sort-key. For GeoJSON sources, the draw order of features is determined by the order of features in the feature collection. Features are draw in descending order. Was this page helpful? Yes No",Optimize map label placement,,,,,,,,,,,,,Label collision,Label density,text-variable-anchor,text-radial-offset,text-justify,Platform-specific examples,Label hierarchy,Order of layers,Order of features inside layers,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Vector tiles,Mapbox Streets v7,Reference documentation for the Mapbox Streets v7 tileset.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,reference,,,"Mapbox Streets v7 Source id: mapbox.mapbox-streets-v7 Note We recommend moving to Mapbox Streets v8 for additional features and improvements. But, Mapbox Streets v7 will continue to receive data updates from OpenStreetMap. This is an in-depth guide to the data inside the Mapbox Streets vector tile source to help with styling. Overview OpenStreetMap Mapbox Streets vector tiles are largely based on data from OpenStreetMap, a free & global source of geographic data built by volunteers. An understanding of the OpenStreetMap data structure and tagging system is not necessary to make use of Mapbox Streets vector tiles, though it's helpful to understand some of the details. When you publicly use styles or software that use Mapbox Streets vector tiles, you must display proper attribution. Name fields There are 12 different name fields for each of the label layers: Field Description name The name (or names) used locally for the place. name_ar Arabic (if available, otherwise same as name) name_en English (if available, otherwise same as name) name_es Spanish (if available, otherwise same as name_en) name_fr French (if available, otherwise same as name_en) name_de German (if available, otherwise same as name_en) name_pt Portuguese (if available, otherwise same as name_en) name_ru Russian (if available, otherwise same as name) name_ja Japanese (if available, otherwise same as name) name_ko Korean (if available, otherwise same as name) name_zh Chinese* (if available, otherwise same as name) name_zh-Hans Simplified Chinese* (if available, otherwise same as name) * The name_zh field contains Mandarin using simplified Chinese characters for our custom label layers: #country_label, #state_label, and #marine_label. All other label layers are sourced from OpenStreetMap and may contain one of several dialects and either simplified or traditional Chinese characters in the name_zh field. The name_zh-Hans field is similar, except any Traditional Chinese characters are automatically transformed to Simplified Chinese. Boolean fields Some fields represent a boolean condition; the value may be either true or false. To keep the vector tiles compact these fields may be stored as integers, where 0 = false and 1 = true. Multiple geometry types Mapnik vector tiles support multiple geometry types in the same layer. The Mapbox Streets source takes advantage of this for some layers. A geometry in the vector tile can be one of 3 types: Point Linestring / multilinestring Polygon / multipolygon In Mapbox Studio, you can select one, two, or all three of these geometry types with the Geometry Type toggles in each layer's Select data tab. Data updates The current supported version of the Mapbox Streets vector tiles receives regular data updates as new information becomes available and existing information is improved. Layer Source most layers OpenStreetMap replication feed #admin custom OpenStreetMap processing #water (ocean parts) OpenStreetMap Data #marine_label, #country_label, #state_label custom data OpenStreetMap IDs OpenStreetMap IDs are not stored as object properties but as object IDs within the vector tile. This means they are not available for styling via Mapbox Studio, but can still be interacted with via Mapbox GL JS and other vector tile libraries. OpenStreetMap ID spaces are not unique across node, way, and relation object types. To make them unique for vector tiles, the IDs are transformed based on their OpenStreetMap object type. OpenStreetMap type OpenStreetMap ID transform node id × 10 eg. 123 → 1230 way (id × 10) + 1 eg. 123 → 1231 relation (id × 10) + 4 eg. 123 → 1234 Often, multiple objects from OpenStreetMap will be combined into a single object in our vector tiles. For example, water polygons are unioned to avoid seams and road lines are joined to save space and simplify better. In these cases the osm_id will either be 0, or one of the input IDs chosen at random. Layer Reference The mapbox-streets-v8 tileset contains the following layers. For reference, the current minimum-available zoom level for each layer is mentioned, but please note that this is subject to change as we roll out updates and improvements. It also does not apply to all features within a layer - only the most prominent features are available at lower-numbered zoom levels, and more features are available as you zoom in. Layer Min. zoom level landuse 5 waterway 7 water 0 aeroway 9 barrier_line 13 building 13 landuse_overlay 5 road 5 admin 0 country_label 0 (max: 10) marine_label 0 (max: 9) state_label 1 (max: 11) place_label 4 water_label 8 airport_label 8 rail_station_label 12 mountain_peak_label 8 poi_label 5 motorway_junction 11 road_label 6 waterway_label 13 housenum_label 16 #landuse buffer: 4 This layer includes polygons representing both land-use and land-cover. It's common for many different types of landuse/landcover to be overlapping, so the polygons in this layer are ordered by the area of their geometries to make sure smaller objects will not be obscured by larger ones. Pay attention to use of transparency when styling - the overlapping shapes can cause muddied or unexpected colors. Classes The main field used for styling the landuse layer is class. Value Description 'aboriginal_lands' The boundary of aboriginal lands. 'agriculture' Various types of crop and farmland 'cemetery' Cemeteries and graveyards 'glacier' Glaciers or permanent ice/snow 'grass' Grasslands, meadows, fields, lawns, etc 'hospital' Hospital grounds 'industrial' Only includes airport areas 'park' City parks, village greens, playgrounds, national parks, nature reserves, etc 'pitch' Sports fields & courts of all types 'rock' Bare rock, scree, quarries 'sand' Sand, beaches, dunes 'school' Primary, secondary, post-secondary school grounds 'scrub' Bushes, scrub, heaths 'wood' Woods and forestry areas Type The type field is pulled from the primary OpenStreetMap tags for that class. #waterway buffer: 4 The waterway layer contains classes for rivers, streams, canals, etc represented as lines. These classes can represent a wide variety of possible widths. Since larger rivers and canals are usually also represented by polygons in the #water layer, make your line styling biased toward the smaller end of the scales. It should also be under the #water layer. Classes and types The waterway layer has two fields for styling - class and type - each with similar values. Value Description 'river' Everything from the Amazon down to small creeks a couple meters wide 'canal' Medium to large artificial waterway 'stream' Very small waterway, usually no wider than a meter or two 'stream_intermittent' Class only. A stream that does not always have water flowing through it. 'drain' Medium to small artificial channel for rainwater drainage, often concrete lined. 'ditch' Small artificial channel dug in the ground for rainwater drainage. #water buffer: 8 This layer includes all types of water bodies: oceans, rivers, lakes, ponds, reservoirs, fountains, and more. It is a simple polygon layer with no differentiating types or classes, and consists of a single merged shape per tile. This allows for seamless stroke and transparency styling, but means there is no way to filter out or highlight specific water bodies or a partial subset of them. Each zoom level includes a set of water bodies that has been filtered and simplified according to scale. The tileset shows only oceans, seas, and large lakes at the lowest zoom levels, while smaller and smaller lakes and ponds appear as you zoom in. #aeroway buffer: 4 The aeroway layer includes both lines and polygons representing runways, helipads, etc. Types The type field separates different types of aeroways for styling. Value Description 'runway' Where planes take off & land 'taxiway' Where planes move between runways, gates, and hangars 'apron' Where planes park, refuel, load 'helipad' Where helicopters take off & land #barrier_line buffer: 4 This layer includes lines and polygons for barriers - things such as walls and fences. Classes Value Description 'cliff' The precipice of a vertical or steep drop, gullies are included 'fence' Include various types of fence and wall barriers 'gate' Only gates that are lines or areas are included 'hedge' A line of closely spaced shrubs and tree species, which form a barrier or mark the boundary of an area 'land' Includes breakwaters and piers Cliff data from OpenStreetMap is designed such that the left-hand side of the line is the top of the cliff, and the right-hand side is the bottom. #building buffer: 2 Large buildings appear at zoom level 13, and all buildings are included in zoom level 15 and up. Underground buildings The underground field is usually false, but will be true for buildings that are underground (for example, some subway stations). Building types The type field lets you differentiate building parts from building outlines. Building part polygons intended primarily for 3D rendering have a value of building:part. Building outlines (covering the full footprint of a building) will have a value of building if tagged as building=yes on OpenStreetMap, otherwise the value will match the building tag from OpenStreetMap (see TagInfo for common values). Building heights The height field contains the height of a building or building part in meters (rounded to the nearest integer). Often this value is derived from the building:levels tag on OpenStreetMap - we estimate 3 meters per level if no exact height is specified. The min_height field contains the height in meters from the ground to the bottom of a building part, for cases where the bottom of the part is not on the ground. This allows for proper extrusion rendering of things such as sky bridges and cantilevered building parts. The extrude field is true or false depending one whether the object should be included in 3D-extrusion renderings. For example a complex building might have various building:part objects mapped with different heights and a building object representing the footprint of the entire building. Only the building:part objects are needed for 3D rendering, so the full footprint outline will have an extrude value of false. #landuse_overlay buffer: 8 This layer is for landuse / landcover polygons that your style should draw above the #water layer. Classes The main field used for styling the landuse_overlay layer is class. Value Description 'national_park' Relatively large area of land set aside by a government for human recreation and enjoyment, animal and environmental protection 'wetland' Wetlands that may include vegetation (marsh, swamp, bog) 'wetland_noveg' Wetlands that probably don't contain vegetation (mud, tidal flat) Types The type field is pulled from the primary OpenStreetMap tags for that class. #road buffer: 4 The roads layers are some of the most complex ones in Mapbox Streets. The tileset merged separate bridge and tunnel layers into road. structure field describes whether the road segment is a bridge, tunnel, ford, or none. Bridges and tunnels are not distinct from roads until zoom level 13. Classes The main field used for styling the road layers is class. Value Description 'motorway' High-speed, grade-separated highways 'motorway_link' Interchanges / on & off ramps 'trunk' Important roads that are not motorways. 'primary' A major highway linking large towns. 'secondary' A highway linking large towns. 'tertiary' A road linking small settlements, or the local centres of a large town or city. 'link' Contains link roads 'street' Standard unclassified, residential, road, and living_street road types 'street_limited' Streets that may have limited or no access for motor vehicles. 'pedestrian' Includes pedestrian streets, plazas, and public transportation platforms. 'construction' Includes motor roads under construction (but not service roads, paths, etc). 'track' Roads mostly for agricultural and forestry use etc. 'service' Access roads, alleys, agricultural tracks, and other services roads. Also includes parking lot aisles, public & private driveways. 'ferry' Those that serves automobiles and no or unspecified automobile service. 'path' Foot paths, cycle paths, ski trails. 'major_rail' Railways, including mainline, commuter rail, and rapid transit. 'minor_rail' Yard and service railways. 'aerialway' Ski lifts, gondolas, and other types of aerialway. 'golf' The approximate centerline of a golf course hole One-way roads The oneway field will have a value of either 'true' or 'false' to show whether the motor traffic on the road is one-way or not. If the road is one-way, traffic travels in the same direction as the linestring. Types The type field is the value of the road's ""primary"" OpenStreetMap tag. For most roads this is the highway tag, but for aerialways it will be the aerialway tag, and for golf holes it will be the golf tag. See TagInfo for a list of used tag values. Several classes pull in additional detail when it is available from OpenStreetMap. Possible construction class type values: 'construction:motorway' 'construction:motorway_link' 'construction:trunk' 'construction:trunk_link' 'construction:primary' 'construction:primary_link' 'construction:secondary' 'construction:secondary_link' 'construction:tertiary' 'construction:tertiary_link' 'construction:unclassifed' 'construction:residential' 'construction:road' 'construction:living_street' 'construction:pedestrian' 'construction' Possible track class type values: 'track:grade1' 'track:grade2' 'track:grade3' 'track:grade4' 'track:grade5' 'track' Possible service class type values: 'service:alley' 'service:emergency_access' 'service:drive_through' 'service:driveway' 'service:parking' 'service:parking_aisle' 'service' For the path class, the tileset made custom type assignments based on insight from various categorical, physical, and access tags from OpenStreetMap. Value Description 'steps' aka stairs 'corridor' An indoors passageway 'sidewalk' aka 'pavement' in many places outside North America 'crossing' Usually connects sidewalk lines across a road 'piste' Ski & snowboard trails, both downhill and cross-country. 'mountain_bike' Trails used primarily or exclusively for mountain biking 'hiking' Hiking trails or otherwise rough pedestrian paths 'trail' May be suitable for either hiking or mountain biking 'cycleway' Paths primarily or exclusively for cyclists 'footway' Paths primarily or exclusively for pedestrians 'path' Unspecified or mixed-use paths 'bridleway' Equestrian trails Possible ferry class type values: Value Description 'ferry_auto' Ferry serves automobiles 'ferry' No or unspecified automobile service Possible aerialway class type values: Value Description 'aerialway:cablecar' One or two large cars. The cable forms a loop, but the cars do not loop around, they move up and down on their own side. 'aerialway:gondola' Many cars on a looped cable. 'aerialway:mixed_lift' Mix of chair lifts and gondolas on the same line; may change seasonally. 'aerialway:chair_lift' Looped cable with a series of single chairs and exposed to the open air. 'aerialway:drag_lift' Includes t-bars, j-bars, platter/button lifts, and tow ropes 'aerialway:magic_carpet' Conveyor belt installed at the level of the snow, some include a canopy or tunnel. 'aerialway' Other or unspecified type of aerialway Layers The layer field is used to determine drawing order of overlapping road segments in the tunnel and bridge layers. 95% of values are -1, 1, or 0, and 99.9999% of values are between -5 and 5. #admin buffer: 4 Administrative boundary lines. These are constructed from the OpenStreetMap data in such a way that there are no overlapping lines where multiple boundary areas meet. Administrative level The admin_level field separates different levels of boundaries, using a similar numbering scheme to OpenStreetMap. Value Description 2 Countries 3 Some subnational regions or groupings: regions of Papua New Guinea, The Philippines, Venezuela; governorates of Lebanon; federal districts of Russia; some disputed and semi-autonomous regions. 4 Most first-level subnational boundaries (states, provinces, etc.) Disputes The disputed field should be used to apply a dashed or otherwise distinct style to disputed boundaries. No single map of the world will ever keep everybody happy, but acknowledging disputes where they exist is an important aspect of good cartography. Maritime boundaries The maritime field can be used as a filter to downplay or hide maritime boundaries, which are often not shown on maps. Note that the practice of tagging maritime boundaries is not entirely consistent or complete within OpenStreetMap, so some boundaries may not have this field set correctly (this mostly affects admin levels 3 & 4). ISO 3166-1 Codes The iso_3166_1 field contains the ISO 3166-1 alpha-2 code or codes that apply to a boundary. For subnational boundaries this will be a single code of the parent country. For international boundaries between two countries, the value will be the codes of both countries in alphabetical order, separated by a dash (-). #country_label buffer: 256 This layer contains points used for labeling countries. The points are placed for minimal overlap with small to medium-sized text. Names See Name fields in the overview for information about names and translations. ISO 3166-1 Code The iso_code field contains the ISO 3166-1 2-letter country code. Administrative Code For territories and other special entities in the countries layer, the admin_code field contains the ISO 3166-1 2-letter country code of the administering or ""parent"" state. Scalerank The scalerank field is intended to help assign different label styles based on the size and available room to label different countries. The possible values are 1 through 6. #marine_label buffer: 256 Points and lines for labeling major marine features such as oceans, seas, large lakes & bays. Names See Name fields in the overview for information about names and translations. Labelrank & placement The labelrank field is intended to help assign different label styles based on the size and available room to label different water bodies. The possible values are whole numbers 1 through 6. The value of the placement field will be either point or line depending on the geometry type of the object. (You can also make this distinction with a Geometry Type filter.) #state_label buffer: 256 Points for labeling states and provinces. Only a small number of countries are included. Names See Name fields in the overview for information about names and translations. Abbreviations The abbr field contains abbreviated versions of the names suitable for labeling at lower zoom levels. Area The area field is the physical area of the entity in square kilometers. Use it to help filter and size your state labels at different zoom levels. #place_label buffer: 128 This layer contains points for labeling human settlements. Names See Name fields in the overview for information about names and translations. Types The main field for styling labels for different kinds of places is type. Value Description 'city' Settlement of about 100,000 or more people. 'town' Urban or rural settlement of about 10,000-100,000 people 'village' Usually rural settlement of less than about 10,000 'hamlet' Rural settlement with a population of about 200 or fewer 'suburb' A distinct section of an urban settlement such as an annexed town, historical district, or large & important neighborhood. 'neighbourhood' A named part of a larger settlement 'island' 'islet' A small island. 'archipelago' Collective name for a group of islands 'residential' Named residential areas, including subdivisions and apartment complexes 'aboriginal_lands' Reservations and other aboriginal lands Capitals The capital field allows distinct styling of labels or icons for the capitals of countries, regions, or states & provinces. The value of this field may be 2, 3, 4, 5, or 6. National capitals are 2, and 3 through 6 represent capitals of various sub-national administrative entities. These levels come from OpenStreetMap and have different meanings in different countries - see the OpenStreetMap wiki for specific details. Scalerank The scalerank field can be used to adjust the prominence of label styles for larger and more prominent cities. The value number from 0 through 9, where 0 is the large end of the scale (for example New York City). All places other than large cities will have a scalerank of null. Localrank The localrank field can be used to adjust the label density by showing fewer labels. It is a whole number greater than 0 calculated by grouping places into a 128 pixel grid at each zoom level, then assigning each place a ranking within that grid. The most important place in that 128 pixels will get a localrank of 1, the second most important is 2, and so on. So to reduce the label density to 4 labels per tile, you can add the filter [localrank=1]. Label direction The ldir field can be used as a hint for label offset directions at lower zoom levels. For places with a scalerank value set, the ldir will be a cardinal direction such as 'N', 'E', 'SW'. #water_label buffer: 64 This layer contains points for labeling bodies of water such as lakes and ponds. Names See Name fields in the overview for information about names and translations. Area The area field holds the area of the associated water polygon in square meters (Mercator-projected units rounded to the nearest whole number, not real-world area). You can use it to adjust label size and visibility. #poi_label buffer: 64 This layer is used to place icons and labels for various points of interest (POIs). Names See Name fields in the overview for information about names and translations. Maki icons The maki field is designed to make it easier to add icons to POIs using the Maki icon project, or with other icons that follow the same naming scheme. Not all Maki icons are used, and different types of related POIs will sometimes have the same maki value (for example universities and colleges, or art supply shops and art galleries). Nameless POIs will have never have a Maki value of marker (the generic default). The possible values for the maki field are listed below. null 'airfield' 'alcohol-shop' 'amusement-park' 'aquarium' 'art-gallery' 'attraction' 'bakery' 'bank' 'bar' 'beer' 'bicycle' 'bicycle-share' 'bus' 'cafe' 'car' 'campsite' 'castle' 'cemetery' 'cinema' 'clothing-store' 'college' 'dentist' 'doctor' 'dog-park' 'drinking-water' 'embassy' 'entrance' 'fast-food' 'ferry' 'fire-station' 'fuel' 'garden' 'golf' 'grocery' 'harbor' 'heliport' 'hospital' 'ice-cream' 'information' 'laundry' 'library' 'lodging' 'monument' 'museum' 'music' 'park' 'pharmacy' 'picnic-site' 'place-of-worship' 'playground' 'police' 'post' 'prison' 'religious-christian' 'religious-jewish' 'religious-muslim' 'restaurant' 'rocket' 'school' 'shop' 'stadium' 'swimming' 'suitcase' 'theatre' 'toilet' 'town-hall' 'veterinary' 'zoo' Types The type field contains a more specific classification intended for display - for example 'Cafe', 'Hotel', 'Laundry'. These values come from the original OpenStreetMap tags and are not a limited set. Scalerank The scalerank field is intended to help assign different label styles based on the prominence of different features. Value Description 1 The POI has a large area 2 The POI has a medium-large area 3 The POI has a small area, or is of a type that is commonly large and important (for example hospital, university) 4 The POI has no known area 5 The POI has no name Controlling label density The localrank field can be used to adjust the label density by showing fewer labels. It is a whole number >=1 calculated by grouping places into a ~300m projected grid, then assigning each place a ranking within that grid. The most important place in each cell will get a localrank of 1, the second most important is 2, and so on. #road_label buffer: 8 Names See Name fields in the overview for information about names and translations. Route numbers Besides the standard name fields, there is also a ref field that holds any reference codes or route numbers a road may have. From zoom levels 6 through 10, all geometries are points and the only labels are highways shields. From zoom level 11 and up the geometries are all lines. The shield field indicates the style of shield needed for the route. Current possibilities are: Value Description default at-motorway Austria (Autobahnen) at-expressway Austria (Schnellstraßen) at-state-b Austria (Landesstraßen B) br-federal Brazil br-state Brazil bg-motorway Bulgaria bg-national Bulgaria hr-motorway Croatia hr-state Croatia hr-county Croatia cz-motorway Czech Republic cz-expressway Czech Republic cz-road Czech Republic dk-primary Denmark dk-secondary Denmark fi-main Finland fi-trunk Finland fi-regional Finland de-motorway Germany (Autobahnen) de-federal Germany (Bundesstraßen) gr-motorway Greece gr-national Greece hu-motorway Hungary hu-main Hungary in-national India in-state India nz-state New Zealand pe-national Peru pe-regional Peru pl-motorway Poland pl-expressway Poland pl-national Poland pl-voivodeship Poland ro-motorway Romania ro-national Romania ro-county Romania ro-communal Romania rs-motorway Serbia rs-state-1b Serbia rs-state-2a Serbia rs-state-2b Serbia sk-highway Slovakia sk-road Slovakia si-motorway Slovenia si-expressway Slovenia si-main Slovenia za-national South Africa za-provincial South Africa za-regional South Africa za-metropolitan South Africa se-main Sweden ch-motorway Switzerland ch-main Switzerland mx-federal United States mx-state United States us-interstate United States us-interstate-duplex United States us-interstate-business United States us-interstate-truck United States us-highway United States us-highway-duplex United States us-highway-alternate United States us-highway-business United States us-highway-bypass United States us-highway-truck United States us-state United States e-road European E-roads To aid with shield styling the reflen field conveys the number of characters present in the ref field. Values can be 1-4. If the ref is 'M27', then the reflen is 3. Classes The class field for road labels matches the #road layers. Value Description 'motorway' High-speed, grade-separated highways 'motorway_link' Interchanges / on & off ramps 'trunk' Important roads that are not motorways. 'primary' A major highway linking large towns. 'secondary' A highway linking large towns. 'tertiary' A road linking small settlements, or the local centres of a large town or city. 'link' Contains link roads 'street' Standard unclassified, residential, road, and living_street road types 'street_limited' Streets that may have limited or no access for motor vehicles. 'pedestrian' Includes pedestrian streets, plazas, and public transportation platforms. 'construction' Includes motor roads under construction (but not service roads, paths, etc). 'track' Roads mostly for agricultural and forestry use etc. 'service' Access roads, alleys, agricultural tracks, and other services roads. Also includes parking lot aisles, public & private driveways. 'ferry' Those that serves automobiles and no or unspecified automobile service. 'path' Foot paths, cycle paths, ski trails. 'major_rail' Railways, including mainline, commuter rail, and rapid transit. 'minor_rail' Yard and service railways. 'aerialway' Ski lifts, gondolas, and other types of aerialway. 'golf' The approximate centerline of a golf course hole Additional information The len field stores the length of the road segment in projected meters, rounded to the nearest whole number. This can be useful for limiting some label styles to longer roads. #motorway_junction buffer: 8 This layer contains point geometries for labeling motorway junctions (aka highway exits). Classes and types match the types in the road layer. Label text The motorway junction layer has a ref field and a name field for styling labels. The reflen field tells you how long the ref value is in case you want to style this layer with shields. Classes & types The class and type fields tell you what kind of road the junction is on. See the #road layer for possible values. #waterway_label buffer: 8 This layer contains line geometries that match those in the #waterway layer but with name fields for label rendering. Label text See Name fields in the overview for information about names and translations. Classes & types The class and type fields match those in the #waterway layer. Value Description 'river' Everything from the Amazon down to small creeks a couple meters wide 'canal' Medium to large artificial waterway 'stream' Very small waterway, usually no wider than a meter or two 'stream_intermittent' Class only. A stream that does not always have water flowing through it. 'drain' Medium to small artificial channel for rainwater drainage, often concrete lined. 'ditch' Small artificial channel dug in the ground for rainwater drainage. #airport_label buffer: 64 This layer contains point geometries that are one of: airport, airfield, heliport, and rocket. Label text See Name fields in the overview for information about names and translations. Airport Codes The ref field contains short identifier codes for many airports. These are pulled from the OpenStreetMap tags iata, ref, icao, or faa (in order of preference). Maki The maki field lets you assign different icons to different types of airports. Value Description 'airport' Most commercial airports 'airfield' Smaller airports & private airfields 'heliport' For helicopters 'rocket' Spaceflight facilities Scalerank The scalerank field is a number representing the size / importance of the airport. Possible values are 1 (large airport) through 4 (small airport). #rail_station_label buffer: 64 This layer contains point geometries with name fields for label rendering. Label text See Name fields in the overview for information about names and translations. Maki The maki field lets you assign icons to the rail station based on a few basic station types: Value Description 'rail' Default rail station 'rail-metro' Station for a subway, metro, or other rapid-transit system 'rail-light' Light rail station 'entrance' Specific station entrance points (for example stairs, escalators, elevators) Network The network field lets you assign more specific icons for rail stations that are part of specific local or regional transit systems. They don't necessarily correspond to a specific network - for example de-u-bahn applies to any U-Bahn network in Germany since these can all use the same icon in a map style. Some stations serve multiple networks; in these cases, multiple network names are joined with a dot (in alphabetical order). If none of the specific networks below apply to a station, the network value will be the same as the maki value (see previous section). Value Description 'barcelona-metro' Barcelona, Spain 'boston-t' Boston, Massachusetts 'chongqing-rail-transit' Chongqing, China 'de-s-bahn' Germany 'de-s-bahn.de-u-bahn' Germany 'de-u-bahn' Germany 'delhi-metro' Delhi, India 'gb-national-rail' London, United Kingdom 'gb-national-rail.london-dlr' London, United Kingdom 'gb-national-rail.london-dlr.london-overground.london-tfl-rail.london-underground' London, United Kingdom 'gb-national-rail.london-dlr.london-overground.london-underground' London, United Kingdom 'gb-national-rail.london-dlr.london-underground' London, United Kingdom 'gb-national-rail.london-overground' London, United Kingdom 'gb-national-rail.london-overground.london-tfl-rail.london-underground' London, United Kingdom 'gb-national-rail.london-overground.london-underground' London, United Kingdom 'gb-national-rail.london-tfl-rail' London, United Kingdom 'gb-national-rail.london-tfl-rail.london-overground' London, United Kingdom 'gb-national-rail.london-tfl-rail.london-underground' London, United Kingdom 'gb-national-rail.london-underground' London, United Kingdom 'hong-kong-mtr' Hong Kong 'kiev-metro' Kiev, Ukraine 'london-dlr' Docklands Light Rail, London, United Kingdom 'london-dlr.london-tfl-rail' London, United Kingdom 'london-dlr.london-tfl-rail.london-underground' London, United Kingdom 'london-dlr.london-underground' London, United Kingdom 'london-overground' London Overground, United Kingdom 'london-overground.london-tfl-rail' London Overground, United Kingdom 'london-overground.london-tfl-rail.london-underground' London Overground, United Kingdom 'london-overground.london-underground' London, United Kingdom 'london-tfl-rail' London, United Kingdom 'london-tfl-rail.london-underground' London, United Kingdom 'london-underground' London Underground, United Kingdom 'madrid-metro' Madrid, Spain 'mexico-city-metro' Mexico City, Mexico 'milan-metro' Milan, Italy 'moscow-met",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox Streets v7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Expressions,The Mapbox Maps SDK for Android.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Expressions Like the rest of the Mapbox developer experience, expressions are all about fine-grain control. Expressions enable you to dynamically style spatial data based on the data's properties. They offer you many flexible and powerful operations. You can style data with multiple feature properties at once, apply conditional logic, and manipulate data with arithmetic or string operations for a more sophisticated relationship between your data and how it is styled. The value for any layout property, paint property, or filter may be specified as an expression. An expression defines a formula for computing the value of the property using the operators described below. The set of expression operators provided by Mapbox GL includes: Mathematical operators for performing arithmetic and other operations on numeric values Logical operators for manipulating boolean values and making conditional decisions String operators for manipulating strings Data operators, providing access to the properties of source features Camera operators, providing access to the parameters defining the current map view Expressions are represented as JSON arrays. The first element of an expression array is a string naming the expression operator. For example, ""*"" or ""case"". The next elements (if any) are the arguments to the expression. Each argument is either a literal value (a string, number, boolean, or null), or another expression array. Popular expressions While there are many expressions to choose from, you should first become familiar with the following expressions that will likely help you achieve your data-driven styling goals: ​​get match switchCase equal ​​literal Learning resources There are several Mapbox resources that can provide more guidance and examples for you to understand the concept of expressions. Javadocs – The Expressions Java class in the Mapbox Maps SDK for Android offers explanations and code samples to explain how each expression method should be used. The Mapbox Android demo app – The app's data-driven styling folder has many examples that use expressions in various ways. Don't have the app? Click here to download it. Introductory blog post – Read our blog post that was published to introduce expressions when they were released for Mapbox GL JS. The post doesn't have examples/syntax related for the Android platform, but it is helpful for understanding the concept of expressions and why Mapbox introduced expressions in the first place. Style specification – Want the minute details about each expression? The Mapbox Style Specification has them. Was this page helpful? Yes No",Expressions,,,,,,,,,,,,,Popular expressions,Learning resources,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Create a map in Unity,Use the Mapbox Maps SDK for Unity to create a visualization of 3D buildings on top of a 3D terrain map for use in a Unity application.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,No code,,"beginner No code Create a map in Unity Prerequisite Familiarity with Unity. This tutorial will walk you through how to create a visualization of 3D buildings on top of a 3D terrain map for use in a Unity application. You will: Set up a Mapbox project in Unity. Learn about the Mapbox-specific terminology, tools, and services you’ll use to build your visualization. Add a map to your scene. Customize your map for your specific needs. Learn how to add buildings and other vector data. This tutorial is for versions 1.4.0 and beyond. If you are using version 1.3.0 or earlier, read the mesh generation tutorials instead. Getting started Before getting started, you’ll need to: Install the Mapbox Maps SDK for Unity. For full installation instructions, visit https://www.mapbox.com/unity-sdk. Create an empty Unity project. Configure your Mapbox access token in your Unity project. For token configuration instructions, visit http://www.mapbox.com/unity-sdk/#token. Set up your project Your new, empty scene will need a Map object to display a map. We provide a Map prefab already that you can drag and drop into your scene. This Map object comes with an Abstract Map script, where you can adjust map settings like location, map style, elevation, and more. To see what the default Map looks like, hit Play. You have a map! Note that you may need to change the camera’s position to see the map properly in the Game panel, but you can see it in the Scene panel. Customize your map Now you’ll learn how to style two kinds of maps: one with rich satellite imagery and elevation data, and one with vector data to show buildings. You will learn how to use various settings in Abstract Map to change a map’s location, map style, elevation, and vector layers. Create a map of Mt. Hood, Oregon Select your Map object and look at the Inspector window. Under the Abstract Map general settings, either change the location to 45.374218, -121.688341 or search “Mt Hood”. Set the zoom level to 13. Open the “Others” settings and toggle Snap Map to Zero. Now open the image settings and change the Data Source to “Mapbox Satellite”. Finally, open the terrain settings and change the Elevation Layer Type to “Terrain with Elevation”. Save your scene and hit play. Switch to your Scene panel and you’ll see something like this: Now you'll make a map of downtown Manhattan! Create a map of downtown Manhattan To make this map of Manhattan, you can either start over in a new scene, or change the settings in your existing scene. It’s up to you! First set the location to 40.706843, -74.011370 or search “New York Stock Exchange”, and set the zoom level to 17. Next, go to the image settings and change the Data Source to “Mapbox Dark”. In the terrain settings, change the Elevation Layer Type to “Flat Terrain”. Now open up the vector settings. Change the Data Source to “Mapbox Streets”. Create a new visualizer by clicking the “Add Visualizer” button. It will now show up in the vector layer visualizers list as “Untitled”. Click it and hit the Enter key to rename it to “Buildings”. Click your “Buildings” visualizer and find the Extrusion Type setting. Change it to “Property Height”. Next, look for the Material Options setting. Next to Roof Material and Wall Material is a small circular icon. Click it, and select ”BuildingMaterial” for both. Hit play to see Manhattan with buildings! Next steps To learn more about what you can do with Mapbox Maps SDK for Unity, read the SDK documentation. Was this page helpful? Yes No",Create a map in Unity,,,,,,,,,,,,,Getting started,Set up your project,Customize your map,"Create a map of Mt. Hood, Oregon",Create a map of downtown Manhattan,Next steps,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Help,Get started with expressions using the Mapbox Maps SDK for iOS,Create a map for iOS that styles a circle based on a data attribute.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,tutorial,Swift,,"intermediate Swift, Objective-C Get started with expressions using the Mapbox Maps SDK for iOS Prerequisite Familiarity with Xcode and either Swift or Objective-C, and completion of the Mapbox Maps SDK for iOS installation guide. In this guide you’ll learn how to write expressions using the Mapbox Maps SDK for iOS to style custom data based on a data attribute and by zoom level. Getting started This guide assumes you are familiar with Objective-C or Swift. Here are the resources you’ll need before getting started: An application including the Mapbox Maps SDK for iOS. This guide also assumes that you have already set up an MGLMapView with the Mapbox Maps SDK for iOS. If you're new to the Maps SDK for iOS, complete the First steps with the Mapbox Maps SDK for iOS guide to set up a map view first. Data. In this tutorial, you'll be using a CSV file of HPC Landmarks from Open Minneapolis. Download the data What are expressions? In the Mapbox Style Specification, the value for any layout property, paint property, or filter may be specified as an expression. Expressions define how one or more feature attribute values and/or the current zoom level are combined using logical, mathematical, string, or color operations to produce the appropriate style property value or filter decision. The Mapbox Maps SDK for iOS allows you create expressions that follow the Mapbox Style Specification standard by using NSExpression. In this tutorial, you'll create both property and zoom expressions to conditionally change a layer's style. A data expression is any expression defined using a reference to feature property data. Property expressions allow the appearance of a feature to change with its properties. They can be used to visually differentiate types of features within the same layer or create data visualizations. Migrating from earlier Maps SDK versions (<4.0.0) If you've styled your data at runtime in the past with older versions of the Mapbox Maps SDK for iOS, read our migration guide to learn more about switching your style functions to expressions. Uses There are countless ways to apply property expressions to your application, including: Data-driven styling: Specify style rules based on one or more data attribute, such as coloring state polygon based on their population. Arithmetic: Do arithmetic on source data, for example performing calculations to convert units dynamically. Conditional logic: Use if-then logic, for example to decide exactly what text to display for a label based on which properties are available in the feature or even the length of the name. String manipulation: Take control over label text with things like uppercase, lowercase, and title case transforms without having to edit, re-prepare and re-upload your data. In this tutorial, you'll learn how to use expressions to style Historic Preservation Commission landmarks in Minneapolis based on age and zoom level. Set up a map Initialize a map view To begin building your data visualization, you first need to initialize a map view. Use the code below to create a map view that uses the Mapbox Light style and is centered on Minneapolis, Minnesota: swift objective-c import UIKit import Mapbox class DDSCircleLayerTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.styleURL = MGLStyle.lightStyleURL mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 44.971, longitude: -93.261), zoomLevel: 10, animated: false) mapView.delegate = self view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { let source = MGLVectorTileSource(identifier: ""historical-places"", configurationURL: URL(string: ""mapbox://examples.5zzwbooj"")!) style.addSource(source) let layer = MGLCircleStyleLayer(identifier: ""landmarks"", source: source) layer.sourceLayerIdentifier = ""HPC_landmarks-b60kqn"" layer.circleColor = NSExpression(forConstantValue: #colorLiteral(red: 0.67, green: 0.28, blue: 0.13, alpha: 1)) layer.circleOpacity = NSExpression(forConstantValue: 0.8) let zoomStops = [ 10: NSExpression(format: ""(2018 - Constructi) / 30""), 13: NSExpression(format: ""(2018 - Constructi) / 10"") ] layer.circleRadius = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", zoomStops) style.addLayer(layer) } } Copy The result will be a blank map using the Mapbox Light style, as shown below: Upload data In this guide, you'll use a vector tileset to display data in your application. You can create a vector tileset by uploading the CSV you downloaded earlier to Mapbox Studio: Visit the Tilesets page in Mapbox Studio. Click New tileset. Select the CSV you downloaded at the beginning of this tutorial and click Confirm. A popover will appear in the bottom right showing the progress of your upload. Once the upload has Succeeded, the tileset will be ready to use! Click on the name of the tileset in the popover, which will open the tileset information page. Take note of the tileset ID on the right side of the tileset information page. You will use the ID to add this tileset to your map in the next step. Add the source data to the map To load the data onto the map, you'll need to do two things: Add the vector tileset to the map dynamically as an MGLVectorTileSource to initially load the source data. Add a corresponding MGLCircleStyleLayer that references the above MGLVectorTileSource to display the data on the map. The source data and style layer should be added after the map is finished loading, so the code to both should reside within the -mapView:didFinishLoadingStyle: delegate method. swift objective-c import UIKit import Mapbox class DDSCircleLayerTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.styleURL = MGLStyle.lightStyleURL mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 44.971, longitude: -93.261), zoomLevel: 10, animated: false) mapView.delegate = self view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { let source = MGLVectorTileSource(identifier: ""historical-places"", configurationURL: URL(string: ""mapbox://examples.5zzwbooj"")!) style.addSource(source) let layer = MGLCircleStyleLayer(identifier: ""landmarks"", source: source) layer.sourceLayerIdentifier = ""HPC_landmarks-b60kqn"" layer.circleColor = NSExpression(forConstantValue: #colorLiteral(red: 0.67, green: 0.28, blue: 0.13, alpha: 1)) layer.circleOpacity = NSExpression(forConstantValue: 0.8) let zoomStops = [ 10: NSExpression(format: ""(2018 - Constructi) / 30""), 13: NSExpression(format: ""(2018 - Constructi) / 10"") ] layer.circleRadius = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", zoomStops) style.addLayer(layer) } } Copy Copy When you run your application, you'll see that the tileset has been added as a source to the map. You can now see circles marking where each landmark is with an assigned circle color and opacity. Use an expression to calculate the age of each landmark Next, you’ll write an expression to style the radius of each circle based on the age of each historic landmark. In this data file, provided by the City of Minneapolis’s open data portal, the age of the historic landmark is not provided, but the year of construction is provided. Instead of manually editing your source data and re-uploading it, you can use arithmetic to calculate the age of each landmark based on the current year. Once the age of each landmark has been calculated, you can style the circleRadius paint property based on the calculated age of each landmark. Start by calculating the age of the landmark and assigning it as the circle's radius, such that older landmarks will have a larger circle radius. layer.circleRadius = NSExpression(format: ""2018 - Constructi"") layer.circleRadius = [NSExpression expressionWithFormat:@""2018 - Constructi""] The above expression subtracts the current year (2018) each feature's date of construction. Constructi is the name of the key corresponds to the year each landmark was constructed. Run the application again to see the changes. Wow! Those circles are quite large. This is because a radius is measured in screen points, whereas Constructi is measured in years. To make this look better, you'll make some adjustments to the circle radius. Adjust the circle radius Since expressions can support mathematical operations, you can take the existing expression and divide the age by 10 to reduce the radius of each circle. layer.circleRadius = NSExpression(format: ""(2018 - Constructi) / 10"") layer.circleRadius = [NSExpression expressionWithFormat:@""(2018 - Constructi) / 10""] That looks better! Reducing the size of the circles makes this map much more legible at this zoom level. There are still some circles overlapping at this zoom level, so lets add a zoom expression to adjust the radius of the circles based on the zoom level the map is at. Add a zoom expression The circles are still overlapping quite a bit at the starting zoom level of 10, but they look good at higher zoom levels. You can use a zoom expression to address this issue, which will allow the appearance of a layer to change with the map’s zoom level. Zoom expressions can be used to create the illusion of depth and control data density. You will create a new linear interpolation expression to define a different circle radius between the following zoom levels: Zoom level Circle radius 0-10 Calculated building age ÷ 30 13+ Calculated building age ÷ 10 By using a linear interpolation, the circle radius will stay the same between categories. For example, at zoom level 18 the circle radius will still be the building age, divided by 10. There are other types of interpolations that would interpret this differently, which you can read about in more detail within the Maps SDK documentation. Within your code, the linear interpolation expression will look like this: swift objective-c import UIKit import Mapbox class DDSCircleLayerTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.styleURL = MGLStyle.lightStyleURL mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 44.971, longitude: -93.261), zoomLevel: 10, animated: false) mapView.delegate = self view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { let source = MGLVectorTileSource(identifier: ""historical-places"", configurationURL: URL(string: ""mapbox://examples.5zzwbooj"")!) style.addSource(source) let layer = MGLCircleStyleLayer(identifier: ""landmarks"", source: source) layer.sourceLayerIdentifier = ""HPC_landmarks-b60kqn"" layer.circleColor = NSExpression(forConstantValue: #colorLiteral(red: 0.67, green: 0.28, blue: 0.13, alpha: 1)) layer.circleOpacity = NSExpression(forConstantValue: 0.8) let zoomStops = [ 10: NSExpression(format: ""(2018 - Constructi) / 30""), 13: NSExpression(format: ""(2018 - Constructi) / 10"") ] layer.circleRadius = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", zoomStops) style.addLayer(layer) } } Copy Note If you've worked with property functions before, notice that MGLInterpolationModeExponential expressions allow you to achieve the same effect as using an `MGLStyleValue` with source stops. Once you run your application again, you'll notice that at the same zoom level, the circles appear more distinct. Finished product You’ve styled custom data using expressions using the Mapbox Maps SDK for iOS! You can find the completed code for this tutorial below. swift objective-c import UIKit import Mapbox class DDSCircleLayerTutorialViewController: UIViewController, MGLMapViewDelegate { override func viewDidLoad() { super.viewDidLoad() let mapView = MGLMapView(frame: view.bounds) mapView.styleURL = MGLStyle.lightStyleURL mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight] mapView.setCenter(CLLocationCoordinate2D(latitude: 44.971, longitude: -93.261), zoomLevel: 10, animated: false) mapView.delegate = self view.addSubview(mapView) } func mapView(_ mapView: MGLMapView, didFinishLoading style: MGLStyle) { let source = MGLVectorTileSource(identifier: ""historical-places"", configurationURL: URL(string: ""mapbox://examples.5zzwbooj"")!) style.addSource(source) let layer = MGLCircleStyleLayer(identifier: ""landmarks"", source: source) layer.sourceLayerIdentifier = ""HPC_landmarks-b60kqn"" layer.circleColor = NSExpression(forConstantValue: #colorLiteral(red: 0.67, green: 0.28, blue: 0.13, alpha: 1)) layer.circleOpacity = NSExpression(forConstantValue: 0.8) let zoomStops = [ 10: NSExpression(format: ""(2018 - Constructi) / 30""), 13: NSExpression(format: ""(2018 - Constructi) / 10"") ] layer.circleRadius = NSExpression(format: ""mgl_interpolate:withCurveType:parameters:stops:($zoomLevel, 'linear', nil, %@)"", zoomStops) style.addLayer(layer) } } Copy Was this page helpful? Yes No",Get started with expressions using the Mapbox Maps SDK for iOS,Objective-C,,,,,,,,,,,,Getting started,What are expressions?,Uses,Set up a map,Initialize a map view,Upload data,Add the source data to the map,Use an expression to calculate the age of each landmark,Adjust the circle radius,Add a zoom expression,Finished product,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Atlas,Run Atlas,Run Atlas.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,,,"Run Atlas Atlas can be started and stopped from the command line. Start the server To start Atlas, run the following commands: $ cd atlas-server (Replace atlas-server with the name of the directory in which you set up Atlas.) $ ./atlas.sh start Once Atlas starts, you will see the message Atlas is ready! Go to https://localhost:2999 or to your configured hostname and port. The first time you do this, you may see a browser warning that your connection is insecure. If this happens, it is safe to dismiss the warning and click through to the page. Log in to Atlas Studio with the username atlas-user and the password you set with the settings command. When you sign in, you land on the Atlas account dashboard page. On this page, you will see a link to the Atlas instance of Mapbox Studio. You will also see your public Atlas access token, which you can copy and use in your apps. Note Although Atlas can be daemonized using systemd, we recommend using the native docker-compose restart policy that ships with Atlas, which we have found does a better job of monitoring individual Atlas services than a generic process manager like systemd does. This will ensure that all services are restarted in the event of failure and on system startup. Stop the server To stop Atlas, run the following commands: $ cd atlas-server (Replace atlas-server with the name of the directory in which you set up Atlas.) $ ./atlas.sh stop You will see a confirmation message once the Atlas server has stopped running. Fix Redis THP and TCP warnings There are a few system requirements that Redis requires to run efficiently. When you first start Atlas, you may see the following Redis log warnings during startup: atlas-redis | 1:C 26 Jun 18:00:13.553 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo atlas-redis | 1:C 26 Jun 18:00:13.555 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started atlas-redis | 1:C 26 Jun 18:00:13.555 # Configuration loaded atlas-redis | 1:M 26 Jun 18:00:13.556 * Running mode=standalone, port=6379. atlas-redis | 1:M 26 Jun 18:00:13.556 # Server initialized atlas-redis | 1:M 26 Jun 18:00:13.556 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect. atlas-redis | 1:M 26 Jun 18:00:13.557 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local to retain the setting after a reboot. Redis must be restarted after THP is disabled. atlas-redis | 1:M 26 Jun 18:00:13.557 * Ready to accept connections You need to do these configurations on the Host level. To mute the overcommit_memory warning message, run the following command: $ sudo sysctl vm.overcommit_memory=1 To mute the THP warning message, run the following command: # macOS environment $ screen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty $ echo never > /sys/kernel/mm/transparent_hugepage/enabled # Ctrl+A and Ctrl+D exits the screen # Linux, Centos environment $ echo never > /sys/kernel/mm/transparent_hugepage/enabled Run Atlas behind a reverse proxy A common configuration is to have Atlas served over HTTP and behind an HTTPS reverse proxy. Because some services within Atlas advertise URIs to the client, you will need to configure Atlas to advertise the correct URI. These environment variables populate those URIs within the services. Stop Atlas: ./atlas.sh stop Edit ./config/src/.env.settings Configure AtlasServerHostName, AtlasServerPort, and AtlasServerProtocol based on your application entry point. For example, https://atlas.us-east-1.elb.amazonaws.com would be configured to: AtlasServerHostName=atlas.us-east-1.elb.amazonaws.com AtlasServerPort=443 AtlasServerProtocol=https Atlas will continue to listen internally on the port and protocol specified by AtlasRouterPort and AtlasProtocol. Run the setup command again to propagate these settings to ./config/dist/: ./atlas.sh setup Start Atlas: ./atlas.sh start Was this page helpful? Yes No",Run Atlas,,,,,,,,,,,,,Start the server,Stop the server,Fix Redis THP and TCP warnings,Run Atlas behind a reverse proxy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Route progress,Learn how to use a user's progress information along a route with the Mapbox Navigation SDK and Navigation UI for Android.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,Java,,"Route progress SDKs covered: Navigation SDK Navigation UI SDK Tracking a user's progress along a route is key to providing helpful and prompt navigation instructions. The RouteProgress class contains all the user's progress information along the route, including legs and steps. This object is provided inside ProgressChangeListener, allowing you to get distance measurements, the percentage of route complete, current step index, and much more. Listening to progress change Like tracking user location changes, the ProgressChangeListener is invoked every time the user's location changes and provides an updated RouteProgress object. The Navigation UI SDK uses this listener by default, but if you are not using the Navigation UI SDK, it is strongly encouraged that you also use this listener. The ProgressChangeListener can typically be used to refresh most of your application's user interface when a change occurs. For example, if you are displaying the user's current progress until the user needs to do the next maneuver. Every time this listener's invoked, you can update your view with the new information from RouteProgress. Besides receiving information about the route progress, the callback also provides you with the user's current location, which can provide their current speed, bearing, etc. If you have the snap-to-route enabled, the location object will be updated to give the snapped coordinates. Java Kotlin navigation.addProgressChangeListener(new ProgressChangeListener() { @Override public void onProgressChange(Location location, RouteProgress routeProgress) { } }); Copy Information about progress There are three classes that contain information on route progress at different levels of granularity: route, leg, and step. Route: The blue line is a route. A route stretches between the origin and destination. Leg: The larger circles with a pink stroke represent waypoints, or stops, along the route. A leg is the part of the route between two waypoints. Step: The smaller circles with a green stroke represent maneuvers. A step is the part of the leg between two maneuvers. RouteProgress This class contains all progress information at any given time during a navigation session. This progress includes information for the current route, leg and step the user is traversing along. With every new valid location update, a new route progress will be generated using the latest information. RouteProgress APIs Description directionsRoute The route acquired from the directions API and being used for navigation. distanceTraveled The total distance the user has traveled along the route. legIndex The route's current leg index that the user's on. currentLeg The route's current leg as a routeLeg object. distanceRemaining Provides the distance remaining in meters till the user reaches the end of the route. durationRemaining The estimated duration remaining till the user arrives at their destination. fractionTraveled A float value between 0 and 1 giving the total percentage the user has completed in the navigation session, based on distance. currentLegProgress returns the LegProgress object with information specific to the current route leg. You can also access step information through this object. remainingWaypoints Number of waypoints remaining on the current route. currentStepPoints List of Points representing the current step geometry. upcomingStepPoints List of Points representing the upcoming step geometry. voiceInstruction The current VoiceInstruction for the given segment along the route. currentState RouteStateProgress is the current state of route initialization and location tracking along the route. RouteLegProgress This is a progress object specific to the current leg the user is on. If there is only one leg in the directions route, much of this information will be the same as the parent RouteProgress. RouteLegProgress APIs Description currentStepProgress returns the stepProgress object with information specific to the current route step. stepIndex The route's current step index the user's on. distanceTraveled Total distance the user has traveled along the current leg. durationRemaining The estimated duration remaining till the user reaches the last maneuver in current route leg. fractionTraveled A float value between 0 and 1 giving the total percentage the user has traveled along the current route leg, based on distance. distanceRemaining The total distance the user has traveled along the current leg. previousStep Get the previous step the user traversed along, if the user is still on the first step, this will return null. currentStep Returns the current step the user is traversing along. Should be used to provide voice / banner instructions. upComingStep Get the next/upcoming step after the current step. If the user is on the last step on the last leg, this will return null since a next step doesn't exist. currentLegAnnotation Provides the current annotation data that the Location updates are traveling along. Note: the DirectionsRoute must be requested with ANNOTATION_DISTANCE to enable this within the RouteProgress - this by default in NavigationRoute. RouteStepProgress This is a progress object specific to the current step the user is on. RouteStepProgress APIs Description distanceTraveled Total distance the user has traveled along the current step. durationRemaining The estimated duration remaining till the user reaches the next step maneuver. fractionTraveled A float value between 0 and 1 giving the total percentage the user has traveled along the current step. distanceRemaining The total distance the user has traveled along the current step. currentIntersection An intersection is considered a current intersection once passed through and will stay so until a different intersection is passed through. upcomingIntersection The intersection being traveled towards on the route. Will be null if the upcoming step is null (last step of the leg). Navigation UI SDK Using NavigationView in your XML gives you the ability to listen to different updates or events that may occur during navigation. Both the ProgressChangeListener (see above) and MilestoneEventListener (see the Maneuver instructions guide) from our core SDK are able to be added, as well as RouteListener. Note This listeners is only available if you are adding NavigationView to your Activity or Fragment layout XML via NavigationViewOptions. You are not able to add them to NavigationLauncherOptions. RouteListener Callback Description allowRerouteFrom(Point offRoutePoint) Will trigger in an off-route scenario: Given the Point the user has gone off-route, this listener can return true or false. Returning true will allow the SDK to proceed with the re-route process and fetch a new route with this given off-route Point. Returning false will stop the re-route process and the user will continue without a new route in the direction they are traveling. onOffRoute(Point offRoutePoint) Will trigger only if RouteListener#allowRerouteFrom(Point) returns true. This serves as the official off-route event and will continue the process to fetch a new route with the given off-route Point. onRerouteAlong(DirectionsRoute directionsRoute) Will trigger when a new DirectionsRoute has been retrieved post off-route. This is the new route the user will be following until another off route event is triggered. onFailedReroute(String errorMessage) Will trigger if the request for a new DirectionsRoute fails. Provides the error message from the directions API used to retrieve the DirectionsRoute. More about route progress Read more about route progress in: Off-route detection: Detect whether a user is on the generated route throughout their trip. If a user is off-route, provide additional instruction or generate a new route. Faster-route detection: Specify when to check for faster routes and how to determine if a route is faster, then retrieve and initialize faster routes. Was this page helpful? Yes No",Route progress,Kotlin,,,,,,,,,,,,Listening to progress change,Information about progress,RouteProgress,RouteLegProgress,RouteStepProgress,Navigation UI SDK,RouteListener,More about route progress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,Mapbox GL JS,Change a map's style,Switch to another map style.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,JavaScript,,Change a map's style Switch to another map style. Was this example helpful? Yes No,Change a map's style,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Introduction,Official documentation and overview of the Mapbox Navigation SDK for Android.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,guide,Java,,"Navigation SDK for Android Current version: v 0.41.0 View changelog Off-route detection Timed instructions Snap-to-route Route progress information Traffic routing Contribute on GitHub The Navigation SDK for Android allows you to build a complete in-app navigation experience. With the Navigation SDK you get the power of the Mapbox Directions API along with a collection of features that are critical when building navigation applications for Android, including: Detecting the direction a device is facing and start the route Providing voice instruction announcements Displaying real-time user progress to their destination Detecting when a user goes off-route Specifying which side of the road to approach a waypoint Available SDKs There are two SDKs that can be used to integrate navigation into your Android application, the core Navigation SDK and the Navigation UI SDK: The core Navigation SDK is where the logic lives for generating routes, tracking progress, receiving instructions, and more. You can use this directly via the MapboxNavigation class or through the Navigation UI SDK. Built on top of the core Navigation SDK (meaning the Navigation SDK is included when you add the Navigation UI SDK as a dependency), the Navigation UI SDK consumes data from the core SDK and arranges it in default UI components that have various customization options. You can use this directly via the NavigationView and NavigationLauncher classes without touching the core MapboxNavigation class directly in your application's code. The core Navigation SDK and the Navigation UI SDK can be used together if you want to use a mixture of the Mapbox-provided UI components and your own custom UI fed data from the core Navigation SDK. Product capabilities This documentation contains information for both the core Navigation SDK and the Navigation UI SDK across a variety of topics: Manage user location User location Fundamentals Build route requests Route generation Fundamentals Offline routing Custom routes Track progress along a route Route progress Fundamentals Maneuver instructions Device notifications Off-route detection Faster-route detection Customize the visual experience Map camera Localization and internationalization Map and app styling User interaction Installation You'll need to add the Navigation SDK or Navigation UI SDK as a dependency before developing your app. Using nightly builds and beta versions You can also use the nightly build/SNAPSHOT or the beta version if one is available. Find more information about how to do this inside the Navigation SDK's GitHub repository. Navigation SDK Learn how to install the core Navigation SDK and request your first route using NavigationRoute. Add the dependency Add the core Navigation SDK only when not using the Navigation UI SDK If you're using the Navigation UI SDK, you don't have to declare the Mapbox Navigation SDK as well. If you only declare the Navigation UI SDK in your project's Gradle file, the Mapbox Navigation SDK will automatically be included. Start Android Studio. Open up your app's build.gradle file. Make sure that your project's minSdkVersion is at API 14 or higher. Under dependencies, add a new build rule for the latest mapbox-android-navigation. Click the Sync Project with Gradle Files near the toolbar in Studio. allprojects { repositories { ... maven { url 'https://mapbox.bintray.com/mapbox' } } } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-navigation: 0.41.0 ' } Get an access token If you don't have a Mapbox account: sign up and navigate to your Account page. For quick development and testing, you can use your default public token. Later in development, you may want to create an access token specifically for this project. Find more details on managing access tokens in our guide on how access tokens work. After you've added the Navigation SDK as a dependency inside your Android project, open the string.xml file, create a new string, and paste the access token. Then, pass this into the Navigation SDK. Java Kotlin @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); MapboxNavigation navigation = new MapboxNavigation(context, YOUR_MAPBOX_ACCESS_TOKEN); ... } Copy Set up permissions The Navigation SDK makes use of the Android manifest merge feature to reduce the need to include any Navigation SDK requirements inside your application's manifest file. You'll need to include either the fine or coarse location permission for navigation to work properly. The user location permission should also be checked during runtime using the PermissionsManager if your app targets the Android API 23 or higher. For optimal navigation results, use the fine location permission, which gives a more precise fix on the user's current location. <uses-permission android:name=""android.permission.ACCESS_FINE_LOCATION"" /> Request a route Now that you have created a way for the MapboxNavigation object to get the user's location, you can create a route using NavigationRoute. Pass in an origin, destination, and a callback to handle the response. Inside the onResponse, you can draw the directions route on a map or show time and distance using the full directions response. More about route generation Find more detailed information about requesting routes in the Route generation guide. Java Kotlin // From Mapbox to The White House Point origin = Point.fromLngLat(-77.03613, 38.90992); Point destination = Point.fromLngLat(-77.0365, 38.8977); NavigationRoute.builder(context) .accessToken(YOUR_MAPBOX_ACCESS_TOKEN) .origin(origin) .destination(destination) .build() .getRoute(new Callback<DirectionsResponse>() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { } @Override public void onFailure(Call<DirectionsResponse> call, Throwable t) { } }); Copy Navigation UI SDK The Navigation UI SDK is the fastest way to get a navigation UI into your application. Add the dependency This dependency is different from the one used to compile the core Mapbox Navigation SDK, but it will still include everything from the core Mapbox Navigation SDK. Maps and Navigation SDKs included If you're using the Navigation UI SDK, we recommend you don't include an explicit version of the Maps SDK or Navigation SDK in your build.gradle file. The Mapbox Navigation UI SDK already includes the core Mapbox Navigation SDK and Mapbox Maps SDK for Android. Gradle automatically takes care of adding the right dependencies. The Navigation UI SDK will include the Navigation and Maps SDK versions that have been tested to provide the best user and developer experience for navigation experiences. Manually adding different versions can lead to unexpected behavior. repositories { mavenCentral() maven { url 'https://mapbox.bintray.com/mapbox' } } dependencies { implementation 'com.mapbox.mapboxsdk:mapbox-android-navigation-ui: 0.41.0 ' } Launch the Navigation UI With either a DirectionsRoute from NavigationRoute (see Request a route above) or two Point objects (origin and destination), you can launch the UI with NavigationLauncher from within your Activity. Java Kotlin // Route fetched from NavigationRoute DirectionsRoute route = ... boolean simulateRoute = true; // Create a NavigationLauncherOptions object to package everything together NavigationLauncherOptions options = NavigationLauncherOptions.builder() .directionsRoute(route) .shouldSimulateRoute(simulateRoute) .build(); // Call this method with Context from within an Activity NavigationLauncher.startNavigation(this, options); Copy Prevent memory leaks Regardless of which SDK you are using, you should override the onDestroy lifecycle method, end the navigation session (if it's running), and use the MabpoxNavigation#onDestroy method inside your application's activity. Doing this prevents any memory leaks and ensures proper shutdown of the service. Java Kotlin @Override protected void onDestroy() { super.onDestroy(); // End the navigation session navigation.onDestroy(); } Copy Testing and development There are a few methods that can be helpful when developing and testing your application. Replay a DirectionsRoute The Navigation SDK includes a ReplayRouteLocationEngine, which allows you to replay a given DirectionsRoute (mainly for testing, so you don't always have to code in a car). After retrieving a DirectionsRoute, you can create a replay engine and pass it to MapboxNavigation. Java Kotlin MapboxNavigation navigation = ... DirectionsRoute routeToReplay = ... ReplayRouteLocationEngine replayEngine = new ReplayRouteLocationEngine(); replayEngine.assign(routeToReplay); navigation.setLocationEngine(replayEngine); navigation.startNavigation(routeToReplay); Copy Turn on debug logging Turn on debug logging using MapboxNavigationOptions: Java Kotlin MapboxNavigationOptions options = MapboxNavigationOptions.builder() .isDebugLoggingEnabled(true) .build(); MapboxNavigation mapboxNavigation = new MapboxNavigation(this, accessToken, options); Copy Was this page helpful? Yes No",Navigation SDK for Android,Kotlin,,,,,,,,,,,,Available SDKs,Product capabilities,Installation,Navigation SDK,Add the dependency,Get an access token,Set up permissions,Request a route,Navigation UI SDK,Launch the Navigation UI,Prevent memory leaks,Testing and development,Replay a DirectionsRoute,Turn on debug logging,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Glossary,Help,Mapbox Matrix API elements,Elements are the source and destination coordinate pairs used in a Mapbox Matrix API request.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,glossary,,,"Mapbox Matrix API elements The Mapbox Matrix API handles bulk requests of varying sizes so billing is tracked by the number of elements returned instead of requests made. For instance, one request from the Matrix API can be many different origin and destination pairs, so one request from the Matrix API is equal to the number of sources multiplied by the number of destinations (for example: 2 sources x 3 destinations equals 6 elements). Read more about how the Mapbox Matrix API works on our comprehensive How Directions Works guide. Was this page helpful? Yes No",Mapbox Matrix API elements,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Maps SDK for Android,Android,Building outline,Query the building layer and show a building's outline.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Building outline Layout View on GitHub <?xml version=""1.0"" encoding=""utf-8""?> <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" xmlns:mapbox=""http://schemas.android.com/apk/res-auto""> <com.mapbox.mapboxsdk.maps.MapView android:id=""@+id/mapView"" mapbox:mapbox_cameraTargetLat=""39.951024"" mapbox:mapbox_cameraTargetLng=""-75.164394"" mapbox:mapbox_cameraZoom=""17.34"" android:layout_width=""match_parent"" android:layout_height=""match_parent"" /> </FrameLayout> Copy Activity View on GitHub package com.mapbox.mapboxandroiddemo.examples.query; import android.graphics.Color; import android.graphics.PointF; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import android.view.Gravity; import android.view.View; import android.widget.FrameLayout; import android.widget.Toast; import com.mapbox.geojson.Feature; import com.mapbox.geojson.FeatureCollection; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.geojson.Polygon; import com.mapbox.mapboxandroiddemo.R; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.mapboxsdk.style.layers.LineLayer; import com.mapbox.mapboxsdk.style.sources.GeoJsonSource; import java.util.ArrayList; import java.util.List; import static com.mapbox.mapboxsdk.style.layers.Property.LINE_CAP_ROUND; import static com.mapbox.mapboxsdk.style.layers.Property.LINE_JOIN_BEVEL; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineCap; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineColor; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineJoin; import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.lineWidth; /** * Query the building layer to draw an outline around the building that is in the middle of the map */ public class BuildingOutlineActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnCameraIdleListener { private MapView mapView; private MapboxMap mapboxMap; private FeatureCollection featureCollection; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Mapbox access token is configured here. This needs to be called either in your application // object or in the same activity which contains the mapview. Mapbox.getInstance(this, getString(R.string.access_token)); // This contains the MapView in XML and needs to be called after the access token is configured. setContentView(R.layout.activity_query_building_outline); mapView = findViewById(R.id.mapView); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); } @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { BuildingOutlineActivity.this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { setUpLineLayer(style); mapboxMap.addOnCameraIdleListener(BuildingOutlineActivity.this); showCrosshair(); Toast.makeText(BuildingOutlineActivity.this, R.string.move_map_around_building_out_instruction, Toast.LENGTH_SHORT).show(); updateOutline(style); } }); } /** * Sets up the source and layer for drawing the building outline */ private void setUpLineLayer(@NonNull Style loadedMapStyle) { // Create a GeoJSONSource from an empty FeatureCollection loadedMapStyle.addSource(new GeoJsonSource(""source"", FeatureCollection.fromFeatures(new Feature[]{}))); // Use runtime styling to adjust the look of the building outline LineLayer loadedMapStyle.addLayer(new LineLayer(""lineLayer"", ""source"").withProperties( lineColor(Color.RED), lineWidth(6f), lineCap(LINE_CAP_ROUND), lineJoin(LINE_JOIN_BEVEL) )); } @Override public void onCameraIdle() { mapboxMap.getStyle(new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { updateOutline(style); } }); } /** * Query the map for a building Feature in the map's building layer. The query happens in the middle of the * map (""the target""). If there's a building Feature in the middle of the map, its coordinates are turned * into a list of Point objects so that a LineString can be created. * * @return the LineString built via the building's coordinates */ private LineString getBuildingFeatureOutline(@NonNull Style style) { // Retrieve the middle of the map final PointF pixel = mapboxMap.getProjection().toScreenLocation(new LatLng( mapboxMap.getCameraPosition().target.getLatitude(), mapboxMap.getCameraPosition().target.getLongitude() )); List<Point> pointList = new ArrayList<>(); // Check whether the map style has a building layer if (style.getLayer(""building"") != null) { // Retrieve the building Feature that is displayed in the middle of the map List<Feature> features = mapboxMap.queryRenderedFeatures(pixel, ""building""); if (features.size() > 0) { if (features.get(0).geometry() instanceof Polygon) { Polygon buildingFeature = (Polygon) features.get(0).geometry(); // Build a list of Point objects from the building Feature's coordinates for (int i = 0; i < buildingFeature.coordinates().size(); i++) { for (int j = 0; j < buildingFeature.coordinates().get(i).size(); j++) { pointList.add(Point.fromLngLat( buildingFeature.coordinates().get(i).get(j).longitude(), buildingFeature.coordinates().get(i).get(j).latitude() )); } } } // Create a LineString from the list of Point objects } } else { Toast.makeText(this, R.string.building_layer_not_present, Toast.LENGTH_SHORT).show(); } return LineString.fromLngLats(pointList); } /** * Update the FeatureCollection used by the building outline LineLayer. Then refresh the map. */ private void updateOutline(@NonNull Style style) { // Update the data source used by the building outline LineLayer and refresh the map featureCollection = FeatureCollection.fromFeatures(new Feature[] {Feature.fromGeometry(getBuildingFeatureOutline(style))}); GeoJsonSource source = style.getSourceAs(""source""); if (source != null) { source.setGeoJson(featureCollection); } } private void showCrosshair() { View crosshair = new View(this); crosshair.setLayoutParams(new FrameLayout.LayoutParams(20, 20, Gravity.CENTER)); crosshair.setBackgroundColor(Color.RED); mapView.addView(crosshair); } @Override public void onResume() { super.onResume(); mapView.onResume(); } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override public void onPause() { super.onPause(); mapView.onPause(); } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onDestroy() { super.onDestroy(); if (mapboxMap != null) { mapboxMap.removeOnCameraIdleListener(this); } mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } } Copy Was this page helpful? Yes No",Building outline,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Navigation SDK for Android,Android,Navigation views,Create a drop-in navigation UI experience.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,example,Java,,"Navigation views Activity View on GitHub package com.mapbox.services.android.navigation.testapp.activity.navigationui; import android.content.Intent; import android.content.SharedPreferences; import android.location.Location; import android.os.Bundle; import android.preference.PreferenceManager; import android.support.annotation.NonNull; import android.support.annotation.Nullable; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.widget.Button; import android.widget.FrameLayout; import android.widget.ProgressBar; import android.widget.Toast; import com.mapbox.android.core.location.LocationEngine; import com.mapbox.android.core.location.LocationEngineCallback; import com.mapbox.android.core.location.LocationEngineProvider; import com.mapbox.android.core.location.LocationEngineRequest; import com.mapbox.android.core.location.LocationEngineResult; import com.mapbox.api.directions.v5.DirectionsCriteria; import com.mapbox.api.directions.v5.models.DirectionsResponse; import com.mapbox.api.directions.v5.models.DirectionsRoute; import com.mapbox.core.constants.Constants; import com.mapbox.geojson.LineString; import com.mapbox.geojson.Point; import com.mapbox.mapboxsdk.Mapbox; import com.mapbox.mapboxsdk.annotations.Marker; import com.mapbox.mapboxsdk.annotations.MarkerOptions; import com.mapbox.mapboxsdk.camera.CameraPosition; import com.mapbox.mapboxsdk.camera.CameraUpdateFactory; import com.mapbox.mapboxsdk.exceptions.InvalidLatLngBoundsException; import com.mapbox.mapboxsdk.geometry.LatLng; import com.mapbox.mapboxsdk.geometry.LatLngBounds; import com.mapbox.mapboxsdk.location.LocationComponent; import com.mapbox.mapboxsdk.location.modes.RenderMode; import com.mapbox.mapboxsdk.maps.MapView; import com.mapbox.mapboxsdk.maps.MapboxMap; import com.mapbox.mapboxsdk.maps.OnMapReadyCallback; import com.mapbox.mapboxsdk.maps.Style; import com.mapbox.services.android.navigation.testapp.NavigationSettingsActivity; import com.mapbox.services.android.navigation.testapp.R; import com.mapbox.services.android.navigation.ui.v5.NavigationLauncher; import com.mapbox.services.android.navigation.ui.v5.NavigationLauncherOptions; import com.mapbox.services.android.navigation.ui.v5.route.NavigationMapRoute; import com.mapbox.services.android.navigation.ui.v5.route.OnRouteSelectionChangeListener; import com.mapbox.services.android.navigation.v5.navigation.NavigationRoute; import com.mapbox.services.android.navigation.v5.utils.LocaleUtils; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; import java.util.Locale; import butterknife.BindView; import butterknife.ButterKnife; import butterknife.OnClick; import retrofit2.Call; import retrofit2.Response; import timber.log.Timber; public class NavigationLauncherActivity extends AppCompatActivity implements OnMapReadyCallback, MapboxMap.OnMapLongClickListener, OnRouteSelectionChangeListener { private static final int CAMERA_ANIMATION_DURATION = 1000; private static final int DEFAULT_CAMERA_ZOOM = 16; private static final int CHANGE_SETTING_REQUEST_CODE = 1; private static final int INITIAL_ZOOM = 16; private static final long UPDATE_INTERVAL_IN_MILLISECONDS = 1000; private static final long FASTEST_UPDATE_INTERVAL_IN_MILLISECONDS = 500; private final NavigationLauncherLocationCallback callback = new NavigationLauncherLocationCallback(this); private LocationEngine locationEngine; private NavigationMapRoute mapRoute; private MapboxMap mapboxMap; private Marker currentMarker; private Point currentLocation; private Point destination; private DirectionsRoute route; private LocaleUtils localeUtils; private boolean locationFound; @BindView(R.id.mapView) MapView mapView; @BindView(R.id.launch_route_btn) Button launchRouteBtn; @BindView(R.id.loading) ProgressBar loading; @BindView(R.id.launch_btn_frame) FrameLayout launchBtnFrame; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_navigation_launcher); ButterKnife.bind(this); mapView.onCreate(savedInstanceState); mapView.getMapAsync(this); localeUtils = new LocaleUtils(); } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.navigation_view_activity_menu, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.settings: showSettings(); return true; default: return super.onOptionsItemSelected(item); } } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == CHANGE_SETTING_REQUEST_CODE && resultCode == RESULT_OK) { boolean shouldRefetch = data.getBooleanExtra(NavigationSettingsActivity.UNIT_TYPE_CHANGED, false) || data.getBooleanExtra(NavigationSettingsActivity.LANGUAGE_CHANGED, false); if (destination != null && shouldRefetch) { fetchRoute(); } } } @Override protected void onStart() { super.onStart(); mapView.onStart(); } @SuppressWarnings( {""MissingPermission""}) @Override public void onResume() { super.onResume(); mapView.onResume(); if (locationEngine != null) { locationEngine.requestLocationUpdates(buildEngineRequest(), callback, null); } } @Override public void onPause() { super.onPause(); mapView.onPause(); if (locationEngine != null) { locationEngine.removeLocationUpdates(callback); } } @Override public void onLowMemory() { super.onLowMemory(); mapView.onLowMemory(); } @Override protected void onStop() { super.onStop(); mapView.onStop(); } @Override protected void onDestroy() { super.onDestroy(); mapView.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mapView.onSaveInstanceState(outState); } @OnClick(R.id.launch_route_btn) public void onRouteLaunchClick() { launchNavigationWithRoute(); } @Override public void onMapReady(MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.MAPBOX_STREETS, style -> { mapboxMap.addOnMapLongClickListener(this); initializeLocationEngine(); initializeLocationComponent(style); initializeMapRoute(); }); } @Override public boolean onMapLongClick(@NonNull LatLng point) { destination = Point.fromLngLat(point.getLongitude(), point.getLatitude()); launchRouteBtn.setEnabled(false); loading.setVisibility(View.VISIBLE); setCurrentMarkerPosition(point); if (currentLocation != null) { fetchRoute(); } return false; } @Override public void onNewPrimaryRouteSelected(DirectionsRoute directionsRoute) { route = directionsRoute; } void updateCurrentLocation(Point currentLocation) { this.currentLocation = currentLocation; } void onLocationFound(Location location) { if (!locationFound) { animateCamera(new LatLng(location.getLatitude(), location.getLongitude())); Snackbar.make(mapView, R.string.explanation_long_press_waypoint, Snackbar.LENGTH_LONG).show(); locationFound = true; hideLoading(); } } private void showSettings() { startActivityForResult(new Intent(this, NavigationSettingsActivity.class), CHANGE_SETTING_REQUEST_CODE); } @SuppressWarnings( {""MissingPermission""}) private void initializeLocationEngine() { locationEngine = LocationEngineProvider.getBestLocationEngine(getApplicationContext()); LocationEngineRequest request = buildEngineRequest(); locationEngine.requestLocationUpdates(request, callback, null); locationEngine.getLastLocation(callback); } @SuppressWarnings( {""MissingPermission""}) private void initializeLocationComponent(Style style) { LocationComponent locationComponent = mapboxMap.getLocationComponent(); locationComponent.activateLocationComponent(this, style, locationEngine); locationComponent.setLocationComponentEnabled(true); locationComponent.setRenderMode(RenderMode.COMPASS); } private void initializeMapRoute() { mapRoute = new NavigationMapRoute(mapView, mapboxMap); mapRoute.setOnRouteSelectionChangeListener(this); } private void fetchRoute() { NavigationRoute.Builder builder = NavigationRoute.builder(this) .accessToken(Mapbox.getAccessToken()) .origin(currentLocation) .destination(destination) .profile(getRouteProfileFromSharedPreferences()) .alternatives(true); setFieldsFromSharedPreferences(builder); builder.build() .getRoute(new SimplifiedCallback() { @Override public void onResponse(Call<DirectionsResponse> call, Response<DirectionsResponse> response) { if (validRouteResponse(response)) { hideLoading(); route = response.body().routes().get(0); if (route.distance() > 25d) { launchRouteBtn.setEnabled(true); mapRoute.addRoutes(response.body().routes()); boundCameraToRoute(); } else { Snackbar.make(mapView, R.string.error_select_longer_route, Snackbar.LENGTH_SHORT).show(); } } } }); loading.setVisibility(View.VISIBLE); } private void setFieldsFromSharedPreferences(NavigationRoute.Builder builder) { builder .language(getLanguageFromSharedPreferences()) .voiceUnits(getUnitTypeFromSharedPreferences()); } private String getUnitTypeFromSharedPreferences() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); String defaultUnitType = getString(R.string.default_unit_type); String unitType = sharedPreferences.getString(getString(R.string.unit_type_key), defaultUnitType); if (unitType.equals(defaultUnitType)) { unitType = localeUtils.getUnitTypeForDeviceLocale(this); } return unitType; } private Locale getLanguageFromSharedPreferences() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); String defaultLanguage = getString(R.string.default_locale); String language = sharedPreferences.getString(getString(R.string.language_key), defaultLanguage); if (language.equals(defaultLanguage)) { return localeUtils.inferDeviceLocale(this); } else { return new Locale(language); } } private boolean getShouldSimulateRouteFromSharedPreferences() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); return sharedPreferences.getBoolean(getString(R.string.simulate_route_key), false); } private String getRouteProfileFromSharedPreferences() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); return sharedPreferences.getString( getString(R.string.route_profile_key), DirectionsCriteria.PROFILE_DRIVING_TRAFFIC ); } private void launchNavigationWithRoute() { if (route == null) { Snackbar.make(mapView, R.string.error_route_not_available, Snackbar.LENGTH_SHORT).show(); return; } NavigationLauncherOptions.Builder optionsBuilder = NavigationLauncherOptions.builder() .shouldSimulateRoute(getShouldSimulateRouteFromSharedPreferences()); CameraPosition initialPosition = new CameraPosition.Builder() .target(new LatLng(currentLocation.latitude(), currentLocation.longitude())) .zoom(INITIAL_ZOOM) .build(); optionsBuilder.initialMapCameraPosition(initialPosition); optionsBuilder.directionsRoute(route); NavigationLauncher.startNavigation(this, optionsBuilder.build()); } private boolean validRouteResponse(Response<DirectionsResponse> response) { return response.body() != null && !response.body().routes().isEmpty(); } private void hideLoading() { if (loading.getVisibility() == View.VISIBLE) { loading.setVisibility(View.INVISIBLE); } } public void boundCameraToRoute() { if (route != null) { List<Point> routeCoords = LineString.fromPolyline(route.geometry(), Constants.PRECISION_6).coordinates(); List<LatLng> bboxPoints = new ArrayList<>(); for (Point point : routeCoords) { bboxPoints.add(new LatLng(point.latitude(), point.longitude())); } if (bboxPoints.size() > 1) { try { LatLngBounds bounds = new LatLngBounds.Builder().includes(bboxPoints).build(); // left, top, right, bottom int topPadding = launchBtnFrame.getHeight() * 2; animateCameraBbox(bounds, CAMERA_ANIMATION_DURATION, new int[] {50, topPadding, 50, 100}); } catch (InvalidLatLngBoundsException exception) { Toast.makeText(this, R.string.error_valid_route_not_found, Toast.LENGTH_SHORT).show(); } } } } private void animateCameraBbox(LatLngBounds bounds, int animationTime, int[] padding) { CameraPosition position = mapboxMap.getCameraForLatLngBounds(bounds, padding); mapboxMap.animateCamera(CameraUpdateFactory.newCameraPosition(position), animationTime); } private void animateCamera(LatLng point) { mapboxMap.animateCamera(CameraUpdateFactory.newLatLngZoom(point, DEFAULT_CAMERA_ZOOM), CAMERA_ANIMATION_DURATION); } private void setCurrentMarkerPosition(LatLng position) { if (position != null) { if (currentMarker == null) { MarkerOptions markerViewOptions = new MarkerOptions() .position(position); currentMarker = mapboxMap.addMarker(markerViewOptions); } else { currentMarker.setPosition(position); } } } @NonNull private LocationEngineRequest buildEngineRequest() { return new LocationEngineRequest.Builder(UPDATE_INTERVAL_IN_MILLISECONDS) .setPriority(LocationEngineRequest.PRIORITY_HIGH_ACCURACY) .setFastestInterval(FASTEST_UPDATE_INTERVAL_IN_MILLISECONDS) .build(); } private static class NavigationLauncherLocationCallback implements LocationEngineCallback<LocationEngineResult> { private final WeakReference<NavigationLauncherActivity> activityWeakReference; NavigationLauncherLocationCallback(NavigationLauncherActivity activity) { this.activityWeakReference = new WeakReference<>(activity); } @Override public void onSuccess(LocationEngineResult result) { NavigationLauncherActivity activity = activityWeakReference.get(); if (activity != null) { Location location = result.getLastLocation(); if (location == null) { return; } activity.updateCurrentLocation(Point.fromLngLat(location.getLongitude(), location.getLatitude())); activity.onLocationFound(location); } } @Override public void onFailure(@NonNull Exception exception) { Timber.e(exception); } } } Copy Was this page helpful? Yes No",Navigation views,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,API,Navigation service,Overview of the Mapbox Navigation service APIs.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,API,,,,Navigation service,,Example waypoint object,Route object,Example route object,Route leg object,,Example route leg object,Route step object,Example route step object,Step maneuver object,Example step maneuver object,Lane object,Example lane object,Voice instruction object,Example voice instruction object,Banner instruction object,Example banner instruction object,Instructions languages,Directions API errors,Directions API restrictions and limits,Isochrone,Retrieve isochrones around a location,Example request: Retrieve isochrones around a location,Response: Retrieve isochrones around a location,Example response: Retrieve isochrones around a location,Isochrone API errors,Isochrone API restrictions and limits,Map Matching,Retrieve a match,Example request: Retrieve a match,Use HTTP POST to retrieve a match,Response: Retrieve a match,Example response: Retrieve a match,Match object,Example match object,Tracepoint object,Example tracepoint object,Map Matching API errors,Map Matching API restrictions and limits,Matrix,Retrieve a matrix,Example request: Retrieve a matrix,Response: Retrieve a matrix,Example response: Retrieve a matrix,Matrix API errors,Matrix API restrictions and limits,Optimization,Retrieve an optimization,Example request: Retrieve an optimization,Response: Retrieve an optimization,Waypoint objects,Trip object,Example response object,Optimization API errors,Optimization API restrictions and limits,Using HTTP POST,Example HTTP POST requests,Directions,Retrieve directions,Optional parameters for the mapbox/walking profile,Example request: Retrieve directions,Use HTTP POST to retrieve directions,Response: Retrieve directions,Example response: Retrieve directions,Waypoint object,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,API,Introduction,An introduction to the Mapbox web services APIs.,https://static-assets.mapbox.com/branding/social/social-1200x630.v1.png,API,,,"Introduction The Mapbox web services APIs allow you to programmatically access Mapbox tools and services. You can use these APIs to retrieve information about your account, upload and change resources, use core Mapbox tools, and more. Mapbox APIs are divided into four distinct services: Maps, Navigation, Search, and Accounts. Each of these services has its own overview page in this documentation. These overview pages are divided into the individual APIs that make up the service. The documentation for each API is structured by endpoints. An endpoint is a specific method within an API that performs one action and is located at a specific URL. Maps service Overview of the Mapbox Maps service APIs. Navigation service Overview of the Mapbox Navigation service APIs. Search service Overview of the Mapbox Search service APIs. Accounts service Overview of the Mapbox Accounts service APIs. The Mapbox APIs described in this documentation are subject to Mapbox's Terms of Service. Reading this documentation Each API endpoint in this documentation is described using several parts: The HTTP method. Includes GET, POST, PUT, PATCH, DELETE. The base path. All URLs referenced in the documentation have the base path https://api.mapbox.com. This base path goes before the endpoint path. The endpoint path. For example, /directions/v5/ { profile } / { coordinates }. Required parameters. These parameters must be included in a request. In the example above, { profile } and { coordinates } are required parameters. In a request, you will replace the placeholders with real values. Optional parameters. These parameters can be included in a request to customize the query. Query parameters are added to the end of the URL with query string encoding. A token scope. If an API endpoint requires a token scope that the default access token does not have, this scope will be listed. Code examples. Each endpoint has example requests in cURL format. Mapbox also provides several SDKs and libraries that can be used to integrate with our web service APIs. When applicable, the documentation for an endpoint will link to the relevant tool's documentation, which will include code examples in that language. Access tokens and token scopes https://api.mapbox.com/ { endpoint } ?access_token= { your_access_token } Access to Mapbox API endpoints requires a valid access token, which will connect API requests to your account. You need supply a valid access token by using the access_token query parameter in every request. The example requests in this documentation will include your default access token if you are signed into your Mapbox account. Your default access token is available on your Account Dashboard. You can also create and manage additional tokens on your Access tokens page or with the Tokens API. When you create a new access token, you can give it one or more token scopes. Each scope adds a different permission to the token, allowing it to be used to access restricted APIs. Throughout this documentation, we specify the scope required to access each endpoint. If no scope is specified, then your default access token will work to access that endpoint. API versioning Each Mapbox API has a version string that is specified in the base URL. The version string for a given Mapbox API can be incremented independently from other Mapbox APIs. We encourage you to use the newest available version of the Mapbox APIs. Backwards compatible changes The following changes to a Mapbox API are considered backwards compatible. The version string of an API will not be incremented if we: Add properties to JSON objects. Change the number of items returned in a single listing request. Change rate limiting thresholds. Change the structure or length of identifiers generated by the API. Change error messages. Backwards incompatible changes The following changes are considered backwards incompatible. The version string of an API will be incremented if we: Remove properties from JSON objects. Change an API's URL structure. If we deprecate an API or API endpoint that you are using, we will email you to give you at least 90 days' notice. Rate limit headers Every Mapbox API response contains the following rate limit headers: Header Description X-Rate-Limit-Interval The length of the rate-limiting interval in seconds. This will always be 60. X-Rate-Limit-Limit The maximum number of requests you can make in the current interval before reaching the limit. The rate limit for each individual API is listed in the rate limits section. X-Rate-Limit-Reset A Unix timestamp that shows when the current interval will end and the rate limit counter will reset. The presence of these headers is expected and does not mean there is an error condition. Rate limits Your user plan sets the rate limits that cap the number of requests you can make against an API endpoint. If you exceed a rate limit, your request will be throttled and you will receive a HTTP 429 Too Many Requests response from the API. If you need a rate limit that is higher than the default, contact the Mapbox sales team. The following table lists the default rate limit for each API. Note that all rate limits are counted per access token, not per account. API Default coordinates per request Default requests per minute Vector Tiles API N/A 100,000 requests per minute Raster Tiles API N/A 100,000 requests per minute Static Images API N/A 600 requests per minute Static Tiles API N/A 2,000 requests per minute Styles API N/A 2,000 requests per minute Tilequery API N/A 300 requests per minute Uploads API N/A 30 requests per minute Tilesets API N/A 50 requests per minute Datasets API (Read) N/A 480 requests per minute Datasets API (Write) N/A 40 requests per minute Directions API (driving, walking, and cycling profiles) 25 coordinates per request 300 requests per minute Directions API (driving-traffic profile) 3 coordinates per request 300 requests per minute Isochrone API 1 coordinate per request 300 requests per minute Map Matching API 100 coordinates per request 300 requests per minute Matrix API (driving, walking, and cycling profiles) 25 coordinates per request 60 requests per minute Matrix API (driving-traffic profile) 10 coordinates per request 30 requests per minute Optimization API 12 coordinates per request 300 requests per minute Geocoding API N/A 600 requests per minute Tokens API N/A 100 requests per minute HTTPS and CORS We recommend that all access to Mapbox is over HTTPS. Requests initiated over HTTP are automatically upgraded to HTTPS. Mapbox web services support Cross-Origin Requests with no domain restrictions. To support Internet Explorer 8 and 9, use a library that falls back to XDomainRequest, like corslite. Coordinate format When you provide geographic coordinates to a Mapbox API, they should be formatted in the order longitude, latitude and specified as decimal degrees in the WGS84 coordinate system. This pattern matches existing standards, including GeoJSON and KML. Mapbox APIs use GeoJSON formatting wherever possible to represent geospatial data. The only exception to this longitude, latitude order is the polyline format, which is supported in Static Images API overlays and Directions API, Map Matching API, and Optimization API responses. When polyline input or output is specified, the polyline content should follow the Google Encoded Polyline format, which specifies latitude, longitude ordering. Date and time format Unless otherwise specified, dates and times returned by Mapbox APIs are represented in RFC 3339 format, which can be parsed by many libraries and languages. The only exception to this rule is the Retrieve TileJSON metadata endpoint of the Tilesets API, which returns created and modified properties as Unix time. Pagination Pagination lets you list many objects from an API by using more than one request. Pagination is supported in the list endpoints for the following APIs: Datasets API Styles API Tilesets API Tokens API Uploads API After receiving a page of objects, you can request the next page of objects using the next link relation in the Link header of the response. This process can be repeated until the server sends a response without a Link header or without a next link relation, which signals the end of the collection. Link: <https://api.mapbox.com/uploads/v1/1454024795582?start=cijywvxlm004rtikohhqf99jv&limit=100>; rel=""next"" In the Mapbox API endpoints that support pagination, the optional limit parameter specifies the maximum number of objects to return. The API will try to return the requested number of objects, but receiving fewer objects does not necessarily signal the end of the collection. Receiving a response with no Link header or no next link relation is the only way to tell that you are at the end of a collection. Your application must use the Link header for pagination instead of constructing your own URLs, since the specific URLs used for pagination may change at any time. The Python requests library and the link-header-parser module for JavaScript can parse Link headers. Link headers follow the RFC 5988 specifications. High DPI images Mapbox supports high DPI image output on all the Maps service APIs that serve images. Add @2x before the file extension on a URL to request an image at double scale. For instance, a map tile that is 256×256 pixels will be 512×512 pixels with @2x, but will show the same content. When displayed on a page, the image will still be sized to 256×256 pixels, but four pixels of the original will represent one pixel in screen units. The @2x part of the URL goes before the entire format, so a URL that ends in .png would end with @2x.png as a high DPI image. (Note that tilesets uploaded as MBTiles are not available at this scale.) SDK and library support Mapbox provides the following SDKs and libraries to help you access and integrate with our web services APIs: Mapbox CLI SDK Mapbox Java SDK Mapbox JavaScript SDK Mapbox Python SDK Mapbox Ruby SDK Mapbox Swift/Objective-C libraries: MapboxGeocoder.swift MapboxDirections.swift MapboxStatic.swift Support for Mapbox API endpoints varies among these libraries. If a library supports a specific endpoint, the endpoint's Request section in this documentation will contain a link to the relevant method in the library's documentation. Each library’s documentation provides information on installing and using the library. If you are interested in incorporating Mapbox maps and web services APIs into a Qt application, contact the Mapbox sales team. Was this page helpful? Yes No",Introduction,,Pagination,High DPI images,SDK and library support,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Reading this documentation,Access tokens and token scopes,API versioning,Backwards compatible changes,Backwards incompatible changes,Rate limit headers,Rate limits,HTTPS and CORS,Coordinate format,Date and time format,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
